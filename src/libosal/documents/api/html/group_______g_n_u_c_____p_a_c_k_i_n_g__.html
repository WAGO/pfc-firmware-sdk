<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OSAL API Manual: Structure Packing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OSAL API Manual&#160;<span id="projectnumber">Version 1.0.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group_______g_n_u_c_____p_a_c_k_i_n_g__.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<div class="title">Structure Packing</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga5791fd8ec5882c2b32e7a80bffa811f9">__PACKING_PRAGMA_USE</a>&#160;&#160;&#160;(0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga14cf6e6eda3d1c0fe4c7a323882daed2">__PACKING_ALIGN1_PRE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#gafa2523011f135f865f97ecff8bb6bd61">__PACKING_ALIGN1_POST</a>&#160;&#160;&#160;__attribute__((__packed__))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga5c0ddfcb6295fe37bdac94ae241b14b4">__PACKING_ALIGN1_PRAGMA_ENTER</a>(lable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga05a7981eb64d5746a7e99ed1dfd4e39b">__PACKING_ALIGN1_PRAGMA_LEAVE</a>(lable)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The syntax of several protocols will be described by structures. The size of a structure and the position of its members depends on the compiler settings and the used processor. To provide always the same syntax, the packing instructions of the compiler have to be used. For example, the one byte alignment instruction forces the alignment of the structure members to one. Normally the alignment of the members depend on the bit size of the used processor. For example, a 32bit processor has a 4byte alignment, a 64bit processor a 8byte boundary.</p>
<p>Based on these information a structure, which contains two members of type unsigned char, has a size of 8 bytes on a 32 bit processor. Both members are aligned to the 4byte boundary. On a 64bit processor the structure size is 8 bytes. Both members are aligned to the 8byte boundary. To force the compiler to use a one byte alignment for the structure, the structure size is always 2 bytes and the members are aligned to a one byte boundary.</p>
<p>For each structure, which will be used to exchange information with remote systems, the alignment instructions have to be used.</p>
<p>The following example shows a typical definition of a structure uses the one byte alignment instructions.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #if (__PACKING_PRAGMA_USE != 0)</span>
<span class="preprocessor"></span><span class="preprocessor"> #pragma __PACKING_ALIGN1_PRAGMA_ENTER(enter_example)</span>
<span class="preprocessor"></span><span class="preprocessor"> #endif</span>
<span class="preprocessor"></span>
 <span class="keyword">typedef</span> <span class="keyword">struct </span>example_syntax_tag      example_syntax_t;

 <a class="code" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga14cf6e6eda3d1c0fe4c7a323882daed2">__PACKING_ALIGN1_PRE</a>
 <span class="keyword">struct </span><a class="code" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#gafa2523011f135f865f97ecff8bb6bd61">__PACKING_ALIGN1_POST</a> example_syntax_tag
 {
   uint16_t        value16;
   uint8_t         value8;
   uint32_t        value32;
 };

<span class="preprocessor"> #if (__PACKING_PRAGMA_USE != 0)</span>
<span class="preprocessor"></span><span class="preprocessor"> #pragma __PACKING_ALIGN1_PRAGMA_LEAVE(enter_example)</span>
<span class="preprocessor"> #endif</span>
</pre></div><p>The used directives are described in the subsequently listed instructions. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga5791fd8ec5882c2b32e7a80bffa811f9"></a><!-- doxytag: member="os_compiler.h::__PACKING_PRAGMA_USE" ref="ga5791fd8ec5882c2b32e7a80bffa811f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __PACKING_PRAGMA_USE&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The define specifies the alignment instruction type. Several compilers use pragma pack information such like the MICROSOFT compilers. In this case the value of this macro has to be set to 1. To enter a one byte alignment section, set the <a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga5c0ddfcb6295fe37bdac94ae241b14b4">__PACKING_ALIGN1_PRAGMA_ENTER</a> macro to a compiler specific pragma pack instruction. To leave a one byte alignment section, set the <a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga05a7981eb64d5746a7e99ed1dfd4e39b">__PACKING_ALIGN1_PRAGMA_LEAVE</a> macro to a compiler specific pragma pack instruction.</p>
<p>Compilers, which do not support the pragma pack directives, the value has to be set to 0. The GNU compilers for example supports attributes. The attribute is placed behind the struct directive. The <a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#gafa2523011f135f865f97ecff8bb6bd61">__PACKING_ALIGN1_POST</a> macro has to be set to the compiler specific alignment instruction.</p>
<p>The REALVIEW compilers for example use attributes to force the one byte alignment, too. But the attribute is placed in front to the struct directive. In this case the <a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga14cf6e6eda3d1c0fe4c7a323882daed2">__PACKING_ALIGN1_PRE</a> macro has to be set to the compiler specific alignment instruction. The value of the <a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga5791fd8ec5882c2b32e7a80bffa811f9">__PACKING_PRAGMA_USE</a> macro is set to 0. </p>

<p>Definition at line <a class="el" href="os__compiler_8h_source.html#l00098">98</a> of file <a class="el" href="os__compiler_8h_source.html">os_compiler.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga14cf6e6eda3d1c0fe4c7a323882daed2"></a><!-- doxytag: member="os_compiler.h::__PACKING_ALIGN1_PRE" ref="ga14cf6e6eda3d1c0fe4c7a323882daed2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __PACKING_ALIGN1_PRE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For compilers, which uses a packing attribute in front of the struct directives, the <a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga14cf6e6eda3d1c0fe4c7a323882daed2">__PACKING_ALIGN1_PRE</a> has to be set to the compiler specific directives. The REALVIEW compilers uses the <em>__packed</em> attribute for example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define __PACKING_ALIGN1_PRE                      __packed</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>For compilers, which do not support the packing attribute in front of struct directives, the macro is empty. </dd></dl>

<p>Definition at line <a class="el" href="os__compiler_8h_source.html#l00113">113</a> of file <a class="el" href="os__compiler_8h_source.html">os_compiler.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafa2523011f135f865f97ecff8bb6bd61"></a><!-- doxytag: member="os_compiler.h::__PACKING_ALIGN1_POST" ref="gafa2523011f135f865f97ecff8bb6bd61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __PACKING_ALIGN1_POST&#160;&#160;&#160;__attribute__((__packed__))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For compilers, which uses a packing attribute behind the struct directives, the <a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#gafa2523011f135f865f97ecff8bb6bd61">__PACKING_ALIGN1_POST</a> has to be set to the compiler specific directives. The GNU compilers uses the <em>__attribute__</em>((__packed__)) attribute for example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define __PACKING_ALIGN1_POST                     __attribute__((__packed__))</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>For compilers, which do not support the packing attribute behind struct directives, the macro is empty. </dd></dl>

<p>Definition at line <a class="el" href="os__compiler_8h_source.html#l00128">128</a> of file <a class="el" href="os__compiler_8h_source.html">os_compiler.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c0ddfcb6295fe37bdac94ae241b14b4"></a><!-- doxytag: member="os_compiler.h::__PACKING_ALIGN1_PRAGMA_ENTER" ref="ga5c0ddfcb6295fe37bdac94ae241b14b4" args="(lable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __PACKING_ALIGN1_PRAGMA_ENTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lable</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the definition only for compilers supports the pragma pack directives. By using MICROSOFT compilers the macro has to set to following directives:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define __PACKING_ALIGN1_PRAGMA_ENTER(lable) pack( push, lable, 1)</span>
</pre></div><p>The value 1 specifies an one byte alignment.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The current packing alignment will be stored to the compiler stack by using the pragma pack directive with the <em>push</em> argument. To restore the currently used packing alignment the pragma pack directive with the <em>pop</em> argument (<a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga05a7981eb64d5746a7e99ed1dfd4e39b">__PACKING_ALIGN1_PRAGMA_LEAVE</a>) has to be used.</dd>
<dd>
For compilers, which do not support pragma pack directives, the macro is empty. </dd></dl>

<p>Definition at line <a class="el" href="os__compiler_8h_source.html#l00149">149</a> of file <a class="el" href="os__compiler_8h_source.html">os_compiler.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga05a7981eb64d5746a7e99ed1dfd4e39b"></a><!-- doxytag: member="os_compiler.h::__PACKING_ALIGN1_PRAGMA_LEAVE" ref="ga05a7981eb64d5746a7e99ed1dfd4e39b" args="(lable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __PACKING_ALIGN1_PRAGMA_LEAVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lable</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the definition only for compilers supports the pragma pack directives. By using MICROSOFT compilers the macro has to set to following directives:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define __PACKING_ALIGN1_PRAGMA_LEAVE(lable) pack( pop, lable, 1)</span>
</pre></div><p>The value 1 specifies an one byte alignment.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The stored packing alignment pushed to the compiler stack will be restored by using the pragma pack directive with the <em>pop</em> argument. The pragma pack directive with the <em>push</em> argument (<a class="el" href="group_______g_n_u_c_____p_a_c_k_i_n_g__.html#ga5c0ddfcb6295fe37bdac94ae241b14b4">__PACKING_ALIGN1_PRAGMA_ENTER</a>) has to be used once before.</dd>
<dd>
For compilers, which do not support pragma pack directives, the macro is empty. </dd></dl>

<p>Definition at line <a class="el" href="os__compiler_8h_source.html#l00170">170</a> of file <a class="el" href="os__compiler_8h_source.html">os_compiler.h</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
<hr>
<p align="right">
  <img border="0" src="wagologo.jpg" align="absmiddle" width="102" height="31">
  documentation. Copyright (c) 1995-2022 WAGO GmbH & Co. KG.
  All rights reserved.
</p>
