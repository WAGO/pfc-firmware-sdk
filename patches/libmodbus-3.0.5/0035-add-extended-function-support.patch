--- libmodbus-3.0.5.base/src/modbus.h	2016-07-12 14:15:15.456141000 +0200
+++ libmodbus-3.0.5/src/modbus.h	2016-07-15 09:04:58.418563121 +0200
@@ -208,6 +208,10 @@
 
 int modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp, size_t max_size);
 
+int modbus_check_confirmation(modbus_t *ctx,
+                              uint8_t const *req, int req_length,
+                              uint8_t const *rsp, int rsp_length);
+
 int modbus_reply(modbus_t *ctx, const uint8_t *req,
                  int req_length, modbus_mapping_t *mb_mapping);
 int modbus_reply2(modbus_t *ctx, const uint8_t *req,
@@ -223,6 +227,25 @@
 int modbus_is_multicast(modbus_t *ctx);
 void modbus_set_response_delay(uint16_t value);
 int modbus_filter_request(modbus_t *ctx, const uint8_t *req);
+
+//Callback to compute the remaining length to read for a partially received message.
+//This function is called in the receive loop when an incoming message begins with the
+//registered function code until it returns 0 as length.
+typedef uint8_t (*modbus_get_length_to_read_t) (int is_indication_msg_type,
+                                                uint8_t const *msg,
+                                                size_t msg_length);
+
+//Callback to check a received response message against a previously sent request message.
+//This function is called within modbus_check_confirmation among other internal checks.
+typedef void (*modbus_check_confirmation_t) (uint8_t const *req_msg, size_t req_msg_length,
+                                             uint8_t const *rsp_msg, size_t rsp_msg_length,
+                                             int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok);
+
+/*Register an extended function handler, the function_code must be less than 128 and not already registered*/
+int modbus_register_extended_function(uint8_t function_code,
+                                      modbus_get_length_to_read_t get_length_to_read_fn,
+                                      modbus_check_confirmation_t check_confirmation_fn);
+
 /**
  * UTILS FUNCTIONS
  **/
--- libmodbus-3.0.5.base/src/modbus-rtu.c	2016-07-12 14:15:15.456141000 +0200
+++ libmodbus-3.0.5/src/modbus-rtu.c	2016-07-14 09:50:45.603939563 +0200
@@ -323,33 +323,37 @@
                                 const int msg_length)
 {
     if (((modbus_rtu_t *)ctx->backend_data)->timestamp_enabled == _MODBUS_RTU_TIMESTAMP_DISABLED) {
-      uint16_t crc_calculated;
-      uint16_t crc_received;
-
-      crc_calculated = crc16(msg, msg_length - 2);
-      crc_received = (msg[msg_length - 2] << 8) | msg[msg_length - 1];
-
-      /* Check CRC of msg */
-      if (crc_calculated == crc_received) {
-          return msg_length;
+      if (msg_length < _MODBUS_RTU_CHECKSUM_LENGTH) {
+        errno = EMBBADDATA;
+        return -1;
       }
-      if (ctx->debug) {
-          fprintf(stderr, "ERROR CRC received %0X != CRC calculated %0X\n",
-                  crc_received, crc_calculated);
+      else {
+        uint8_t const * const crc = &msg[msg_length - _MODBUS_RTU_CHECKSUM_LENGTH];
+        uint16_t const crc_calculated = crc16(msg, msg_length - _MODBUS_RTU_CHECKSUM_LENGTH);
+        uint16_t const crc_received = ((uint16_t)crc[0] << 8) | crc[1];
+
+        /* Check CRC of msg */
+        if (crc_calculated == crc_received) {
+            return msg_length;
+        }
+        if (ctx->debug) {
+            fprintf(stderr, "ERROR CRC received %0X != CRC calculated %0X\n",
+                    crc_received, crc_calculated);
+        }
+        errno = EMBBADCRC;
+        return -1;
       }
-      errno = EMBBADCRC;
-      return -1;
     }
     else {
       if (msg_length < (_MODBUS_RTU_CHECKSUM_LENGTH + _MODBUS_RTU_TIMESTAMP_LENGTH)) {
-        errno = EINVAL;
+        errno = EMBBADDATA;
         return -1;
       }
       else {
         uint8_t const* const ts_buf = &msg[msg_length - _MODBUS_RTU_TIMESTAMP_LENGTH];
         uint8_t const* const crc = ts_buf - _MODBUS_RTU_CHECKSUM_LENGTH;
         uint16_t const crc_calculated = crc16(msg, msg_length - (_MODBUS_RTU_CHECKSUM_LENGTH + _MODBUS_RTU_TIMESTAMP_LENGTH));
-        uint16_t const crc_received = (crc[0] << 8) | crc[1];
+        uint16_t const crc_received = ((uint16_t)crc[0] << 8) | crc[1];
 
         /* Check CRC of msg */
         if (crc_calculated != crc_received) {
--- libmodbus-3.0.5.base/src/modbus.c	2016-07-12 14:15:15.460141000 +0200
+++ libmodbus-3.0.5/src/modbus.c	2016-07-18 13:47:14.973414453 +0200
@@ -22,6 +22,7 @@
 
 #include <stdio.h>
 #include <string.h>
+#include <stdint.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <limits.h>
@@ -33,8 +34,744 @@
 #include "modbus.h"
 #include "modbus-private.h"
 
-/* Internal use */
-#define MSG_LENGTH_UNDEFINED -1
+
+static uint8_t compute_length_to_read(size_t msg_length, size_t msg_length_expect)
+{
+    size_t const diff = (msg_length_expect > msg_length) ? (msg_length_expect - msg_length) : 0;
+    return (diff > UINT8_MAX) ? UINT8_MAX : (uint8_t)diff;
+}
+
+//compute the remaining length to read for function code 0x01 (read coils)
+static uint8_t rcvlenFC01(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC01_IND_META_LENGTH : _FC01_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x01 (read coils)
+static void chkcnfFC01(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if ((req_msg_length >= _FC01_IND_META_LENGTH) && (rsp_msg_length >= _FC01_CNF_META_LENGTH)) {
+        size_t const req_nbr_of_values = ((size_t)req_msg[3] << 8) + req_msg[4];
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC01_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = (rsp_byte_count == ((req_nbr_of_values + 7) / 8)) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+    }
+    *is_content_ok = *is_msg_length_ok;
+}
+
+//compute the remaining length to read for function code 0x02 (read discrete inputs)
+static uint8_t rcvlenFC02(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC02_IND_META_LENGTH : _FC02_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x02 (read discrete inputs)
+static void chkcnfFC02(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if ((req_msg_length >= _FC02_IND_META_LENGTH) && (rsp_msg_length >= _FC02_CNF_META_LENGTH)) {
+        size_t const req_nbr_of_values = ((size_t)req_msg[3] << 8) + req_msg[4];
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC02_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = (rsp_byte_count == ((req_nbr_of_values + 7) / 8)) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+    }
+    *is_content_ok = *is_msg_length_ok;
+}
+
+//compute the remaining length to read for function code 0x03 (read holding registers)
+static uint8_t rcvlenFC03(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC03_IND_META_LENGTH : _FC03_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x03 (read holding registers)
+static void chkcnfFC03(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if ((req_msg_length >= _FC03_IND_META_LENGTH) && (rsp_msg_length >= _FC03_CNF_META_LENGTH)) {
+        size_t const req_nbr_of_values = ((size_t)req_msg[3] << 8) + req_msg[4];
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC03_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = (rsp_byte_count == (req_nbr_of_values * 2)) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+    }
+    *is_content_ok = *is_msg_length_ok;
+}
+
+//compute the remaining length to read for function code 0x04 (read input registers)
+static uint8_t rcvlenFC04(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC04_IND_META_LENGTH : _FC04_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x04 (read input registers)
+static void chkcnfFC04(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if ((req_msg_length >= _FC04_IND_META_LENGTH) && (rsp_msg_length >= _FC04_CNF_META_LENGTH)) {
+        size_t const req_nbr_of_values = ((size_t)req_msg[3] << 8) + req_msg[4];
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC04_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = (rsp_byte_count == (req_nbr_of_values * 2)) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+    }
+    *is_content_ok = *is_msg_length_ok;
+}
+
+//compute the remaining length to read for function code 0x05 (write single coil)
+static uint8_t rcvlenFC05(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    (void)is_indication_msg_type; //unused parameter, expect same fix length for indication and confirmation
+    return compute_length_to_read(msg_length, _FC05_META_LENGTH);
+}
+
+//check a received response for function code 0x05 (write single coil)
+static void chkcnfFC05(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    size_t const msg_length_expect = _FC05_META_LENGTH;
+    //The normal response is an echo of the request.
+    *is_msg_length_ok = (req_msg_length == rsp_msg_length) && (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    *is_content_ok = *is_msg_length_ok;
+    if (*is_msg_length_ok == TRUE) {
+        size_t i = 0;
+        while ((i < req_msg_length) && (req_msg[i] == rsp_msg[i])) {
+            i++;
+        }
+        if (i < req_msg_length) {
+            *is_content_ok = FALSE;
+        }
+    }
+}
+
+//compute the remaining length to read for function code 0x06 (write single register)
+static uint8_t rcvlenFC06(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    (void)is_indication_msg_type; //unused parameter, expect same fix length for indication and confirmation
+    return compute_length_to_read(msg_length, _FC06_META_LENGTH);
+}
+
+//check a received response for function code 0x06 (write single register)
+static void chkcnfFC06(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    size_t const msg_length_expect = _FC06_META_LENGTH;
+    //The normal response is an echo of the request.
+    *is_msg_length_ok = (req_msg_length == rsp_msg_length) && (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    *is_content_ok = *is_msg_length_ok;
+    if (*is_msg_length_ok == TRUE) {
+        size_t i = 0;
+        while ((i < req_msg_length) && (req_msg[i] == rsp_msg[i])) {
+            i++;
+        }
+        if (i < req_msg_length) {
+            *is_content_ok = FALSE;
+        }
+    }
+}
+
+//compute the remaining length to read for function code 0x07 (read exception status)
+static uint8_t rcvlenFC07(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC07_IND_META_LENGTH : _FC07_CNF_META_LENGTH;
+    //expect only meta data with fix length
+    return compute_length_to_read(msg_length, meta_length);
+}
+
+//check a received response for function code 0x07 (read exception status)
+static void chkcnfFC07(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    *is_msg_length_ok    = (rsp_msg_length == _FC07_CNF_META_LENGTH) ? TRUE : FALSE;
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    *is_content_ok       = *is_msg_length_ok;
+    (void)req_msg; (void)req_msg_length; (void)rsp_msg; //unused parameter
+}
+
+//compute the remaining length to read for function code 0x08 (diagnostics)
+static uint8_t rcvlenFC08(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    if (msg_length < _FC08_META_LENGTH) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, _FC08_META_LENGTH);
+    }
+    else { //step 2: expect values depending on subfunction code and message type
+        int const subfunction = ((int)msg[_FC08_META_LENGTH - 2] << 8) + msg[_FC08_META_LENGTH - 1];
+        switch (subfunction)
+        {
+          case _SFC_RETURN_QUERY_DATA: //expect maximum ADU length (query data has undefined length)
+            rc = compute_length_to_read(msg_length, (MODBUS_RTU_MAX_ADU_LENGTH - 3)); //-3 byte RTU header and CRC
+            break;
+          case _SFC_RETURN_DIAGNOSTIC_REGISTER:
+            if (is_indication_msg_type == FALSE) {
+                //expect maximum ADU length when confirmation message (diagnostic registers has undefined length)
+                rc = compute_length_to_read(msg_length, (MODBUS_RTU_MAX_ADU_LENGTH - 3)); //-3 byte RTU header and CRC
+                break;
+            }
+            //else: no break;
+          case _SFC_RESTART_COMMUNICATIONS_OPTION:
+          case _SFC_CHANGE_ASCII_INPUT_DELIMITER:
+          case _SFC_FORCE_LISTEN_ONLY_MODE:
+          case _SFC_CLEAR_COUNTERS_AND_DIAGNOSTIC_REGISTER:
+          case _SFC_RETURN_BUS_MESSAGE_COUNT:
+          case _SFC_RETURN_BUS_COMMUNICATION_ERROR_COUNT:
+          case _SFC_RETURN_BUS_EXCEPTION_ERROR_COUNT:
+          case _SFC_RETURN_SERVER_MESSAGE_COUNT:
+          case _SFC_RETURN_SERVER_NO_RESPONSE_COUNT:
+          case _SFC_RETURN_NAK_COUNT:
+          case _SFC_RETURN_SERVER_BUSY_COUNT:
+          case _SFC_RETURN_BUS_CHARACTER_OVERRUN_COUNT:
+          case _SFC_CLEAR_OVERRUN_COUNTER_AND_FLAG:
+            //data field of diagnostic messages have 2 bytes length by default
+            rc = compute_length_to_read(msg_length, (_FC08_META_LENGTH + 2));
+            break;
+          default:
+            break;
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x08 (diagnostics)
+static void chkcnfFC08(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if ((req_msg_length >= _FC08_META_LENGTH) && (rsp_msg_length >= _FC08_META_LENGTH)) {
+        int const req_subfunction = ((int)req_msg[_FC08_META_LENGTH - 2] << 8) + req_msg[_FC08_META_LENGTH - 1];
+        int const rsp_subfunction = ((int)rsp_msg[_FC08_META_LENGTH - 2] << 8) + rsp_msg[_FC08_META_LENGTH - 1];
+        if (req_subfunction == rsp_subfunction) {
+            switch (req_subfunction)
+            {
+              case _SFC_RETURN_QUERY_DATA:
+              case _SFC_RESTART_COMMUNICATIONS_OPTION:
+              case _SFC_CHANGE_ASCII_INPUT_DELIMITER:
+              case _SFC_CLEAR_COUNTERS_AND_DIAGNOSTIC_REGISTER:
+              case _SFC_CLEAR_OVERRUN_COUNTER_AND_FLAG:
+                //The normal response is an echo of the request.
+                *is_msg_length_ok = (req_msg_length == rsp_msg_length) ? TRUE : FALSE;
+                *is_nbr_of_values_ok = *is_msg_length_ok;
+                *is_content_ok = *is_msg_length_ok;
+                if (*is_msg_length_ok == TRUE) {
+                    size_t i = 0;
+                    while ((i < req_msg_length) && (req_msg[i] == rsp_msg[i])) {
+                        i++;
+                    }
+                    if (i < req_msg_length) {
+                        *is_content_ok = FALSE;
+                    }
+                }
+                return;
+              case _SFC_RETURN_DIAGNOSTIC_REGISTER:
+                *is_msg_length_ok = ((rsp_msg_length + 3) <= MODBUS_RTU_MAX_ADU_LENGTH) ? TRUE : FALSE;
+                *is_nbr_of_values_ok = *is_msg_length_ok;
+                *is_content_ok = *is_msg_length_ok;
+                return;
+              case _SFC_RETURN_BUS_MESSAGE_COUNT:
+              case _SFC_RETURN_BUS_COMMUNICATION_ERROR_COUNT:
+              case _SFC_RETURN_BUS_EXCEPTION_ERROR_COUNT:
+              case _SFC_RETURN_SERVER_MESSAGE_COUNT:
+              case _SFC_RETURN_SERVER_NO_RESPONSE_COUNT:
+              case _SFC_RETURN_NAK_COUNT:
+              case _SFC_RETURN_SERVER_BUSY_COUNT:
+              case _SFC_RETURN_BUS_CHARACTER_OVERRUN_COUNT:
+                *is_msg_length_ok = (rsp_msg_length == (_FC08_META_LENGTH + 2)) ? TRUE : FALSE;
+                *is_nbr_of_values_ok = *is_msg_length_ok;
+                *is_content_ok = *is_msg_length_ok;
+                return;
+              case _SFC_FORCE_LISTEN_ONLY_MODE:
+                //response not defined
+              default:
+                break;
+            }
+        }
+    }
+    *is_msg_length_ok = FALSE;
+    *is_nbr_of_values_ok = FALSE;
+    *is_content_ok = FALSE;
+}
+
+
+//compute the remaining length to read for function code 0x0b (get comm event counter)
+static uint8_t rcvlenFC11(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC11_IND_META_LENGTH : _FC11_CNF_META_LENGTH;
+    //expect only meta data with fix length
+    return compute_length_to_read(msg_length, meta_length);
+}
+
+//check a received response for function code 0x0b (get comm event counter)
+static void chkcnfFC11(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    *is_msg_length_ok    = (rsp_msg_length == _FC11_CNF_META_LENGTH) ? TRUE : FALSE;
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    *is_content_ok       = *is_msg_length_ok;
+    (void)req_msg; (void)req_msg_length; (void)rsp_msg; //unused parameter
+}
+
+//compute the remaining length to read for function code 0x0c (get comm event log)
+static uint8_t rcvlenFC12(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC12_IND_META_LENGTH : _FC12_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x0c (get comm event log)
+static void chkcnfFC12(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if (rsp_msg_length >= _FC12_CNF_META_LENGTH) {
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC12_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+    }
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    *is_content_ok = *is_msg_length_ok;
+}
+
+//compute the remaining length to read for function code 0x0f (write multiple coils)
+static uint8_t rcvlenFC15(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC15_IND_META_LENGTH : _FC15_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length if indication message
+        if (is_indication_msg_type != FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x0f (write multiple coils)
+static void chkcnfFC15(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    *is_msg_length_ok = ((req_msg_length > rsp_msg_length) && (rsp_msg_length == _FC15_CNF_META_LENGTH)) ? TRUE : FALSE;
+    *is_content_ok = *is_msg_length_ok;
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    if (*is_msg_length_ok == TRUE) {
+        uint16_t const req_address       = ((uint16_t)req_msg[1] << 8) + req_msg[2];
+        uint16_t const req_nbr_of_values = ((uint16_t)req_msg[3] << 8) + req_msg[4];
+        uint16_t const rsp_address       = ((uint16_t)rsp_msg[1] << 8) + rsp_msg[2];
+        uint16_t const rsp_nbr_of_values = ((uint16_t)rsp_msg[3] << 8) + rsp_msg[4];
+        if (req_nbr_of_values != rsp_nbr_of_values) {
+            *is_nbr_of_values_ok = FALSE;
+        }
+        if (req_address != rsp_address) {
+            *is_content_ok = FALSE;
+        }
+    }
+}
+
+//compute the remaining length to read for function code 0x10 (write multiple registers)
+static uint8_t rcvlenFC16(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC16_IND_META_LENGTH : _FC16_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length if indication message
+        if (is_indication_msg_type != FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x10 (write multiple registers)
+static void chkcnfFC16(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    *is_msg_length_ok = ((req_msg_length > rsp_msg_length) && (rsp_msg_length == _FC16_CNF_META_LENGTH)) ? TRUE : FALSE;
+    *is_content_ok = *is_msg_length_ok;
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    if (*is_msg_length_ok == TRUE) {
+        uint16_t const req_address       = ((uint16_t)req_msg[1] << 8) + req_msg[2];
+        uint16_t const req_nbr_of_values = ((uint16_t)req_msg[3] << 8) + req_msg[4];
+        uint16_t const rsp_address       = ((uint16_t)rsp_msg[1] << 8) + rsp_msg[2];
+        uint16_t const rsp_nbr_of_values = ((uint16_t)rsp_msg[3] << 8) + rsp_msg[4];
+        if (req_nbr_of_values != rsp_nbr_of_values) {
+            *is_nbr_of_values_ok = FALSE;
+        }
+        if (req_address != rsp_address) {
+            *is_content_ok = FALSE;
+        }
+    }
+}
+
+//compute the remaining length to read for function code 0x11 (report server ID)
+static uint8_t rcvlenFC17(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC17_IND_META_LENGTH : _FC17_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            rc = compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x11 (report server ID)
+static void chkcnfFC17(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if (rsp_msg_length >= _FC17_CNF_META_LENGTH)
+    {
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC17_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = (rsp_byte_count > 0) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+    }
+    *is_content_ok = *is_msg_length_ok;
+    (void)req_msg; (void)req_msg_length; //unused parameter
+}
+
+//compute the remaining length to read for function code 0x14 (read file record)
+static uint8_t rcvlenFC20(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    size_t const meta_length = _FC20_META_LENGTH;
+    (void)is_indication_msg_type; //unused parameter, expect same fix meta length for indication and confirmation
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        return compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length
+        return compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+    }
+}
+
+//check a received response for function code 0x14 (read file record)
+static void chkcnfFC20(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if (rsp_msg_length >= _FC20_META_LENGTH)
+    {
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC20_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = *is_msg_length_ok;
+        *is_content_ok = *is_msg_length_ok;
+        if ((*is_msg_length_ok == TRUE) && (rsp_byte_count > 0)) {
+            //ToDo: check sub-response count
+        }
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+        *is_content_ok = FALSE;
+    }
+    (void)req_msg; (void)req_msg_length; //unused parameter
+}
+
+//compute the remaining length to read for function code 0x15 (write file record)
+static uint8_t rcvlenFC21(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    size_t const meta_length = _FC21_META_LENGTH;
+    (void)is_indication_msg_type; //unused parameter, expect same fix meta length for indication and confirmation
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        return compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length
+        return compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+    }
+}
+
+//check a received response for function code 0x15 (write file record)
+static void chkcnfFC21(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if (rsp_msg_length >= _FC21_META_LENGTH)
+    {
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC21_META_LENGTH + rsp_byte_count;
+        //The normal response is an echo of the request.
+        *is_msg_length_ok = (req_msg_length == rsp_msg_length) && (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = *is_msg_length_ok;
+        *is_content_ok = *is_msg_length_ok;
+        if (*is_msg_length_ok == TRUE) {
+            size_t i = 0;
+            while ((i < req_msg_length) && (req_msg[i] == rsp_msg[i])) {
+                i++;
+            }
+            if (i < req_msg_length) {
+                *is_content_ok = FALSE;
+            }
+        }
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+        *is_content_ok = FALSE;
+    }
+}
+
+//compute the remaining length to read for function code 0x16 (mask write register)
+static uint8_t rcvlenFC22(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    (void)is_indication_msg_type; //unused parameter, expect same fix length for indication and confirmation
+    return compute_length_to_read(msg_length, _FC22_META_LENGTH);
+}
+
+//check a received response for function code 0x16 (mask write register)
+static void chkcnfFC22(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    size_t const msg_length_expect = _FC22_META_LENGTH;
+    //The normal response is an echo of the request.
+    *is_msg_length_ok = (req_msg_length == rsp_msg_length) && (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+    *is_nbr_of_values_ok = *is_msg_length_ok;
+    *is_content_ok = *is_msg_length_ok;
+    if (*is_msg_length_ok == TRUE) {
+        size_t i = 0;
+        while ((i < req_msg_length) && (req_msg[i] == rsp_msg[i])) {
+            i++;
+        }
+        if (i < req_msg_length) {
+            *is_content_ok = FALSE;
+        }
+    }
+}
+
+//compute the remaining length to read for function code 0x17 (read/write multiple registers)
+static uint8_t rcvlenFC23(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC23_IND_META_LENGTH : _FC23_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        return compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length
+        return compute_length_to_read(msg_length, meta_length + msg[meta_length - 1]);
+    }
+}
+
+//check a received response for function code 0x17 (read/write multiple registers)
+static void chkcnfFC23(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if ((req_msg_length >= _FC23_IND_META_LENGTH) && (rsp_msg_length >= _FC23_CNF_META_LENGTH)) {
+        size_t const req_nbr_of_values = ((size_t)req_msg[3] << 8) + req_msg[4];
+        size_t const rsp_byte_count    = rsp_msg[1];
+        size_t const msg_length_expect = _FC23_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = (rsp_byte_count == (req_nbr_of_values * 2)) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+    }
+    *is_content_ok = *is_msg_length_ok;
+}
+
+//compute the remaining length to read for function code 0x18 (read FIFO queue)
+static uint8_t rcvlenFC24(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = _FC24_META_LENGTH;
+    (void)is_indication_msg_type; //unused parameter, expect same fix meta length for indication and confirmation
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            size_t const data_length = ((size_t)msg[meta_length - 2] << 8) + msg[meta_length - 1];
+            rc = compute_length_to_read(msg_length, meta_length + data_length);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x18 (read FIFO queue)
+static void chkcnfFC24(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if (rsp_msg_length >= _FC24_META_LENGTH) {
+        size_t const rsp_byte_count    = ((size_t)rsp_msg[1] << 8) + rsp_msg[2];
+        size_t const msg_length_expect = _FC24_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = *is_msg_length_ok;
+        *is_content_ok = *is_msg_length_ok;
+        if ((*is_msg_length_ok == TRUE) && (rsp_byte_count > 0)) {
+            //ToDo: check FIFO value count
+        }
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+        *is_content_ok = FALSE;
+    }
+}
+
+//compute the remaining length to read for function code 0x42 (extended read registers)
+static uint8_t rcvlenFC66(int is_indication_msg_type, uint8_t const *msg, size_t msg_length)
+{
+    uint8_t rc = 0;
+    size_t const meta_length = (is_indication_msg_type != FALSE) ? _FC66_IND_META_LENGTH : _FC66_CNF_META_LENGTH;
+    if (msg_length < meta_length) { //step 1: expect meta data with fix length
+        rc = compute_length_to_read(msg_length, meta_length);
+    }
+    else { //step 2: expect values with dynamic length in confirmation message
+        if (is_indication_msg_type == FALSE) {
+            size_t const data_length = ((size_t)msg[meta_length - 2] << 8) + msg[meta_length - 1];
+            rc = compute_length_to_read(msg_length, meta_length + data_length);
+        }
+    }
+    return rc;
+}
+
+//check a received response for function code 0x42 (extended read registers)
+static void chkcnfFC66(uint8_t const *req_msg, size_t req_msg_length,
+                       uint8_t const *rsp_msg, size_t rsp_msg_length,
+                       int *is_msg_length_ok, int *is_nbr_of_values_ok, int *is_content_ok)
+{
+    if ((req_msg_length >= _FC66_IND_META_LENGTH) && (rsp_msg_length >= _FC66_CNF_META_LENGTH)) {
+        size_t const req_nbr_of_values = ((size_t)req_msg[3] << 8) + req_msg[4];
+        size_t const rsp_byte_count    = ((size_t)rsp_msg[1] << 8) + rsp_msg[2];
+        size_t const msg_length_expect = _FC66_CNF_META_LENGTH + rsp_byte_count;
+        *is_msg_length_ok    = (rsp_msg_length == msg_length_expect) ? TRUE : FALSE;
+        *is_nbr_of_values_ok = (rsp_byte_count == (req_nbr_of_values * 2)) ? TRUE : FALSE;
+    }
+    else {
+        *is_msg_length_ok = FALSE;
+        *is_nbr_of_values_ok = FALSE;
+    }
+    *is_content_ok = *is_msg_length_ok;
+}
+
+
+static modbus_get_length_to_read_t table_get_length_to_read[128] = {
+      NULL, rcvlenFC01, rcvlenFC02, rcvlenFC03, rcvlenFC04, rcvlenFC05, rcvlenFC06, rcvlenFC07, rcvlenFC08,       NULL,
+      NULL, rcvlenFC11, rcvlenFC12,       NULL,       NULL, rcvlenFC15, rcvlenFC16, rcvlenFC17,       NULL,       NULL,
+rcvlenFC20, rcvlenFC21, rcvlenFC22, rcvlenFC23, rcvlenFC24,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL, rcvlenFC66,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL
+};
+
+static modbus_check_confirmation_t table_check_confirmation[128] = {
+      NULL, chkcnfFC01, chkcnfFC02, chkcnfFC03, chkcnfFC04, chkcnfFC05, chkcnfFC06, chkcnfFC07, chkcnfFC08,       NULL,
+      NULL, chkcnfFC11, chkcnfFC12,       NULL,       NULL, chkcnfFC15, chkcnfFC16, chkcnfFC17,       NULL,       NULL,
+chkcnfFC20, chkcnfFC21, chkcnfFC22, chkcnfFC23, chkcnfFC24,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL, chkcnfFC66,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,
+      NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL,       NULL
+};
+
 
 /* Exported version */
 const unsigned int libmodbus_version_major = LIBMODBUS_VERSION_MAJOR;
@@ -56,7 +793,8 @@
     _STEP_INDICATION_HEADER,
     _STEP_FUNCTION,
     _STEP_META,
-    _STEP_DATA
+    _STEP_DATA,
+    _STEP_CRC
 } _step_t;
 
 void modbus_set_alternate_data(modbus_t *ctx, uint8_t value)
@@ -174,87 +912,6 @@
     return rc;
 }
 
-/* Computes the length of FC08 subfunctions */
-static int compute_subfunction_length(modbus_t *ctx, uint8_t *msg)
-{
-    int length;
-    int subfunction;
-
-    subfunction = msg[ctx->backend->header_length + 1];
-    subfunction <<= 8;
-    subfunction += msg[ctx->backend->header_length + 2];
-    switch (subfunction)
-    {
-      case _SFC_RESTART_COMMUNICATIONS_OPTION:
-      case _SFC_RETURN_DIAGNOSTIC_REGISTER:
-      case _SFC_CHANGE_ASCII_INPUT_DELIMITER:
-      case _SFC_FORCE_LISTEN_ONLY_MODE:
-      case _SFC_CLEAR_COUNTERS_AND_DIAGNOSTIC_REGISTER:
-      case _SFC_RETURN_BUS_MESSAGE_COUNT:
-      case _SFC_RETURN_BUS_COMMUNICATION_ERROR_COUNT:
-      case _SFC_RETURN_BUS_EXCEPTION_ERROR_COUNT:
-      case _SFC_RETURN_SERVER_MESSAGE_COUNT:
-      case _SFC_RETURN_SERVER_NO_RESPONSE_COUNT:
-      case _SFC_RETURN_NAK_COUNT:
-      case _SFC_RETURN_SERVER_BUSY_COUNT:
-      case _SFC_RETURN_BUS_CHARACTER_OVERRUN_COUNT:
-      case _SFC_CLEAR_OVERRUN_COUNTER_AND_FLAG:
-        length = 2;
-        break;
-      case _SFC_RETURN_QUERY_DATA:
-      default:
-        length = MSG_LENGTH_UNDEFINED;
-        break;
-    }
-    return length;
-}
-
-/* Computes the length of the expected response */
-static unsigned int compute_response_length_from_request(modbus_t *ctx, uint8_t *req)
-{
-    int length;
-    const int offset = ctx->backend->header_length;
-
-    switch (req[offset]) {
-    case _FC_READ_COILS:
-    case _FC_READ_DISCRETE_INPUTS: {
-        /* Header + nb values (code from write_bits) */
-        int nb = (req[offset + 3] << 8) | req[offset + 4];
-        length = 2 + (nb / 8) + ((nb % 8) ? 1 : 0);
-    }
-        break;
-    case _FC_WRITE_AND_READ_REGISTERS:
-    case _FC_READ_HOLDING_REGISTERS:
-    case _FC_READ_INPUT_REGISTERS:
-        /* Header + 2 * nb values */
-        length = 2 + 2 * (req[offset + 3] << 8 | req[offset + 4]);
-        break;
-    case _FC_READ_INPUT_REGISTERS_XL:
-        /* Header + 2 * nb values */
-        length = 3 + 2 * (req[offset + 3] << 8 | req[offset + 4]);
-        break;
-    case _FC_READ_EXCEPTION_STATUS:
-        length = 3;
-        break;
-    case _FC_MASK_WRITE_REGISTER:
-        length = 7;
-        break;
-    case _FC_DIAGNOSTICS:
-        length = compute_subfunction_length(ctx, req) + 3;
-        if(length == MSG_LENGTH_UNDEFINED)
-            return MSG_LENGTH_UNDEFINED;
-        break;
-    case _FC_REPORT_SLAVE_ID:
-        /* The response is device specific (the header provides the
-           length) */
-        return MSG_LENGTH_UNDEFINED;
-    default:
-        length = 5;
-    }
-
-    return offset + length + ctx->backend->checksum_length;
-}
-
 /* Sends a request/response */
 static int send_msg(modbus_t *ctx, uint8_t *msg, int msg_length)
 {
@@ -339,172 +996,49 @@
 */
 
 /* Computes the length to read after the function received */
-static int compute_meta_length_after_function(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)
+static int compute_length_after_function(modbus_t const *ctx, uint8_t const *msg, size_t msg_length, msg_type_t msg_type,
+                                         size_t *pResult)
 {
-    int const function = msg[ctx->backend->header_length];
-    int length;
-
-    if (msg_type == MSG_INDICATION)
+    int rc = -1;
+    if (msg_length > ctx->backend->header_length)
     {
-        switch (function)
+        uint8_t const function = msg[ctx->backend->header_length];
+        int const is_indication_msg_type = (msg_type == MSG_INDICATION) ? TRUE : FALSE;
+
+        if (function < 128)
         {
-          case _FC_READ_EXCEPTION_STATUS:
-          case _FC_REPORT_SLAVE_ID:
-          case _FC_GET_COMM_EVENT_COUNT:
-          case _FC_GET_COMM_EVENT_LOG:
-            length = 0;
-            break;
-          case _FC_DIAGNOSTICS:
-            length = 2;
-            break;
-          case _FC_READ_COILS:
-          case _FC_READ_DISCRETE_INPUTS:
-          case _FC_READ_HOLDING_REGISTERS:
-          case _FC_READ_INPUT_REGISTERS:
-          case _FC_WRITE_SINGLE_COIL:
-          case _FC_WRITE_SINGLE_REGISTER:
-          case _FC_READ_INPUT_REGISTERS_XL:
-            length = 4;
-            break;
-          case _FC_WRITE_MULTIPLE_COILS:
-          case _FC_WRITE_MULTIPLE_REGISTERS:
-            length = 5;
-            break;
-          case _FC_MASK_WRITE_REGISTER:
-            length = 6;
-            break;
-          case _FC_WRITE_AND_READ_REGISTERS:
-            length = 9;
-            break;
-          default:
-            /*invalid function code*/
-            length = MSG_LENGTH_UNDEFINED;
-            break;
+            if (table_get_length_to_read[function] != NULL)
+            {
+                *pResult = table_get_length_to_read[function](is_indication_msg_type, &msg[ctx->backend->header_length],
+                                                              (msg_length - ctx->backend->header_length));
+                rc = 0;
+            }
         }
-    }
-    else
-    {
-        /* MSG_CONFIRMATION */
-        switch (function)
-        {
-          case _FC_READ_COILS:
-          case _FC_READ_DISCRETE_INPUTS:
-          case _FC_READ_HOLDING_REGISTERS:
-          case _FC_READ_INPUT_REGISTERS:
-          case _FC_READ_EXCEPTION_STATUS:
-          case _FC_GET_COMM_EVENT_LOG:
-          case _FC_REPORT_SLAVE_ID:
-          case _FC_WRITE_AND_READ_REGISTERS:
-            length = 1;
-            break;
-          case _FC_DIAGNOSTICS:
-          case _FC_READ_INPUT_REGISTERS_XL:
-            length = 2;
-            break;
-          case _FC_WRITE_SINGLE_COIL:
-          case _FC_WRITE_SINGLE_REGISTER:
-          case _FC_WRITE_MULTIPLE_COILS:
-          case _FC_WRITE_MULTIPLE_REGISTERS:
-          case _FC_GET_COMM_EVENT_COUNT:
-            length = 4;
-            break;
-          case _FC_MASK_WRITE_REGISTER:
-            length = 6;
-            break;
-          default:
-            if ((function >= 128) && (function < 256))
-            { //exception response
-                length = 1;
-            } else {
-                length = MSG_LENGTH_UNDEFINED;
+        else {
+            if (is_indication_msg_type == FALSE)
+            { //exception response message
+                *pResult = 1;
+                rc = 0;
             }
-            break;
         }
     }
-    return length;
+    return rc;
 }
 
 /* Computes the length to read after the meta information (address, count, etc) */
-static int compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)
+static void compute_length_after_meta(modbus_t const *ctx, uint8_t const *msg, size_t msg_length, msg_type_t msg_type,
+                                      size_t *pResult)
 {
-    int const function = msg[ctx->backend->header_length];
-    int length;
-
-    if (msg_type == MSG_INDICATION)
-    {
-        switch (function)
-        {
-          case _FC_READ_COILS:
-          case _FC_READ_DISCRETE_INPUTS:
-          case _FC_READ_HOLDING_REGISTERS:
-          case _FC_READ_INPUT_REGISTERS:
-          case _FC_WRITE_SINGLE_COIL:
-          case _FC_WRITE_SINGLE_REGISTER:
-          case _FC_READ_EXCEPTION_STATUS:
-          case _FC_GET_COMM_EVENT_COUNT:
-          case _FC_GET_COMM_EVENT_LOG:
-          case _FC_REPORT_SLAVE_ID:
-          case _FC_MASK_WRITE_REGISTER:
-          case _FC_READ_INPUT_REGISTERS_XL:
-            length = 0;
-            break;
-          case _FC_DIAGNOSTICS:
-            length = compute_subfunction_length(ctx, msg);
-            break;
-          case _FC_WRITE_MULTIPLE_COILS:
-          case _FC_WRITE_MULTIPLE_REGISTERS:
-            length = msg[ctx->backend->header_length + 5];
-            break;
-          case _FC_WRITE_AND_READ_REGISTERS:
-            length = msg[ctx->backend->header_length + 9];
-            break;
-          default:
-            /*invalid function code*/
-            length = MSG_LENGTH_UNDEFINED;
-            break;
-        }
-    }
-    else
+    uint8_t const function = msg[ctx->backend->header_length];
+    if ((function < 128) && (table_get_length_to_read[function] != NULL) && (msg_length > ctx->backend->header_length))
     {
-        /* MSG_CONFIRMATION */
-        switch (function)
-        {
-          case _FC_READ_EXCEPTION_STATUS:
-          case _FC_WRITE_SINGLE_COIL:
-          case _FC_WRITE_SINGLE_REGISTER:
-          case _FC_WRITE_MULTIPLE_COILS:
-          case _FC_WRITE_MULTIPLE_REGISTERS:
-          case _FC_GET_COMM_EVENT_COUNT:
-          case _FC_MASK_WRITE_REGISTER:
-            length = 0;
-            break;
-          case _FC_READ_COILS:
-          case _FC_READ_DISCRETE_INPUTS:
-          case _FC_READ_HOLDING_REGISTERS:
-          case _FC_READ_INPUT_REGISTERS:
-          case _FC_GET_COMM_EVENT_LOG:
-          case _FC_REPORT_SLAVE_ID:
-          case _FC_WRITE_AND_READ_REGISTERS:
-            length = msg[ctx->backend->header_length + 1];
-            break;
-          case _FC_READ_INPUT_REGISTERS_XL:
-            length = msg[ctx->backend->header_length + 1];
-            length <<= 8;
-            length += msg[ctx->backend->header_length + 2];
-            break;
-          case _FC_DIAGNOSTICS:
-            length = compute_subfunction_length(ctx, msg);
-          default:
-            /*unexpected function code*/
-            length = MSG_LENGTH_UNDEFINED;
-            break;
-        }
+        int const is_indication_msg_type = (msg_type == MSG_INDICATION) ? TRUE : FALSE;
+        *pResult = table_get_length_to_read[function](is_indication_msg_type, &msg[ctx->backend->header_length],
+                                                      (msg_length - ctx->backend->header_length));
     }
-    if (length != MSG_LENGTH_UNDEFINED)
-    {
-      length += ctx->backend->checksum_length;
+    else {
+        *pResult = 0;
     }
-    return length;
 }
 
 
@@ -527,8 +1061,8 @@
     fd_set rfds;
     struct timeval tv;
     struct timeval *p_tv;
-    int length_to_read;
-    int msg_length = 0;
+    size_t length_to_read;
+    size_t msg_length = 0;
     _step_t step;
 
     if (ctx->debug) {
@@ -562,7 +1096,7 @@
 
     while (length_to_read > 0)
     {
-        if (length_to_read > msg_size)
+        if ((msg_length + length_to_read) > msg_size)
         {
             if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
                 if (msg_type == MSG_INDICATION) {
@@ -577,79 +1111,103 @@
         }
         rc = ctx->backend->select(ctx, &rfds, p_tv, length_to_read);
         if (rc == -1) {
-            if (ctx->debug)
-                fprintf(stderr, "ERROR select failed: %s\n", modbus_strerror(errno));
-            if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&
-                (errno == EBADF)) {
-                int saved_errno = errno;
-                modbus_close(ctx);
-                modbus_connect(ctx);
-                errno = saved_errno;
-            }
-            else if((ctx->error_recovery & MODBUS_ERROR_RECOVERY_TIMEOUT) &&
-                    (errno == ETIMEDOUT)) {
-                if(msg_type == MSG_CONFIRMATION) {
-                    // sleep not necessary, reponse time already expired
-                    modbus_flush(ctx);
+            if (errno == ETIMEDOUT) {
+                if (step == _STEP_DATA) {
+                    //continue with integrity check when meta data complete (values may have undefined length)
+                    step = _STEP_CRC;
+                    length_to_read = 0;
+                }
+                else {
+                    if (msg_length != 0)
+                    {   //byte timeout before end of meta data (incomplete frame)
+                        errno = EMBBADDATA;
+                        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                            if (msg_type == MSG_INDICATION) {
+                                modbus_flush(ctx);
+                            }
+                            else {
+                                _sleep_and_flush(ctx);
+                            }
+                        }
+                    }
+                    else { //response timeout
+                        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_TIMEOUT) {
+                            modbus_flush(ctx); //don't sleep, response time is already expired
+                        }
+                    }
+                    return -1;
                 }
             }
-            return -1;
-        }
-        rc = ctx->backend->recv(ctx, msg + msg_length, length_to_read);
-        if (rc == 0) {
-            errno = ECONNRESET;
-            rc = -1;
-        }
-        if (rc == -1) {
-            if (ctx->debug)
-                fprintf(stderr, "ERROR recv failed: %s\n", modbus_strerror(errno));
-            if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&
-                (errno == ECONNRESET || errno == ECONNREFUSED ||
-                    errno == EBADF)) {
-                int saved_errno = errno;
-                modbus_close(ctx);
-                modbus_connect(ctx);
-                errno = saved_errno;
-            }
-            if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) &&
-                (errno == EMBBADDATA || errno == EMBMDATA)) {
-                int saved_errno = errno;
-                if (msg_type == MSG_INDICATION) {
-                    modbus_flush(ctx);
+            else {
+                if (ctx->debug) {
+                    fprintf(stderr, "ERROR select failed: %s\n", modbus_strerror(errno));
                 }
-                else {
-                    _sleep_and_flush(ctx);
+                if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&
+                    (errno == EBADF)) {
+                    int saved_errno = errno;
+                    modbus_close(ctx);
+                    modbus_connect(ctx);
+                    errno = saved_errno;
                 }
-                errno = saved_errno;
+                return -1;
             }
-            return -1;
         }
-        if (rc > length_to_read)
-        {  //this should not happen since recv got length_to_read as limit
-            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
-                if (msg_type == MSG_INDICATION) {
-                    modbus_flush(ctx);
+        else {
+            rc = ctx->backend->recv(ctx, msg + msg_length, length_to_read);
+            if (rc == 0) {
+                errno = ECONNRESET;
+                rc = -1;
+            }
+            if (rc == -1) {
+                if (ctx->debug)
+                    fprintf(stderr, "ERROR recv failed: %s\n", modbus_strerror(errno));
+                if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&
+                    (errno == ECONNRESET || errno == ECONNREFUSED ||
+                        errno == EBADF)) {
+                    int saved_errno = errno;
+                    modbus_close(ctx);
+                    modbus_connect(ctx);
+                    errno = saved_errno;
                 }
-                else {
-                    _sleep_and_flush(ctx);
+                if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) &&
+                    (errno == EMBBADDATA || errno == EMBMDATA)) {
+                    int saved_errno = errno;
+                    if (msg_type == MSG_INDICATION) {
+                        modbus_flush(ctx);
+                    }
+                    else {
+                        _sleep_and_flush(ctx);
+                    }
+                    errno = saved_errno;
                 }
+                return -1;
+            }
+            if (rc > length_to_read)
+            {  //this should not happen since recv got length_to_read as limit
+                if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                    if (msg_type == MSG_INDICATION) {
+                        modbus_flush(ctx);
+                    }
+                    else {
+                        _sleep_and_flush(ctx);
+                    }
+                }
+                errno = EMBMDATA;
+                return -1;
             }
-            errno = EMBMDATA;
-            return -1;
-        }
-
-        /* Display the hex code of each character received */
-        if (ctx->debug) {
-            int i;
-            for (i=0; i < rc; i++)
-                printf("<%.2X>", msg[msg_length + i]);
-        }
 
-        /* Sums bytes received */
-        msg_length += rc;
-        /* Computes remaining bytes */
-        length_to_read -= rc;
+            /* Display the hex code of each character received */
+            if (ctx->debug) {
+                int i;
+                for (i=0; i < rc; i++)
+                    printf("<%.2X>", msg[msg_length + i]);
+            }
 
+            /* Sums bytes received */
+            msg_length += rc;
+            /* Computes remaining bytes */
+            length_to_read -= rc;
+        }
         if (length_to_read == 0)
         {
             switch (step)
@@ -673,8 +1231,7 @@
                 break;
               case _STEP_FUNCTION:
                 /* Function code position */
-                length_to_read = compute_meta_length_after_function(ctx, msg, msg_type);
-                if (length_to_read == MSG_LENGTH_UNDEFINED)
+                if (compute_length_after_function(ctx, msg, msg_length, msg_type, &length_to_read) != 0)
                 {
                     if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
                         if (msg_type == MSG_INDICATION) {
@@ -687,28 +1244,27 @@
                     errno = EMBBADDATA;
                     return -1;
                 }
-                if (length_to_read != 0) {
+                if (length_to_read == 0)
+                {
+                    length_to_read = ctx->backend->checksum_length;
+                    step = _STEP_CRC;
+                }
+                else {
                     step = _STEP_META;
-                    break;
                 }
-                /* else: no break, switches straight to the next step */
+                break;
               case _STEP_META:
-                length_to_read = compute_data_length_after_meta(ctx, msg, msg_type);
-                if (length_to_read == MSG_LENGTH_UNDEFINED)
+                step = _STEP_DATA;
+                //no break;
+              case _STEP_DATA:
+                compute_length_after_meta(ctx, msg, msg_length, msg_type, &length_to_read);
+                if (length_to_read == 0)
                 {
-                    if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
-                        if (msg_type == MSG_INDICATION) {
-                            modbus_flush(ctx);
-                        }
-                        else {
-                            _sleep_and_flush(ctx);
-                        }
-                    }
-                    errno = EMBBADDATA;
-                    return -1;
+                    length_to_read = ctx->backend->checksum_length;
+                    step = _STEP_CRC;
                 }
-                step = _STEP_DATA;
                 break;
+              case _STEP_CRC:
               default:
                 break;
             }
@@ -721,9 +1277,9 @@
         p_tv = &tv;
     }
 
-    if (ctx->debug)
+    if (ctx->debug) {
         printf("\n");
-
+    }
     rc = ctx->backend->check_integrity(ctx, msg, msg_length);
     if (rc == -1) {
         if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
@@ -748,577 +1304,203 @@
 
 /* Receives the confirmation.
 
-   The function shall store the read response in rsp and return the number of
-   values (bits or words). Otherwise, its shall return -1 and errno is set.
-
-   The function doesn't check the confirmation is the expected response to the
-   initial request.
-*/
-int modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp, size_t max_size)
-{
-    return receive_msg(ctx, rsp, max_size, MSG_CONFIRMATION);
-}
-
-static int check_confirmation(modbus_t *ctx, uint8_t *req, int req_length,
-                              uint8_t *rsp, int rsp_length)
-{
-    int rc;
-    int rsp_length_computed;
-    const int offset = ctx->backend->header_length;
-
-    if (ctx->backend->pre_check_confirmation) {
-        rc = ctx->backend->pre_check_confirmation(ctx, req, rsp, rsp_length);
-        if (rc == -1) {
-            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
-                _sleep_and_flush(ctx);
-            }
-            return -1;
-        }
-    }
-
-    rsp_length_computed = compute_response_length_from_request(ctx, req);
-
-    /* Check length */
-    if (rsp_length == rsp_length_computed ||
-        rsp_length_computed == MSG_LENGTH_UNDEFINED) {
-        int req_nb_value;
-        int rsp_nb_value;
-        const int function = rsp[offset];
-
-        /* Check function code */
-        if (function != req[offset]) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Received function not corresponding to the request (%d != %d)\n",
-                        function, req[offset]);
-            }
-            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
-                _sleep_and_flush(ctx);
-            }
-            errno = EMBBADDATA;
-            return -1;
-        }
-
-        /* Check the number of values is corresponding to the request */
-        switch (function) {
-        case _FC_READ_COILS:
-        case _FC_READ_DISCRETE_INPUTS:
-            /* Read functions, 8 values in a byte (nb
-             * of values in the request and byte count in
-             * the response. */
-            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];
-            req_nb_value = (req_nb_value / 8) + ((req_nb_value % 8) ? 1 : 0);
-            rsp_nb_value = rsp[offset + 1];
-            break;
-        case _FC_WRITE_AND_READ_REGISTERS:
-        case _FC_READ_HOLDING_REGISTERS:
-        case _FC_READ_INPUT_REGISTERS:
-            /* Read functions 1 value = 2 bytes */
-            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];
-            rsp_nb_value = (rsp[offset + 1] / 2);
-            break;
-        case _FC_READ_INPUT_REGISTERS_XL:
-            /* Read functions 1 value = 2 bytes */
-            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];
-            rsp_nb_value = ((rsp[offset + 1] << 8) + rsp[offset +2]) / 2;
-            break;
-        case _FC_WRITE_MULTIPLE_COILS:
-        case _FC_WRITE_MULTIPLE_REGISTERS:
-            /* N Write functions */
-            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];
-            rsp_nb_value = (rsp[offset + 3] << 8) | rsp[offset + 4];
-            break;
-        case _FC_DIAGNOSTICS:
-            req_nb_value = rsp_nb_value = rsp_length - offset - 3;
-            break;
-        case _FC_REPORT_SLAVE_ID:
-            /* Report slave ID (bytes received) */
-            req_nb_value = rsp_nb_value = rsp[offset + 1];
-            break;
-        default:
-            /* 1 Write functions & others */
-            req_nb_value = rsp_nb_value = 1;
-        }
-
-        if (req_nb_value == rsp_nb_value) {
-            rc = rsp_nb_value;
-        } else {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Quantity not corresponding to the request (%d != %d)\n",
-                        rsp_nb_value, req_nb_value);
-            }
-
-            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
-                _sleep_and_flush(ctx);
-            }
-
-            errno = EMBBADDATA;
-            rc = -1;
-        }
-    } else if (rsp_length == (offset + 2 + ctx->backend->checksum_length) &&
-               req[offset] == (rsp[offset] - 0x80)) {
-        /* EXCEPTION CODE RECEIVED */
-
-        int exception_code = rsp[offset + 1];
-        if (exception_code < MODBUS_EXCEPTION_MAX) {
-            errno = MODBUS_ENOBASE + exception_code;
-        } else {
-            errno = EMBBADEXC;
-        }
-        rc = -1;
-    } else {
-        if (ctx->debug) {
-            fprintf(stderr,
-                    "Message length not corresponding to the computed length (%d != %d)\n",
-                    rsp_length, rsp_length_computed);
-        }
-        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
-            _sleep_and_flush(ctx);
-        }
-        errno = EMBBADDATA;
-        rc = -1;
-    }
-
-    return rc;
-}
-
-//static int response_io_status(int address, int nb,
-//                              uint8_t *tab_io_status,
-//                              uint8_t *rsp, int offset)
-//{
-//    int shift = 0;
-//    int byte = 0;
-//    int i;
-//
-//    for (i = address; i < address+nb; i++) {
-//        byte |= tab_io_status[i] << shift;
-//        if (shift == 7) {
-//            /* Byte is full */
-//            rsp[offset++] = byte;
-//            byte = shift = 0;
-//        } else {
-//            shift++;
-//        }
-//    }
-//
-//    if (shift != 0)
-//        rsp[offset++] = byte;
-//
-//    return offset;
-//}
-
-/* Build the exception response */
-static int response_exception(modbus_t *ctx, sft_t *sft,
-                              int exception_code, uint8_t *rsp)
-{
-    int rsp_length;
-
-    sft->function = sft->function + 0x80;
-    rsp_length = ctx->backend->build_response_basis(sft, rsp);
-
-    /* Positive exception code */
-    rsp[rsp_length++] = exception_code;
-
-    return rsp_length;
-}
-
-int modbus_filter_request(modbus_t *ctx, const uint8_t *req)
-{
-    int offset = ctx->backend->header_length;
-    int slave = req[offset - 1];
-    return ctx->backend->filter_request(ctx, slave);
-}
-
-/* Send a response to the received request.
-   Analyses the request and constructs a response.
-
-   If an error occurs, this function construct the response
-   accordingly.
-*/
-int modbus_reply(modbus_t *ctx, const uint8_t *req,
-                 int req_length, modbus_mapping_t *mb_mapping)
-{
-    int rc;
-    int offset = ctx->backend->header_length;
-    int slave = req[offset - 1];
-    int function = req[offset];
-    uint16_t address = (req[offset + 1] << 8) + req[offset + 2];
-    uint8_t rsp[MAX_RESPONSE_MESSAGE_LENGTH];
-    int rsp_length = 0;
-    sft_t sft;
-
-    if (ctx->backend->filter_request(ctx, slave) == 1) {
-        /* Filtered */
-        return 0;
-    }
-
-    sft.slave = slave;
-    sft.function = function;
-    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);
-
-    switch (function) {
-    case _FC_READ_COILS: {
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-
-        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal nb of values %d in read_bits (max %d)\n",
-                        nb, MODBUS_MAX_READ_BITS);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-        } else if ((address + nb) > mb_mapping->nb_bits) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in read_bits\n",
-                        address + nb);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);
-            rsp_length += modbus_get_bytes_from_bitmap16(mb_mapping->tab_bits,
-                                                         address, nb, &rsp[rsp_length]);
-        }
-    }
-        break;
-    case _FC_READ_DISCRETE_INPUTS: {
-        /* Similar to coil status (but too many arguments to use a
-         * function) */
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-
-        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal nb of values %d in read_input_bits (max %d)\n",
-                        nb, MODBUS_MAX_READ_BITS);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-        } else if ((address + nb) > mb_mapping->nb_input_bits) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in read_input_bits\n",
-                        address + nb);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);
-            rsp_length += modbus_get_bytes_from_bitmap16(mb_mapping->tab_input_bits,
-                                                         address, nb, &rsp[rsp_length]);
-        }
-    }
-        break;
-    case _FC_READ_HOLDING_REGISTERS: {
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-
-        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal nb of values %d in read_holding_registers (max %d)\n",
-                        nb, MODBUS_MAX_READ_REGISTERS);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-        } else if ((address + nb) > mb_mapping->nb_registers) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in read_registers\n",
-                        address + nb);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            int i;
-
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            rsp[rsp_length++] = nb << 1;
-            for (i = address; i < address + nb; i++) {
-                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
-                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
-            }
-        }
-    }
-        break;
-    case _FC_READ_INPUT_REGISTERS: {
-        /* Similar to holding registers (but too many arguments to use a
-         * function) */
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-
-        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal number of values %d in read_input_registers (max %d)\n",
-                        nb, MODBUS_MAX_READ_REGISTERS);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-        } else if ((address + nb) > mb_mapping->nb_input_registers) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in read_input_registers\n",
-                        address + nb);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            int i;
-
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            rsp[rsp_length++] = nb << 1;
-            for (i = address; i < address + nb; i++) {
-                rsp[rsp_length++] = mb_mapping->tab_input_registers[i] >> 8;
-                rsp[rsp_length++] = mb_mapping->tab_input_registers[i] & 0xFF;
-            }
-        }
-    }
-        break;
-    case _FC_WRITE_SINGLE_COIL:
-        if (address >= mb_mapping->nb_bits) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in write_bit\n",
-                        address);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            int data = (req[offset + 3] << 8) + req[offset + 4];
-
-            if (data == 0xFF00 || data == 0x0) {
-                uint8_t status = (data) ? ON : OFF;
-                modbus_set_bitmap16_from_bytes(mb_mapping->tab_bits, address, 1, &status);
-                memcpy(rsp, req, req_length);
-                rsp_length = req_length;
-            } else {
-                if (ctx->debug) {
-                    fprintf(stderr,
-                            "Illegal data value %0X in write_bit request at address %0X\n",
-                            data, address);
-                }
-                rsp_length = response_exception(
-                    ctx, &sft,
-                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-            }
-        }
-        break;
-    case _FC_WRITE_SINGLE_REGISTER:
-        if (address >= mb_mapping->nb_registers) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in write_register\n",
-                        address);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            int data = (req[offset + 3] << 8) + req[offset + 4];
-
-            mb_mapping->tab_registers[address] = data;
-            memcpy(rsp, req, req_length);
-            rsp_length = req_length;
-        }
-        break;
-    case _FC_WRITE_MULTIPLE_COILS: {
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-
-        if ((address + nb) > mb_mapping->nb_bits) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in write_bits\n",
-                        address + nb);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            /* 6 = byte count */
-            modbus_set_bitmap16_from_bytes(mb_mapping->tab_bits, address, nb, &req[offset + 6]);
-
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            /* 4 to copy the bit address (2) and the quantity of bits */
-            memcpy(rsp + rsp_length, req + rsp_length, 4);
-            rsp_length += 4;
-        }
-    }
-        break;
-    case _FC_WRITE_MULTIPLE_REGISTERS: {
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-
-        if ((address + nb) > mb_mapping->nb_registers) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in write_registers\n",
-                        address + nb);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            int i, j;
-            for (i = address, j = 6; i < address + nb; i++, j += 2) {
-                /* 6 and 7 = first value */
-                mb_mapping->tab_registers[i] =
-                    (req[offset + j] << 8) + req[offset + j + 1];
-            }
-
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            /* 4 to copy the address (2) and the no. of registers */
-            memcpy(rsp + rsp_length, req + rsp_length, 4);
-            rsp_length += 4;
-        }
-    }
-        break;
-    case _FC_REPORT_SLAVE_ID: {
-        int str_len;
-        int byte_count_pos;
-
-        rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-        /* Skip byte count for now */
-        byte_count_pos = rsp_length++;
-        rsp[rsp_length++] = _REPORT_SLAVE_ID;
-        /* Run indicator status to ON */
-        rsp[rsp_length++] = 0xFF;
-        /* LMB + length of LIBMODBUS_VERSION_STRING */
-        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);
-        memcpy(rsp + rsp_length, "LMB" LIBMODBUS_VERSION_STRING, str_len);
-        rsp_length += str_len;
-        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
-    }
-        break;
-    case _FC_READ_EXCEPTION_STATUS:
-        //FIXME:
-        if (ctx->debug) {
-            fprintf(stderr, "FC_READ_EXCEPTION_STATUS not implemented\n");
-        }
-        errno = ENOPROTOOPT;
-        return -1;
-        break;
-
-    case _FC_MASK_WRITE_REGISTER:
-        if (address > mb_mapping->nb_registers) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in mask_write_registers\n",
-                        address);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            uint16_t and_mask = (req[offset + 3] << 8) + req[offset + 4];
-            uint16_t or_mask = (req[offset + 5] << 8) + req[offset + 6];
-            mb_mapping->tab_registers[address] &= and_mask;
-            mb_mapping->tab_registers[address] |= (or_mask & ~and_mask);
-            //The normal response is an echo of the request
-            memcpy(rsp, req, req_length);
-            rsp_length = req_length;
-        }
-        break;
-
-    case _FC_WRITE_AND_READ_REGISTERS: {
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];
-        int nb_write = (req[offset + 7] << 8) + req[offset + 8];
-        int nb_write_bytes = req[offset + 9];
-
-        if (nb_write < 1 || MODBUS_MAX_RW_WRITE_REGISTERS < nb_write ||
-            nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ||
-            nb_write_bytes != nb_write * 2) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n",
-                        nb_write, nb,
-                        MODBUS_MAX_RW_WRITE_REGISTERS, MODBUS_MAX_READ_REGISTERS);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-        } else if ((address + nb) > mb_mapping->nb_registers ||
-                   (address_write + nb_write) > mb_mapping->nb_registers) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal data read address %0X or write address %0X write_and_read_registers\n",
-                        address + nb, address_write + nb_write);
-            }
-            rsp_length = response_exception(ctx, &sft,
-                                            MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            int i, j;
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            rsp[rsp_length++] = nb << 1;
+   The function shall store the read response in rsp and return the number of
+   values (bits or words). Otherwise, its shall return -1 and errno is set.
 
-            /* Write first.
-               10 and 11 are the offset of the first values to write */
-            for (i = address_write, j = 10; i < address_write + nb_write; i++, j += 2) {
-                mb_mapping->tab_registers[i] =
-                    (req[offset + j] << 8) + req[offset + j + 1];
-            }
+   The function doesn't check the confirmation is the expected response to the
+   initial request.
+*/
+int modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp, size_t max_size)
+{
+    return receive_msg(ctx, rsp, max_size, MSG_CONFIRMATION);
+}
 
-            /* and read the data for the response */
-            for (i = address; i < address + nb; i++) {
-                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
-                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
+int modbus_check_confirmation(modbus_t *ctx,
+                              uint8_t const *req, int req_length,
+                              uint8_t const *rsp, int rsp_length)
+{
+    int const minimum_msg_length = ctx->backend->header_length + 1 + ctx->backend->checksum_length;
+
+    if (ctx->backend->pre_check_confirmation) {
+        int const rc = ctx->backend->pre_check_confirmation(ctx, req, rsp, rsp_length);
+        if (rc == -1) {
+            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                _sleep_and_flush(ctx);
             }
+            return -1;
         }
     }
-        break;
-    case _FC_READ_INPUT_REGISTERS_XL: {
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
-
-        if (nb < 1 || MODBUS_MAX_READ_REGISTERS_FC66 < nb) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal number of values %d in read_input_registers_xl (max %d)\n",
-                        nb, MODBUS_MAX_READ_REGISTERS);
+    if ((req_length < minimum_msg_length) || (rsp_length < minimum_msg_length))
+    {
+        if (ctx->debug) {
+            fprintf(stderr,
+                    "Invalid message length (req %d, rsp %d, minimum %d)\n",
+                    req_length, rsp_length, minimum_msg_length);
+        }
+        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+            _sleep_and_flush(ctx);
+        }
+        errno = EMBBADDATA;
+        return -1;
+    }
+    else {
+        uint8_t const req_function = req[ctx->backend->header_length];
+        uint8_t const rsp_function = rsp[ctx->backend->header_length];
+        if (rsp_function < 128)
+        {
+            if (req_function != rsp_function) {
+                if (ctx->debug) {
+                    fprintf(stderr,
+                            "Received function not corresponding to the request (%d != %d)\n",
+                            rsp_function, req_function);
+                }
+                if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                    _sleep_and_flush(ctx);
+                }
+                errno = EMBBADDATA;
+                return -1;
             }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-        } else if ((address + nb) > mb_mapping->nb_input_registers) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in read_input_registers_xl\n",
-                        address + nb);
+            if (table_check_confirmation[rsp_function] != NULL)
+            {
+                int is_msg_length_ok;
+                int is_nbr_of_values_ok;
+                int is_content_ok;
+                //compute message length without header and crc
+                size_t const req_msg_length = (size_t)(req_length - minimum_msg_length + 1);
+                size_t const rsp_msg_length = (size_t)(rsp_length - minimum_msg_length + 1);
+                table_check_confirmation[rsp_function](&req[ctx->backend->header_length], req_msg_length,
+                                                       &rsp[ctx->backend->header_length], rsp_msg_length,
+                                                       &is_msg_length_ok, &is_nbr_of_values_ok, &is_content_ok);
+                if (is_msg_length_ok == FALSE) {
+                    if (ctx->debug) {
+                        fprintf(stderr,
+                                "Message length not corresponding to the computed length\n");
+                    }
+                    if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                        _sleep_and_flush(ctx);
+                    }
+                    errno = EMBBADDATA;
+                    return -1;
+                }
+                if (is_nbr_of_values_ok == FALSE) {
+                    if (ctx->debug) {
+                        fprintf(stderr,
+                                "Quantity not corresponding to the request\n");
+                    }
+                    if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                        _sleep_and_flush(ctx);
+                    }
+                    errno = EMBBADDATA;
+                    return -1;
+                }
+                if (is_content_ok == FALSE) {
+                    if (ctx->debug) {
+                        fprintf(stderr,
+                                "Message content not corresponding to the request\n");
+                    }
+                    if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                        _sleep_and_flush(ctx);
+                    }
+                    errno = EMBBADDATA;
+                    return -1;
+                }
             }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-        } else {
-            int i;
-            int nb_bytes = nb << 1;
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            rsp[rsp_length++] = nb_bytes >> 8;
-            rsp[rsp_length++] = nb_bytes & 0xFF;
-            for (i = address; i < address + nb; i++) {
-                rsp[rsp_length++] = mb_mapping->tab_input_registers[i] >> 8;
-                rsp[rsp_length++] = mb_mapping->tab_input_registers[i] & 0xFF;
+        }
+        else { //exception response
+            int const exception_code = rsp[ctx->backend->header_length + 1];
+            int const rsp_function_expect = req_function + 128;
+            int const rsp_length_expect = ctx->backend->header_length + 2 + ctx->backend->checksum_length;
+            if ((int)rsp_function != rsp_function_expect)
+            {
+                if (ctx->debug) {
+                    fprintf(stderr,
+                            "Received exception response not corresponding to the request (%d != %d)\n",
+                            rsp_function, rsp_function_expect);
+                }
+                if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                    _sleep_and_flush(ctx);
+                }
+                errno = EMBBADDATA;
+                return -1;
+            }
+            if (rsp_length != rsp_length_expect)
+            {
+                if (ctx->debug) {
+                    fprintf(stderr,
+                            "Exception response length not corresponding to the computed length (%d != %d)\n",
+                            rsp_length, rsp_length_expect);
+                }
+                if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
+                    _sleep_and_flush(ctx);
+                }
+                errno = EMBBADDATA;
+                return -1;
             }
+            errno = (exception_code < MODBUS_EXCEPTION_MAX) ? (MODBUS_ENOBASE + exception_code) : EMBBADEXC;
+            return -1;
         }
     }
-        break;
+    return 0;
+}
 
-    default:
-        rsp_length = response_exception(ctx, &sft,
-                                        MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
-                                        rsp);
-        break;
-    }
+//static int response_io_status(int address, int nb,
+//                              uint8_t *tab_io_status,
+//                              uint8_t *rsp, int offset)
+//{
+//    int shift = 0;
+//    int byte = 0;
+//    int i;
+//
+//    for (i = address; i < address+nb; i++) {
+//        byte |= tab_io_status[i] << shift;
+//        if (shift == 7) {
+//            /* Byte is full */
+//            rsp[offset++] = byte;
+//            byte = shift = 0;
+//        } else {
+//            shift++;
+//        }
+//    }
+//
+//    if (shift != 0)
+//        rsp[offset++] = byte;
+//
+//    return offset;
+//}
 
-    wait_response_delay();
-    if ((_MODBUS_BACKEND_TYPE_RTU == ctx->backend->backend_type) && (MODBUS_BROADCAST_ADDRESS == slave))
-    { /* No response on RTU broadcasts */
-        rc = 0;
-    }
-    else {
-        rc = send_msg(ctx, rsp, rsp_length);
-    }
-    return rc;
+/* Build the exception response */
+static int response_exception(modbus_t *ctx, sft_t *sft,
+                              int exception_code, uint8_t *rsp)
+{
+    int rsp_length;
+
+    sft->function = sft->function + 0x80;
+    rsp_length = ctx->backend->build_response_basis(sft, rsp);
+
+    /* Positive exception code */
+    rsp[rsp_length++] = exception_code;
+
+    return rsp_length;
+}
+
+int modbus_filter_request(modbus_t *ctx, const uint8_t *req)
+{
+    int offset = ctx->backend->header_length;
+    int slave = req[offset - 1];
+    return ctx->backend->filter_request(ctx, slave);
+}
+
+/* Send a response to the received request.
+   Analyses the request and constructs a response.
+
+   If an error occurs, this function construct the response
+   accordingly.
+*/
+int modbus_reply(modbus_t *ctx, const uint8_t *req,
+                 int req_length, modbus_mapping_t *mb_mapping)
+{
+    modbus_reply_result_t result;
+    return modbus_reply2(ctx, req, req_length, mb_mapping, &result);
 }
 
 int modbus_reply2(modbus_t *ctx, const uint8_t *req,
@@ -1326,7 +1508,7 @@
                   modbus_reply_result_t *result)
 {
     int rc;
-    int offset = ctx->backend->header_length;
+    unsigned int offset = ctx->backend->header_length;
     int slave = req[offset - 1];
     int function = req[offset];
     int address = (req[offset + 1] << 8) + req[offset + 2];
@@ -1370,7 +1552,7 @@
                 MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
             result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
         } else {
-            uint32_t nb_bytes = (nb / 8) + ((nb % 8) ? 1 : 0);
+            uint32_t nb_bytes = (nb + 7) / 8;
             rsp_length = ctx->backend->build_response_basis(&sft, rsp);
             rsp[rsp_length++] = (uint8_t)nb_bytes;
             if (ctx->alternate_data_enabled == FALSE) {
@@ -1409,7 +1591,7 @@
                 MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
             result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
         } else {
-            uint32_t nb_bytes = (nb / 8) + ((nb % 8) ? 1 : 0);
+            uint32_t nb_bytes = (nb + 7) / 8;
             rsp_length = ctx->backend->build_response_basis(&sft, rsp);
             rsp[rsp_length++] = (uint8_t)nb_bytes;
             if (ctx->alternate_data_enabled == FALSE) {
@@ -1446,7 +1628,7 @@
                 MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
             result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
         } else {
-            uint32_t nb_bytes = nb << 1;
+            int nb_bytes = nb * 2;
             rsp_length = ctx->backend->build_response_basis(&sft, rsp);
             rsp[rsp_length++] = (uint8_t)nb_bytes;
             if (ctx->alternate_data_enabled == FALSE) {
@@ -1456,7 +1638,7 @@
                     rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
                 }
             } else {
-                modbus_set_fixdata(&rsp[rsp_length], nb_bytes, ctx->alternate_data_value);
+                modbus_set_fixdata(&rsp[rsp_length], (uint32_t)nb_bytes, ctx->alternate_data_value);
                 rsp_length += nb_bytes;
                 ctx->alternate_data_enabled = FALSE;
             }
@@ -1488,7 +1670,7 @@
                 MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
             result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
         } else {
-            uint32_t nb_bytes = nb << 1;
+            int nb_bytes = nb * 2;
             rsp_length = ctx->backend->build_response_basis(&sft, rsp);
             rsp[rsp_length++] = (uint8_t)nb_bytes;
             if (ctx->alternate_data_enabled == FALSE) {
@@ -1498,7 +1680,7 @@
                     rsp[rsp_length++] = mb_mapping->tab_input_registers[i] & 0xFF;
                 }
             } else {
-                modbus_set_fixdata(&rsp[rsp_length], nb_bytes, ctx->alternate_data_value);
+                modbus_set_fixdata(&rsp[rsp_length], (uint32_t)nb_bytes, ctx->alternate_data_value);
                 rsp_length += nb_bytes;
                 ctx->alternate_data_enabled = FALSE;
             }
@@ -1556,8 +1738,10 @@
         break;
     case _FC_WRITE_MULTIPLE_COILS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
+        int nb_bytes = req[offset + 5];
 
-        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {
+        if ( (nb < 1) || (MODBUS_MAX_WRITE_BITS < nb) || (nb_bytes != ((nb + 7) / 8)) ||
+             (req_length < (offset + _FC15_IND_META_LENGTH + nb_bytes)) ) {
             if (ctx->debug) {
                 fprintf(stderr,
                         "Illegal nb of values %d in write_bits (max %d)\n",
@@ -1577,7 +1761,7 @@
                 MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
             result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
         } else {
-            /* 6 = byte count */
+            /* 7 = first value */
             modbus_set_bitmap16_from_bytes(mb_mapping->tab_bits, address, nb, &req[offset + 6]);
 
             rsp_length = ctx->backend->build_response_basis(&sft, rsp);
@@ -1589,8 +1773,10 @@
         break;
     case _FC_WRITE_MULTIPLE_REGISTERS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
+        int nb_bytes = req[offset + 5];
 
-        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {
+        if ( (nb < 1) || (MODBUS_MAX_WRITE_REGISTERS < nb) || (nb_bytes != (nb * 2)) ||
+            (req_length < (offset + _FC16_IND_META_LENGTH + nb_bytes)) ) {
             if (ctx->debug) {
                 fprintf(stderr,
                         "Illegal nb of values %d in write_registers (max %d)\n",
@@ -1624,34 +1810,31 @@
         }
     }
         break;
-    case _FC_REPORT_SLAVE_ID: {
-        int str_len;
-        int byte_count_pos;
-
-        rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-        /* Skip byte count for now */
-        byte_count_pos = rsp_length++;
-        rsp[rsp_length++] = _REPORT_SLAVE_ID;
-        /* Run indicator status to ON */
-        rsp[rsp_length++] = 0xFF;
-        /* LMB + length of LIBMODBUS_VERSION_STRING */
-        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);
-        memcpy(rsp + rsp_length, "LMB" LIBMODBUS_VERSION_STRING, str_len);
-        rsp_length += str_len;
-        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
-    }
-        break;
-    case _FC_READ_EXCEPTION_STATUS:
-        //FIXME:
-        if (ctx->debug) {
-            fprintf(stderr, "FC_READ_EXCEPTION_STATUS not implemented\n");
+    case _FC_REPORT_SLAVE_ID:
+        if (ctx->backend->backend_type != _MODBUS_BACKEND_TYPE_RTU) {
+           //for serial line only
+           rsp_length = response_exception(ctx, &sft,
+                                           MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
+                                           rsp);
+           result->exception_code = MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
+        }
+        else {
+            int str_len;
+            int byte_count_pos;
+
+            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
+            /* Skip byte count for now */
+            byte_count_pos = rsp_length++;
+            rsp[rsp_length++] = _REPORT_SLAVE_ID;
+            /* Run indicator status to ON */
+            rsp[rsp_length++] = 0xFF;
+            /* LMB + length of LIBMODBUS_VERSION_STRING */
+            str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);
+            memcpy(rsp + rsp_length, "LMB" LIBMODBUS_VERSION_STRING, str_len);
+            rsp_length += str_len;
+            rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
         }
-        rsp_length = response_exception(ctx, &sft,
-                                        MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
-                                        rsp);
-        result->exception_code = MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
         break;
-
     case _FC_MASK_WRITE_REGISTER:
         if (address > mb_mapping->nb_registers) {
             if (ctx->debug) {
@@ -1672,16 +1855,15 @@
             rsp_length = req_length;
         }
         break;
-
     case _FC_WRITE_AND_READ_REGISTERS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
-        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];
+        int address_write = (req[offset + 5] << 8) + req[offset + 6];
         int nb_write = (req[offset + 7] << 8) + req[offset + 8];
         int nb_write_bytes = req[offset + 9];
 
-        if (nb_write < 1 || MODBUS_MAX_RW_WRITE_REGISTERS < nb_write ||
-            nb < 1 || MODBUS_MAX_READ_REGISTERS < nb ||
-            nb_write_bytes != nb_write * 2) {
+        if ( (nb_write < 1) || (MODBUS_MAX_RW_WRITE_REGISTERS < nb_write) || (nb_write_bytes != (nb_write * 2)) ||
+            (req_length < (offset + _FC23_IND_META_LENGTH + nb_write_bytes)) ||
+            (nb < 1) || (MODBUS_MAX_READ_REGISTERS < nb) ) {
             if (ctx->debug) {
                 fprintf(stderr,
                         "Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n",
@@ -1704,7 +1886,7 @@
             result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
         } else {
             int i, j;
-            uint16_t nb_bytes = nb << 1;
+            int nb_bytes = nb * 2;
             rsp_length = ctx->backend->build_response_basis(&sft, rsp);
             rsp[rsp_length++] = (uint8_t)nb_bytes;
 
@@ -1722,55 +1904,71 @@
                     rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
                 }
             } else {
-                modbus_set_fixdata(&rsp[rsp_length], nb_bytes, ctx->alternate_data_value);
+                modbus_set_fixdata(&rsp[rsp_length], (uint32_t)nb_bytes, ctx->alternate_data_value);
                 rsp_length += nb_bytes;
                 ctx->alternate_data_enabled = FALSE;
             }
         }
     }
         break;
-    case _FC_READ_INPUT_REGISTERS_XL: {
-        int nb = (req[offset + 3] << 8) + req[offset + 4];
+    case _FC_READ_INPUT_REGISTERS_XL:
+        if (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU) {
+           //not for serial line
+           rsp_length = response_exception(ctx, &sft,
+                                           MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
+                                           rsp);
+           result->exception_code = MODBUS_EXCEPTION_ILLEGAL_FUNCTION;
+        }
+        else {
+            int nb = (req[offset + 3] << 8) + req[offset + 4];
 
-        if (nb < 1 || MODBUS_MAX_READ_REGISTERS_FC66 < nb) {
-            if (ctx->debug) {
-                fprintf(stderr,
-                        "Illegal number of values %d in read_input_registers_xl (max %d)\n",
-                        nb, MODBUS_MAX_READ_REGISTERS);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
-            result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE;
-        } else if ((address + nb) > mb_mapping->nb_input_registers) {
-            if (ctx->debug) {
-                fprintf(stderr, "Illegal data address %0X in read_input_registers_xl\n",
-                        address + nb);
-            }
-            rsp_length = response_exception(
-                ctx, &sft,
-                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
-            result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
-        } else {
-            int i;
-            int nb_bytes = nb << 1;
-            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
-            rsp[rsp_length++] = nb_bytes >> 8;
-            rsp[rsp_length++] = nb_bytes & 0xFF;
-            if (ctx->alternate_data_enabled == FALSE) {
-                for (i = address; i < address + nb; i++) {
-                    rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
-                    rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
+            if (nb < 1 || MODBUS_MAX_READ_REGISTERS_FC66 < nb) {
+                if (ctx->debug) {
+                    fprintf(stderr,
+                            "Illegal number of values %d in read_input_registers_xl (max %d)\n",
+                            nb, MODBUS_MAX_READ_REGISTERS);
                 }
+                rsp_length = response_exception(
+                    ctx, &sft,
+                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp);
+                result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE;
+            } else if ((address + nb) > mb_mapping->nb_input_registers) {
+                if (ctx->debug) {
+                    fprintf(stderr, "Illegal data address %0X in read_input_registers_xl\n",
+                            address + nb);
+                }
+                rsp_length = response_exception(
+                    ctx, &sft,
+                    MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp);
+                result->exception_code = MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS;
             } else {
-                modbus_set_fixdata(&rsp[rsp_length], nb_bytes, ctx->alternate_data_value);
-                rsp_length += nb_bytes;
-                ctx->alternate_data_enabled = FALSE;
+                int i;
+                int nb_bytes = nb * 2;
+                rsp_length = ctx->backend->build_response_basis(&sft, rsp);
+                rsp[rsp_length++] = nb_bytes >> 8;
+                rsp[rsp_length++] = nb_bytes & 0xFF;
+                if (ctx->alternate_data_enabled == FALSE) {
+                    for (i = address; i < address + nb; i++) {
+                        rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
+                        rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
+                    }
+                } else {
+                    modbus_set_fixdata(&rsp[rsp_length], (uint32_t)nb_bytes, ctx->alternate_data_value);
+                    rsp_length += nb_bytes;
+                    ctx->alternate_data_enabled = FALSE;
+                }
             }
         }
-    }
         break;
-
+    //FIXME: not implemented functions:
+    case _FC_READ_EXCEPTION_STATUS:
+    case _FC_DIAGNOSTICS:
+    case _FC_GET_COMM_EVENT_COUNT:
+    case _FC_GET_COMM_EVENT_LOG:
+    case _FC_READ_FILE_RECORD:
+    case _FC_WRITE_FILE_RECORD:
+    case _FC_READ_FIFO_QUEUE:
+    case _FC_ENCAPSULATED_TRANSPORT:
     default:
         rsp_length = response_exception(ctx, &sft,
                                         MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
@@ -1793,6 +1991,14 @@
 int modbus_reply_exception(modbus_t *ctx, const uint8_t *req,
                            unsigned int exception_code)
 {
+    int reply_filtered;
+    return modbus_reply_exception2(ctx, req, exception_code, &reply_filtered);
+}
+
+int modbus_reply_exception2(modbus_t *ctx, const uint8_t *req,
+                           unsigned int exception_code,
+                           int *reply_filtered)
+{
     int offset = ctx->backend->header_length;
     int slave = req[offset - 1];
     int function = req[offset];
@@ -1803,8 +2009,10 @@
 
     if (ctx->backend->filter_request(ctx, slave) == 1) {
         /* Filtered */
+        *reply_filtered = TRUE;
         return 0;
     }
+    *reply_filtered = FALSE;
 
     sft.slave = slave;
     sft.function = function + 0x80;;
@@ -1822,21 +2030,6 @@
     }
 }
 
-int modbus_reply_exception2(modbus_t *ctx, const uint8_t *req,
-                           unsigned int exception_code,
-                           int *reply_filtered)
-{
-  int offset = ctx->backend->header_length;
-  int slave = req[offset - 1];
-  if (ctx->backend->filter_request(ctx, slave) == 1) {
-      /* Filtered */
-      *reply_filtered = TRUE;
-      return 0;
-  }
-  *reply_filtered = FALSE;
-  return modbus_reply_exception(ctx, req, exception_code);
-}
-
 /* Reads IO status */
 static int read_io_status(modbus_t *ctx, int function,
                           int addr, int nb, uint8_t *dest)
@@ -1860,7 +2053,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
         if (rc == -1)
             return -1;
 
@@ -1929,7 +2122,7 @@
         return nb;
 }
 
-/* Reads the data from a remove device and put that data into an array */
+/* Reads the data from a remote device and put that data into an array */
 static int read_registers(modbus_t *ctx, int function, int addr, int nb,
                           uint16_t *dest)
 {
@@ -1959,7 +2152,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
         if (rc == -1)
             return -1;
 
@@ -2031,6 +2224,12 @@
         return -1;
     }
 
+    if (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU)
+    { //not allowed for serial line
+        errno = EINVAL;
+        return -1;
+    }
+
     req_length = ctx->backend->build_request_basis(ctx, _FC_READ_INPUT_REGISTERS_XL, addr, nb, req);
 
     rc = send_msg(ctx, req, req_length);
@@ -2042,7 +2241,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
         if (rc == -1)
             return -1;
 
@@ -2083,7 +2282,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
     }
 
     return rc;
@@ -2128,7 +2327,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
     }
 
     return rc;
@@ -2192,7 +2391,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
     }
 
 
@@ -2244,7 +2443,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
     }
 
     return rc;
@@ -2307,7 +2506,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
         if (rc == -1)
             return -1;
 
@@ -2346,6 +2545,12 @@
         return -1;
     }
 
+    if (ctx->backend->backend_type != _MODBUS_BACKEND_TYPE_RTU)
+    { //allowed for serial line only
+        errno = EINVAL;
+        return -1;
+    }
+
     req_length = ctx->backend->build_request_basis(ctx, _FC_DIAGNOSTICS,
                                                    subfunction, 0, req);
 
@@ -2369,7 +2574,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
 
         offset = ctx->backend->header_length;
 
@@ -2394,6 +2599,12 @@
     req_length = ctx->backend->build_request_basis(ctx, _FC_REPORT_SLAVE_ID,
                                                    0, 0, req);
 
+    if (ctx->backend->backend_type != _MODBUS_BACKEND_TYPE_RTU)
+    { //allowed for serial line only
+        errno = EINVAL;
+        return -1;
+    }
+
     /* HACKISH, addr and count are not used */
     req_length -= 4;
 
@@ -2407,7 +2618,7 @@
         if (rc == -1)
             return -1;
 
-        rc = check_confirmation(ctx, req, req_length, rsp, rc);
+        rc = modbus_check_confirmation(ctx, req, req_length, rsp, rc);
         if (rc == -1)
             return -1;
 
@@ -2671,6 +2882,23 @@
     return ctx->backend->is_multicast(ctx);
 }
 
+int modbus_register_extended_function(uint8_t function_code,
+                                      modbus_get_length_to_read_t get_length_to_read_fn,
+                                      modbus_check_confirmation_t check_confirmation_fn)
+{
+  int rc = 0;
+  if ((function_code < 128) &&
+      (table_get_length_to_read[function_code] == NULL) &&
+      (table_check_confirmation[function_code] == NULL))
+  {
+      table_get_length_to_read[function_code] = get_length_to_read_fn;
+      table_check_confirmation[function_code] = check_confirmation_fn;
+  }
+  else {
+      rc = -1;
+  }
+  return rc;
+}
 
 #ifndef HAVE_STRLCPY
 /*
--- libmodbus-3.0.5.base/src/modbus-private.h	2016-07-12 14:15:15.460141000 +0200
+++ libmodbus-3.0.5/src/modbus-private.h	2016-07-14 14:32:27.215321147 +0200
@@ -65,10 +65,49 @@
 #define _FC_WRITE_MULTIPLE_COILS      0x0F
 #define _FC_WRITE_MULTIPLE_REGISTERS  0x10
 #define _FC_REPORT_SLAVE_ID           0x11
+#define _FC_READ_FILE_RECORD          0x14
+#define _FC_WRITE_FILE_RECORD         0x15
 #define _FC_MASK_WRITE_REGISTER       0x16
 #define _FC_WRITE_AND_READ_REGISTERS  0x17
+#define _FC_READ_FIFO_QUEUE           0x18
+#define _FC_ENCAPSULATED_TRANSPORT    0x2B
 #define _FC_READ_INPUT_REGISTERS_XL   0x42
 
+/*Length to read for meta data in indication/confirmation message (including 1 byte of function code)*/
+#define _FC01_IND_META_LENGTH   5
+#define _FC02_IND_META_LENGTH   5
+#define _FC03_IND_META_LENGTH   5
+#define _FC04_IND_META_LENGTH   5
+#define _FC07_IND_META_LENGTH   1
+#define _FC11_IND_META_LENGTH   1
+#define _FC12_IND_META_LENGTH   1
+#define _FC15_IND_META_LENGTH   6
+#define _FC16_IND_META_LENGTH   6
+#define _FC17_IND_META_LENGTH   1
+#define _FC23_IND_META_LENGTH  10
+#define _FC66_IND_META_LENGTH   5
+
+#define _FC01_CNF_META_LENGTH   2
+#define _FC02_CNF_META_LENGTH   2
+#define _FC03_CNF_META_LENGTH   2
+#define _FC04_CNF_META_LENGTH   2
+#define _FC07_CNF_META_LENGTH   2
+#define _FC11_CNF_META_LENGTH   5
+#define _FC12_CNF_META_LENGTH   2
+#define _FC15_CNF_META_LENGTH   5
+#define _FC16_CNF_META_LENGTH   5
+#define _FC17_CNF_META_LENGTH   2
+#define _FC23_CNF_META_LENGTH   2
+#define _FC66_CNF_META_LENGTH   3
+
+#define _FC05_META_LENGTH   5
+#define _FC06_META_LENGTH   5
+#define _FC08_META_LENGTH   3
+#define _FC20_META_LENGTH   2
+#define _FC21_META_LENGTH   2
+#define _FC22_META_LENGTH   7
+#define _FC24_META_LENGTH   3
+
 /* Subfunction codes of _FC_DIAGNOSTICS */
 #define _SFC_RETURN_QUERY_DATA                       0x00
 #define _SFC_RESTART_COMMUNICATIONS_OPTION           0x01
--- libmodbus-3.0.5.base/configure.ac	2016-07-12 14:15:15.460141000 +0200
+++ libmodbus-3.0.5/configure.ac	2016-07-12 14:16:39.912140036 +0200
@@ -41,7 +41,7 @@
 # ABI version
 # http://www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html
 LIBMODBUS_LD_CURRENT=750
-LIBMODBUS_LD_REVISION=34
+LIBMODBUS_LD_REVISION=35
 LIBMODBUS_LD_AGE=0
 LIBMODBUS_LT_VERSION_INFO=$LIBMODBUS_LD_CURRENT:$LIBMODBUS_LD_REVISION:$LIBMODBUS_LD_AGE
 AC_SUBST(LIBMODBUS_LT_VERSION_INFO)
