diff --git a/.gitignore b/.gitignore
index 529bcfc2128..95d0bcb3ec3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -89,3 +89,6 @@ GTAGS
 /allrandom.config
 /allyes.config
 /compile_commands.json
+m-arm
+update-svn-patches.sh
+export-release-patch.sh
diff --git a/Documentation/user/booting-linux.rst b/Documentation/user/booting-linux.rst
index 60babb513ce..b6889238479 100644
--- a/Documentation/user/booting-linux.rst
+++ b/Documentation/user/booting-linux.rst
@@ -225,6 +225,14 @@ compatible NFS URI string must be passed to the boot command:
 
   boot nfs://nfshost[:port]//path/
 
+Barebox can choose certain Bootloader Spec config files directly. That avoids searching
+for the right bootentrie. Pass the path of a certain Bootloader Spec config file with
+``file://`` prefix to the boot command:
+
+.. code-block:: sh
+
+  boot file://path/loader/entries/filename.conf
+
 Additionally to the options defined in the original spec barebox understands the
 ``linux-appendroot`` option. This is a boolean value and if set to ``true`` barebox
 will automatically append a ``root=`` string to the Linux commandline based on the
diff --git a/arch/arm/boards/Makefile b/arch/arm/boards/Makefile
index 5aac64fce58..cb00e46f54c 100644
--- a/arch/arm/boards/Makefile
+++ b/arch/arm/boards/Makefile
@@ -137,6 +137,7 @@ obj-$(CONFIG_MACH_SOLIDRUN_MICROSOM)		+= solidrun-microsom/
 obj-$(CONFIG_MACH_STM32MP15XX_DKX)		+= stm32mp15xx-dkx/
 obj-$(CONFIG_MACH_LXA_MC1)			+= lxa-mc1/
 obj-$(CONFIG_MACH_STM32MP15X_EV1)		+= stm32mp15x-ev1/
+obj-$(CONFIG_MACH_STM32MP151_CC100)		+= stm32mp151-cc100/
 obj-$(CONFIG_MACH_TECHNEXION_PICO_HOBBIT)	+= technexion-pico-hobbit/
 obj-$(CONFIG_MACH_TECHNEXION_WANDBOARD)		+= technexion-wandboard/
 obj-$(CONFIG_MACH_TNY_A9260)			+= tny-a926x/
@@ -177,6 +178,8 @@ obj-$(CONFIG_MACH_ZII_IMX8MQ_DEV)		+= zii-imx8mq-dev/
 obj-$(CONFIG_MACH_ZII_VF610_DEV)		+= zii-vf610-dev/
 obj-$(CONFIG_MACH_ZII_IMX7D_DEV)		+= zii-imx7d-dev/
 obj-$(CONFIG_MACH_WAGO_PFC_AM35XX)		+= wago-pfc-am35xx/
+obj-$(CONFIG_MACH_WAGO_PFC_AM335X)		+= wago-pfc-am335x/
+obj-$(CONFIG_MACH_WAGO_VTPCTP_MX6)		+= wago-vtpctp-imx6/
 obj-$(CONFIG_MACH_LS1046ARDB)			+= ls1046ardb/
 obj-$(CONFIG_MACH_TQMLS1046A)			+= tqmls1046a/
 obj-$(CONFIG_MACH_MNT_REFORM)			+= mnt-reform/
diff --git a/arch/arm/boards/stm32mp151-cc100/Makefile b/arch/arm/boards/stm32mp151-cc100/Makefile
new file mode 100644
index 00000000000..ce2e8582802
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/Makefile
@@ -0,0 +1,3 @@
+lwl-y += lowlevel.o
+obj-y += board.o
+bbenv-y += defaultenv-stm32mp151-cc100
diff --git a/arch/arm/boards/stm32mp151-cc100/board.c b/arch/arm/boards/stm32mp151-cc100/board.c
new file mode 100644
index 00000000000..b831b26188a
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/board.c
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <bootsource.h>
+#include <common.h>
+#include <init.h>
+#include <mach/bbu.h>
+#include <envfs.h>
+#include <xsection.h>
+#include <linux/micrel_phy.h>
+#include <net.h>
+#include <gpio.h>
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+
+#define KSZ8863_GLOBAL_CONTROL_4		0x06
+#define KSZ8863_PORT1_Q0_INGRESS_DATA_RATE	0x16
+#define KSZ8863_PORT1_GLOBAL_CONTRL12		0x1c
+#define KSZ8863_PORT1_GLOBAL_CONTRL13		0x1d
+#define KSZ8863_PORT1_STATUS1			0x1f
+
+static int cc100_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static int ksz8863_phy_fixup(struct phy_device *phydev)
+{
+	phy_write(phydev, KSZ8863_PORT1_STATUS1, 0x8190);
+	phy_write(phydev, KSZ8863_PORT1_Q0_INGRESS_DATA_RATE, 0x202);
+	phy_write(phydev, KSZ8863_GLOBAL_CONTROL_4, 0x30);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL12, 0x9f);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL13, 0x00);
+
+	return 0;
+}
+
+static int cc100_ksz8863_setup(void)
+{
+	int ret = 0;
+
+	phy_register_fixup_for_uid(PHY_ID_KSZ8863, MICREL_PHY_ID_MASK,
+							ksz8863_phy_fixup);
+
+	return ret;
+}
+fs_initcall(cc100_ksz8863_setup);
+
+static int stm32mp151_cc100_late_init(void)
+{
+	int ret;
+
+	ret = cc100_set_ethaddr();
+	if (ret < 0)
+		pr_info("no valid ethaddr in eeprom found. Using randomized MAC address\n");
+
+	//  switch the led-mmc on, if booted from mmc
+	if ((bootsource_get() == BOOTSOURCE_MMC) &&
+	    (bootsource_get_instance() == 0)) {
+
+		int gpio_led_mmc = gpio_find_by_label("led-mmc");
+		if (gpio_led_mmc < 0)
+			pr_err("mmc led out of order because gpio led-mmc \
+				not found in dts\n");
+		else
+			gpio_direction_output(gpio_led_mmc, 1);
+	}
+
+	return ret;
+}
+late_initcall(stm32mp151_cc100_late_init);
+
+
+static int stm32mp151_cc100_probe(struct device_d *dev)
+{
+	int flags;
+
+	flags = bootsource_get_instance() == 0 ? BBU_HANDLER_FLAG_DEFAULT : 0;
+	stm32mp_bbu_mmc_register_handler("sd", "/dev/mmc0.ssbl", flags);
+
+	flags = bootsource_get_instance() == 1 ? BBU_HANDLER_FLAG_DEFAULT : 0;
+	stm32mp_bbu_mmc_register_handler("emmc", "/dev/mmc1.ssbl", flags);
+
+	defaultenv_append_directory(defaultenv_stm32mp151_cc100);
+
+	if (bootsource_get_instance() == 0)
+		of_device_enable_path("/chosen/environment-sd");
+	else
+		of_device_enable_path("/chosen/environment-emmc");
+
+	barebox_set_model("STM32MP151-CC100");
+
+	return 0;
+}
+
+static const struct of_device_id stm32mp151_cc100_of_match[] = {
+	{ .compatible = "st,stm32mp151_cc100" },
+	{ /* sentinel */ },
+};
+
+static struct driver_d stm32mp151_cc100_board_driver = {
+	.name = "board-stm32mp151_cc100",
+	.probe = stm32mp151_cc100_probe,
+	.of_compatible = stm32mp151_cc100_of_match,
+};
+postcore_platform_driver(stm32mp151_cc100_board_driver);
diff --git a/arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/init/aa-cc100-setup-board-env b/arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/init/aa-cc100-setup-board-env
new file mode 100644
index 00000000000..860a8abb085
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/init/aa-cc100-setup-board-env
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+# set variables for vtpctp
+
+global.pfc.emmc_dev_rootfs0="/dev/mmc1.4"
+global.pfc.emmc_dev_rootfs1="/dev/mmc1.7"
+
+# this is only a workaround until the boot partition on the sd-card is
+# available
+global.pfc.sd_dev_boot="/dev/mmc0.99"
+
+global.pfc.sd_dev_rootfs="/dev/mmc0.4"
+
+global.pfc.linux_uart_device="ttySTM"
+global.pfc.barebox_uart="0"
+
+# Linux driver of the internal watchdog does not support module parameterization.
+# Thus the watchdog timeout has to be set in appropriate DTS file (timeout-sec).
+global.linux.bootargs.watchdog=""
diff --git a/arch/arm/boards/stm32mp151-cc100/lowlevel.c b/arch/arm/boards/stm32mp151-cc100/lowlevel.c
new file mode 100644
index 00000000000..c753e5c84c5
--- /dev/null
+++ b/arch/arm/boards/stm32mp151-cc100/lowlevel.c
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0+
+#include <common.h>
+#include <mach/entry.h>
+#include <debug_ll.h>
+
+extern char __dtb_z_stm32mp151_cc100_start[];
+
+static void setup_uart(void)
+{
+	/* first stage has set up the UART, so nothing to do here */
+	putc_ll('>');
+}
+
+ENTRY_FUNCTION(start_stm32mp151_cc100, r0, r1, r2)
+{
+	void *fdt;
+
+	stm32mp_cpu_lowlevel_init();
+
+	if (IS_ENABLED(CONFIG_DEBUG_LL))
+		setup_uart();
+
+	fdt = __dtb_z_stm32mp151_cc100_start + get_runtime_offset();
+
+	stm32mp1_barebox_entry(fdt);
+}
diff --git a/arch/arm/boards/wago-pfc-am335x/Makefile b/arch/arm/boards/wago-pfc-am335x/Makefile
new file mode 100644
index 00000000000..1355b5faadd
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/Makefile
@@ -0,0 +1,3 @@
+lwl-y += lowlevel.o
+obj-y += board.o
+bbenv-y += defaultenv-pfc-am335x
diff --git a/arch/arm/boards/wago-pfc-am335x/board.c b/arch/arm/boards/wago-pfc-am335x/board.c
new file mode 100644
index 00000000000..9fd48dcd70f
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/board.c
@@ -0,0 +1,321 @@
+/*
+ * Copyright (C) 2015 Wadim Egorov, PHYTEC Messtechnik GmbH
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * Device initialization for the following pfc board variants:
+ *   - 750-810x	PFC100
+ *   - 750-8208	PFC200
+ *   - 750-821x	PFC200
+ *   - 768-330x	PFC200ADV
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <bootsource.h>
+#include <common.h>
+#include <nand.h>
+#include <net.h>
+#include <init.h>
+#include <io.h>
+#include <linux/sizes.h>
+#include <envfs.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/am33xx-generic.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <mach/bbu.h>
+#include <mach/devices.h>
+#include <xsection.h>
+#include <linux/bitmap.h>
+#include <gpio.h>
+#include <of_gpio.h>
+#include <mci.h>
+
+static int pfc_coredevice_init(void)
+{
+	if (!of_machine_is_compatible("wago,am335x-pfc"))
+		return 0;
+
+	am33xx_register_ethaddr(0, 0);
+
+	return 0;
+}
+coredevice_initcall(pfc_coredevice_init);
+
+static char *mlo_nandslots[] = {
+	"/dev/nand0.mlo0.bb",
+	"/dev/nand0.mlo1.bb",
+	"/dev/nand0.mlo2.bb",
+	"/dev/nand0.mlo3.bb"
+};
+
+static char *boot_nandslots[] = {
+	"/dev/nand0.boot0.bb",
+	"/dev/nand0.boot1.bb",
+	"/dev/nand0.boot2.bb",
+	"/dev/nand0.boot3.bb"
+};
+
+static char *boot_emmcslots[] = {
+	"/dev/mmc1.boot0",
+	"/dev/mmc1.boot1",
+	"/dev/mmc1.boot2",
+	"/dev/mmc1.boot3",
+};
+
+static struct omap_barebox_boot_parts pfc_barebox_boot_parts = {
+	.boot_nandslots = boot_nandslots,
+	.boot_emmcslots = boot_emmcslots,
+	.num_boot_nandslots = ARRAY_SIZE(boot_nandslots),
+	.num_boot_emmcslots = ARRAY_SIZE(boot_emmcslots),
+};
+
+#define DISABLE_SD_BOOT_BIT 0
+static int pfc_set_device_state(struct omap_board_info *board)
+{
+	u8 mac[6], boot_mode_id_ext;
+	int ret;
+
+	ret = xsection_get_boot_mode_id_ext(&boot_mode_id_ext);
+	if (ret < 0)
+		goto out;
+
+	if (test_bit(DISABLE_SD_BOOT_BIT, &boot_mode_id_ext)) {
+		board->disable_sd_boot = true;
+		pr_info("%s: booting from sd disabled\n", __func__);
+	}
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		goto out;
+
+	if (mac[0] != 0x00 || mac[1] != 0x30 || mac[2] != 0xde)
+		board->production_mode = true;
+
+	if (test_bit(HAS_USB, board->boot_devices)) {
+		struct device_d *usbgadget;
+
+		usbgadget = get_device_by_name("usbgadget");
+		if (!usbgadget) {
+			ret = -ENODEV;
+			goto out;
+		}
+
+		/* use processors internal ethaddr as unique
+		 * serial number for usb connections
+		 */
+		am33xx_get_internal_mac_id(mac, 0);
+		ret = dev_set_param(usbgadget, "serialnumber",
+					basprintf("%02x%02x%02x%02x%02x%02x",
+					mac[0], mac[1], mac[2], mac[3], mac[4],
+					mac[5]));
+		if (ret)
+			goto out;
+
+		ret = dev_set_param(usbgadget, "manufacturer",
+					"WAGO Kontakttechnik GmbH & Co. KG");
+	}
+out:
+	return ret < 0 ? ret : 0;
+}
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+static int pfc_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static void pfc_set_available_dev(struct omap_board_info *board, char *alias,
+						enum omap_board_boot_device dev)
+{
+	struct device_node *node;
+
+	node = of_find_node_by_alias(of_get_root_node(), alias);
+	if (!node)
+		return;
+
+	if (of_device_is_available(node))
+		set_bit(dev, board->boot_devices);
+}
+
+static int pfc_devices_init(void)
+{
+	int ret;
+	const char *s;
+	struct omap_board_info *board;
+	struct mci *mci;
+	char *bbu_mlo;
+	char *bbu_mlo_target;
+	char *bbu_barebox;
+
+	if (!of_machine_is_compatible("wago,am335x-pfc"))
+		return 0;
+
+	board = xzalloc(sizeof(*board));
+
+	/* Do this also in mlo, because the pfc startup code needs this
+	 * information to get the right barebox image.
+	 */
+	ret = of_property_read_string(of_get_root_node(), "board-variant", &s);
+	if (!ret)
+		board->board_variant = xstrdup(s);
+	else
+		pr_warn("failed to get board.variant from oftree\n");
+
+	pfc_set_available_dev(board, "sd", HAS_SD);
+	pfc_set_available_dev(board, "emmc", HAS_EMMC);
+	pfc_set_available_dev(board, "nand", HAS_NAND);
+	pfc_set_available_dev(board, "usb0", HAS_USB);
+
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
+	}
+
+	if (test_bit(HAS_EMMC, board->boot_devices)) {
+		am33xx_bbu_emmc_mlo_register_handler("mlo.emmc.raw", "/dev/mmc1");
+		am33xx_bbu_emmc_register_handler("boot.emmc.raw", boot_emmcslots,
+						ARRAY_SIZE(boot_emmcslots));
+
+		bbu_register_std_file_update("mlo.emmc.vfat",
+						BBU_HANDLER_FLAG_DEFAULT,
+						"/mnt/mmc1.0/mlo",
+						filetype_ch_image);
+
+		bbu_mlo_target = basprintf("mlo.emmc.vfat.%s",
+							board->board_variant);
+		bbu_mlo = basprintf("/mnt/mmc1.0/mlo.%s",
+							board->board_variant);
+		bbu_register_std_file_update(xstrdup(bbu_mlo_target),
+						BBU_HANDLER_FLAG_DEFAULT,
+						xstrdup(bbu_mlo),
+						filetype_ch_image);
+
+		bbu_barebox = basprintf("/mnt/mmc1.0/barebox.bin.%s",
+							board->board_variant);
+		bbu_register_std_file_update("mlo.boot.vfat",
+						BBU_HANDLER_FLAG_DEFAULT,
+						xstrdup(bbu_barebox),
+						filetype_arm_barebox);
+	}
+
+	if (test_bit(HAS_NAND, board->boot_devices)) {
+		am33xx_bbu_nand_xloadslots_register_handler("mlo.nand",
+						mlo_nandslots,
+						ARRAY_SIZE(mlo_nandslots));
+		am33xx_bbu_nand_slots_register_handler("boot.nand",
+						boot_nandslots,
+						ARRAY_SIZE(boot_nandslots));
+	}
+
+	mci = mci_get_device_by_name("mmc0");
+	if (mci && mci->host->card_present) {
+		if (mci->host->card_present(mci->host))
+			of_device_enable_path("/chosen/environment-sd");
+
+	} else if (test_bit(HAS_EMMC, board->boot_devices)) {
+		of_device_enable_path("/chosen/environment-emmc");
+	}
+
+	omap_set_barebox_boot_parts(&pfc_barebox_boot_parts);
+	defaultenv_append_directory(defaultenv_pfc_am335x);
+
+	armlinux_set_architecture(MACH_TYPE_PFC_AM335X);
+	barebox_set_hostname("pfc");
+
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		/* Set MAC address for ethernet0 from eeprom. If no valid MAC
+		 * address could read, use the randomized one. Dont do this in
+		 * mlo, because this is useless there.
+		 */
+		ret = pfc_set_ethaddr();
+		if (ret < 0) {
+			pr_warn("no valid ethaddr in eeprom found. Using "
+				"randomized MAC address\n");
+		}
+	}
+
+	ret = pfc_set_device_state(board);
+	if (ret)
+		goto out;
+
+	omap_set_board_info(board);
+
+	/* dont free in case of mlo boot. We need the board information in the
+	 * xload-pfc module
+	 */
+	if (IS_ENABLED(CONFIG_SHELL_NONE)) {
+		ret = am33xx_of_register_bootdevice();
+		goto out_ret;
+	}
+
+out:
+	free(board->board_variant);
+	free(board);
+out_ret:
+	return ret;
+}
+late_initcall(pfc_devices_init);
+
+#define I2C_EEPROM_BOOT_MODE_ID_DEV_BIT (1 << 0)
+static int pfc_check_and_set_debug_uart(void)
+{
+	struct device_node *boot_mode_node;
+	struct cdev *cdev;
+	u8 boot_mode_id;
+	int ret = 0;
+
+	if (IS_ENABLED(CONFIG_SHELL_NONE)) {
+		boot_mode_node = of_find_node_by_name(NULL, "boot-mode-id@0");
+		if (!boot_mode_node) {
+			pr_err("%s: could not find boot-mode-id@0 node\n",
+								__func__);
+			ret = -ENODEV;
+			goto out;
+		}
+
+		cdev = cdev_by_device_node(boot_mode_node);
+		if (!cdev) {
+			ret = -ENODEV;
+			goto out;
+		}
+
+		ret = cdev_read(cdev, &boot_mode_id, cdev->size, 0, 0);
+		if (ret < 0)
+			goto out;
+
+		if (boot_mode_id & I2C_EEPROM_BOOT_MODE_ID_DEV_BIT) {
+			pr_info("%s: debug mode active\n", __func__);
+			omap_add_uart(0, AM33XX_UART0_BASE);
+		}
+	}
+
+out:
+	return ret < 0 ? ret : 0;
+}
+late_initcall(pfc_check_and_set_debug_uart);
diff --git a/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/bin/pfc-config-production-boot b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/bin/pfc-config-production-boot
new file mode 100644
index 00000000000..e174ac5613f
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/bin/pfc-config-production-boot
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+global.linux.bootargs.watchdog=""
+global.boot.watchdog_timeout=0
+global.autoboot=abort
+
+uart_console -e ${global.pfc.barebox_uart}
+led_mode -m -c green
+usbgadget ${global.pfc.usbgadget_options}
+
+echo -e ${info} "waiting for commands over fastboot"
+
+exit 0
diff --git a/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/init/d-pfc-setup-board-env b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/init/d-pfc-setup-board-env
new file mode 100644
index 00000000000..c61c083f69f
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/init/d-pfc-setup-board-env
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+# setup pmic to enable LS2/LS3
+i2c_write -b 0x0 -a 0x24 -r 0x10 0x6F
+i2c_write -b 0x0 -a 0x24 -r 0x12 0x1f
+i2c_write -b 0x0 -a 0x24 -r 0x10 0x69
+i2c_write -b 0x0 -a 0x24 -r 0x14 0xcd
\ No newline at end of file
diff --git a/arch/arm/boards/wago-pfc-am335x/lowlevel.c b/arch/arm/boards/wago-pfc-am335x/lowlevel.c
new file mode 100644
index 00000000000..4814c0aa151
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/lowlevel.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2015 Wadim Egorov, PHYTEC Messtechnik GmbH
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <linux/sizes.h>
+#include <io.h>
+#include <init.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/am33xx-clock.h>
+#include <mach/generic.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/am33xx-mux.h>
+#include <mach/am33xx-generic.h>
+#include <mach/wdt.h>
+#include <debug_ll.h>
+
+#include "ram-timings.h"
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+static noinline void am33xx_pfc_sram_init(void *fdt, int sdram)
+{
+	/*
+	 * WDT1 is already running when the bootloader gets control
+	 * Disable it to avoid "random" resets
+	 */
+	writel(WDT_DISABLE_CODE1, AM33XX_WDT_REG(WSPR));
+	while (readl(AM33XX_WDT_REG(WWPS)) != 0x0);
+
+	writel(WDT_DISABLE_CODE2, AM33XX_WDT_REG(WSPR));
+	while (readl(AM33XX_WDT_REG(WWPS)) != 0x0);
+
+	am33xx_pll_init(MPUPLL_M_600, DDRPLL_M_400);
+
+	am335x_sdram_init(DDR_IOCTRL, &pfc_timings[sdram].cmd_ctrl,
+			&pfc_timings[sdram].regs,
+			&pfc_timings[sdram].data);
+
+	am33xx_uart_soft_reset((void *)AM33XX_UART0_BASE);
+	am33xx_enable_uart0_pin_mux();
+	omap_uart_lowlevel_init((void *)AM33XX_UART0_BASE);
+	putc_ll('>');
+
+	am335x_barebox_entry(fdt);
+}
+
+static noinline void am33xx_pfc_board_entry(unsigned long bootinfo, int sdram,
+					void *fdt)
+{
+	am33xx_save_bootinfo((void *)bootinfo);
+
+	arm_cpu_lowlevel_init();
+
+	/*
+	 * Setup C environment, the board init code uses global variables.
+	 * Stackpointer has already been initialized by the ROM code.
+	 */
+	relocate_to_current_adr();
+	setup_c();
+	am33xx_pfc_sram_init(fdt, sdram);
+}
+
+#define PFC_ENTRY_MLO(name, fdt_name, sdram)				\
+	ENTRY_FUNCTION(name, bootinfo, r1, r2)				\
+	{								\
+		extern char __dtb_z_##fdt_name##_start[];		\
+		void *fdt = __dtb_z_##fdt_name##_start +		\
+			get_runtime_offset();				\
+		am33xx_pfc_board_entry(bootinfo, sdram, fdt);		\
+	}
+
+#define PFC_ENTRY(name, fdt_name, mem_size)				\
+	ENTRY_FUNCTION(name, r0, r1, r2)				\
+	{								\
+		extern char __dtb_z_##fdt_name##_start[];		\
+		void *fdt = __dtb_z_##fdt_name##_start +		\
+			get_runtime_offset();				\
+		barebox_arm_entry(0x80000000, mem_size, fdt);		\
+	}
+
+PFC_ENTRY_MLO(start_am33xx_pfc_750_810x_sram_256mb, am335x_pfc_750_810x_mlo,
+								PFC_DDR3_256MB);
+PFC_ENTRY_MLO(start_am33xx_pfc_750_8208_sram_256mb, am335x_pfc_750_8208_mlo,
+								PFC_DDR3_256MB);
+PFC_ENTRY_MLO(start_am33xx_pfc_750_821x_sram_512mb, am335x_pfc_750_821x_mlo,
+								PFC_DDR3_512MB);
+PFC_ENTRY_MLO(start_am33xx_pfc_768_330x_sram_512mb, am335x_pfc_768_330x_mlo,
+								PFC_DDR3_512MB);
+
+PFC_ENTRY(start_am33xx_pfc_750_810x_sdram, am335x_pfc_750_810x, SZ_256M);
+PFC_ENTRY(start_am33xx_pfc_750_8208_sdram, am335x_pfc_750_8208, SZ_256M);
+PFC_ENTRY(start_am33xx_pfc_750_821x_sdram, am335x_pfc_750_821x, SZ_512M);
+PFC_ENTRY(start_am33xx_pfc_768_330x_sdram, am335x_pfc_768_330x, SZ_512M);
diff --git a/arch/arm/boards/wago-pfc-am335x/ram-timings.h b/arch/arm/boards/wago-pfc-am335x/ram-timings.h
new file mode 100644
index 00000000000..fbbea4daaf3
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/ram-timings.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2015 Wadim Egorov, PHYTEC Messtechnik GmbH
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __RAM_TIMINGS_H
+#define __RAM_TIMINGS_H
+
+#define DDR_IOCTRL	0x18B
+
+struct am335x_sdram_timings {
+	struct am33xx_emif_regs regs;
+	struct am33xx_ddr_data data;
+	struct am33xx_cmd_control cmd_ctrl;
+};
+
+enum {
+	PFC_DDR3_256MB,
+	PFC_DDR3_512MB,
+};
+
+struct am335x_sdram_timings pfc_timings[] = {
+	[PFC_DDR3_256MB] = {
+		.regs = {
+			.emif_read_latency	= 0x100007,
+			.emif_tim1		= 0x0AAAD4DB,
+			.emif_tim2		= 0x24437FDA,
+			.emif_tim3		= 0x50FFE3FF,
+			.sdram_config		= 0x61C052B2,
+			.sdram_ref_ctrl		= 0x20000064,
+			.ocp_config		= 0x00141414,
+			.zq_config		= 0x50074BE4,
+			.sdram_config2		= 0x0,
+		},
+		.data = {
+			.rd_slave_ratio0        = 0x38,
+			.wr_dqs_slave_ratio0    = 0x44,
+			.fifo_we_slave_ratio0	= 0x94,
+			.wr_slave_ratio0        = 0x7D,
+			.use_rank0_delay	= 0x01,
+			.dll_lock_diff0		= 0x0,
+		},
+		.cmd_ctrl = {
+			.slave_ratio0	= 0x80,
+			.dll_lock_diff0	= 0x1,
+			.invert_clkout0	= 0x0,
+			.slave_ratio1	= 0x80,
+			.dll_lock_diff1	= 0x1,
+			.invert_clkout1	= 0x0,
+			.slave_ratio2	= 0x80,
+			.dll_lock_diff2	= 0x1,
+			.invert_clkout2	= 0x0,
+		},
+	},
+
+	[PFC_DDR3_512MB] = {
+		.regs = {
+			.emif_read_latency	= 0x100007,
+			.emif_tim1		= 0x0AAAD4DB,
+			.emif_tim2		= 0x206B7FDA,
+			.emif_tim3		= 0x501F867F,
+			.sdram_config		= 0x61C05332,
+			.sdram_ref_ctrl		= 0x20000064,
+			.ocp_config		= 0x00141414,
+			.zq_config		= 0x50074BE4,
+			.sdram_config2		= 0x0,
+		},
+		.data = {
+			.rd_slave_ratio0        = 0x38,
+			.wr_dqs_slave_ratio0    = 0x44,
+			.fifo_we_slave_ratio0	= 0x94,
+			.wr_slave_ratio0        = 0x7D,
+			.use_rank0_delay	= 0x01,
+			.dll_lock_diff0		= 0x0,
+		},
+		.cmd_ctrl = {
+			.slave_ratio0	= 0x80,
+			.dll_lock_diff0	= 0x1,
+			.invert_clkout0	= 0x0,
+			.slave_ratio1	= 0x80,
+			.dll_lock_diff1	= 0x1,
+			.invert_clkout1	= 0x0,
+			.slave_ratio2	= 0x80,
+			.dll_lock_diff2	= 0x1,
+			.invert_clkout2	= 0x0,
+		},
+
+	},
+};
+
+#endif
diff --git a/arch/arm/boards/wago-pfc-am35xx/Makefile b/arch/arm/boards/wago-pfc-am35xx/Makefile
index 7bd3009f31e..fd053fd2871 100644
--- a/arch/arm/boards/wago-pfc-am35xx/Makefile
+++ b/arch/arm/boards/wago-pfc-am35xx/Makefile
@@ -3,4 +3,5 @@ ifdef CONFIG_OMAP_BUILD_IFT
 obj-y += board-mlo.o
 else
 obj-y += board.o
+bbenv-y += defaultenv-pfc-am35xx
 endif
diff --git a/arch/arm/boards/wago-pfc-am35xx/board-mlo.c b/arch/arm/boards/wago-pfc-am35xx/board-mlo.c
index c940565b4af..bc72298a131 100644
--- a/arch/arm/boards/wago-pfc-am35xx/board-mlo.c
+++ b/arch/arm/boards/wago-pfc-am35xx/board-mlo.c
@@ -5,6 +5,7 @@
  */
 
 #include <common.h>
+#include <bootsource.h>
 #include <init.h>
 #include <io.h>
 #include <linux/sizes.h>
@@ -14,14 +15,25 @@
 #include <errno.h>
 #include <mach/omap3-devices.h>
 #include <mach/generic.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <nand.h>
+#include <i2c/i2c.h>
+#include <linux/bitmap.h>
 
-/* map first four erase blocks */
-static struct omap_barebox_part pfc200_mlo_part = {
-	/* start of boot0..boot3 (stage2 bootcode),
-	 * we have 4x partitions
-	 */
-	.nand_offset = 4 * SZ_128K,
-	.nand_size = 4 * SZ_128K,
+static char *boot_nandslots[] = {
+	"/dev/nand0.boot0.bb",
+	"/dev/nand0.boot1.bb",
+	"/dev/nand0.boot2.bb",
+	"/dev/nand0.boot3.bb"
+};
+
+static struct omap_barebox_boot_parts pfc_barebox_boot_parts = {
+	.boot_nandslots = boot_nandslots,
+	.num_boot_nandslots = ARRAY_SIZE(boot_nandslots),
+};
+
+static struct omap_board_info board = {
+	.board_variant = "pfc200",
 };
 
 /**
@@ -31,10 +43,8 @@ static struct omap_barebox_part pfc200_mlo_part = {
  */
 static int pfc200_init_console(void)
 {
-	barebox_set_model("Wago PFC200 MLO Stage #1");
-	barebox_set_hostname("pfc200-mlo");
-
-	omap3_add_uart3();
+	barebox_set_model("PFC-750-820x MLO");
+	barebox_set_hostname("PFC-750-820x-MLO");
 
 	return 0;
 }
@@ -51,10 +61,61 @@ mem_initcall(pfc200_mem_init);
 __maybe_unused static struct gpmc_nand_platform_data nand_plat = {
 	.cs = 0,
 	.device_width = 8,
-	.ecc_mode = OMAP_ECC_BCH8_CODE_HW_ROMCODE,
+	.ecc_mode = OMAP_ECC_BCH8_CODE_HW_DETECTION_SW,
 	.nand_cfg = &omap3_nand_cfg,
 };
 
+static struct omap_hsmmc_platform_data mmc_pdata = {
+	.devname = "mmc0",
+	.cd_gpio = 116,
+	.cd_inverted = true,
+};
+
+static struct i2c_platform_data i2c_pdata = {
+	.bitrate = 400000,
+};
+
+#define I2C_EEPROM_BUS	 		1
+#define I2C_EEPROM_ADDR			0x54
+#define I2C_EEPROM_BOOT_MODE_ID 	0x0
+#define I2C_EEPROM_BOOT_MODE_ID_EXT 	0x0102
+#define I2C_EEPROM_BOOT_MODE_ID_DEV_BIT (1 << 0)
+#define I2C_EEPROM_BOOT_MODE_ID_DISABLE_SD_BIT (1 << 0)
+static int pfc200_set_device_state_and_enable_debug_uart(void)
+{
+	struct i2c_adapter *adapter;
+	struct i2c_client client;
+	u8 boot_mode_id, boot_mode_id_ext;
+
+	adapter = i2c_get_adapter(I2C_EEPROM_BUS);
+	if (!adapter) {
+		pr_err("%s: i2c2 not found\n", __func__);
+		return -ENODEV;
+	}
+
+	client.adapter = adapter;
+	client.addr = I2C_EEPROM_ADDR;
+
+	i2c_read_reg(&client, I2C_EEPROM_BOOT_MODE_ID | I2C_ADDR_16_BIT,
+							&boot_mode_id, 1);
+
+	if (boot_mode_id & I2C_EEPROM_BOOT_MODE_ID_DEV_BIT) {
+		pr_info("%s: debug mode active\n", __func__);
+		omap3_add_uart3();
+	}
+
+	i2c_read_reg(&client, I2C_EEPROM_BOOT_MODE_ID_EXT | I2C_ADDR_16_BIT,
+							&boot_mode_id_ext, 1);
+
+	if (boot_mode_id_ext & I2C_EEPROM_BOOT_MODE_ID_DISABLE_SD_BIT) {
+		printf("pfc: booting from sd disabled\n");
+		board.disable_sd_boot = true;
+	}
+
+	return 0;
+}
+late_initcall(pfc200_set_device_state_and_enable_debug_uart);
+
 static int pfc200_init_devices(void)
 {
 #ifdef CONFIG_OMAP_GPMC
@@ -64,10 +125,50 @@ static int pfc200_init_devices(void)
 	gpmc_generic_init(0x10);
 	omap_add_gpmc_nand_device(&nand_plat);
 #endif
-	omap_set_barebox_part(&pfc200_mlo_part);
 
-	omap3_add_mmc1(NULL);
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
+	}
+
+	omap3_add_mmc1(&mmc_pdata);
+
+	if (IS_ENABLED(CONFIG_I2C_OMAP))
+		omap3_add_i2c2(&i2c_pdata);
+
+	bitmap_zero(board.boot_devices, NUM_BOOT_DEVICES);
+	set_bit(HAS_SD, board.boot_devices);
+	set_bit(HAS_NAND, board.boot_devices);
+	omap_set_board_info(&board);
 
 	return 0;
 }
 device_initcall(pfc200_init_devices);
+
+#define BOOT_START_OFFSET 	0x80000
+#define BOOT_SIZE		0x80000
+static int pfc200_create_boot_partitions(void)
+{
+	int i = 0;
+	loff_t offset = BOOT_START_OFFSET;
+	char part_name[12];
+
+	do {
+		sprintf(part_name, "nand0.boot%d", i);
+		devfs_add_partition("nand0", offset, BOOT_SIZE,
+					DEVFS_PARTITION_FIXED, part_name);
+
+		dev_add_bb_dev(part_name, "bb");
+
+		offset += BOOT_SIZE;
+		i++;
+
+	} while (i < pfc_barebox_boot_parts.num_boot_nandslots);
+
+	omap_set_barebox_boot_parts(&pfc_barebox_boot_parts);
+
+	return 0;
+}
+late_initcall(pfc200_create_boot_partitions);
diff --git a/arch/arm/boards/wago-pfc-am35xx/board.c b/arch/arm/boards/wago-pfc-am35xx/board.c
index c0a039ba507..2d3133e976a 100644
--- a/arch/arm/boards/wago-pfc-am35xx/board.c
+++ b/arch/arm/boards/wago-pfc-am35xx/board.c
@@ -5,20 +5,65 @@
  */
 #define pr_fmt(fmt)	"pfc200: " fmt
 
+/**
+ * @file
+ * @brief PFCxxx Specific Board Initialization routines
+ */
+
+#include <bootsource.h>
 #include <common.h>
 #include <init.h>
 #include <driver.h>
-#include <gpio.h>
+#include <envfs.h>
+#include <environment.h>
 #include <linux/sizes.h>
+#include <net.h>
+#include <envfs.h>
+#include <bootsource.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/am33xx-generic.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/gpmc.h>
 #include <linux/err.h>
-#include <linux/phy.h>
-#include <linux/micrel_phy.h>
-#include <asm/memory.h>
-#include <mach/generic.h>
+#include <gpio.h>
+
+#include <mach/omap3-devices.h>
+
+#include <mach/am33xx-clock.h>
+#include <mach/omap3-devices.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <mach/bbu.h>
+#include <xsection.h>
+
+static char *mlo_nandslots[] = {
+	"/dev/nand0.mlo0.bb",
+	"/dev/nand0.mlo1.bb",
+	"/dev/nand0.mlo2.bb",
+	"/dev/nand0.mlo3.bb"
+};
+
+static char *boot_nandslots[] = {
+	"/dev/nand0.boot0.bb",
+	"/dev/nand0.boot1.bb",
+	"/dev/nand0.boot2.bb",
+	"/dev/nand0.boot3.bb"
+};
+
+static int pfc200_coredevice_init(void)
+{
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
+		return 0;
+
+	return 0;
+}
+coredevice_initcall(pfc200_coredevice_init);
 
 static int pfc200_mem_init(void)
 {
-	if (!of_machine_is_compatible("ti,pfc200"))
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
 		return 0;
 
 	arm_add_mem_device("ram0", 0x80000000, SZ_256M);
@@ -26,59 +71,63 @@ static int pfc200_mem_init(void)
 }
 mem_initcall(pfc200_mem_init);
 
-#define BMCR_HP_MDIX 0x20
-
-static int pfc200_phy_fixup(struct mii_bus *mii, int phyadr)
+#define ETH_DEVICE_0 0
+static int pfc_set_ethaddr(void)
 {
-	struct phy_device *phydev;
-	int ret;
-
-	phydev = mdiobus_scan(mii, phyadr);
-
-	if (IS_ERR(phydev)) {
-		pr_err("Cannot find phydev %d on mii bus\n", phyadr);
-		return PTR_ERR(phydev);
+	u8 mac[6];
+	int ret = 0;
+	struct eth_device *edev;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0 || !is_valid_ether_addr(mac)) {
+		random_ether_addr(mac);
+		ret = -EINVAL;
 	}
 
-	ret = phy_write(phydev, MII_BMCR, BMCR_ANENABLE | BMCR_HP_MDIX);
-	if (ret)
-		pr_err("Failed to write to phy: %s\n", strerror(-ret));
+	for_each_netdev(edev) {
+		if (edev->dev.id == ETH_DEVICE_0)
+			eth_set_ethaddr(edev, mac);
+	}
 
 	return ret;
 }
 
-static int pfc200_late_init(void)
+static int pfc200_devices_init(void)
 {
-	struct mii_bus *mii;
+	int ret;
 
-	if (!of_machine_is_compatible("ti,pfc200"))
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
 		return 0;
 
-	mii = mdiobus_get_bus(0);
-	if (!mii) {
-		pr_err("Cannot find mii bus 0\n");
-		return -ENODEV;
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
 	}
 
-	pfc200_phy_fixup(mii, 1);
-	pfc200_phy_fixup(mii, 2);
-
-	return 0;
-}
-late_initcall(pfc200_late_init);
-
-
-#define GPIO_KSZ886x_RESET	136
-
-static int pfc200_devices_init(void)
-{
-	if (!of_machine_is_compatible("ti,pfc200"))
-		return 0;
-
-	gpio_direction_output(GPIO_KSZ886x_RESET, 1);
-
-	omap_set_bootmmc_devname("mmc0");
+	am33xx_bbu_nand_xloadslots_register_handler("mlo.nand",
+					mlo_nandslots, ARRAY_SIZE(mlo_nandslots));
+	am33xx_bbu_nand_slots_register_handler("boot.nand", boot_nandslots,
+							ARRAY_SIZE(boot_nandslots));
+
+	defaultenv_append_directory(defaultenv_pfc_am35xx);
+
+	armlinux_set_architecture(MACH_TYPE_PFC_AM35XX);
+	barebox_set_hostname("pfc");
+
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		/* Set MAC address for ethernet0 from eeprom. If no valid MAC
+		 * address could read, use the randomized one. Dont do this in
+		 * mlo, because this is useless there.
+		 */
+		ret = pfc_set_ethaddr();
+		if (ret < 0) {
+			pr_warn("no valid ethaddr in eeprom found. Using "
+				"randomized MAC address\n");
+		}
+	}
 
 	return 0;
 }
-coredevice_initcall(pfc200_devices_init);
+device_initcall(pfc200_devices_init);
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/boot/net-setupfw b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/boot/net-setupfw
new file mode 100644
index 00000000000..848bf51849a
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/boot/net-setupfw
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+global.dhcp.retries=1000
+global.dhcp.vendor_id="750-8206"
+global.dhcp.option224="barebox running"
+
+ifup ${global.pfc.eth}
+
+if [ ${eth0.ipaddr} != "0.0.0.0" ] && [ ${eth0.serverip} != "0.0.0.0" ] && [ ! -z "${global.dhcp.bootfile}"  ]; then
+
+	echo -e ${info} "get ${global.dhcp.bootfile} from tftp server ${eth0.serverip}."
+
+	tftp ${global.dhcp.bootfile}
+	if [ "$?" = 0 ]; then
+		global.linux.bootargs.dyn.ip="ip=$eth0.ipaddr:$eth0.serverip:$eth0.gateway:$eth0.netmask::eth0:"
+
+		echo -e ${info} "boot ${global.dhcp.bootfile} to ${global.pfc.nand_ubidata}"
+
+		# we need to be sure, that the mac-address is invalid when the
+		# firmware loader (in case of am35xx based devices is this
+		# barebox v2014.11.0) is booted. Otherwise the firmware-loader
+		# tries to boot in default mode
+		xsection.ethaddr1=00:00:00:00:00:00
+		xsection.ethaddr2=00:00:00:00:00:00
+
+		bootm ${global.dhcp.bootfile}
+		if [ $? -ne 0 ]; then
+			echo -e ${error} "$0: could not boot ${global.dhcp.bootfile}"
+			pfc-config-broken-boot
+			exit 1
+		fi
+	else
+		echo -e ${error} "$0: tftp download failed."
+		pfc-config-broken-boot
+		exit 1
+	fi
+else
+	echo -e ${error} "$0: dhcp configuration not set correctly."
+	pfc-config-broken-boot
+	exit 1
+fi
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8 b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8
new file mode 100644
index 00000000000..210da14ea2e
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8
@@ -0,0 +1,6 @@
+#!/bin/sh 
+
+# on am35xx based targets we need to set 
+# the ecc-mode bch8 when flashing barebox
+
+gpmc_nand0.eccmode="bch8_hw_detsw"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8-legacy b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8-legacy
new file mode 100644
index 00000000000..1813bcb1a9d
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8-legacy
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+# on am35xx based targets we need to set
+# the ecc-mode bch8_legacy when flashing
+# images < 2014
+
+gpmc_nand0.eccmode="bch8_hw_detsw_legacy"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-hamming b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-hamming
new file mode 100644
index 00000000000..be3e96a99d1
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-hamming
@@ -0,0 +1,6 @@
+#!/bin/sh 
+
+# on am35xx based targets we need to set 
+# the ecc-mode hamming when flashing mlo
+
+gpmc_nand0.eccmode="hamming_hw_romcode"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env
new file mode 100644
index 00000000000..637a9eae0ef
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+# put here board specific variables or overwrite global variables
+
+global.pfc.linux_uart="0"
+global.pfc.barebox_uart="3"
+global.pfc.barebox_linux_uart="2"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/pfc-ksz8863-pwr-down b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/pfc-ksz8863-pwr-down
new file mode 100644
index 00000000000..476010f9372
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/pfc-ksz8863-pwr-down
@@ -0,0 +1,30 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# let the phys up when debug-mode is active to do ethernet communication when
+# e.g. enabling fastboot over ethernet.
+[ "${global.pfc.debug_mode_active}" = "true" ] && exit 0
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+phy_x1_addr=1
+phy_x2_addr=2
+
+# registers
+control_reg=0
+
+powerdown_enable=6176    	# 0x1820 - set the power down flag
+
+# We assume that we are running on a pfc200 G1 device
+#
+# Power down the phys. This is essetial especially for separated mode
+# operation.
+
+echo -e ${info} "switch: power down the phys"
+miitool -w "${mii_bus}:${phy_x1_addr}:${control_reg}" -p powerdown_enable
+miitool -w "${mii_bus}:${phy_x2_addr}:${control_reg}" -p powerdown_enable
+
+exit 0
diff --git a/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x128mx16.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x128mx16.imxcfg
new file mode 100644
index 00000000000..fd0d0e29264
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x128mx16.imxcfg
@@ -0,0 +1,42 @@
+wm 32 MX6_MMDC_P0_MDPDC			0x00020036
+wm 32 MX6_MMDC_P0_MDSCR			0x00008000
+wm 32 MX6_MMDC_P0_MDCFG0		0x54597955
+wm 32 MX6_MMDC_P0_MDCFG1		0xFF328F64
+wm 32 MX6_MMDC_P0_MDCFG2		0x01FF00DB
+wm 32 MX6_MMDC_P0_MDRWD			0x000026D2
+wm 32 MX6_MMDC_P0_MDOR			0x00591023
+wm 32 MX6_MMDC_P0_MDOTC			0x09444040
+wm 32 MX6_MMDC_P0_MDPDC			0x00025576
+wm 32 MX6_MMDC_P0_MDASP			0x00000027
+wm 32 MX6_MMDC_P0_MDCTL			0x831A0000
+wm 32 MX6_MMDC_P0_MDSCR			0x02088032
+wm 32 MX6_MMDC_P0_MDSCR			0x00008033
+wm 32 MX6_MMDC_P0_MDSCR			0x00048031
+wm 32 MX6_MMDC_P0_MDSCR			0x19408030
+wm 32 MX6_MMDC_P0_MDSCR			0x04008040
+wm 32 MX6_MMDC_P0_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P1_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P0_MDREF			0x00007800
+wm 32 MX6_MMDC_P0_MPODTCTRL		0x00022227
+wm 32 MX6_MMDC_P1_MPODTCTRL		0x00022227
+
+wm 32 MX6_MMDC_P0_MPDGCTRL0		0x0338034C
+wm 32 MX6_MMDC_P0_MPDGCTRL1		0x03340334
+wm 32 MX6_MMDC_P1_MPDGCTRL0		0x03400350
+wm 32 MX6_MMDC_P1_MPDGCTRL1		0x03340304
+
+wm 32 MX6_MMDC_P0_MPRDDLCTL		0x4A383C42
+wm 32 MX6_MMDC_P1_MPRDDLCTL		0x3C3E3A46
+
+wm 32 MX6_MMDC_P0_MPWRDLCTL		0x3A3C4040
+wm 32 MX6_MMDC_P1_MPWRDLCTL		0x48384840
+
+wm 32 MX6_MMDC_P0_MPWLDECTRL0	0x00220022
+wm 32 MX6_MMDC_P0_MPWLDECTRL1	0x002F0024
+wm 32 MX6_MMDC_P1_MPWLDECTRL0	0x001B002B
+wm 32 MX6_MMDC_P1_MPWLDECTRL1	0x00110026
+
+wm 32 MX6_MMDC_P0_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P1_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P0_MDSCR			0x00000000
+wm 32 MX6_MMDC_P0_MAPSR			0x00011006
diff --git a/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x256mx16.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x256mx16.imxcfg
new file mode 100644
index 00000000000..e095b79672f
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x256mx16.imxcfg
@@ -0,0 +1,45 @@
+wm 32 MX6_MMDC_P0_MDPDC			0x00020036
+wm 32 MX6_MMDC_P0_MDOTC			0x09444040
+wm 32 MX6_MMDC_P0_MDCFG0		0x898E7955
+wm 32 MX6_MMDC_P0_MDCFG1		0xFF328F64
+wm 32 MX6_MMDC_P0_MDCFG2		0x01FF00DB
+wm 32 MX6_MMDC_P0_MDMISC		0x00011740
+wm 32 MX6_MMDC_P0_MDSCR			0x00008000
+wm 32 MX6_MMDC_P0_MDRWD			0x000026D2
+wm 32 MX6_MMDC_P0_MDOR			0x008E1023
+wm 32 MX6_MMDC_P0_MDASP			0x00000047
+wm 32 MX6_MMDC_P0_MDCTL			0x841A0000 // row/column address width
+
+//Mode register writes we use only CS0
+wm 32 MX6_MMDC_P0_MDSCR			0x02088032
+wm 32 MX6_MMDC_P0_MDSCR			0x00008033
+wm 32 MX6_MMDC_P0_MDSCR			0x00048031
+wm 32 MX6_MMDC_P0_MDSCR			0x19408030
+wm 32 MX6_MMDC_P0_MDSCR			0x04008040
+
+wm 32 MX6_MMDC_P0_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P1_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P0_MDREF			0x00007800
+wm 32 MX6_MMDC_P0_MPODTCTRL		0x00022227
+wm 32 MX6_MMDC_P1_MPODTCTRL		0x00022227
+
+wm 32 MX6_MMDC_P0_MPDGCTRL0		0x03100324
+wm 32 MX6_MMDC_P0_MPDGCTRL1		0x030C0304
+wm 32 MX6_MMDC_P1_MPDGCTRL0		0x03180328
+wm 32 MX6_MMDC_P1_MPDGCTRL1		0x0310025C
+
+wm 32 MX6_MMDC_P0_MPRDDLCTL		0x4230363A
+wm 32 MX6_MMDC_P1_MPRDDLCTL		0x3A363442
+
+wm 32 MX6_MMDC_P0_MPWRDLCTL		0x34363E38
+wm 32 MX6_MMDC_P1_MPWRDLCTL		0x442C483C
+
+wm 32 MX6_MMDC_P0_MPWLDECTRL0	0x001F001F
+wm 32 MX6_MMDC_P0_MPWLDECTRL1	0x00280023
+wm 32 MX6_MMDC_P1_MPWLDECTRL0	0x00190030
+wm 32 MX6_MMDC_P1_MPWLDECTRL1	0x00190028
+
+wm 32 MX6_MMDC_P0_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P1_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P0_MDSCR			0x00000000
+wm 32 MX6_MMDC_P0_MAPSR			0x00011006
diff --git a/arch/arm/boards/wago-vtpctp-imx6/Makefile b/arch/arm/boards/wago-vtpctp-imx6/Makefile
new file mode 100644
index 00000000000..c7a078b952c
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/Makefile
@@ -0,0 +1,3 @@
+obj-y += board.o
+lwl-y += lowlevel.o
+bbenv-y += defaultenv-vtpctp-imx6
diff --git a/arch/arm/boards/wago-vtpctp-imx6/board.c b/arch/arm/boards/wago-vtpctp-imx6/board.c
new file mode 100644
index 00000000000..312d773d263
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/board.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2012 Steffen Trumtrar, Pengutronix
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Ralf Gliese <ralf.gliese@wago.com>
+ *
+ * Device initialization for the following touch panel variants:
+ *   - 762-4x0x Touch Panel 600 Standard Line
+ *   - 762-5x0x Touch Panel 600 Advanced Line
+ *   - 762-620x Touch Panel 600 Marine Line
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <init.h>
+#include <gpio.h>
+#include <mach/bbu.h>
+#include <mach/generic.h>
+#include <mach/iomux-mx6.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <linux/micrel_phy.h>
+#include <net.h>
+#include <envfs.h>
+#include <xsection.h>
+
+#define LCD_CTRL_VLCD_ON	IMX_GPIO_NR(6, 11)
+#define LCD_CTRL_LIGHT_ON	IMX_GPIO_NR(2, 8)
+#define LCD_CTRL_VLED_ON	IMX_GPIO_NR(2, 11)
+#define LCD_CTRL_PWM		IMX_GPIO_NR(2, 9)
+#define CAPTAST_NRESET		IMX_GPIO_NR(2, 3)
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+
+#define KSZ8863_GLOBAL_CONTROL_4		0x06
+#define KSZ8863_PORT1_Q0_INGRESS_DATA_RATE	0x16
+#define KSZ8863_PORT1_GLOBAL_CONTRL12		0x1c
+#define KSZ8863_PORT1_GLOBAL_CONTRL13		0x1d
+#define KSZ8863_PORT1_STATUS1			0x1f
+
+static iomux_v3_cfg_t vtpctp_enet_gpio_pads[] = {
+	/* Ethernet */
+	MX6Q_PAD_EIM_D23__GPIO_3_23,		/* RGMII_nRST */
+	MX6Q_PAD_RGMII_RXC__GPIO_6_30,		/* PHYAD */
+	MX6Q_PAD_RGMII_RD0__GPIO_6_25,		/* MODE0 */
+	MX6Q_PAD_RGMII_RD1__GPIO_6_27,		/* MODE1 */
+	MX6Q_PAD_RGMII_RD2__GPIO_6_28,		/* MODE2 */
+	MX6Q_PAD_RGMII_RD3__GPIO_6_29,		/* MODE3 */
+	MX6Q_PAD_RGMII_RX_CTL__GPIO_6_24,
+};
+
+static struct gpio fec_gpios[] = {
+	{
+		.gpio = 105,
+		.flags = GPIOF_OUT_INIT_LOW,
+		.label = "phy-rst",
+	}, {
+		.gpio = 190,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-addr2",
+	}, {
+		.gpio = 23,
+		.flags = GPIOF_OUT_INIT_LOW,
+		.label = "phy-led-mode",
+	}, {
+		/* MODE strap-in pins: advertise all capabilities */
+		.gpio = 185,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		.gpio = 187,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		.gpio = 188,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		.gpio = 189,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		/* Enable 125 MHz clock output */
+		.gpio = 184,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-125MHz",
+	},
+};
+
+static int pfc_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static int ksz8863_phy_fixup(struct phy_device *phydev)
+{
+	phy_write(phydev, KSZ8863_PORT1_STATUS1, 0x8190);
+	phy_write(phydev, KSZ8863_PORT1_Q0_INGRESS_DATA_RATE, 0x202);
+	phy_write(phydev, KSZ8863_GLOBAL_CONTROL_4, 0x30);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL12, 0x9f);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL13, 0x00);
+
+	return 0;
+}
+
+static int vtpctp_ksz8863_setup(void)
+{
+	int ret;
+
+	if (!of_machine_is_compatible("wago,imx6q-vtpctp"))
+		return 0;
+
+	mxc_iomux_v3_setup_multiple_pads(vtpctp_enet_gpio_pads,
+			ARRAY_SIZE(vtpctp_enet_gpio_pads));
+
+	ret = gpio_request_array(fec_gpios, ARRAY_SIZE(fec_gpios));
+	if (ret) {
+		pr_err("Failed to request fec gpios: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	mdelay(10);
+
+	/* FEC driver picks up the reset gpio later and
+	 * releases the phy reset
+	 */
+	gpio_free_array(fec_gpios, ARRAY_SIZE(fec_gpios));
+
+	phy_register_fixup_for_uid(PHY_ID_KSZ8863, MICREL_PHY_ID_MASK,
+							ksz8863_phy_fixup);
+
+	return 0;
+}
+/*
+ * Do this before the fec initializes but after our
+ * gpios are available.
+ */
+fs_initcall(vtpctp_ksz8863_setup);
+
+static int vtpctp_devices_init(void)
+{
+	int ret;
+
+	if (!of_machine_is_compatible("wago,imx6q-vtpctp"))
+		return 0;
+
+	imx6_bbu_internal_mmc_register_handler("boot.emmc", "/dev/mmc2",
+						BBU_HANDLER_FLAG_DEFAULT);
+
+	of_device_enable_path("/chosen/environment-sd");
+	defaultenv_append_directory(defaultenv_vtpctp_imx6);
+
+	armlinux_set_architecture(MACH_TYPE_VTPCTP_MX6);
+
+	ret = pfc_set_ethaddr();
+	if (ret < 0)
+		pr_info("no valid ethaddr in eeprom found. Using randomized MAC address\n");
+
+	barebox_set_hostname("tp600");
+
+	return 0;
+}
+device_initcall(vtpctp_devices_init);
+
+static int vtpctp_coredevices_init(void)
+{
+	if (!of_machine_is_compatible("wago,imx6q-vtpctp"))
+		return 0;
+
+	gpio_request(LCD_CTRL_VLCD_ON, "LCD_CTRL_VLCD_ON");
+	gpio_request(LCD_CTRL_LIGHT_ON, "LCD_CTRL_LIGHT_ON");
+	gpio_request(LCD_CTRL_VLED_ON, "LCD_CTRL_VLED_ON");
+	gpio_request(LCD_CTRL_PWM, "LCD_CTRL_PWM");
+	gpio_request(CAPTAST_NRESET, "CAPTAST_NRESET");
+	gpio_direction_output(LCD_CTRL_VLCD_ON, 1);
+	gpio_set_value(LCD_CTRL_VLCD_ON, 1);
+	mdelay(30);
+	gpio_direction_output(LCD_CTRL_LIGHT_ON, 1);
+	gpio_set_value(LCD_CTRL_LIGHT_ON, 1);
+	gpio_direction_output(LCD_CTRL_VLED_ON, 1);
+	gpio_set_value(LCD_CTRL_VLED_ON, 1);
+	gpio_direction_output(LCD_CTRL_PWM, 0);
+	gpio_set_value(LCD_CTRL_PWM, 0);
+	gpio_set_value(CAPTAST_NRESET, 1);
+
+	return 0;
+}
+coredevice_initcall(vtpctp_coredevices_init);
diff --git a/arch/arm/boards/wago-vtpctp-imx6/clocks.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/clocks.imxcfg
new file mode 100644
index 00000000000..582ec0bca74
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/clocks.imxcfg
@@ -0,0 +1,10 @@
+wm 32 0x020c4068 0x00c03f3f
+wm 32 0x020c406c 0x0030fc03
+wm 32 0x020c4070 0x0fffc000
+wm 32 0x020c4074 0x3ff00000
+wm 32 0x020c4078 0x00fff300
+wm 32 0x020c407c 0x0f0000c3
+wm 32 0x020c4080 0x000003ff
+wm 32 0x020e0010 0xf00000cf
+wm 32 0x020e0018 0x007f007f
+wm 32 0x020e001c 0x007f007f
diff --git a/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/bin/pfc-config-production-boot b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/bin/pfc-config-production-boot
new file mode 100644
index 00000000000..6b00d83e062
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/bin/pfc-config-production-boot
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+
+global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+global.linux.bootargs.base="root=/dev/mmcblk0p2 rw rootwait cma=64M consoleblank=0"
+global.boot.watchdog_timeout=0
+
+if [ -e "${global.pfc.sd}" ] && [ -e "${global.pfc.sd_boot}/production_mode.sh" ]; then
+	global.boot.default="${global.pfc.sd_boot}/production_mode.sh"
+else
+	echo -e ${error} "vtpctp no script found for production-mode"
+	pfc-config-broken-boot
+	exit 1
+fi
diff --git a/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/init/aa-vtpctp-setup-board-env b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/init/aa-vtpctp-setup-board-env
new file mode 100644
index 00000000000..4a130318bcc
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/init/aa-vtpctp-setup-board-env
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+# set variables for vtpctp
+
+# emmc settings
+global.pfc.emmc_name="mmc2"
+global.pfc.emmc="/dev/mmc2"
+global.pfc.emmc_boot="/mnt/mmc2.0"
+global.pfc.emmc_dev_rootfs0="/dev/mmc2.4"
+global.pfc.emmc_dev_rootfs1="/dev/mmc2.7"
+
+global.pfc.linux_uart_device="ttymxc"
+global.pfc.linux_uart="1"
+global.pfc.barebox_uart="0"
+
+global.linux.bootargs.watchdog="imx2-wdt.timeout=${global.pfc.watchdog_timeout_linux_boot}"
diff --git a/arch/arm/boards/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg
new file mode 100644
index 00000000000..9b5fdafcd46
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg
@@ -0,0 +1,10 @@
+soc imx6
+loadaddr 0x20000000
+
+ivtofs 0x400
+#include <mach/imx6-ddr-regs.h>
+#include <mach/imx6q-ddr-regs.h>
+
+#include "ram-base.imxcfg"
+#include "1066mhz_4x256mx16.imxcfg"
+#include "clocks.imxcfg"
diff --git a/arch/arm/boards/wago-vtpctp-imx6/lowlevel.c b/arch/arm/boards/wago-vtpctp-imx6/lowlevel.c
new file mode 100644
index 00000000000..05a4dc03a13
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/lowlevel.c
@@ -0,0 +1,41 @@
+#include <common.h>
+#include <linux/sizes.h>
+#include <mach/generic.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/imx6-regs.h>
+#include <io.h>
+#include <mach/debug_ll.h>
+#include <mach/esdctl.h>
+#include <asm/cache.h>
+
+extern char __dtb_imx6q_vtpctp_762_4xxx_start[];
+
+static noinline void imx6q_vtpctp_start(void)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *uart = IOMEM(MX6_UART1_BASE_ADDR);
+
+	writel(0x4, iomuxbase + 0x0bc);
+
+	imx6_ungate_all_peripherals();
+	imx6_uart_setup(uart);
+	pbl_set_putc(imx_uart_putc, uart);
+
+	pr_debug("Freescale i.MX6q VTPCTP\n");
+
+	imx6q_barebox_entry(__dtb_imx6q_vtpctp_762_4xxx_start);
+}
+
+ENTRY_FUNCTION(start_imx6q_vtpctp, r0, r1, r2)
+{
+	imx6_cpu_lowlevel_init();
+
+	arm_early_mmu_cache_invalidate();
+
+	relocate_to_current_adr();
+	setup_c();
+	barrier();
+
+	imx6q_vtpctp_start();
+}
diff --git a/arch/arm/boards/wago-vtpctp-imx6/ram-base.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/ram-base.imxcfg
new file mode 100644
index 00000000000..cf303ed0c0f
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/ram-base.imxcfg
@@ -0,0 +1,67 @@
+wm 32 MX6_IOM_DRAM_SDQS0		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS1		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS2		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS3		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS4		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS5		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS6		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS7		0x00000028
+
+wm 32 MX6_IOM_GRP_B0DS			0x00000028
+wm 32 MX6_IOM_GRP_B1DS			0x00000028
+wm 32 MX6_IOM_GRP_B2DS			0x00000028
+wm 32 MX6_IOM_GRP_B3DS			0x00000028
+wm 32 MX6_IOM_GRP_B4DS			0x00000028
+wm 32 MX6_IOM_GRP_B5DS			0x00000028
+wm 32 MX6_IOM_GRP_B6DS			0x00000028
+wm 32 MX6_IOM_GRP_B7DS			0x00000028
+wm 32 MX6_IOM_GRP_ADDDS			0x00000028
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+wm 32 MX6_IOM_GRP_CTLDS			0x00000028
+
+wm 32 MX6_IOM_DRAM_DQM0			0x00000028
+wm 32 MX6_IOM_DRAM_DQM1			0x00000028
+wm 32 MX6_IOM_DRAM_DQM2			0x00000028
+wm 32 MX6_IOM_DRAM_DQM3			0x00000028
+wm 32 MX6_IOM_DRAM_DQM4			0x00000028
+wm 32 MX6_IOM_DRAM_DQM5			0x00000028
+wm 32 MX6_IOM_DRAM_DQM6			0x00000028
+wm 32 MX6_IOM_DRAM_DQM7			0x00000028
+
+wm 32 MX6_IOM_DRAM_CAS			0x00000028
+wm 32 MX6_IOM_DRAM_RAS			0x00000028
+wm 32 MX6_IOM_DRAM_SDCLK_0		0x00000028
+wm 32 MX6_IOM_DRAM_SDCLK_1		0x00000028
+
+wm 32 MX6_IOM_DRAM_RESET		0x00000028
+wm 32 MX6_IOM_DRAM_SDCKE0		0x00003000
+wm 32 MX6_IOM_DRAM_SDCKE1		0x00003000
+
+wm 32 MX6_IOM_DRAM_SDODT0		0x00000028
+wm 32 MX6_IOM_DRAM_SDODT1		0x00000028
+
+/* (differential input) */
+wm 32 MX6_IOM_DDRMODE_CTL		0x00020000
+/* (differential input) */
+wm 32 MX6_IOM_GRP_DDRMODE		0x00020000
+/* disable ddr pullups */
+wm 32 MX6_IOM_GRP_DDRPKE		0x00000000
+wm 32 MX6_IOM_DRAM_SDBA2		0x00000000
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+wm 32 MX6_IOM_GRP_DDR_TYPE		0x000C0000
+
+/* Read data DQ Byte0-3 delay */
+wm 32 MX6_MMDC_P0_MPRDDQBY0DL	0x33333333
+wm 32 MX6_MMDC_P0_MPRDDQBY1DL	0x33333333
+wm 32 MX6_MMDC_P0_MPRDDQBY2DL	0x33333333
+wm 32 MX6_MMDC_P0_MPRDDQBY3DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY0DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY1DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY2DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY3DL	0x33333333
+
+/* MDMISC	mirroring	interleaved (row/bank/col) */
+wm 32 MX6_MMDC_P0_MDMISC		0x00011740
+
+/* MDSCR	con_req */
+wm 32 MX6_MMDC_P0_MDSCR			0x00008000
diff --git a/arch/arm/configs/am335x_mlo_defconfig b/arch/arm/configs/am335x_mlo_defconfig
index 51d238db3e5..adc7d60c389 100644
--- a/arch/arm/configs/am335x_mlo_defconfig
+++ b/arch/arm/configs/am335x_mlo_defconfig
@@ -29,6 +29,7 @@ CONFIG_MTD_M25P80=y
 CONFIG_NAND=y
 CONFIG_NAND_OMAP_GPMC=y
 CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
 # CONFIG_MCI_WRITE is not set
 CONFIG_MCI_OMAP_HSMMC=y
 CONFIG_PINCTRL_SINGLE=y
diff --git a/arch/arm/configs/am335x_pfc_adv_defconfig b/arch/arm/configs/am335x_pfc_adv_defconfig
new file mode 100644
index 00000000000..27d4bfa0a69
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_adv_defconfig
@@ -0,0 +1,147 @@
+CONFIG_ARCH_OMAP=y
+# CONFIG_OMAP_GPMC is not set
+CONFIG_BAREBOX_UPDATE_AM33XX_EMMC=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_768_330x=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_CONSOLE_RATP=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_FASTBOOT_SPARSE=y
+CONFIG_FASTBOOT_CMD_OEM=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_SFDISK=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_USBGADGET=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OF_DISPLAY_TIMINGS=y
+CONFIG_CMD_OF_FIXUP_STATUS=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_CMD_BOARD_INFO=y
+CONFIG_CMD_FASTBOOT_NET=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_FASTBOOT=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_NET_CPSW=y
+CONFIG_MICREL_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_NET_USB=y
+CONFIG_NET_USB_ASIX=y
+CONFIG_NET_USB_SMSC95XX=y
+# CONFIG_SPI is not set
+CONFIG_MTD=y
+CONFIG_USB_HOST=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_USB_MUSB=y
+CONFIG_USB_MUSB_AM335X=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_LED_PCA955X=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_OMAP=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_ZLIB=y
diff --git a/arch/arm/configs/am335x_pfc_adv_mlo_defconfig b/arch/arm/configs/am335x_pfc_adv_mlo_defconfig
new file mode 100644
index 00000000000..4c1dd91f644
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_adv_mlo_defconfig
@@ -0,0 +1,36 @@
+CONFIG_ARCH_OMAP=y
+# CONFIG_OMAP_GPMC is not set
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_768_330x=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_IMAGE_COMPRESSION_XZKERN=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="MLO>"
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_USB_HOST=y
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_AUTOSTART is not set
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_USB_MUSB=y
+CONFIG_USB_MUSB_AM335X=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_XSECTION=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am335x_pfc_defconfig b/arch/arm/configs/am335x_pfc_defconfig
new file mode 100644
index 00000000000..13a92168ffb
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_defconfig
@@ -0,0 +1,158 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_BAREBOX_UPDATE_AM33XX_NAND=y
+CONFIG_BAREBOX_UPDATE_AM33XX_EMMC=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_810x=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_8208=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_821x=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_FASTBOOT_SPARSE=y
+CONFIG_FASTBOOT_CMD_OEM=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_UBIFORMAT=y
+CONFIG_CMD_SFDISK=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_NANDTEST=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_USBGADGET=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OF_DISPLAY_TIMINGS=y
+CONFIG_CMD_OF_FIXUP_STATUS=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_CMD_BOARD_INFO=y
+CONFIG_CMD_FASTBOOT_NET=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_FASTBOOT=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_NET_CPSW=y
+CONFIG_MICREL_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_NET_USB=y
+CONFIG_NET_USB_ASIX=y
+CONFIG_NET_USB_SMSC95XX=y
+# CONFIG_SPI is not set
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_USB_HOST=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_USB_MUSB=y
+CONFIG_USB_MUSB_AM335X=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_LED_PCA955X=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_OMAP=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_BUS_OMAP_GPMC=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_UBIFS=y
+CONFIG_FS_UBIFS_COMPRESSION_LZO=y
+CONFIG_FS_UBIFS_COMPRESSION_ZLIB=y
diff --git a/arch/arm/configs/am335x_pfc_mlo_defconfig b/arch/arm/configs/am335x_pfc_mlo_defconfig
new file mode 100644
index 00000000000..7416522617d
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_mlo_defconfig
@@ -0,0 +1,37 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_810x=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_8208=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_821x=y
+CONFIG_THUMB2_BAREBOX=y
+# CONFIG_MEMINFO is not set
+CONFIG_IMAGE_COMPRESSION_XZKERN=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="MLO>"
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_OFDEVICE=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MTD=y
+# CONFIG_MTD_WRITE is not set
+# CONFIG_MTD_OOB_DEVICE is not set
+CONFIG_NAND=y
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_XSECTION=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_BUS_OMAP_GPMC=y
+# CONFIG_VIRTIO_MENU is not set
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am35xx_pfc_defconfig b/arch/arm/configs/am35xx_pfc_defconfig
new file mode 100644
index 00000000000..c361e403c05
--- /dev/null
+++ b/arch/arm/configs/am35xx_pfc_defconfig
@@ -0,0 +1,135 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_BAREBOX_UPDATE_AM33XX_NAND=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM35XX=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_DEFAULT_COMPRESSION_LZO=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_FASTBOOT_SPARSE=y
+CONFIG_FASTBOOT_CMD_OEM=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_UBIFORMAT=y
+CONFIG_CMD_SFDISK=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_NANDTEST=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_CMD_BOARD_INFO=y
+CONFIG_CMD_FASTBOOT_NET=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_FASTBOOT=y
+CONFIG_OFDEVICE=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_NET_DAVINCI_EMAC=y
+# CONFIG_SPI is not set
+CONFIG_MTD=y
+CONFIG_NAND=y
+CONFIG_NAND_ECC_HW_SW_ERR_DETECTION=y
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_OMAP=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_BUS_OMAP_GPMC=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_UBIFS=y
+CONFIG_FS_UBIFS_COMPRESSION_LZO=y
diff --git a/arch/arm/configs/am35xx_pfc200_xload_defconfig b/arch/arm/configs/am35xx_pfc_mlo_defconfig
similarity index 76%
rename from arch/arm/configs/am35xx_pfc200_xload_defconfig
rename to arch/arm/configs/am35xx_pfc_mlo_defconfig
index da55382f056..6c755204e73 100644
--- a/arch/arm/configs/am35xx_pfc200_xload_defconfig
+++ b/arch/arm/configs/am35xx_pfc_mlo_defconfig
@@ -15,26 +15,22 @@ CONFIG_PROMPT="X-load pfc200>"
 CONFIG_SHELL_NONE=y
 # CONFIG_ERRNO_MESSAGES is not set
 # CONFIG_TIMESTAMP is not set
-CONFIG_CONSOLE_SIMPLE=y
+CONFIG_COMPILE_LOGLEVEL=3
 CONFIG_DRIVER_SERIAL_NS16550=y
 CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
 # CONFIG_SPI is not set
+CONFIG_I2C=y
+CONFIG_I2C_OMAP=y
 CONFIG_MTD=y
 # CONFIG_MTD_WRITE is not set
 # CONFIG_MTD_OOB_DEVICE is not set
 CONFIG_NAND=y
-# CONFIG_NAND_ECC_SOFT is not set
-# CONFIG_NAND_ECC_HW_SYNDROME is not set
-# CONFIG_NAND_ECC_HW_NONE is not set
-# CONFIG_NAND_INFO is not set
-# CONFIG_NAND_BBT is not set
+CONFIG_NAND_ECC_HW_SW_ERR_DETECTION=y
 CONFIG_NAND_OMAP_GPMC=y
 CONFIG_MCI=y
 CONFIG_MCI_STARTUP=y
 # CONFIG_MCI_WRITE is not set
 CONFIG_MCI_MMC_BOOT_PARTITIONS=y
 CONFIG_MCI_OMAP_HSMMC=y
-# CONFIG_FS_RAMFS is not set
-# CONFIG_FS_DEVFS is not set
 CONFIG_FS_FAT=y
 CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/imx6_vtpctp_defconfig b/arch/arm/configs/imx6_vtpctp_defconfig
new file mode 100644
index 00000000000..c3cd2a84cd3
--- /dev/null
+++ b/arch/arm/configs/imx6_vtpctp_defconfig
@@ -0,0 +1,155 @@
+CONFIG_ARCH_IMX=y
+CONFIG_IMX_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_VTPCTP_MX6=y
+CONFIG_IMX_IIM=y
+CONFIG_IMX_IIM_FUSE_BLOW=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_ARM_PSCI=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_BLSPEC=y
+CONFIG_IMD=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_CONSOLE_RATP=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_FASTBOOT_SPARSE=y
+CONFIG_FASTBOOT_CMD_OEM=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_CMD_BOARD_INFO=y
+CONFIG_CMD_FASTBOOT_NET=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_FASTBOOT=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_NET_FEC_IMX=y
+CONFIG_DRIVER_NET_MICREL=y
+CONFIG_MICREL_PHY=y
+CONFIG_DRIVER_SPI_GPIO=y
+CONFIG_DRIVER_SPI_IMX=y
+CONFIG_DISK_AHCI=y
+CONFIG_DISK_AHCI_IMX=y
+CONFIG_DISK_INTF_PLATFORM_IDE=y
+CONFIG_DISK_PATA_IMX=y
+CONFIG_USB_HOST=y
+CONFIG_USB_IMX_CHIPIDEA=y
+CONFIG_USB_EHCI=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_STORAGE=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_IMX_ESDHC=y
+CONFIG_MFD_DA9063=y
+CONFIG_MFD_MC13XXX=y
+CONFIG_MFD_MC34704=y
+CONFIG_MFD_MC9SDZ60=y
+CONFIG_MFD_STMPE=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_LED_PCA955X=y
+CONFIG_EEPROM_AT25=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_IMX=y
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_MXS_APBH_DMA=y
+CONFIG_GPIO_74164=y
+CONFIG_GPIO_STMPE=y
+CONFIG_IMX_OCOTP=y
+CONFIG_IMX_OCOTP_WRITE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED=y
+CONFIG_GENERIC_PHY=y
+CONFIG_USB_NOP_XCEIV=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_ZLIB=y
+CONFIG_LZO_DECOMPRESS=y
diff --git a/arch/arm/configs/stm32mp_cc100_defconfig b/arch/arm/configs/stm32mp_cc100_defconfig
new file mode 100644
index 00000000000..868f3d6ddd8
--- /dev/null
+++ b/arch/arm/configs/stm32mp_cc100_defconfig
@@ -0,0 +1,174 @@
+CONFIG_ARCH_STM32MP=y
+CONFIG_MACH_STM32MP151_CC100=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BOOTM_OFTREE_UIMAGE=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_PBL_CONSOLE=y
+CONFIG_CONSOLE_RATP=y
+CONFIG_RATP_CMD_I2C=y
+CONFIG_RATP_CMD_GPIO=y
+CONFIG_PARTITION_DISK_EFI=y
+# CONFIG_PARTITION_DISK_EFI_GPT_NO_FORCE is not set
+# CONFIG_PARTITION_DISK_EFI_GPT_COMPARE is not set
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW_REBOOT_MODE=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/stm32mp151-cc100/defaultenv-stm32mp151-cc100/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_CMD_DMESG=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_IMD=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_GO=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_SFDISK=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_POWEROFF=y
+CONFIG_CMD_USBGADGET=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_DIFF=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OF_OVERLAY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_CMD_BOARD_INFO=y
+CONFIG_CMD_FASTBOOT_NET=y
+CONFIG_NET=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_FASTBOOT=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_AIODEV=y
+CONFIG_STM32_ADC=y
+CONFIG_DRIVER_SERIAL_STM32=y
+CONFIG_DRIVER_NET_DESIGNWARE_EQOS=y
+CONFIG_DRIVER_NET_DESIGNWARE_STM32=y
+CONFIG_AT803X_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_REALTEK_PHY=y
+# CONFIG_SPI is not set
+CONFIG_USB_HOST=y
+CONFIG_USB_DWC2_HOST=y
+CONFIG_USB_DWC2_GADGET=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_STM32_SDMMC2=y
+CONFIG_MFD_STPMIC1=y
+CONFIG_MFD_STM32_TIMERS=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_PWM=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_INPUT_SPECIALKEYS=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_POLLER=y
+CONFIG_STM32_IWDG_WATCHDOG=y
+CONFIG_STPMIC1_WATCHDOG=y
+CONFIG_PWM=y
+CONFIG_PWM_STM32=y
+CONFIG_HWRNG=y
+CONFIG_HWRNG_STM32=y
+CONFIG_GPIO_DESIGNWARE=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_STM32_BSEC=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED=y
+CONFIG_REGULATOR_STM32_PWR=y
+CONFIG_REGULATOR_STM32_VREFBUF=y
+CONFIG_REGULATOR_STPMIC1=y
+CONFIG_REMOTEPROC=y
+CONFIG_STM32_REMOTEPROC=y
+CONFIG_RESET_STM32=y
+CONFIG_GENERIC_PHY=y
+CONFIG_PHY_STM32_USBPHYC=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_PSTORE=y
+CONFIG_FS_PSTORE_CONSOLE=y
+CONFIG_FS_PSTORE_RAMOOPS=y
+CONFIG_FS_SQUASHFS=y
+CONFIG_FS_RATP=y
+CONFIG_ZLIB=y
+CONFIG_CRC8=y
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index ffa9fe88c12..5f54b4ae12a 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -116,6 +116,7 @@ lwl-$(CONFIG_MACH_SOLIDRUN_MICROSOM) += imx6dl-hummingboard.dtb.o imx6q-hummingb
 				imx6q-h100.dtb.o
 lwl-$(CONFIG_MACH_SKOV_IMX6) += imx6dl-skov-imx6.dtb.o imx6q-skov-imx6.dtb.o
 lwl-$(CONFIG_MACH_SKOV_ARM9CPU) += at91-skov-arm9cpu.dtb.o
+lwl-$(CONFIG_MACH_STM32MP151_CC100) += stm32mp151-cc100.dtb.o
 lwl-$(CONFIG_MACH_SEEED_ODYSSEY) += stm32mp157c-odyssey.dtb.o
 lwl-$(CONFIG_MACH_STM32MP15XX_DKX) += stm32mp157c-dk2.dtb.o stm32mp157a-dk1.dtb.o
 lwl-$(CONFIG_MACH_LXA_MC1) += stm32mp157c-lxa-mc1.dtb.o
@@ -177,5 +178,18 @@ lwl-$(CONFIG_MACH_LS1046ARDB) += fsl-ls1046a-rdb.dtb.o
 lwl-$(CONFIG_MACH_TQMLS1046A) += fsl-tqmls1046a-mbls10xxa.dtb.o
 lwl-$(CONFIG_MACH_ZEDBOARD) += zynq-zed.dtb.o
 lwl-$(CONFIG_MACH_MNT_REFORM) += imx8mq-mnt-reform2.dtb.o
+lwl-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += \
+	am335x-pfc-750_810x.dtb.o \
+	am335x-pfc-750_810x-mlo.dtb.o
+lwl-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += \
+	am335x-pfc-750_8208.dtb.o \
+	am335x-pfc-750_8208-mlo.dtb.o
+lwl-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += \
+	am335x-pfc-750_821x.dtb.o \
+	am335x-pfc-750_821x-mlo.dtb.o
+lwl-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += \
+	am335x-pfc-768_330x.dtb.o \
+	am335x-pfc-768_330x-mlo.dtb.o
+lwl-$(CONFIG_MACH_WAGO_VTPCTP_MX6) += imx6q-vtpctp-762-4xxx.dtb.o
 
 clean-files := *.dtb *.dtb.S .*.dtc .*.pre .*.dts *.dtb.lzo
diff --git a/arch/arm/dts/am335x-pfc-750_810x-mlo.dts b/arch/arm/dts/am335x-pfc-750_810x-mlo.dts
new file mode 100644
index 00000000000..3297145a533
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_810x-mlo.dts
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-750-810x MLO";
+	compatible = "wago,am335x-pfc-750_810x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc100";
+};
+
+&gpmc {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_810x.dts b/arch/arm/dts/am335x-pfc-750_810x.dts
new file mode 100644
index 00000000000..3749a0b2369
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_810x.dts
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii2.dtsi"
+
+/ {
+	model = "PFC-750-810x";
+	compatible = "wago,am335x-pfc-750_810x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc100";
+	switch-reset-gpio = <&gpio2 21 GPIO_ACTIVE_LOW>;
+};
+
+&am33xx_pinmux {
+	pinctrl-0 = <&switch_reset>;
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x140 PIN_OUTPUT_PULLDOWN MUX_MODE7   /* mii1_rxd0.gpio2_21 */
+		>;
+	};
+};
+
+&rst {
+	gpios = <&gpio3 15 GPIO_ACTIVE_LOW>;
+};
+
+&gpmc {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&mac {
+	status = "okay";
+};
+
+/delete-node/ &pca9552_61;
diff --git a/arch/arm/dts/am335x-pfc-750_8208-mlo.dts b/arch/arm/dts/am335x-pfc-750_8208-mlo.dts
new file mode 100644
index 00000000000..1738dafc84c
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_8208-mlo.dts
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-750-820x MLO";
+	compatible = "wago,am335x-pfc-750_8208", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v2";
+};
+
+&gpmc {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_8208.dts b/arch/arm/dts/am335x-pfc-750_8208.dts
new file mode 100644
index 00000000000..c0ed33c8323
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_8208.dts
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii2.dtsi"
+
+/ {
+	model = "PFC-750-820x";
+	compatible = "wago,am335x-pfc-750_8208", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v2";
+	switch-reset-gpio = <&gpio3 10 GPIO_ACTIVE_LOW>;
+};
+
+
+&am33xx_pinmux {
+	pinctrl-0 = <&switch_reset>;
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x130 PIN_OUTPUT_PULLDOWN MUX_MODE7 /* mii1_rx_clk.gpio3_10 */
+		>;
+	};
+};
+
+&gpmc {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&pca9552_61 {
+	status = "okay";
+};
+
+&mac {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_821x-mlo.dts b/arch/arm/dts/am335x-pfc-750_821x-mlo.dts
new file mode 100644
index 00000000000..ff9d912bcc8
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_821x-mlo.dts
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-750-821x MLO";
+	compatible = "wago,am335x-pfc-750_821x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v3";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+};
+
+&mmc2 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_821x.dts b/arch/arm/dts/am335x-pfc-750_821x.dts
new file mode 100644
index 00000000000..e91c774866b
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_821x.dts
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii12.dtsi"
+
+/ {
+	model = "PFC-750-821x";
+	compatible = "wago,am335x-pfc-750_821x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v3";
+	switch-reset-gpio = <&pca953x 4 GPIO_ACTIVE_LOW>;
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+};
+
+&i2c0 {
+	pca953x: pca953x@70 {
+		compatible = "nxp,pca9538";
+		reg = <0x70>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&mmc1 {
+	cd-gpios = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&pca9552_61 {
+	status = "okay";
+};
+
+&mac {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-768_330x-mlo.dts b/arch/arm/dts/am335x-pfc-768_330x-mlo.dts
new file mode 100644
index 00000000000..410e5df9d62
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-768_330x-mlo.dts
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-768-330x MLO";
+	compatible = "wago,am335x-pfc-768_330x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200adv";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+
+	aliases {
+		usb0 = &usb0;
+	};
+};
+
+&mmc1_cd_pins {
+	pinctrl-single,pins = <
+		0x04C PIN_INPUT_PULLDOWN MUX_MODE7 /* gpmc_a3.gpio1_19 */
+	>;
+};
+
+&mmc1 {
+	cd-gpios = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-768_330x.dts b/arch/arm/dts/am335x-pfc-768_330x.dts
new file mode 100644
index 00000000000..329974779ba
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-768_330x.dts
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii12.dtsi"
+
+/ {
+	model = "PFC-768-330x";
+	compatible = "wago,am335x-pfc-768_330x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200adv";
+	switch-reset-gpio = <&pca953x 4 GPIO_ACTIVE_LOW>;
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+
+	aliases {
+		usb0 = &usb0;
+	};
+};
+
+&i2c0 {
+	pca953x: pca953x@70 {
+		compatible = "nxp,pca9538";
+		reg = <0x70>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&mmc1_cd_pins {
+	pinctrl-single,pins = <
+		0x04C PIN_INPUT_PULLDOWN MUX_MODE7 /* gpmc_a3.gpio1_19 */
+	>;
+};
+
+&mmc1 {
+	cd-gpios = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&led_0 {
+	label = "ds-red";
+};
+
+&led_1 {
+	label = "ds-green";
+};
+
+&led_2 {
+	label = "ec-red";
+};
+
+&led_3 {
+	label = "ec-blue";
+};
+
+&led_4 {
+	label = "ms-red";
+};
+
+&led_5 {
+	label = "ms-green";
+};
+
+&led_6 {
+	label = "ns-red";
+};
+
+&led_7 {
+	label = "ns-green";
+};
+
+&led_8 {
+	label = "run-red";
+};
+
+&led_9 {
+	label = "run-green";
+};
+
+&led_10 {
+	label = "app-red";
+};
+
+&led_11 {
+	label = "app-green";
+};
+
+&mac {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0 {
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&rst {
+	gpios = <&gpio3 15 GPIO_ACTIVE_LOW>;
+};
+
+&partitions {
+	blp_uii: ethaddr2@1CF {
+		label = "blp_uii";
+		reg = <0x1CF 0x28>;
+	};
+};
+
+&xsection {
+	blp_uii = <&blp_uii>;
+};
diff --git a/arch/arm/dts/am335x-pfc-emmc.dtsi b/arch/arm/dts/am335x-pfc-emmc.dtsi
new file mode 100644
index 00000000000..39b30b43622
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-emmc.dtsi
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&am33xx_pinmux {
+	emmc_pins: pinmux_emmc_pins {
+		pinctrl-single,pins = <
+			0x080 (PIN_INPUT_PULLUP | SLEWCTRL_FAST) MUX_MODE2 /* gpmc_csn1.mmc1_clk */
+			0x084 (PIN_INPUT_PULLUP | SLEWCTRL_FAST) MUX_MODE2 /* gpmc_csn2.mmc1_cmd */
+			0x000 (PIN_INPUT_PULLUP | SLEWCTRL_FAST) MUX_MODE1 /* gpmc_ad0.gpmc_ad0  */
+			0x004 (PIN_INPUT_PULLUP | SLEWCTRL_FAST) MUX_MODE1 /* gpmc_ad0.gpmc_ad1  */
+			0x008 (PIN_INPUT_PULLUP | SLEWCTRL_FAST) MUX_MODE1 /* gpmc_ad0.gpmc_ad2  */
+			0x00c (PIN_INPUT_PULLUP | SLEWCTRL_FAST) MUX_MODE1 /* gpmc_ad0.gpmc_ad3  */
+		>;
+	};
+};
+
+&mmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&emmc_pins>;
+	vmmc-supply = <&vmmcsd_fixed>;
+	bus-width = <4>;
+	non-removable;
+	status = "disabled";
+};
+
+#include "am3xxx-pfc-emmcparts.dtsi"
diff --git a/arch/arm/dts/am335x-pfc-gpmc.dtsi b/arch/arm/dts/am335x-pfc-gpmc.dtsi
new file mode 100644
index 00000000000..7d6c302bdff
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-gpmc.dtsi
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&gpmc {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+	num-cs = <3>;
+	num-waitpins = <1>;
+	ranges = <
+		0 0 0x08000000 0x01000000 /* CS0: NAND */
+	>;
+
+ 	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		elm_id = <&elm>;
+	};
+};
+
+/include/ "am3xxx-pfc-nandparts.dtsi"
diff --git a/arch/arm/dts/am335x-pfc-leds.dtsi b/arch/arm/dts/am335x-pfc-leds.dtsi
new file mode 100644
index 00000000000..fe90719b03d
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-leds.dtsi
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&i2c0 {
+	/*
+	 * Note:
+	 * The predefined order here determines
+	 * the order how leds are enabled.
+	 *
+	 * Note: BUG in barebox-led trigger code.
+	 * triggers are assuming, that leds-max
+	 * value is 1. this is correct for gpio-leds but
+	 * not for brightness driven leds like the
+	 * pca 9552 chip.
+	 *
+	 * for pca-chips use custom brightness values for
+	 * triggering:
+	 *
+	 * 		1 Blink  1 HZ
+	 * 		2 Blink  4 HZ
+	 * 		3 Blink 10 HZ
+	 */
+
+	pca9552_61: pca9552@61 {
+		compatible = "pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x61>;
+		status = "disabled";
+
+		u1-green@11 {
+		      label = "u1-green";
+		      reg = <11>;
+		      linux,default-trigger = "none";
+		};
+
+		u1-red@10 {
+		      label = "u1-red";
+		      reg = <10>;
+		      linux,default-trigger = "none";
+		};
+
+		u2-green@9 {
+		      label = "u2-green";
+		      reg = <9>;
+		      linux,default-trigger = "none";
+		};
+
+		u2-red@8 {
+		      label = "u2-red";
+		      reg = <8>;
+		      linux,default-trigger = "none";
+		};
+
+		u3-green@7 {
+		      label = "u3-green";
+		      reg = <7>;
+		      linux,default-trigger = "none";
+		};
+
+		u3-red@6 {
+		      label = "u3-red";
+		      reg = <6>;
+		      linux,default-trigger = "none";
+		};
+
+		u4-green@5 {
+		      label = "u4-green";
+		      reg = <5>;
+		      linux,default-trigger = "none";
+		};
+
+		u4-red@4 {
+		      label = "u4-red";
+		      reg = <4>;
+		      linux,default-trigger = "none";
+		};
+
+		u5-green@3 {
+		      label = "u5-green";
+		      reg = <3>;
+		      linux,default-trigger = "none";
+		};
+
+		u5-red@2 {
+		      label = "u5-red";
+		      reg = <2>;
+		      linux,default-trigger = "none";
+		};
+
+		u6-green@1 {
+		      label = "u6-green";
+		      reg = <1>;
+		      linux,default-trigger = "none";
+		};
+
+		u6-red@0 {
+		      label = "u6-red";
+		      reg = <0>;
+		      linux,default-trigger = "none";
+		};
+        };
+
+	pca9552_60: pca9552@60 {
+		compatible = "pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x60>;
+		status = "disabled";
+
+		overwrite: overwrite@15 {
+			label = "overwrite";
+			reg = <15>;
+			linux,default-trigger = "default-on";
+		};
+
+		led_0: sys-red@0 {
+			label = "sys-red";
+			reg = <0>;
+			linux,default-trigger = "none";
+		};
+
+		led_1: sys-green@1 {
+			label = "sys-green";
+			reg = <1>;
+			linux,default-trigger = "none";
+		};
+
+		led_2: run-red@2 {
+			label = "run-red";
+			reg = <2>;
+			linux,default-trigger = "none";
+		};
+
+		led_3: run-green@3 {
+			label = "run-green";
+			reg = <3>;
+			linux,default-trigger = "none";
+		};
+
+		led_4: io-red@4 {
+			label = "io-red";
+			reg = <4>;
+			linux,default-trigger = "none";
+		};
+
+		led_5: io-green@5 {
+			label = "io-green";
+			reg = <5>;
+			linux,default-trigger = "none";
+		};
+
+		led_6: ms-red@6 {
+			label = "ms-red";
+			reg = <6>;
+			linux,default-trigger = "none";
+		};
+
+		led_7: ms-green@7 {
+			label = "ms-green";
+			reg = <7>;
+			linux,default-trigger = "none";
+		};
+
+		led_8: ns-red@8 {
+			label = "ns-red";
+			reg = <8>;
+			linux,default-trigger = "none";
+		};
+
+		led_9: ns-green@9 {
+			label = "ns-green";
+			reg = <9>;
+			linux,default-trigger = "none";
+		};
+
+		led_10: u7-red@10 {
+			label = "u7-red";
+			reg = <10>;
+			linux,default-trigger = "none";
+		};
+
+		led_11: u7-green@11 {
+			label = "u7-green";
+			reg = <11>;
+			linux,default-trigger = "none";
+		};
+	};
+};
diff --git a/arch/arm/dts/am335x-pfc-nand.dtsi b/arch/arm/dts/am335x-pfc-nand.dtsi
new file mode 100644
index 00000000000..1f340decc1c
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-nand.dtsi
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&am33xx_pinmux {
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x00 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad0, INPUT_PULLDOWN | MODE0 */
+			0x04 PIN_INPUT_PULLDOWN	MUX_MODE0	/* gpmc_ad1, INPUT_PULLDOWN | MODE0 */
+			0x08 PIN_INPUT_PULLDOWN	MUX_MODE0	/* gpmc_ad2, INPUT_PULLDOWN | MODE0 */
+			0x0c PIN_INPUT_PULLDOWN	MUX_MODE0	/* gpmc_ad3, INPUT_PULLDOWN | MODE0 */
+			0x10 PIN_INPUT_PULLDOWN	MUX_MODE0	/* gpmc_ad4, INPUT_PULLDOWN | MODE0 */
+			0x14 PIN_INPUT_PULLDOWN	MUX_MODE0	/* gpmc_ad5, INPUT_PULLDOWN | MODE0 */
+			0x18 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad6, INPUT_PULLDOWN | MODE0 */
+			0x1c PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad7, INPUT_PULLDOWN | MODE0 */
+			0x20 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad8, INPUT_PULLDOWN | MODE0 */
+			0x24 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad9, INPUT_PULLDOWN | MODE0 */
+			0x28 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad10, INPUT_PULLDOWN | MODE0 */
+			0x2c PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad11, INPUT_PULLDOWN | MODE0 */
+			0x30 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad12, INPUT_PULLDOWN | MODE0 */
+			0x34 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad13, INPUT_PULLDOWN | MODE0 */
+			0x38 PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad14, INPUT_PULLDOWN | MODE0 */
+			0x3c PIN_INPUT_PULLDOWN MUX_MODE0	/* gpmc_ad15, INPUT_PULLDOWN | MODE0 */
+			0x70 PIN_INPUT_PULLUP MUX_MODE0		/* gpmc_wait0, INPUT_PULLUP | MODE0 */
+			0x7c PIN_OUTPUT_PULLUP MUX_MODE0	/* gpmc_csn0, OUTPUT_PULLUP | MODE0 */
+			0x80 PIN_OUTPUT_PULLUP MUX_MODE0	/* gpmc_csn1, OUTPUT_PULLUP | MODE0 */
+			0x84 PIN_OUTPUT_PULLUP MUX_MODE1	/* gpmc_csn2, OUTPUT_PULLUP | MODE1 (gpmc_be1n_mux1) */
+			0x90 PIN_OUTPUT MUX_MODE0	/* gpmc_advn_ale, MODE0 */
+			0x94 PIN_OUTPUT MUX_MODE0	/* gpmc_oen_ren,  MODE0 */
+			0x98 PIN_OUTPUT MUX_MODE0	/* gpmc_wen, OUTPUT_PULLUP | MODE0 */
+			0x9c PIN_OUTPUT MUX_MODE0	/* gpmc_ben0_cle.gpmc_be0n_cle, OUTPUT_PULLUP | MODE0 */
+		>;
+	};
+};
+
+/include/ "am335x-pfc-gpmc.dtsi"
diff --git a/arch/arm/dts/am335x-pfc-rmii12.dtsi b/arch/arm/dts/am335x-pfc-rmii12.dtsi
new file mode 100644
index 00000000000..b066149671b
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-rmii12.dtsi
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&am33xx_pinmux {
+	cpsw_rmmi12_default: cpsw_rmmi12_default {
+		pinctrl-single,pins = <
+			/* RMMI2 */
+			0x040 (PIN_OUTPUT | SLEWCTRL_FAST) MUX_MODE3 /* gpmc_a0.rmii2_txen     */
+			0x050 (PIN_OUTPUT | SLEWCTRL_FAST) MUX_MODE3 /* gpmc_a4.rmii2_txd1     */
+			0x054 (PIN_OUTPUT | SLEWCTRL_FAST) MUX_MODE3 /* gpmc_a5.rmii2_txd0     */
+			0x068 PIN_INPUT MUX_MODE3 /* gpmc_a10.rmii2_rxd1    */
+			0x06C PIN_INPUT MUX_MODE3 /* gpmc_a11.rmii2_rxd0    */
+			0x108 PIN_INPUT MUX_MODE1 /* mii1_col.rmii2_refclk  */
+			0x088 PIN_INPUT MUX_MODE2 /* gpmc_csn3.rmii2_crs_dv */
+			0x074 PIN_INPUT MUX_MODE7 /* gpmc_wpn.gpio0_31      */
+
+			/* RMMI1 only used on Marvell based devices; default off */
+			0x144 PIN_INPUT MUX_MODE7 /* rmii1_ref_clk.rmii1_refclk */
+			0x114 PIN_INPUT MUX_MODE7 /* mii1_txen.rmii1_txen       */
+			0x128 PIN_INPUT MUX_MODE7 /* mii1_txd0.rmii1_txd0       */
+			0x124 PIN_INPUT MUX_MODE7 /* mii1_txd1.rmii1_txd1       */
+			0x140 PIN_INPUT MUX_MODE7 /* mii1_rxd0.rmii1_rxd0       */
+			0x13c PIN_INPUT MUX_MODE7 /* mii1_rxd1.rmii1_rxd1       */
+			0x10c PIN_INPUT MUX_MODE7 /* mii1_crs.rmii1_crs_dv      */
+		>;
+	};
+
+	cpsw_rmmi12_sleep: cpsw_rmmi12_sleep {
+		pinctrl-single,pins = <
+			/* RMMI2 */
+			0x040 PIN_INPUT MUX_MODE7 /* gpmc_a0.rmii2_txen     */
+			0x050 PIN_INPUT MUX_MODE7 /* gpmc_a4.rmii2_txd1     */
+			0x054 PIN_INPUT MUX_MODE7 /* gpmc_a5.rmii2_txd0     */
+			0x068 PIN_INPUT MUX_MODE7 /* gpmc_a10.rmii2_rxd1    */
+			0x06C PIN_INPUT MUX_MODE7 /* gpmc_a11.rmii2_rxd0    */
+			0x108 PIN_INPUT MUX_MODE7 /* mii1_col.rmii2_refclk  */
+			0x088 PIN_INPUT MUX_MODE7 /* gpmc_csn3.rmii2_crs_dv */
+			0x074 PIN_INPUT MUX_MODE7 /* gpmc_wpn.gpio0_31      */
+
+			/* RMMI1 only used on Marvell based devices; default off to not brick
+			 * the bootstrap option of marvell based devices
+			 */
+			0x144 PIN_INPUT MUX_MODE7 /* rmii1_ref_clk.rmii1_refclk      */
+			0x114 PIN_INPUT MUX_MODE7 /* mii1_txen.rmii1_txen (gpio3_3)  */
+			0x128 PIN_INPUT MUX_MODE7 /* mii1_txd0.rmii1_txd0 (gpio0_28) */
+			0x124 PIN_INPUT MUX_MODE7 /* mii1_txd1.rmii1_txd1 (gpio0_21) */
+			0x140 PIN_INPUT MUX_MODE7 /* mii1_rxd0.rmii1_rxd0 (gpio2_21) */
+			0x13c PIN_INPUT MUX_MODE7 /* mii1_rxd1.rmii1_rxd1 (gpio2_20) */
+			0x10c PIN_INPUT MUX_MODE7 /* mii1_crs.rmii1_crs_dv (gpio3_1) */
+	       >;
+	};
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_rmmi12_default>;
+	pinctrl-1 = <&cpsw_rmmi12_sleep>;
+	status = "disabled";
+};
diff --git a/arch/arm/dts/am335x-pfc-rmii2.dtsi b/arch/arm/dts/am335x-pfc-rmii2.dtsi
new file mode 100644
index 00000000000..17e62ee3aa2
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-rmii2.dtsi
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&am33xx_pinmux {
+	cpsw_rmmi2_default: cpsw_rmmi2_default {
+		pinctrl-single,pins = <
+                        0x040 PIN_OUTPUT_PULLDOWN MUX_MODE3 /* gpmc_a0.rmii2_txen */
+                        0x050 PIN_OUTPUT_PULLDOWN MUX_MODE3 /* gpmc_a4.rmii2_txd1 */
+                        0x054 PIN_OUTPUT_PULLDOWN MUX_MODE3 /* gpmc_a5.rmii2_txd0 */
+                        0x068 PIN_INPUT_PULLDOWN MUX_MODE3  /* gpmc_a10.rmii2_rxd1 */
+                        0x06C PIN_INPUT_PULLDOWN MUX_MODE3  /* gpmc_a11.rmii2_rxd0 */
+                        0x074 PIN_INPUT_PULLDOWN MUX_MODE3  /* gpmc_wpn.rmii2_rxer */
+                        0x108 PIN_INPUT_PULLDOWN MUX_MODE1  /* mii1_col.rmii2_refclk */
+                        0x088 PIN_INPUT MUX_MODE2  /* gpmc_csn3.rmii2_crs_dv */
+		>;
+	};
+
+	cpsw_rmmi2_sleep: cpsw_rmmi2_sleep {
+		pinctrl-single,pins = <
+                        0x040 PIN_INPUT_PULLDOWN MUX_MODE7
+                        0x050 PIN_INPUT_PULLDOWN MUX_MODE7
+                        0x054 PIN_INPUT_PULLDOWN MUX_MODE7
+                        0x068 PIN_INPUT_PULLDOWN MUX_MODE7
+                        0x06C PIN_INPUT_PULLDOWN MUX_MODE7
+                        0x074 PIN_INPUT_PULLDOWN MUX_MODE7
+                        0x108 PIN_INPUT_PULLDOWN MUX_MODE7
+                        0x088 PIN_INPUT_PULLDOWN MUX_MODE7
+		>;
+	};
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_rmmi2_default>;
+	pinctrl-1 = <&cpsw_rmmi2_sleep>;
+	status = "disabled";
+};
diff --git a/arch/arm/dts/am335x-pfc-strip.dtsi b/arch/arm/dts/am335x-pfc-strip.dtsi
new file mode 100644
index 00000000000..d52a1b37870
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-strip.dtsi
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	aliases {
+		/delete-property/ serial1;
+		/delete-property/ serial2;
+		/delete-property/ serial3;
+		/delete-property/ serial4;
+		/delete-property/ serial5;
+		/delete-property/ usb1;
+		/delete-property/ phy1;
+		/delete-property/ bootmatrix;
+		/delete-property/ ethernet0;
+		/delete-property/ ethernet1;
+		/delete-property/ spi0;
+		/delete-property/ bootstate;
+	};
+};
+
+/delete-node/ &environment_sd;
+/delete-node/ &uart1;
+/delete-node/ &uart2;
+/delete-node/ &uart3;
+/delete-node/ &uart4;
+/delete-node/ &uart5;
+/delete-node/ &davinci_mdio_default;
+/delete-node/ &davinci_mdio_sleep;
+/delete-node/ &bas_pins;
+/delete-node/ &bootmatrix;
+/delete-node/ &davinci_mdio;
+/delete-node/ &cpsw_emac0;
+/delete-node/ &cpsw_emac1;
+/delete-node/ &mac;
+/delete-node/ &spi0;
+/delete-node/ &bootstate;
diff --git a/arch/arm/dts/am335x-pfc.dtsi b/arch/arm/dts/am335x-pfc.dtsi
new file mode 100644
index 00000000000..71522839b97
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc.dtsi
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "am33xx.dtsi"
+#include "bootchooser.dtsi"
+
+/ {
+	aliases {
+		ethernet0 = &cpsw_emac1;
+		ethernet1 = &cpsw_emac0;
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+		nand = &gpmc;
+		emmc = &mmc2;
+		sd = &mmc1;
+
+		/delete-property/ usb0;
+		/delete-property/ usb1;
+	};
+
+	chosen {
+		stdout-path = &uart0;
+
+		environment_sd: environment-sd {
+			compatible = "barebox,environment";
+			device-path = &mmc1, "partname:0";
+			file-path = "barebox.env";
+			status = "disabled";
+		};
+
+		environment_emmc: environment-emmc {
+			compatible = "barebox,environment";
+			device-path = &mmc2, "partname:0";
+			file-path = "barebox.env";
+			status = "disabled";
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bas_pins>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpio3 18 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpio3 17 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpio3 16 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpio3 15 GPIO_ACTIVE_HIGH>;};
+	};
+
+	vmmcsd_fixed: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vmmcsd_fixed";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&am33xx_pinmux {
+
+	pinctrl-0 = <&uart0_pins
+		     &uart1_pins>;
+
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			0x170 PIN_INPUT_PULLUP MUX_MODE0	/* uart0_rxd.uart0_rxd */
+			0x174 PIN_OUTPUT_PULLDOWN MUX_MODE0	/* uart0_txd.uart0_txd */
+		>;
+	};
+
+	uart1_pins: pinmux_uart1_pins {
+		pinctrl-single,pins = <
+			0x178 PIN_INPUT_PULLUP MUX_MODE0	/* uart1_cts.uart1_cts */
+			0x17C PIN_OUTPUT_PULLDOWN MUX_MODE0	/* uart1_rts.uart1_rts */
+			0x180 PIN_INPUT_PULLUP MUX_MODE0	/* uart1_rxd.uart1_rxd */
+			0x184 PIN_OUTPUT_PULLDOWN MUX_MODE0	/* uart1_txd.uart1_txd */
+			0x1A4 PIN_OUTPUT_PULLDOWN MUX_MODE7 /* mcasp0_fsr.gpio3_19 */
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			0x188 PIN_INPUT_PULLUP MUX_MODE0	/* i2c0_sda.i2c0_sda */
+			0x18c PIN_INPUT_PULLUP MUX_MODE0	/* i2c0_scl.i2c0_scl */
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST) MUX_MODE0 /* mdio_data.mdio_data */
+			0x14c PIN_OUTPUT_PULLUP MUX_MODE0		     /* mdio_clk.mdio_clk */
+		>;
+	};
+
+	davinci_mdio_sleep: davinci_mdio_sleep {
+		pinctrl-single,pins = <
+			0x148 PIN_INPUT_PULLDOWN MUX_MODE7
+			0x14c PIN_INPUT_PULLDOWN MUX_MODE7
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x0F0 PIN_INPUT_PULLUP MUX_MODE0	/* mmc0_dat3.mmc0_dat3 */
+			0x0F4 PIN_INPUT_PULLUP MUX_MODE0	/* mmc0_dat2.mmc0_dat2 */
+			0x0F8 PIN_INPUT_PULLUP MUX_MODE0	/* mmc0_dat1.mmc0_dat1 */
+			0x0FC PIN_INPUT_PULLUP MUX_MODE0	/* mmc0_dat0.mmc0_dat0 */
+			0x100 PIN_INPUT_PULLUP MUX_MODE0	/* mmc0_clk.mmc0_clk   */
+			0x104 PIN_INPUT_PULLUP MUX_MODE0	/* mmc0_cmd.mmc0_cmd   */
+		>;
+	};
+
+	mmc1_cd_pins: pinmux_mmc1_cd_pins {
+		pinctrl-single,pins = <
+			0x190 PIN_INPUT_PULLDOWN MUX_MODE7  /* mcasp0_aclkx.gpio3_14 */
+		>;
+	};
+
+	bas_pins: pinmux_bas_pins {
+		pinctrl-single,pins = <
+			0x194 PIN_INPUT MUX_MODE7    /* mcasp0_fsx.gpio3_15    */    //b13   RESET-ALL-BUT
+			0x198 PIN_INPUT MUX_MODE7    /* mcasp0_axr0.gpio3_16   */    //d12   nRST-BAS
+			0x19c PIN_INPUT MUX_MODE7    /* mcasp0_ahclkr.gpio3_17 */    //c12   nSTOP-BAS
+			0x1A0 PIN_INPUT MUX_MODE7    /* mcasp0_aclkr.gpio3_18  */    //b12   nRUN-BAS
+		>;
+	};
+};
+
+&cppi41dma  {
+	status = "okay";
+};
+
+&mmc1 {
+	status = "okay";
+	vmmc-supply = <&vmmcsd_fixed>;
+	bus-width = <0x4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>, <&mmc1_cd_pins>;
+	cd-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+	cd-inverted;
+};
+
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "disabled";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
+	status = "disabled";
+};
+
+&cpsw_emac0 {
+	phy-mode = "rmii";
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&cpsw_emac1 {
+	phy-mode = "rmii";
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&davinci_mdio {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&davinci_mdio_default>;
+	pinctrl-1 = <&davinci_mdio_sleep>;
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	clock-frequency = <400000>;
+	status = "okay";
+
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+	};
+};
+
+#include "eepromparts.dtsi"
+
+
+&usb {
+	status = "disabled";
+};
+
+&usb_ctrl_mod {
+	status = "disabled";
+};
+
+&usb0 {
+	status = "disabled";
+};
+
+&usb0_phy {
+	status = "disabled";
+};
+
+&usb1 {
+	status = "disabled";
+};
+
+&usb1_phy {
+	status = "disabled";
+};
diff --git a/arch/arm/dts/am35xx-pfc-750_820x.dts b/arch/arm/dts/am35xx-pfc-750_820x.dts
index 55c883944b8..17321ee6603 100644
--- a/arch/arm/dts/am35xx-pfc-750_820x.dts
+++ b/arch/arm/dts/am35xx-pfc-750_820x.dts
@@ -11,10 +11,12 @@
 /dts-v1/;
 
 #include <arm/am3517.dtsi>
+#include "bootchooser.dtsi"
 
 / {
-	model = "Wago PFC200 (AM3505)";
-	compatible = "ti,pfc200", "ti,am3517", "ti,omap3";
+	model = "PFC-750-820x";
+	compatible =  "wago,am3505-pfc-750_820x", "wago,am35xx-pfc", "ti,am3517", "ti,omap3";
+	board-variant = "pfc200";
 
 	chosen {
 		stdout-path = &uart3;
@@ -41,8 +43,47 @@
 		gpio4 = &gpio5;
 		gpio5 = &gpio6;
 		mmc0 = &mmc1;
-		mmc1 = &mmc2;
-		mmc2 = &mmc3;
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+	};
+
+	chosen {
+		stdout-path = &uart3;
+
+		environment_sd: environment-sd {
+			compatible = "barebox,environment";
+			device-path = &mmc1, "partname:0";
+			file-path = "barebox.env";
+			status = "okay";
+		};
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bas_pins>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpio3 26 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpio3 27 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpio3 28 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpio3 29 GPIO_ACTIVE_HIGH>; };
 	};
 
 	gpio-leds {
@@ -202,22 +243,10 @@
 	};
 };
 
-&uart1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart1_pins>;
-	status = "disabled";
-};
-
-&uart2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&uart2_pins>;
-	status = "disabled";
-};
-
 &uart3 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&uart3_pins>;
-        status = "okay";
+        status = "disabled";
 };
 
 &davinci_emac {
@@ -247,21 +276,26 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c2_pins>;
 	clock-frequency = <400000>;
-};
+        status = "okay";
 
-&i2c3 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&i2c3_pins>;
-	clock-frequency = <100000>;
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+		wp-gpios = <&gpio6 10 GPIO_ACTIVE_HIGH>;
+	};
 };
 
+#include "eepromparts.dtsi"
+
 &mmc1 {
         status = "okay";
 	pinctrl-names = "default";
 	pinctrl-0 = <&mmc1_pins>;
 	vmmc-supply = <&vmmc_fixed>;
 	bus-width = <4>;
-	cd-gpios = <&gpio4 20 GPIO_ACTIVE_HIGH>; /* GPIO 116 */
+	cd-gpios = <&gpio4 20 GPIO_ACTIVE_LOW>; /* GPIO 116 */
 	cd-inverted;
 };
 
@@ -275,24 +309,9 @@
 
 &omap3_pmx_core {
 	pinctrl-names = "default";
-	pinctrl-0 = <&bas_pins>;
-
-	uart1_pins: pinmux_uart1_pins {
-		pinctrl-single,pins = <
-                        0x150 (PIN_INPUT | MUX_MODE0)		  /* uart1_cts.uart1_cts */
-                        0x14e (PIN_OUTPUT | MUX_MODE0)		  /* uart1_rts.uart1_rts */
-                        0x152 (WAKEUP_EN | PIN_INPUT | MUX_MODE0) /* uart1_rx.uart1_rx   */
-                        0x14c (PIN_OUTPUT | MUX_MODE0)		  /* uart1_tx.uart1_tx   */
-		        0x1a2 (PIN_OUTPUT | MUX_MODE4)            /* mcspi1_cs2.gpio_176: sel_rs232/485_gpio176 */
-		>;
-	};
-
-	uart2_pins: pinmux_uart2_pins {
-		pinctrl-single,pins = <
-                        0x14a (WAKEUP_EN | PIN_INPUT | MUX_MODE0) /* uart2_rx.uart2_rx */
-                        0x148 (PIN_OUTPUT | MUX_MODE0)		/* uart2_tx.uart2_tx */
-		>;
-	};
+	pinctrl-0 = <&emac_pins
+		     &switch_reset
+		     &uart3_pins>;
 
 	uart3_pins: pinmux_uart3_pins {
 		pinctrl-single,pins = <
@@ -435,6 +454,12 @@
 			0x0a2 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait3.gpmc_wait3 */
 		>;
 	};
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x134 (PIN_OUTPUT | MUX_MODE4) /* mmc2_dat4.gpio5_8 (gpio_136) nrst_switch */
+		>;
+	};
 };
 
 &gpmc {
@@ -450,7 +475,7 @@
 	nand: nand@0,0 {
 		reg = <0 0 0>; /* CS0, offset 0 */
 		nand-bus-width = <8>;
-		ti,nand-ecc-opt = "bch8";
+		ti,nand-ecc-opt = "bch8-hw-det-sw";
 		gpmc,device-nand = "true";
 		gpmc,device-width = <1>;
 
@@ -484,4 +509,13 @@
 	};
 };
 
-/include/ "am3xxx-pfc-nandparts.dtsi"
+#include "am3xxx-pfc-nandparts.dtsi"
+
+&gpio5 {
+	switch_reset {
+		gpio-hog;
+		gpios = <8 GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "switch-reset";
+	};
+};
diff --git a/arch/arm/dts/am3xxx-pfc-emmcparts.dtsi b/arch/arm/dts/am3xxx-pfc-emmcparts.dtsi
new file mode 100644
index 00000000000..f8aa4c32ffe
--- /dev/null
+++ b/arch/arm/dts/am3xxx-pfc-emmcparts.dtsi
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oliver Schildan <oliver.schildan@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&mmc2{
+        #size-cells = <1>;
+        #address-cells = <1>;
+
+	partition@0 {
+		label = "mlo0";
+		reg = <0x0 0x20000>;
+	};
+
+	partition@20000 {
+		label = "mlo1";
+		reg = <0x20000 0x20000>;
+	};
+
+	partition@40000 {
+		label = "mlo2";
+		reg = <0x40000 0x20000>;
+	};
+
+	partition@60000 {
+		label = "mlo3";
+		reg = <0x60000 0x20000>;
+	};
+
+	partition@80000 {
+		label = "boot0";
+		reg = <0x80000 0x80000>;
+	};
+
+	partition@100000 {
+		label = "boot1";
+		reg = <0x100000 0x80000>;
+	};
+
+	partition@180000 {
+		label = "boot2";
+		reg = <0x180000 0x80000>;
+	};
+
+	partition@200000 {
+		label = "boot3";
+		reg = <0x200000 0x80000>;
+	};
+};
diff --git a/arch/arm/dts/am3xxx-pfc-nandparts.dtsi b/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
index 65dd56b8151..00a2ade8d42 100644
--- a/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
+++ b/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
@@ -10,54 +10,54 @@
  */
 
 &nand {
-	        /* 4 x 128k MLOs */
-		partition@0 {
-			label = "mlo0";
-			reg = <0x0 0x20000>;
-		};
-
-		partition@20000 {
-			label = "mlo1";
-			reg = <0x20000 0x20000>;
-		};
-
-		partition@40000 {
-			label = "mlo2";
-			reg = <0x40000 0x20000>;
-		};
-
-		partition@60000 {
-			label = "mlo3";
-			reg = <0x60000 0x20000>;
-		};
-
-	        /* 16 x 128k: 4 x stage2 (4x128k) */
-		partition@80000 {
-			label = "boot0";
-			reg = <0x80000 0x80000>;
-		};
-
-		partition@100000 {
-			label = "boot1";
-			reg = <0x100000 0x80000>;
-		};
-
-		partition@180000 {
-			label = "boot2";
-			reg = <0x180000 0x80000>;
-		};
-
-		partition@200000 {
-			label = "boot3";
-			reg = <0x200000 0x80000>;
-		};
-
-		partition@280000 {
-			label = "ubidata";
-			/*
-			 * Size 0x0 extends partition to
-			 * end of nand flash.
-			 */
-			reg = <0x280000 0x0>;
-		};
+        /* 4 x 128k MLOs */
+	partition@0 {
+		label = "mlo0";
+		reg = <0x0 0x20000>;
+	};
+
+	partition@1 {
+		label = "mlo1";
+		reg = <0x20000 0x20000>;
+	};
+
+	partition@2 {
+		label = "mlo2";
+		reg = <0x40000 0x20000>;
+	};
+
+	partition@3 {
+		label = "mlo3";
+		reg = <0x60000 0x20000>;
+	};
+
+        /* 16 x 128k: 4 x stage2 (4x128k) */
+	partition@4 {
+		label = "boot0";
+		reg = <0x80000 0x80000>;
+	};
+
+	partition@5 {
+		label = "boot1";
+		reg = <0x100000 0x80000>;
+	};
+
+	partition@6 {
+		label = "boot2";
+		reg = <0x180000 0x80000>;
+	};
+
+	partition@7 {
+		label = "boot3";
+		reg = <0x200000 0x80000>;
+	};
+
+	partition@8 {
+		label = "ubidata";
+		/*
+		 * Size 0x0 extends partition to
+		 * end of nand flash.
+		 */
+		reg = <0x280000 0x0>;
+	};
 };
diff --git a/arch/arm/dts/bootchooser.dtsi b/arch/arm/dts/bootchooser.dtsi
new file mode 100644
index 00000000000..14566487c33
--- /dev/null
+++ b/arch/arm/dts/bootchooser.dtsi
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	bootstate: bootstate {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		magic = <0x3f45620e>;
+		compatible = "barebox,state";
+		backend-type = "raw";
+		backend = <&backend_state_eeprom>;
+		backend-storage-type = "direct";
+		backend-stridesize = <0x40>;
+
+		rootfs.1 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@0 {
+				reg = <0x0 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@4 {
+				reg = <0x4 0x4>;
+				type = "uint32";
+				default = <20>;
+			};
+		};
+
+		rootfs.2 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@8 {
+				reg = <0x8 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@10 {
+				reg = <0xC 0x4>;
+				type = "uint32";
+				default = <10>;
+			};
+		};
+
+		last_chosen@10 {
+			reg = <0x10 0x4>;
+			type = "uint32";
+		};
+
+		device_setup@14 {
+			reg = <0x14 0x4>;
+			type = "uint32";
+		};
+	};
+};
diff --git a/arch/arm/dts/eepromparts.dtsi b/arch/arm/dts/eepromparts.dtsi
new file mode 100644
index 00000000000..c7718e1b5ad
--- /dev/null
+++ b/arch/arm/dts/eepromparts.dtsi
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&eeprom {
+	partitions: partitions {
+		compatible = "fixed-partitions";
+		#size-cells = <1>;
+		#address-cells = <1>;
+
+		backend_state_eeprom: state@2100 {
+			reg = <0x2100 0x120>;
+			label = "state-eeprom";
+		};
+
+		boot_mode_id: boot-mode-id@0 {
+			reg = <0x0 0x1>;
+			label = "boot_mode_id";
+		};
+
+		boot_mode_id_ext: boot-mode-id_ext@0102 {
+			reg = <0x0102 0x1>;
+			label = "boot_mode_id_ext";
+		};
+
+		blidx: blidx@1F7 {
+			reg = <0x1F7 0x1>;
+			label = "blidx";
+		};
+
+		devconf: devconf@1FE {
+			reg = <0x1FE 0x2>;
+			label = "devconf";
+		};
+
+		ethaddr1: ethaddr1@200 {
+			reg = <0x200 0x6>;
+			label = "ethaddr1";
+		};
+
+		ethaddr2: ethaddr2@206 {
+			label = "ethaddr2";
+			reg = <0x206 0x6>;
+		};
+	};
+};
diff --git a/arch/arm/dts/imx6q-vtpctp-762-4xxx.dts b/arch/arm/dts/imx6q-vtpctp-762-4xxx.dts
new file mode 100644
index 00000000000..593f55e9189
--- /dev/null
+++ b/arch/arm/dts/imx6q-vtpctp-762-4xxx.dts
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Ralf Gliese <ralf.gliese@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include <arm/imx6q.dtsi>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include "bootchooser.dtsi"
+
+/ {
+	model = "VTPCTP-762-4xxx";
+	compatible = "wago,imx6q-vtpctp-762_4xxx", "wago,imx6q-vtpctp", "fsl,imx6q";
+	board-variant = "vtpctp";
+	switch-reset-gpio = <&gpio4 9 GPIO_ACTIVE_LOW>;
+
+	aliases {
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+		ethernet1 = &fec;
+	};
+
+	chosen {
+		stdout-path = &uart1;
+
+		environment-sd {
+			compatible = "barebox,environment";
+			device-path = &usdhc1, "partname:0";
+			file-path = "barebox.env";
+			status = "disabled";
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x10000000 0x80000000>; /* 2GB */
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_bas>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpio2 12 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpio2 13 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpio2 15 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpio4 7  GPIO_ACTIVE_LOW>; };
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_2p5v: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "2P5V";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 15 GPIO_ACTIVE_LOW>;
+			enable-active-high;
+		};
+
+		reg_lvds_backlight_3v3: regulator@3 {
+			compatible = "regulator-fixed";
+			regulator-name = "lvds-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+	};
+
+	front_rgb_leds {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_led>;
+		compatible = "gpio-leds";
+
+		sys-red {
+			label = "sys-red";
+			gpios = <&gpio2 4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		sys-green {
+			label = "sys-green";
+			gpios = <&gpio2 5 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		sys-blue {
+			label = "sys-blue";
+			gpios = <&gpio2 6 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+	};
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 19 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "okay";
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-reset-gpios = <&gpio4 9 GPIO_ACTIVE_LOW>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8863";
+			device_type = "ethernet-phy";
+			reg = <0>;
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	imx6q-nitrogen6x {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* SGTL5000 sys_mclk */
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x030b0
+			>;
+		};
+
+		pinctrl_ecspi1: ecspi1grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO	0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI	0x100b1
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK	0x100b1
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19  0x000b1	/* CS */
+			>;
+		};
+
+		pinctrl_enet: enetgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO	    0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC	    0x1b0b0
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0 0x1b0b0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1 0x1b0b0
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN  0x1b0b0
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0 0x1b0b0
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1 0x1b0b0
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN   0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK    0x1b0b0
+				/* Phy reset */
+				MX6QDL_PAD_KEY_ROW1__GPIO4_IO09	    0x1B0B0
+				//MX6QDL_PAD_KEY_ROW1__GPIO4_IO09   0x80000000
+				/* phy irq */
+				MX6QDL_PAD_GPIO_6__ENET_IRQ         0x000b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL	  0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA 	  0x4001b8b1
+				/* EEPROM WP GPIO169 */
+				MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09 0x1b0b0
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA 0x1b0b1
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA 0x1b0b1
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				/* OTG_ID */
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID  0x1b0b1
+				/* OTG_OC */
+				MX6QDL_PAD_KEY_COL4__USB_OTG_OC	   0x1b0b1
+				/* OTG_PWR */
+				//MX6QDL_PAD_KEY_ROW4__USB_OTG_PWR 0x130b0
+				/* OTG_PWR */
+				MX6QDL_PAD_KEY_ROW4__GPIO4_IO15	   0x130b0
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD	0x17059
+				MX6QDL_PAD_SD1_CLK__SD1_CLK	0x10059
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0	0x17059
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1	0x17059
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2	0x17059
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3	0x17059
+				/* CD */
+				MX6QDL_PAD_GPIO_1__SD1_CD_B	0x1b0b0
+				/* SD-CARD.EN */
+				MX6QDL_PAD_SD4_CMD__GPIO7_IO09	0x1b0b0
+			>;
+		};
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD	0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK	0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0	0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1	0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2	0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3	0x17059
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4	0x17059
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5	0x17059
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6	0x17059
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7	0x17059
+			>;
+		};
+
+		pinctrl_rgb_led: rgb_led {
+			fsl,pins = <
+				/* LED-RD-ON */
+				MX6QDL_PAD_NANDF_D4__GPIO2_IO04	0x1b0b0
+				/* LED-GN-ON */
+				MX6QDL_PAD_NANDF_D5__GPIO2_IO05	0x1b0b0
+				/* LED-BL-ON */
+				MX6QDL_PAD_NANDF_D6__GPIO2_IO06	0x1b0b0
+			>;
+		};
+
+		pinctrl_bas: basgrp {
+			fsl,pins = <
+				/* BAS-NRUN */
+				MX6QDL_PAD_SD4_DAT4__GPIO2_IO12	0x1b0b0
+				/* BAS-NSTOP */
+				MX6QDL_PAD_SD4_DAT5__GPIO2_IO13	0x1b0b0
+				/* BAS-NRESET */
+				MX6QDL_PAD_SD4_DAT7__GPIO2_IO15	0x1b0b0
+				/* RESET-ALL */
+				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07	0x1b0b0
+			>;
+		};
+
+	};
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "disabled";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "disabled";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	phy_type = "utmi";
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	cd-gpios = <&gpio7 9 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	non-removable;
+	bus-width = <8>;
+	status = "okay";
+};
+
+#include "eepromparts.dtsi"
diff --git a/arch/arm/dts/stm32mp151-cc100-pinctrl.dtsi b/arch/arm/dts/stm32mp151-cc100-pinctrl.dtsi
new file mode 100644
index 00000000000..c96c67e864b
--- /dev/null
+++ b/arch/arm/dts/stm32mp151-cc100-pinctrl.dtsi
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
+
+#include <dt-bindings/pinctrl/stm32-pinfunc.h>
+
+&pinctrl {
+	uart4_pins_a: uart4_a-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('G', 11, AF6)>; /* UART4_TX */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <0>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('B', 2, AF8)>; /* UART4_RX */
+			bias-disable;
+		};
+	};
+
+	i2c2_pins_a: i2c2-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 4, AF4)>,  /* I2C2_SCL */
+					 <STM32_PINMUX('G', 15, AF4)>; /* I2C2_SDA */
+			bias-pull-up;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	i2c4_pins_a: i2c4-0 {
+		pins {
+			pinmux = <STM32_PINMUX('H', 11, AF4)>, /* I2C4_SCL */
+					 <STM32_PINMUX('H', 12, AF4)>; /* I2C4_SDA */
+			bias-disable;
+			drive-open-drain;
+			slew-rate = <0>;
+		};
+	};
+
+	eth1_pins_a: eth1_a-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('A', 1, AF11)>, /* ETH1_REF_CLK */
+					 <STM32_PINMUX('B', 13, AF11)>, /* ETH1_TXD1 */
+					 <STM32_PINMUX('G', 13, AF11)>; /* ETH1_TXD0 */
+			bias-disable;
+			drive-push-pull;
+			slew-rate = <1>;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('A', 7, AF11)>, /* ETH1_CRS_DV */
+					 <STM32_PINMUX('C', 4, AF11)>, /* ETH1_RXD0 */
+					 <STM32_PINMUX('C', 5, AF11)>; /* ETH1_RXD1 */
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('B', 11, AF11)>; /* ETH1_TX_EN */
+		};
+	};
+
+	sdmmc1_b4_pins_a: sdmmc1-b4-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('C',  8, AF12)>, /* SDMMC1_D0 */
+				 <STM32_PINMUX('C',  9, AF12)>, /* SDMMC1_D1 */
+				 <STM32_PINMUX('E',  6,  AF8)>, /* SDMMC1_D2 */
+				 <STM32_PINMUX('C', 11, AF12)>, /* SDMMC1_D3 */
+				 <STM32_PINMUX('D',  2, AF12)>; /* SDMMC1_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('C', 12, AF12)>; /* SDMMC1_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-disable;
+		};
+		pins3 {
+			pinmux = <STM32_PINMUX('I', 5, GPIO)>; 	/* SDMMC1_NCD */
+			slew-rate = <0>;
+			bias-disable;
+			input-enable;
+		};
+		pins4 {
+			pinmux = <STM32_PINMUX('G', 10, GPIO)>; /* SDMMC1_LED */
+			slew-rate = <0>;
+			drive-push-pull;
+			bias-disable;
+			output-low;
+		};
+	};
+
+	sdmmc2_b8_pins: sdmmc2-b8-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B', 14, AF9)>,  /* SDMMC2_D0 */
+				 <STM32_PINMUX('B', 15, AF9)>,  /* SDMMC2_D1 */
+				 <STM32_PINMUX('B',  3, AF9)>,  /* SDMMC2_D2 */
+				 <STM32_PINMUX('B',  4, AF9)>,  /* SDMMC2_D3 */
+				 <STM32_PINMUX('E',  4, AF9)>,  /* SDMMC2_D4 */
+				 <STM32_PINMUX('B',  9, AF10)>, /* SDMMC2_D5 */
+				 <STM32_PINMUX('E',  5, AF9)>,  /* SDMMC2_D6 */
+				 <STM32_PINMUX('D',  3, AF9)>,  /* SDMMC2_D7 */
+				 <STM32_PINMUX('G',  6, AF10)>; /* SDMMC2_CMD */
+			slew-rate = <1>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+		pins2 {
+			pinmux = <STM32_PINMUX('E', 3, AF9)>; /* SDMMC2_CK */
+			slew-rate = <2>;
+			drive-push-pull;
+			bias-pull-up;
+		};
+	};
+
+	bas_pins: bas-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('J',  6, GPIO)>,  /* BAS_RUN */
+				 <STM32_PINMUX('A',  8, GPIO)>,  /* BAS_STOP */
+				 <STM32_PINMUX('I', 11, GPIO)>,  /* BAS_RESET */
+				 <STM32_PINMUX('Z',  4, GPIO)>;  /* BAS_RST */
+		};
+	};
+
+	led_pins: led-0 {
+		pins1 {
+			pinmux = <STM32_PINMUX('B',  0, GPIO)>,  /* LED_RUN_G */
+				 <STM32_PINMUX('B', 12, GPIO)>,  /* LED_RUN_R */
+				 <STM32_PINMUX('A', 14, GPIO)>,  /* LED_SYS_G */
+				 <STM32_PINMUX('A', 13, GPIO)>,  /* LED_SYS_R */
+				 <STM32_PINMUX('J',  1, GPIO)>,  /* LED_USR_G */
+				 <STM32_PINMUX('I', 10, GPIO)>;  /* LED_USR_R */
+		};
+	};
+};
diff --git a/arch/arm/dts/stm32mp151-cc100.dts b/arch/arm/dts/stm32mp151-cc100.dts
new file mode 100644
index 00000000000..5ce73f36970
--- /dev/null
+++ b/arch/arm/dts/stm32mp151-cc100.dts
@@ -0,0 +1,402 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/dts-v1/;
+
+#include <arm/stm32mp151.dtsi>
+#include "stm32mp151.dtsi"
+#include "stm32mp151-cc100-pinctrl.dtsi"
+#include <arm/stm32mp15xxaa-pinctrl.dtsi>
+#include <arm/stm32mp15xc.dtsi>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/mfd/st,stpmic1.h>
+#include "bootchooser.dtsi"
+
+/ {
+	model = "CC100-751-9301";
+	compatible = "wago,stm32mp151-cc100-751_9301", "wago,stm32mp151-cc100", "st,stm32mp151";
+	board-variant = "cc100";
+
+	aliases {
+		ethernet0 = &ethernet0;
+		mdio-gpio0 = &bitbang_mdio0;
+		serial0 = &uart4;
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bitbang_mdio0: gpio_mdio {
+		compatible = "virtual,mdio-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		gpios = <
+			&gpioc 1 0	/* 0: mdc  */
+			&gpioa 2 0	/* 1: mdio */
+		>;
+		status = "disabled";
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bas_pins>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpioj  6 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpioa  8 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpioi 11 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpioz  4 GPIO_ACTIVE_LOW>; };
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_pins>;
+
+		u1-green@0 {
+			label = "u1-green";
+			gpios = <&gpioj 1 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		u1-red@1 {
+			label = "u1-red";
+			gpios = <&gpioi 10 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		sys-green@2 {
+			label = "sys-green";
+			gpios = <&gpioa 14 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "none";
+		};
+
+		sys-red@3 {
+			label = "sys-red";
+			gpios = <&gpioa 13 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "none";
+		};
+
+		run-green@4 {
+			label = "run-green";
+			gpios = <&gpiob 0 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		run-red@5 {
+			label = "run-red";
+			gpios = <&gpiob 12 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+	};
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+	secure-status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	clock-frequency = <100000>;
+
+	rtc_r2221t: rtc@32 {
+		compatible = "ricoh,r2221tl";
+		reg = <0x32>;
+
+		interrupt-parent = <&gpiob>;
+		interrupts = <8 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4_pins_a>;
+	i2c-scl-rising-time-ns = <185>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+	secure-status = "okay";
+	/delete-property/dmas;
+	/delete-property/dma-names;
+	clock-frequency = <100000>;
+
+	eeprom: m24c512@54 {
+		status = "okay";
+		compatible = "st,24c512", "at24";
+		reg = <0x54>;
+		pagesize = <128>;
+	};
+
+	pmic: stpmic@33 {
+		compatible = "st,stpmic1";
+		reg = <0x33>;
+		interrupts-extended = <&gpioa 0 IRQ_TYPE_EDGE_FALLING>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+		status = "okay";
+
+		regulators {
+			compatible = "st,stpmic1-regulators";
+			ldo1-supply = <&v3v3>;
+			ldo3-supply = <&vdd_ddr>;
+			ldo6-supply = <&v3v3>;
+			pwr_sw1-supply = <&bst_out>;
+			pwr_sw2-supply = <&bst_out>;
+
+			vddcore: buck1 {
+				regulator-name = "vddcore";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd_ddr: buck2 {
+				regulator-name = "vdd_ddr";
+				regulator-min-microvolt = <1350000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-always-on;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			vdd: buck3 {
+				regulator-name = "vdd";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				st,mask-reset;
+				regulator-initial-mode = <0>;
+				regulator-over-current-protection;
+			};
+
+			v3v3: buck4 {
+				regulator-name = "v3v3";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+				regulator-initial-mode = <0>;
+			};
+
+			v1v8_audio: ldo1 {
+				regulator-name = "v1v8_audio";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO1 0>;
+			};
+
+			v3v3_hdmi: ldo2 {
+				regulator-name = "v3v3_hdmi";
+				regulator-min-microvolt = <2800000>;
+				regulator-max-microvolt = <2800000>;
+
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO2 0>;
+			};
+
+			vtt_ddr: ldo3 {
+				regulator-name = "vtt_ddr";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			vdd_usb: ldo4 {
+				regulator-name = "vdd_usb";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				interrupts = <IT_CURLIM_LDO4 0>;
+			};
+
+			vdda: ldo5 {
+				regulator-name = "vdda";
+				regulator-min-microvolt = <2900000>;
+				regulator-max-microvolt = <2900000>;
+				interrupts = <IT_CURLIM_LDO5 0>;
+				regulator-boot-on;
+			};
+
+			v1v2_hdmi: ldo6 {
+				regulator-name = "v1v2_hdmi";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				interrupts = <IT_CURLIM_LDO6 0>;
+			};
+
+			vref_ddr: vref_ddr {
+				regulator-name = "vref_ddr";
+				regulator-always-on;
+				regulator-over-current-protection;
+			};
+
+			bst_out: boost {
+				regulator-name = "bst_out";
+				interrupts = <IT_OCP_BOOST 0>;
+			};
+
+			vbus_otg: pwr_sw1 {
+				regulator-name = "vbus_otg";
+				interrupts = <IT_OCP_OTG 0>;
+			};
+
+			vbus_sw: pwr_sw2 {
+				regulator-name = "vbus_sw";
+				interrupts = <IT_OCP_SWOUT 0>;
+				regulator-active-discharge;
+			};
+		};
+
+		onkey {
+			compatible = "st,stpmic1-onkey";
+			interrupts = <IT_PONKEY_F 0>, <IT_PONKEY_R 0>;
+			interrupt-names = "onkey-falling", "onkey-rising";
+			power-off-time-sec = <10>;
+		};
+
+		watchdog {
+			compatible = "st,stpmic1-wdt";
+			status = "disabled";
+		};
+	};
+
+};
+
+#include "eepromparts.dtsi"
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins_a>;
+	status = "disabled";
+};
+
+&sdmmc1 {
+	status = "okay";
+
+	bus-width = <4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc1_b4_pins_a>;
+	cd-gpios = <&gpioi 5 GPIO_ACTIVE_LOW>;
+	cd-inverted;
+	disable-wp;
+	st,neg-edge;
+};
+
+&sdmmc2 {
+	status = "okay";
+
+	bus-width = <8>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2_b8_pins>;
+	non-removable;
+};
+
+&gpiog {
+         led-mmc {
+                 gpio-hog;
+                 gpios = <10 GPIO_ACTIVE_HIGH>;
+                 output-low;
+        };
+};
+
+&ethernet0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&eth1_pins_a>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-reset-gpios = <&gpiog 7 GPIO_ACTIVE_LOW>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8863";
+			device_type = "ethernet-phy";
+			reg = <0>;
+		};
+	};
+};
+
+&bitbang_mdio0 {
+	ksz8863_switch: switch@0 {
+		compatible = "micrel,ksz8863";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg = <0>;
+		dsa,member = <0 0>;
+		dsa,enable-on-boot;
+
+		ksz,reset-switch;
+
+		phy-mode = "rmii";
+
+		interrupt-parent = <&gpiog>;
+		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
+
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <2>;
+				label = "ethX1";
+				phy-mode = "rmii";
+				phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "ethX2";
+				phy-mode = "rmii";
+				phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <3>;
+				label = "cpu";
+				phy-mode = "rmii";
+				ethernet = <&ethernet0>;
+				fixed-link {
+					speed = <100>;
+					full-duplex;
+				};
+			};
+		};
+	};
+
+};
+
+&iwdg2 {
+	status = "okay";
+};
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index fa373f9a7cd..28a7b8173c2 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -464,6 +464,12 @@ config MACH_ADVANTECH_ROM_742X
 	select ARCH_IMX6
 	select ARM_USE_COMPRESSED_DTB
 
+config MACH_WAGO_VTPCTP_MX6
+	bool "Wago VTPCTP Panels"
+	select ARCH_IMX6
+	help
+	  Support for Wago i.MX6 Quad-Core Touch-Panels
+
 config MACH_WARP7
 	bool "NXP i.MX7: element 14 WaRP7 Board"
 	select ARCH_IMX7
diff --git a/arch/arm/mach-omap/Kconfig b/arch/arm/mach-omap/Kconfig
index 220b6351679..951a3323a26 100644
--- a/arch/arm/mach-omap/Kconfig
+++ b/arch/arm/mach-omap/Kconfig
@@ -185,9 +185,58 @@ config MACH_WAGO_PFC_AM35XX
         select ARCH_AM35XX
         select HAVE_PBL_MULTI_IMAGES
         select HAVE_CONFIGURABLE_MEMORY_LAYOUT
+	select WAGO_PFC_XLOAD
         help
           Say Y here if you are using a the AM3505 based PFC200 controller
 
+config MACH_WAGO_PFC_AM335X
+	bool "WAGO PFC200 AM335X based Fieldbus Controller"
+	select ARCH_AM33XX
+	select WAGO_PFC_XLOAD
+	help
+	  Say Y here if you are using a AM335x based PFC200 controller
+
+if MACH_WAGO_PFC_AM335X
+
+config MACH_WAGO_PFC_AM335X_750_810x
+	bool "PFC-750-810x"
+	help
+	  Say Y here if you are using a am335x based Wago PFC-750-810x
+
+config MACH_WAGO_PFC_AM335X_750_8208
+	bool "PFC-750-8208"
+	help
+	  Say Y here if you are using a am335x based Wago PFC-750-8208
+
+config MACH_WAGO_PFC_AM335X_750_821x
+	bool "PFC-750-821x"
+	help
+	  Say Y here if you are using a am335x based Wago PFC-750-821x
+
+config MACH_WAGO_PFC_AM335X_768_330x
+	bool "PAC-768-330x"
+	help
+	  Say Y here if you are using a am335x based Wago PAC-768-330x
+
+config MACH_WAGO_PFC_AM335X_768_330x
+	bool "PAC-768-330x"
+	help
+	  Say Y here if you are using a am335x based Wago PAC-768-330x
+
+endif
+
+endif
+
+if MACH_WAGO_PFC_AM335X || MACH_WAGO_PFC_AM35XX
+
+config WAGO_PFC_XLOAD
+	bool
+	select PARAMETER if !MACH_WAGO_PFC_AM35XX
+	prompt "Activate Wago PFC specific xload startup"
+	help
+	  Say Y to enable pfc specific xload startup code. This simultaneously
+	  disables the upstream xload startup code.
+
 endif
 
 source "arch/arm/boards/phytec-som-am335x/Kconfig"
diff --git a/arch/arm/mach-omap/Makefile b/arch/arm/mach-omap/Makefile
index 36b2aa090e4..f7c83067191 100644
--- a/arch/arm/mach-omap/Makefile
+++ b/arch/arm/mach-omap/Makefile
@@ -27,7 +27,11 @@ obj-$(CONFIG_ARCH_AM33XX) += am33xx_scrm.o
 obj-$(CONFIG_ARCH_OMAP3) += omap3_clock.o
 pbl-$(CONFIG_ARCH_OMAP3) += omap3_clock.o
 obj-$(CONFIG_OMAP_GPMC) += gpmc.o devices-gpmc-nand.o
+ifdef CONFIG_WAGO_PFC_XLOAD
+obj-$(CONFIG_SHELL_NONE) += xload-pfc.o
+else
 obj-$(CONFIG_SHELL_NONE) += xload.o
+endif
 obj-$(CONFIG_MFD_TWL6030) += omap4_twl6030_mmc.o
 obj-$(CONFIG_OMAP4_USBBOOT) += omap4_rom_usb.o
 obj-$(CONFIG_OMAP3_USBBOOT) += omap3_xload_usb.o
diff --git a/arch/arm/mach-omap/am33xx_bbu_emmc.c b/arch/arm/mach-omap/am33xx_bbu_emmc.c
index 29e13de778a..96ca3fa4f92 100644
--- a/arch/arm/mach-omap/am33xx_bbu_emmc.c
+++ b/arch/arm/mach-omap/am33xx_bbu_emmc.c
@@ -23,6 +23,12 @@
 #define PART_TABLE_SIZE		66
 #define PART_TABLE_OFFSET	0x1BE
 
+struct emmc_bbu_handler {
+	struct bbu_handler bbu_handler;
+	char **devicefile;
+	int num_devicefiles;
+};
+
 static int emmc_mlo_handler(struct bbu_handler *handler, struct bbu_data *data)
 {
 	int ret = 0;
@@ -77,6 +83,68 @@ error:
 	return (ret > 0) ? 0 : ret;
 }
 
+static int emmc_write_to_device(const char *devicefile, const void *image,
+								size_t size)
+{
+	int ret, fd;
+
+	fd = open(devicefile, O_RDWR);
+	if (fd < 0) {
+		pr_err("could not open %s: %s\n", devicefile,
+							errno_str());
+		return fd;
+	}
+
+	ret = write(fd, image, size);
+	if (ret < 0)
+		pr_err("could not write to fd %s: %s\n", devicefile,
+								errno_str());
+
+	close(fd);
+
+	return ret;
+
+}
+
+static int emmc_update_handler(struct bbu_handler *handler,
+							struct bbu_data *data)
+{
+	int ret = 0;
+	int i = 0;
+	const void *image = data->image;
+	size_t size = data->len;
+	struct emmc_bbu_handler *nh;
+
+	nh = container_of(handler, struct emmc_bbu_handler, bbu_handler);
+
+	if (file_detect_type(image, size) != filetype_arm_barebox) {
+		pr_err("%s is not a valid ch-image\n", data->imagefile);
+		return -EINVAL;
+	}
+
+	ret = bbu_confirm(data);
+	if (ret != 0)
+		goto out;
+
+	/* check if the devicefile has been overwritten */
+	if (strcmp(data->devicefile, nh->devicefile[0]) != 0) {
+		ret = emmc_write_to_device(data->devicefile, image, size);
+		if (!ret)
+			goto out;
+	} else {
+		for (i = 0; i < nh->num_devicefiles; i++) {
+			ret = emmc_write_to_device(nh->devicefile[i], image, size);
+			if (!ret)
+				goto out;
+		}
+	}
+
+	return 0;
+
+out:
+	return ret;
+}
+
 int am33xx_bbu_emmc_mlo_register_handler(const char *name, char *devicefile)
 {
 	struct bbu_handler *handler;
@@ -94,3 +162,23 @@ int am33xx_bbu_emmc_mlo_register_handler(const char *name, char *devicefile)
 
 	return ret;
 }
+
+int am33xx_bbu_emmc_register_handler(const char *name, char **devicefile,
+							int num_devicefiles)
+{
+	struct emmc_bbu_handler *handler;
+	int ret;
+
+	handler = xzalloc(sizeof(*handler));
+	handler->devicefile = devicefile;
+	handler->num_devicefiles = num_devicefiles;
+	handler->bbu_handler.devicefile = devicefile[0];
+	handler->bbu_handler.handler = emmc_update_handler;
+	handler->bbu_handler.name = name;
+
+	ret = bbu_register_handler(&handler->bbu_handler);
+	if (ret)
+		free(handler);
+
+	return ret;
+}
diff --git a/arch/arm/mach-omap/am33xx_generic.c b/arch/arm/mach-omap/am33xx_generic.c
index 3c5cdf065c8..8b5d711d2c5 100644
--- a/arch/arm/mach-omap/am33xx_generic.c
+++ b/arch/arm/mach-omap/am33xx_generic.c
@@ -28,6 +28,7 @@
 #include <mach/am33xx-generic.h>
 #include <mach/gpmc.h>
 #include <reset_source.h>
+#include <mach/syslib.h>
 
 static void __noreturn am33xx_restart_soc(struct restart_handler *rst)
 {
@@ -189,11 +190,10 @@ static void am33xx_detect_reset_reason(void)
 	}
 }
 
-int am33xx_register_ethaddr(int eth_id, int mac_id)
+int am33xx_get_internal_mac_id(uint8_t *mac_addr, int mac_id)
 {
 	void __iomem *mac_id_low = (void *)AM33XX_MAC_ID0_LO + mac_id * 8;
 	void __iomem *mac_id_high = (void *)AM33XX_MAC_ID0_HI + mac_id * 8;
-	uint8_t mac_addr[6];
 	uint32_t mac_hi, mac_lo;
 
 	mac_lo = readl(mac_id_low);
@@ -205,6 +205,15 @@ int am33xx_register_ethaddr(int eth_id, int mac_id)
 	mac_addr[4] = mac_lo & 0xff;
 	mac_addr[5] = (mac_lo & 0xff00) >> 8;
 
+	return 0;
+}
+
+int am33xx_register_ethaddr(int eth_id, int mac_id)
+{
+	uint8_t mac_addr[6];
+
+	am33xx_get_internal_mac_id(mac_addr, mac_id);
+
 	if (is_valid_ether_addr(mac_addr)) {
 		eth_register_ethaddr(eth_id, mac_addr);
 		return 0;
@@ -432,6 +441,7 @@ void am335x_sdram_init(int ioctrl, const struct am33xx_cmd_control *cmd_ctrl,
 	am33xx_enable_ddr_clocks();
 
 	am33xx_config_vtp();
+	sdelay(50000);
 
 	am33xx_ddr_phydata_cmd_macro(cmd_ctrl);
 	am33xx_config_ddr_data(ddr_data, 0);
diff --git a/arch/arm/mach-omap/include/mach/am33xx-generic.h b/arch/arm/mach-omap/include/mach/am33xx-generic.h
index 7e64e74d5c2..0d2afb89a5c 100644
--- a/arch/arm/mach-omap/include/mach/am33xx-generic.h
+++ b/arch/arm/mach-omap/include/mach/am33xx-generic.h
@@ -6,6 +6,7 @@
 #include <mach/am33xx-silicon.h>
 
 int am33xx_register_ethaddr(int eth_id, int mac_id);
+int am33xx_get_internal_mac_id(uint8_t *mac_addr, int mac_id);
 
 u32 am33xx_get_cpu_rev(void);
 
diff --git a/arch/arm/mach-omap/include/mach/am3xxx-pfc-generic.h b/arch/arm/mach-omap/include/mach/am3xxx-pfc-generic.h
new file mode 100644
index 00000000000..3d671d5506a
--- /dev/null
+++ b/arch/arm/mach-omap/include/mach/am3xxx-pfc-generic.h
@@ -0,0 +1,42 @@
+#ifndef __MACH_AM3XXX_PFC_GENERIC_H
+#define __MACH_AM3XXX_PFC_GENERIC_H
+
+struct omap_barebox_boot_parts {
+	char **boot_nandslots;
+	char **boot_emmcslots;
+	int num_boot_nandslots;
+	int num_boot_emmcslots;
+};
+
+enum omap_board_boot_device {
+	HAS_SD = 0,
+	HAS_NAND,
+	HAS_EMMC,
+	HAS_USB,
+	NUM_BOOT_DEVICES,
+};
+
+struct omap_board_info {
+	char *board_variant;
+	bool production_mode;
+	bool disable_sd_boot;
+	DECLARE_BITMAP(boot_devices, NUM_BOOT_DEVICES);
+};
+
+#ifdef CONFIG_SHELL_NONE
+int omap_set_barebox_boot_parts(struct omap_barebox_boot_parts *parts);
+int omap_set_board_info(struct omap_board_info *board_info);
+#else
+static inline int
+omap_set_barebox_boot_parts(struct omap_barebox_boot_parts *parts)
+{
+	return 0;
+}
+
+static inline int omap_set_board_info(struct omap_board_info *board_info)
+{
+	return 0;
+}
+#endif
+
+#endif /* __MACH_AM3XXX_PFC_GENERIC_H */
diff --git a/arch/arm/mach-omap/include/mach/bbu.h b/arch/arm/mach-omap/include/mach/bbu.h
index 94d3f96bb45..b92df9e3581 100644
--- a/arch/arm/mach-omap/include/mach/bbu.h
+++ b/arch/arm/mach-omap/include/mach/bbu.h
@@ -47,7 +47,8 @@ static inline int am33xx_bbu_nand_register_handler(const char *device)
 
 #ifdef CONFIG_BAREBOX_UPDATE_AM33XX_EMMC
 int am33xx_bbu_emmc_mlo_register_handler(const char *name, char *devicefile);
-int am33xx_bbu_emmc_register_handler(const char *name, char *devicefile);
+int am33xx_bbu_emmc_register_handler(const char *name, char **devicefile,
+							int num_devicefiles);
 #else
 static inline int am33xx_bbu_emmc_mlo_register_handler(const char *name,
 							char *devicefile)
@@ -56,7 +57,8 @@ static inline int am33xx_bbu_emmc_mlo_register_handler(const char *name,
 }
 
 static inline int am33xx_bbu_emmc_register_handler(const char *name,
-							char *devicefile)
+							char **devicefile,
+							int num_devicefiles)
 {
 	return 0;
 }
diff --git a/arch/arm/mach-omap/include/mach/gpmc_nand.h b/arch/arm/mach-omap/include/mach/gpmc_nand.h
index f172b576eb2..d777fe84a74 100644
--- a/arch/arm/mach-omap/include/mach/gpmc_nand.h
+++ b/arch/arm/mach-omap/include/mach/gpmc_nand.h
@@ -34,6 +34,8 @@ enum gpmc_ecc_mode {
 	OMAP_ECC_HAMMING_CODE_HW_ROMCODE,
 	OMAP_ECC_BCH8_CODE_HW,
 	OMAP_ECC_BCH8_CODE_HW_ROMCODE,
+	OMAP_ECC_BCH8_CODE_HW_DETECTION_SW,
+	OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY,
 	OMAP_ECC_BCH16_CODE_HW,
 };
 
diff --git a/arch/arm/mach-omap/include/mach/omap_hsmmc.h b/arch/arm/mach-omap/include/mach/omap_hsmmc.h
index 19942df587d..308d181c3df 100644
--- a/arch/arm/mach-omap/include/mach/omap_hsmmc.h
+++ b/arch/arm/mach-omap/include/mach/omap_hsmmc.h
@@ -22,5 +22,7 @@
 struct omap_hsmmc_platform_data {
 	unsigned f_max;         /* host interface upper limit */
 	char *devname;		/* The mci device name, optional */
+	int cd_gpio;
+	bool cd_inverted;
 };
 #endif /* __ASM_OMAP_HSMMC_H */
diff --git a/arch/arm/mach-omap/xload-pfc.c b/arch/arm/mach-omap/xload-pfc.c
new file mode 100644
index 00000000000..c5e698b8938
--- /dev/null
+++ b/arch/arm/mach-omap/xload-pfc.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Peter Galka <peter.galka@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * Xload handler tries to boot from mmc first, if card inserted and barebox
+ * image available. Otherwise it boots from internal memory (nand or emmc).
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <init.h>
+#include <mci.h>
+#include <bootsource.h>
+#include <mach/generic.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <filetype.h>
+#include <fcntl.h>
+#include <sys/mount.h>
+#include <libfile.h>
+#include <fs.h>
+#include <usb/gadget-multi.h>
+
+#define UIMAGE_HEADER_SIZE 64
+
+struct omap_barebox_boot_parts *barebox_boot_parts;
+struct omap_board_info *board;
+
+static int pfc_mmc_inserted(void)
+{
+	struct mci *mci;
+
+	mci = mci_get_device_by_name("mmc0");
+	if (!mci)
+		return 0;
+
+	if (mci->host->card_present)
+		return (mci->host->card_present(mci->host) <= 0) ? 0 : 1;
+
+	return 0;
+}
+
+static unsigned int pfc_xload_get_image_size(void *head)
+{
+	unsigned int ret = 0;
+	unsigned int *psize = head + ARM_HEAD_SIZE_OFFSET;
+
+	if (is_barebox_arm_head(head))
+		ret = *psize;
+	pr_info("Detected barebox image size %u\n", ret);
+
+	return ret;
+}
+
+static void *pfc_xload_read_image_head(const char *name)
+{
+	void *header = xmalloc(ARM_HEAD_SIZE);
+	struct cdev *cdev;
+	int ret;
+
+	cdev = cdev_open(name, O_RDONLY);
+	if (!cdev) {
+		pr_info("%s: failed to open %s\n", name, __func__);
+		return NULL;
+	}
+
+	ret = cdev_read(cdev, header, ARM_HEAD_SIZE, 0, 0);
+	cdev_close(cdev);
+
+	if (ret != ARM_HEAD_SIZE) {
+		pr_info("%s: failed to read from %s\n", __func__, name);
+		return NULL;
+	}
+
+	return header;
+}
+
+static void *pfc_xload_read_cdev_barebox(const char *partition)
+{
+	int ret;
+	int size;
+	void *to, *header;
+	struct cdev *cdev;
+
+	header = pfc_xload_read_image_head(partition);
+	if (header == NULL)
+		return NULL;
+
+	size = pfc_xload_get_image_size(header);
+	if (!size) {
+		pr_info("%s: failed to get image size\n", __func__);
+		return NULL;
+	}
+
+	to = xmalloc(size);
+
+	cdev = cdev_open(partition, O_RDONLY);
+	if (!cdev) {
+		pr_info("%s: failed to open partition\n", __func__);
+		return NULL;
+	}
+
+	ret = cdev_read(cdev, to, size, 0, 0);
+	if (ret != size) {
+		pr_info("%s: failed to read from partition\n", __func__);
+		return NULL;
+	}
+
+	return to;
+}
+
+static void *pfc_xload_boot_parts(char **parts, int num_parts)
+{
+	int i = 0;
+	void *to;
+
+	for (i=0; i < num_parts; i++) {
+		to = pfc_xload_read_cdev_barebox(parts[i]);
+		if (to) {
+			pr_info("%s: found image on raw partition %s\n",
+							 __func__, parts[i]);
+			break;
+		}
+	}
+
+	return to;
+}
+
+static void *pfc_xload_boot_mmc(char *bootfile)
+{
+	int ret;
+	int len;
+	const char *rootpath;
+	const char *diskdev;
+	char *partname;
+	char *bootfile_path;
+	struct cdev *cdev;
+	void *buf = NULL;
+
+	diskdev = omap_get_bootmmc_devname();
+	if (!diskdev)
+		goto out;
+
+	ret = device_detect_by_name(diskdev);
+	if (ret)
+		goto out;
+
+	partname = basprintf("%s.0", diskdev);
+	cdev = cdev_by_name(partname);
+	if (!cdev) {
+		pr_err("failed to get device %s\n", partname);
+		goto free;
+	}
+
+	rootpath = cdev_mount_default(cdev, NULL);
+	if (IS_ERR(rootpath)) {
+		pr_err("failed to mount %s: (%ld)\n", cdev->name,
+							PTR_ERR(rootpath));
+		goto free;
+	}
+
+	bootfile_path = basprintf("%s/%s", rootpath, bootfile);
+	buf = read_file(bootfile_path, &len);
+	free(bootfile_path);
+
+free:
+	free(partname);
+out:
+	return buf;
+}
+
+static int pfc_xload_activate_fastboot(void)
+{
+	struct f_multi_opts *opts;
+	struct file_list *files;
+	int ret;
+
+	opts = xzalloc(sizeof(*opts));
+	opts->release = usb_multi_opts_release;
+
+	files = file_list_parse("/barebox(barebox)c");
+	if (IS_ERR(files)) {
+		ret = PTR_ERR(files);
+		goto err;
+	}
+
+	opts->fastboot_opts.files = files;
+
+	ret = usb_multi_register(opts);
+	if (ret)
+		goto err;
+
+	return ret;
+err:
+	usb_multi_opts_release(opts);
+	return ret;
+}
+
+static __noreturn int pfc_xload(void)
+{
+	char *bootfile = NULL;
+	char *bootfile_legacy = "barebox.img";
+	void *barebox = NULL;
+	enum bootsource bootsource;
+	int ret;
+
+	if (!board) {
+		pr_err("%s: no board information set\n", __func__);
+		goto out;
+	}
+
+	printf("%s: rom-code boots us from: ", __func__);
+
+	bootsource = bootsource_get();
+	switch (bootsource) {
+		case BOOTSOURCE_MMC:
+			printf("mmc%d\n", bootsource_get_instance());
+			break;
+		case BOOTSOURCE_NAND:
+			printf("nand%d\n", bootsource_get_instance());
+			break;
+		default:
+			printf("unknown\n");
+	}
+
+	if (!board->board_variant)
+		bootfile = basprintf("barebox.bin");
+	else
+		bootfile = basprintf("barebox.bin.%s", board->board_variant);
+
+	printf("%s: board-variant: %s\n", __func__, board->board_variant ?
+							board->board_variant :
+							"none");
+
+	if (test_bit(HAS_SD, board->boot_devices) && pfc_mmc_inserted() &&
+						!board->disable_sd_boot) {
+		omap_set_bootmmc_devname("mmc0");
+		printf("%s: boot %s vfat from %s\n", __func__, bootfile,
+						omap_get_bootmmc_devname());
+
+		barebox = pfc_xload_boot_mmc(bootfile);
+		if (!barebox) {
+			printf("%s: file %s not found on %s\n", __func__,
+					bootfile, omap_get_bootmmc_devname());
+
+			/* legacy support for FW < 05 */
+			printf("%s: boot %s vfat from %s\n", __func__,
+						bootfile_legacy,
+						omap_get_bootmmc_devname());
+			barebox = pfc_xload_boot_mmc(bootfile_legacy);
+			if (barebox) {
+				/* skip uimage header */
+				barebox += UIMAGE_HEADER_SIZE;
+			} else {
+				printf("%s: file %s not found on %s\n",
+						__func__, bootfile_legacy,
+						omap_get_bootmmc_devname());
+			}
+		}
+	}
+
+	if (test_bit(HAS_EMMC, board->boot_devices) && !barebox) {
+		omap_set_bootmmc_devname("mmc1");
+
+		if (barebox_boot_parts) {
+			printf("%s: boot raw from %s\n", __func__,
+						omap_get_bootmmc_devname());
+
+			barebox = pfc_xload_boot_parts(
+					barebox_boot_parts->boot_emmcslots,
+					barebox_boot_parts->num_boot_emmcslots);
+		}
+
+		if (!barebox) {
+			printf("%s: no raw image file found on %s\n", __func__,
+						omap_get_bootmmc_devname());
+
+			printf("%s: boot %s vfat from %s\n", __func__,
+						bootfile,
+						omap_get_bootmmc_devname());
+			barebox = pfc_xload_boot_mmc(bootfile);
+		}
+	}
+
+	if (test_bit(HAS_NAND, board->boot_devices) && !barebox) {
+		if (barebox_boot_parts) {
+			printf("%s: boot raw from nand\n", __func__);
+			barebox = pfc_xload_boot_parts(
+					barebox_boot_parts->boot_nandslots,
+					barebox_boot_parts->num_boot_nandslots);
+		}
+	}
+
+	if (IS_ENABLED(CONFIG_USB_GADGET_FASTBOOT) &&
+				!barebox && board->production_mode &&
+				test_bit(HAS_USB, board->boot_devices)) {
+		ret = pfc_xload_activate_fastboot();
+		if (ret)
+			printf("%s: could not activate fastboot\n", __func__);
+		else
+			printf("%s: waiting for fastboot commands...\n",
+								__func__);
+		goto out_poll;
+	}
+
+	if (barebox)
+		omap_start_barebox(barebox);
+out:
+	pr_err("%s: could not boot from any boot device\n", __func__);
+out_poll:
+	free(bootfile);
+	while (1) { poller_call(); }
+}
+
+int omap_set_barebox_boot_parts(struct omap_barebox_boot_parts *parts)
+{
+	barebox_boot_parts = parts;
+
+	return 0;
+}
+
+int omap_set_board_info(struct omap_board_info *board_info)
+{
+	board = board_info;
+
+	return 0;
+}
+
+static int pfc_set_xload(void)
+{
+	barebox_main = pfc_xload;
+
+	return 0;
+}
+late_initcall(pfc_set_xload);
diff --git a/arch/arm/mach-stm32mp/Kconfig b/arch/arm/mach-stm32mp/Kconfig
index 95d3dc510d1..8bab9df5063 100644
--- a/arch/arm/mach-stm32mp/Kconfig
+++ b/arch/arm/mach-stm32mp/Kconfig
@@ -31,4 +31,9 @@ config MACH_STM32MP15X_EV1
 	  as SSBL on any STM32MP15X-EVAL platform, like the
 	  STM32MP157C-EV1
 
+config MACH_STM32MP151_CC100
+	select ARCH_STM32MP157
+	bool "STM32MP151-CC100 PLC board"
+	help
+	  todo
 endif
diff --git a/arch/arm/mach-stm32mp/init.c b/arch/arm/mach-stm32mp/init.c
index 01961ae4562..017450a69c2 100644
--- a/arch/arm/mach-stm32mp/init.c
+++ b/arch/arm/mach-stm32mp/init.c
@@ -76,8 +76,12 @@ static void setup_boot_mode(void)
 		src = BOOTSOURCE_USB;
 		break;
 	case STM32MP_BOOT_FLASH_SD:
+		src = BOOTSOURCE_MMC;
+		instance = 0;
+		break;
 	case STM32MP_BOOT_FLASH_EMMC:
 		src = BOOTSOURCE_MMC;
+		instance = 1;
 		break;
 	case STM32MP_BOOT_FLASH_NAND:
 		src = BOOTSOURCE_NAND;
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 01bc7aa20a7..e86b91ccf9c 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -4723,3 +4723,6 @@ ecv4			MACH_ECV4		ECV4			4768
 webbg3flight		MACH_WEBBG3FLIGHT	WEBBG3FLIGHT		4769
 sbc_phycore_am335x	MACH_SBC_PHYCORE_AM335X	SBC_PHYCORE_AM335X	4770
 tsc			MACH_TSC		TSC			4771
+pfc_am35xx		MACH_PFC_AM35XX		PFC_AM35XX		9000
+pfc_am335x		MACH_PFC_AM335X		PFC_AM335X		9002
+vtpctp_imx6		MACH_VTPCTP_MX6		VTPCTP_MX6		9003
diff --git a/commands/Kconfig b/commands/Kconfig
index 22375360885..545fe0fabab 100644
--- a/commands/Kconfig
+++ b/commands/Kconfig
@@ -634,6 +634,14 @@ config CMD_UMOUNT
 
 	  Unmount a filesystem mounted on a specific MOINTPOINT
 
+config CMD_SFDISK
+	bool
+	prompt "sfdisk"
+	help
+	  Usage: sfdisk <script> <device>
+
+	  Format <device> as defined in <script>
+
 # end Partition commands
 endmenu
 
@@ -1859,6 +1867,13 @@ config CMD_LED
 
 	  Without arguments the available LEDs are listed.
 
+config CMD_LED_MODE
+	bool
+	depends on LED
+	prompt "led-mode command"
+	help
+	  Set LED's to mode "static" or "moving"
+
 config CMD_NAND
 	tristate
 	default y
@@ -2239,6 +2254,43 @@ config CMD_UBSAN
 	  This is a test command for the undefined behavior sanitizer.
 	  It triggers various undefined behavior, and detect it.
 
+config CMD_UART_CONSOLE
+	tristate
+	prompt "uart_console"
+	help
+	  uart_console - activate uart as console
+
+	  Usage: uart_console [-e] [NUM]
+
+	  Options:
+		  -e		enable uart<NUM> as console
+
+config CMD_ETHADDR_MATCH
+	bool
+	prompt "ethaddr_match"
+	help
+	  ethaddr_match - Match a given pattern to configured ethaddr of an
+	  ethernet interface
+
+	  Usage: ethaddr_match [-i intf] [-p pattern]
+
+	  Options:
+		  -i		network interface e.g. eth0
+		  -p		pattern to match against ethaddr
+
+config CMD_BOARD_INFO
+	bool
+	prompt "board_info"
+	help
+	  board_info - Retrieve board information from Oftree, append ID to compatible
+	  and give possibility to update ethaddr of ethernet devices.
+
+config CMD_FASTBOOT_NET
+	bool
+	prompt "fastboot_net"
+	help
+	  board_info - Enable/disable fastboot over network
+
 # end Miscellaneous commands
 endmenu
 
diff --git a/commands/Makefile b/commands/Makefile
index ba5ea19eb20..f60357ace78 100644
--- a/commands/Makefile
+++ b/commands/Makefile
@@ -132,5 +132,11 @@ obj-$(CONFIG_CMD_IP_ROUTE_GET)  += ip-route-get.o
 obj-$(CONFIG_CMD_BTHREAD)	+= bthread.o
 obj-$(CONFIG_CMD_UBSAN)		+= ubsan.o
 obj-$(CONFIG_CMD_SELFTEST)	+= selftest.o
+obj-$(CONFIG_CMD_UART_CONSOLE)	+= uart_console.o
+obj-$(CONFIG_CMD_ETHADDR_MATCH) += ethaddr_match.o
+obj-$(CONFIG_CMD_LED_MODE) 	+= led_mode.o
+obj-$(CONFIG_CMD_SFDISK)	+= sfdisk.o
+obj-$(CONFIG_CMD_BOARD_INFO)	+= board_info.o
+obj-$(CONFIG_CMD_FASTBOOT_NET)	+= fastboot_net.o
 
 UBSAN_SANITIZE_ubsan.o := y
diff --git a/commands/board_info.c b/commands/board_info.c
new file mode 100644
index 00000000000..9260745c1ef
--- /dev/null
+++ b/commands/board_info.c
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+/*
+ * Copyright (C) 2021 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ */
+
+#include "asm-generic/errno.h"
+#include "stdio.h"
+#include <asm-generic/memory_layout.h>
+#include <asm/byteorder.h>
+#include <binfmt.h>
+#include <bootm.h>
+#include <command.h>
+#include <common.h>
+#include <driver.h>
+#include <environment.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <filetype.h>
+#include <fs.h>
+#include <getopt.h>
+#include <globalvar.h>
+#include <image.h>
+#include <init.h>
+#include <magicvar.h>
+#include <malloc.h>
+#include <memory.h>
+#include <of.h>
+#include <rtc.h>
+#include <uncompress.h>
+#include <xfuncs.h>
+#include <net.h>
+#include <of_gpio.h>
+#include <gpio.h>
+
+static char *global_board_variant;
+static unsigned int global_switch_reset_gpio;
+
+enum board_info_actions {
+	MAC,
+	COMPATIBLE,
+	BOARD_VARIANT,
+	SWITCH_RESET_GPIO,
+};
+
+static int board_info_register_ethaddr(char *ethaddr, char *eth_name)
+{
+	int ret;
+	u8 addr[6];
+	struct eth_device *edev;
+
+	ret = string_to_ethaddr(ethaddr, addr);
+	if (ret)
+		goto out;
+
+	edev = eth_get_byname(eth_name);
+	if (!edev) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	eth_register_ethaddr(edev->dev.id, addr);
+	return 0;
+
+out:
+	return ret;
+}
+
+static int board_info_rewrite_compatible(char *id)
+{
+	struct device_node *root;
+	int ret;
+	char const *first_compat_str;
+	char *new_string;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string_index(root, "compatible", 0,
+							&first_compat_str);
+	if (ret < 0)
+		goto out;
+
+	new_string = basprintf("%s-%s", first_compat_str, id);
+	if (!new_string) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = of_property_write_string(root, "compatible", new_string);
+	free(new_string);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int board_info_board_variant(char *globalvar)
+{
+	int ret;
+	const char *s;
+
+	ret = of_property_read_string(of_get_root_node(), "board-variant", &s);
+	if (ret)
+		return ret;
+
+	global_board_variant = xstrdup(s);
+	return globalvar_add_simple_string(globalvar, &global_board_variant);
+}
+
+static int board_info_switch_reset_gpio(char *globalvar)
+{
+	global_switch_reset_gpio = of_get_named_gpio(of_get_root_node(),
+							"switch-reset-gpio", 0);
+	if (!gpio_is_valid(global_switch_reset_gpio))
+		global_switch_reset_gpio = -1;
+
+	return globalvar_add_simple_int(globalvar, &global_switch_reset_gpio,
+									"%d");
+}
+
+static int do_board_info(int argc, char *argv[])
+{
+	int opt, ret = -1;
+
+	if (argc < 2)
+		return COMMAND_ERROR_USAGE;
+
+	while ((opt = getopt(argc, argv, "m:r:b:s:")) > 0) {
+		switch (opt) {
+		case 'm':
+			if (optind >= argc)
+				return COMMAND_ERROR_USAGE;
+
+			ret = board_info_register_ethaddr(optarg,
+							argv[optind++]);
+			break;
+		case 'r':
+			ret = board_info_rewrite_compatible(optarg);
+			break;
+		case 'b':
+			ret = board_info_board_variant(optarg);
+			break;
+		case 's':
+			ret = board_info_switch_reset_gpio(optarg);
+			break;
+		default:
+			return COMMAND_ERROR_USAGE;
+		}
+	}
+
+	return ret;
+}
+
+BAREBOX_CMD_HELP_START(board_info)
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT("-m MAC ETH_DEVICE", "register ethaddr to given ethernet device")
+BAREBOX_CMD_HELP_OPT("-r ID\t\t", "append identifier to compatible string")
+BAREBOX_CMD_HELP_OPT("-b VAR\t\t", "get configured board variant from oftree and write it to variable VAR")
+BAREBOX_CMD_HELP_OPT("-s VAR\t\t", "get switch reset gpio number if any is configured in oftree and write it to variable VAR")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(board_info)
+	.cmd = do_board_info,
+	BAREBOX_CMD_DESC("set and get board information")
+	BAREBOX_CMD_OPTS("[-mrbs]")
+	BAREBOX_CMD_HELP(cmd_board_info_help)
+BAREBOX_CMD_END
diff --git a/commands/ethaddr_match.c b/commands/ethaddr_match.c
new file mode 100644
index 00000000000..5afbe5c78a9
--- /dev/null
+++ b/commands/ethaddr_match.c
@@ -0,0 +1,69 @@
+/*
+ * ethaddr_match.c - match a given ethaddr pattern command support
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <command.h>
+#include <getopt.h>
+#include <net.h>
+
+static int do_ethaddr_match(int argc, char *argv[])
+{
+	int opt;
+	struct eth_device *edev;
+	char *ethname = NULL, *pattern = NULL;
+	char ethaddr_str[sizeof("xx:xx:xx:xx:xx:xx")];
+
+	while ((opt = getopt(argc, argv, "i:p:")) > 0) {
+		switch (opt) {
+		case 'i':
+			ethname = optarg;
+			break;
+		case 'p':
+			pattern = optarg;
+			break;
+		}
+	}
+
+	if (!ethname || !pattern)
+		return COMMAND_ERROR_USAGE;
+
+	edev = eth_get_byname(ethname);
+	if (!edev)
+		return -ENODEV;
+
+	ethaddr_to_string(edev->ethaddr, ethaddr_str);
+	if (strstr(ethaddr_str, pattern))
+		return COMMAND_SUCCESS;
+
+	return COMMAND_ERROR;
+}
+
+BAREBOX_CMD_HELP_START(ethaddr_match)
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT("-i <intf>",           "network interface e.g. eth0\n")
+BAREBOX_CMD_HELP_OPT("-p <match_pattern>",  "pattern to match to ethaddr of"
+								" <intf>\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(ethaddr_match)
+	.cmd		= do_ethaddr_match,
+	BAREBOX_CMD_DESC("Match a given pattern to configured ethaddr of an"
+							"ethernet interface")
+	BAREBOX_CMD_OPTS("[-ip]")
+	BAREBOX_CMD_GROUP(CMD_GRP_MISC)
+	BAREBOX_CMD_HELP(cmd_ethaddr_match_help)
+BAREBOX_CMD_END
diff --git a/commands/fastboot_net.c b/commands/fastboot_net.c
new file mode 100644
index 00000000000..7bdb78ff360
--- /dev/null
+++ b/commands/fastboot_net.c
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ */
+
+#include "asm-generic/errno.h"
+#include "stdio.h"
+#include <asm-generic/memory_layout.h>
+#include <asm/byteorder.h>
+#include <binfmt.h>
+#include <bootm.h>
+#include <command.h>
+#include <common.h>
+#include <driver.h>
+#include <environment.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <filetype.h>
+#include <fs.h>
+#include <getopt.h>
+#include <image.h>
+#include <init.h>
+#include <magicvar.h>
+#include <malloc.h>
+#include <memory.h>
+#include <of.h>
+#include <rtc.h>
+#include <uncompress.h>
+#include <xfuncs.h>
+#include <fastboot.h>
+#include <fastboot_net.h>
+
+static int do_fastboot_net(int argc, char *argv[])
+{
+	struct fastboot_net *fbn;
+
+	fbn = fastboot_net_init(NULL);
+	if (IS_ERR(fbn))
+		return PTR_ERR(fbn);
+
+	return 0;
+}
+
+BAREBOX_CMD_HELP_START(fastboot_net)
+BAREBOX_CMD_HELP_TEXT("Activate fastboot over ethernet")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(fastboot_net)
+	.cmd = do_fastboot_net,
+	BAREBOX_CMD_DESC("Activate fastboot over ethernet")
+	BAREBOX_CMD_HELP(cmd_fastboot_net_help)
+BAREBOX_CMD_END
diff --git a/commands/led_mode.c b/commands/led_mode.c
new file mode 100644
index 00000000000..2b945099d76
--- /dev/null
+++ b/commands/led_mode.c
@@ -0,0 +1,177 @@
+/*
+ * led_mode.c - command to set all registered leds to a specific mode
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <led.h>
+#include <led_mode.h>
+#include <command.h>
+#include <getopt.h>
+#include <errno.h>
+
+#define OVERWRITE_LED "overwrite"
+
+enum led_mode {
+	STATIC = 0,
+	MOVING,
+	INVALID_MODE,
+};
+
+int led_mode_static(char *color, bool state)
+{
+	struct led *led;
+	int i;
+
+	if (strcmp(color, "green") && strcmp(color, "red") &&
+							strcmp(color, "yellow"))
+		return -EINVAL;
+
+	led = led_by_number(0);
+	if (!led)
+		return -ENODEV;
+
+	i = 0;
+	while ((led = led_by_number(i))) {
+		if (strcmp(led->name, OVERWRITE_LED)) {
+			if (strstr(led->name, color))
+				state ? led_set(led, led->max_value) :
+								led_set(led, 0);
+			else if (!strcmp(color, "yellow"))
+				state ? led_set(led, led->max_value) :
+								led_set(led, 0);
+		}
+		i++;
+	}
+
+	return 0;
+}
+
+int led_mode_moving(char *color, unsigned int duration_ms, bool turn_off_anc)
+{
+	struct led *led, *last_led;
+	int i;
+
+	if (strcmp(color, "green") && strcmp(color, "red"))
+		return -EINVAL;
+
+	led = led_by_number(0);
+	if (!led)
+		return -ENODEV;
+
+	/* switch all leds off */
+	led_mode_static("yellow", false);
+
+	i = 0;
+	last_led = NULL;
+	while ((led = led_by_number(i++))) {
+		if (strcmp(led->name, OVERWRITE_LED)) {
+			if (strstr(led->name, color)) {
+				if (last_led && turn_off_anc)
+					led_set(last_led, 0);
+
+				led_set(led, led->max_value);
+				last_led = led;
+				mdelay(duration_ms);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int do_led_mode(int argc, char *argv[])
+{
+	char *color = "none";
+	enum led_mode mode = INVALID_MODE;
+	bool state = false, turn_off_anc = true;
+	unsigned int duration_ms = 30;
+	int opt, ret = 0;
+
+	while ((opt = getopt(argc, argv, "smc:v::d::t")) > 0) {
+		switch (opt) {
+		case 's':
+			mode = STATIC;
+			break;
+		case 'm':
+			mode = MOVING;
+			break;
+		case 'c':
+			color = optarg;
+			break;
+		case 'v':
+			if (!strcmp(optarg, "on"))
+				state = true;
+			else
+				state = false;
+			break;
+		case 'd':
+			duration_ms = simple_strtoul(optarg, NULL, 0);
+			break;
+		case 't':
+			turn_off_anc = false;
+			break;
+
+		default:
+			ret = COMMAND_ERROR_USAGE;
+			goto out;
+		}
+	}
+
+	if (argc == 1) {
+		ret = COMMAND_ERROR_USAGE;
+		goto out;
+	}
+
+	switch (mode) {
+	case STATIC:
+		ret = led_mode_static(color, state);
+		break;
+	case MOVING:
+		ret = led_mode_moving(color, duration_ms, turn_off_anc);
+		break;
+	default:
+		ret = COMMAND_ERROR_USAGE;
+	}
+
+out:
+	return ret;
+}
+
+BAREBOX_CMD_HELP_START(led_mode)
+BAREBOX_CMD_HELP_TEXT("Set all registered leds to a specific mode. Supported ")
+BAREBOX_CMD_HELP_TEXT("modes are: static and moving. In static mode all leds ")
+BAREBOX_CMD_HELP_TEXT("are turned on/off at once.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("In moving mode all leds are flashing with a defined ")
+BAREBOX_CMD_HELP_TEXT("duration.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("LEDs are set by the order they where registered. ")
+BAREBOX_CMD_HELP_TEXT("To see the currently configured order call ")
+BAREBOX_CMD_HELP_TEXT("cmd: <led> without args.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT ("-s -c <green|red|yellow> -v <on|off>", "set all leds to static state")
+BAREBOX_CMD_HELP_OPT ("-m -c <green|red> [ -d <duration_ms> ] [ -t ]", "move the leds with optional duration time. Default 30ms. The optional option -t is used to not tur off the ancestor led")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(led_mode)
+	.cmd		= do_led_mode,
+	BAREBOX_CMD_DESC("set leds to specific mode")
+	BAREBOX_CMD_OPTS("MODE COLOR STATE|DURATION")
+	BAREBOX_CMD_GROUP(CMD_GRP_HWMANIP)
+	BAREBOX_CMD_HELP(cmd_led_mode_help)
+BAREBOX_CMD_END
diff --git a/commands/miitool.c b/commands/miitool.c
index 47494f50897..74da0dfa3b1 100644
--- a/commands/miitool.c
+++ b/commands/miitool.c
@@ -21,6 +21,7 @@
 #include <fs.h>
 #include <fcntl.h>
 #include <getopt.h>
+#include <environment.h>
 #include <linux/stat.h>
 #include <xfuncs.h>
 #include <net.h>
@@ -257,13 +258,139 @@ enum miitool_operations {
 	MIITOOL_NOOP,
 	MIITOOL_SHOW,
 	MIITOOL_REGISTER,
+	MIITOOL_MDIO_READ,
+	MIITOOL_MDIO_WRITE,
 };
 
+static int miitool_parse(const char *str, int *bus, struct mii_bus **mii,
+			 int *addr, int *reg)
+{
+	char *endp;
+
+	if (!str || !*str)
+		return COMMAND_ERROR_USAGE;
+
+	if (!bus || !mii)
+		return COMMAND_ERROR;
+
+	*bus = simple_strtoul(str, &endp, 0);
+
+	*mii = mdiobus_get_bus(*bus);
+	if (!*mii) {
+		printf("Can't find MDIO bus #%d\n", *bus);
+		return COMMAND_ERROR;
+	}
+
+	if (!addr)
+		return COMMAND_SUCCESS;
+
+	if (*endp != ':') {
+		printf("No colon between bus and address\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	endp++;
+	*addr = simple_strtoul(endp, &endp, 0);
+
+	if (*addr >= PHY_MAX_ADDR) {
+		printf("Address out of range (max %d)\n", PHY_MAX_ADDR - 1);
+		return COMMAND_ERROR_USAGE;
+	}
+
+	if (!reg)
+		return COMMAND_SUCCESS;
+
+	if (*endp != ':') {
+		printf("No colon address and register\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	endp++;
+	*reg = simple_strtoul(endp, &endp, 0);
+
+	if (*reg > U8_MAX) {
+		printf("Register number out of range (max %d)\n", U8_MAX);
+		return COMMAND_ERROR_USAGE;
+	}
+
+	return 0;
+}
+
+static int miitool_mdio_write(const char *str, const char *variable, int ext)
+{
+	int ret;
+	struct mii_bus *mii;
+	int bus, addr, reg;
+	unsigned long val;
+
+	if (!variable || !*variable)
+		return COMMAND_ERROR_USAGE;
+
+	ret = miitool_parse(str, &bus, &mii, &addr, &reg);
+	if (ret)
+		return ret;
+
+	ret = getenv_ul(variable, &val);
+	if (ret)
+		return COMMAND_ERROR_USAGE;
+
+	if (val > U16_MAX) {
+		printf("Value out auf range (max %d 0x%04X)\n", U16_MAX,
+		       U16_MAX);
+		return COMMAND_ERROR;
+	}
+
+	if (ext) {
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK);
+		mdiobus_write(mii, addr, MII_MMD_DATA, reg);
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK |
+						MII_MMD_CTRL_NOINCR);
+		ret = mdiobus_write(mii, addr, MII_MMD_DATA, val);
+	} else
+		ret = mdiobus_write(mii, addr, reg, val);
+
+	return (!ret) ? ret : COMMAND_ERROR_USAGE;
+}
+
+static int miitool_mdio_read(const char *str, const char *variable, int ext)
+{
+	int ret;
+	struct mii_bus *mii;
+	int bus, addr, reg;
+	char buf[20] = {0};
+
+	if (!variable || !*variable)
+		return COMMAND_ERROR_USAGE;
+
+	ret = miitool_parse(str, &bus, &mii, &addr, &reg);
+	if (ret)
+		return ret;
+
+	if (ext) {
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK);
+		mdiobus_write(mii, addr, MII_MMD_DATA, reg);
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK |
+							MII_MMD_CTRL_NOINCR);
+		ret = mdiobus_read(mii, addr, MII_MMD_DATA);
+	} else
+		ret = mdiobus_read(mii, addr, reg);
+
+	if (ret < 0)
+		return ret;
+
+	snprintf(buf, sizeof(buf), "%d", (u16)ret);
+
+	ret = setenv(variable, strim(buf));
+
+	return (!ret) ? ret : COMMAND_ERROR_USAGE;
+}
+
 static int do_miitool(int argc, char *argv[])
 {
 	char *phydevname = NULL;
 	char *regstr = NULL;
-	char *endp;
+	char *variable = NULL;
+	int ext = 0;
 	struct mii_bus *mii;
 	int opt, ret;
 	int verbose = 0;
@@ -271,8 +398,11 @@ static int do_miitool(int argc, char *argv[])
 	enum miitool_operations action = MIITOOL_NOOP;
 	int addr, bus;
 
-	while ((opt = getopt(argc, argv, "vs:r:")) > 0) {
+	while ((opt = getopt(argc, argv, "evs:r:w:x:p:")) > 0) {
 		switch (opt) {
+		case 'e':
+			ext = 1;
+			break;
 		case 's':
 			action = MIITOOL_SHOW;
 			phydevname = xstrdup(optarg);
@@ -284,42 +414,50 @@ static int do_miitool(int argc, char *argv[])
 		case 'v':
 			verbose++;
 			break;
+		case 'p':
+			variable = optarg;
+			break;
+		case 'w':
+			action = MIITOOL_MDIO_WRITE;
+			regstr = optarg;
+			break;
+		case 'x':
+			action = MIITOOL_MDIO_READ;
+			regstr = optarg;
+			break;
 		default:
 			ret = COMMAND_ERROR_USAGE;
-			goto free_phydevname;
+			goto out;
 		}
 	}
 
 	switch (action) {
 	case MIITOOL_REGISTER:
-		bus = simple_strtoul(regstr, &endp, 0);
-		if (*endp != ':') {
-			printf("No colon between bus and address\n");
-			return COMMAND_ERROR_USAGE;
-		}
-		endp++;
-		addr = simple_strtoul(endp, NULL, 0);
-
-		if (addr >= PHY_MAX_ADDR)
-			printf("Address out of range (max %d)\n", PHY_MAX_ADDR - 1);
-
-		mii = mdiobus_get_bus(bus);
-		if (!mii) {
-			printf("Can't find MDIO bus #%d\n", bus);
-			ret = COMMAND_ERROR;
-			goto free_phydevname;
-		}
+		ret = miitool_parse(regstr, &bus, &mii, &addr, NULL);
+		if (ret)
+			goto out;
 
 		phydev = phy_device_create(mii, addr, -1);
+
 		ret = phy_register_device(phydev);
 		if (ret) {
 			printf("failed to register phy %s: %s\n",
 				dev_name(&phydev->dev), strerror(-ret));
-			goto free_phydevname;
+			goto out;
 		} else {
 			printf("registered phy %s\n", dev_name(&phydev->dev));
 		}
 		break;
+	case MIITOOL_MDIO_WRITE:
+		ret = miitool_mdio_write(regstr, variable, ext);
+		if (ret)
+			goto out;
+		break;
+	case MIITOOL_MDIO_READ:
+		ret = miitool_mdio_read(regstr, variable, ext);
+		if (ret)
+			goto out;
+		break;
 	default:
 	case MIITOOL_SHOW:
 		for_each_mii_bus(mii) {
@@ -333,7 +471,7 @@ static int do_miitool(int argc, char *argv[])
 
 	ret = COMMAND_SUCCESS;
 
-free_phydevname:
+out:
 	free(phydevname);
 	return ret;
 }
@@ -343,17 +481,21 @@ BAREBOX_CMD_HELP_TEXT("This utility checks or sets the status of a network inter
 BAREBOX_CMD_HELP_TEXT("Media Independent Interface (MII) unit as well as allowing to")
 BAREBOX_CMD_HELP_TEXT("register dummy PHY devices for raw MDIO access. Most fast ethernet")
 BAREBOX_CMD_HELP_TEXT("adapters use an MII to autonegotiate link speed and duplex setting.")
+BAREBOX_CMD_HELP_TEXT("Furthermore it allows to acces to MDIO bus directly")
 BAREBOX_CMD_HELP_TEXT("")
 BAREBOX_CMD_HELP_TEXT("Options:")
 BAREBOX_CMD_HELP_OPT("-v", "increase verbosity")
 BAREBOX_CMD_HELP_OPT("-s <devpath/devname>", "show PHY status (not providing PHY prints status of all)")
-BAREBOX_CMD_HELP_OPT("-r <busno>:<adr>", "register a PHY")
+BAREBOX_CMD_HELP_OPT("-r <busno>:<addr>", "register a PHY")
+BAREBOX_CMD_HELP_OPT("-w <busno>:<addr>:<reg> -p variable", "read value from variable and writes it to MDIO bus")
+BAREBOX_CMD_HELP_OPT("-x <busno>:<addr>:<reg> -p variable", "read value from MDIO bus and writes it to variable")
+BAREBOX_CMD_HELP_OPT("-e", "enable (once) extended register read/write")
 BAREBOX_CMD_HELP_END
 
 BAREBOX_CMD_START(miitool)
 	.cmd		= do_miitool,
-	BAREBOX_CMD_DESC("view media-independent interface status")
-	BAREBOX_CMD_OPTS("[-vsr]")
+	BAREBOX_CMD_DESC("media-independent interface access")
+	BAREBOX_CMD_OPTS("[-evsrwxp]")
 	BAREBOX_CMD_GROUP(CMD_GRP_NET)
 	BAREBOX_CMD_HELP(cmd_miitool_help)
 BAREBOX_CMD_END
diff --git a/commands/sfdisk.c b/commands/sfdisk.c
new file mode 100644
index 00000000000..3eb87c75ef8
--- /dev/null
+++ b/commands/sfdisk.c
@@ -0,0 +1,374 @@
+/*
+ * sfdisk minimalistic implementation
+ *
+ * Copyright (C) 2019 WAGO Kontakttechnik GmbH & Co. KG
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+
+#include <common.h>
+#include <command.h>
+#include <stdlib.h>
+#include <libfile.h>
+#include <fs.h>
+
+#define PART_OFFS 446
+#define PART_LEN 16
+#define SECT_SIZE 512
+#define MBR_SIZE SECT_SIZE
+
+#define PRIMARY_PARTITIONS 4
+#define MAX_PARTITIONS 32
+
+/* Align all EBR and partitions on a 2k sector line,
+ * which is 1 MByte aligned.
+ * Except the first partition, which is 8k aligned = 4 MByte
+ */
+#define BOUNDARY 0x800
+#define FIRST_BOUNDARY 0x2000
+#define SECT_ALIGN(x) (((x)+(BOUNDARY-1)) & ~(BOUNDARY-1))
+
+#define TYPE_EXT   0x05
+#define TYPE_LINUX 0x83
+#define TYPE_SWAP  0x82
+
+struct part {
+	unsigned char act;
+	unsigned char type;
+	unsigned long start;
+	unsigned long size;
+};
+
+struct mbr {
+	unsigned long position;
+	int active;
+	struct part part[4];
+};
+
+/* This Cylinder/Heads/Sector stuff is most probably superfluous */
+#define HEADS_PER_CYL 4
+#define SECTORS_PER_TRACK 16
+
+/* https://en.wikipedia.org/wiki/Logical_block_addressing#CHS_conversion */
+static void lba2chs(unsigned int lba, unsigned char *p)
+{
+	int c, h, s;
+
+	c =  lba / (HEADS_PER_CYL * SECTORS_PER_TRACK);
+	h = (lba / SECTORS_PER_TRACK) % HEADS_PER_CYL;
+	s = (lba % SECTORS_PER_TRACK) + 1;
+
+	p[0] = h;
+	p[1] = s | ((c >> 2) & 0xc0);
+	p[2] = c & 0xff;
+}
+
+static void host2le(unsigned int n, unsigned char *p)
+{
+	int i;
+
+	for (i = 0; i < 4; i++)
+		p[i] = (n >> (8*i)) & 0xff;
+}
+
+static void serialize_partition(struct mbr *mbr, unsigned char *data, int n)
+{
+	struct part *part_n = mbr->part + n;
+	unsigned char *part = data + PART_OFFS + n * PART_LEN;
+	unsigned long chs_start = part_n->start + mbr->position;
+
+	part[0] = part_n->act;
+	lba2chs(chs_start, part + 1);
+
+	part[4] = part_n->type;
+	lba2chs(chs_start + part_n->size - 1, part + 5);
+
+	host2le(part_n->start, part + 8);
+	host2le(part_n->size, part + 12);
+}
+
+static int write_mbr(struct cdev *cdev, struct mbr *mbr)
+{
+	int i;
+	unsigned char data[MBR_SIZE];
+
+	memset(data, 0, sizeof(data));
+	data[MBR_SIZE-1] = 0xaa;
+	data[MBR_SIZE-2] = 0x55;
+
+	srand(get_time_ns());
+	get_random_bytes(data + (PART_OFFS - 6), 6);
+
+	for (i = 0; i < 4; i++) {
+		if (mbr->part[i].size > 0)
+			serialize_partition(mbr, data, i);
+	}
+	return cdev_write(cdev, data, sizeof(data), mbr->position*SECT_SIZE, 0);
+}
+
+static int write_partitions(const char *device, struct mbr *mbr, int n_mbr)
+{
+	int i, ret = COMMAND_SUCCESS;
+	struct cdev *cdev;
+
+	cdev = cdev_open(device, O_RDWR);
+	if (!cdev) {
+		perror(device);
+		return COMMAND_ERROR;
+	}
+	for (i = 0; i < n_mbr; i++) {
+		if (!mbr[i].active)
+			continue;
+		if (write_mbr(cdev, mbr + i) == -1) {
+			perror("Write MBR");
+			ret = COMMAND_ERROR;
+			break;
+		}
+	}
+	cdev_close(cdev);
+	return ret;
+}
+
+unsigned long no_sectors;
+static void get_device_sectors(const char *device)
+{
+	struct cdev *cdev = cdev_open(device, O_RDWR);
+
+	if (cdev) {
+		no_sectors = cdev->size / SECT_SIZE;
+		cdev_close(cdev);
+	}
+}
+
+static int init_part(struct part *part, int act, int type,
+			unsigned long start, unsigned long size)
+{
+	part->start = SECT_ALIGN(start);
+
+	if (!size)
+		size = no_sectors - part->start;
+
+	part->size  = SECT_ALIGN(size);
+
+	part->act = act ? 0x80 : 0x00;
+	part->type = type;
+
+	return part->start + part->size;
+}
+
+static int add_extended(struct mbr *mbr, struct part *prev, int type,
+			unsigned long start, unsigned long size)
+{
+	unsigned long part_start = BOUNDARY;
+
+	if (!prev)
+		part_start = FIRST_BOUNDARY;
+
+	if (!size)
+		size = no_sectors - start;
+
+	mbr->position = start - part_start;
+	mbr->active = 1;
+	init_part(mbr->part, 0, type, part_start, size);
+
+	if (prev) {
+		prev->type = TYPE_EXT;
+		prev->start = mbr->position;
+		prev->size = mbr->part[0].start + mbr->part[0].size;
+	}
+
+	return mbr->position + mbr->part[0].start + mbr->part[0].size;
+}
+
+static unsigned long char2num(const char *val)
+{
+	char *end;
+	unsigned long v;
+
+	if (!val || !*val)
+		return 0;
+
+	v = simple_strtoul(val, &end, 10);
+	if (!v || !end || !*end)
+		return v;
+
+	switch (*end) {
+	case 'm':
+	case 'M':
+		v *= 1024; /* FALL */
+	case 'k':
+	case 'K':
+		v = v * (1024 / SECT_SIZE);
+	}
+	return v;
+}
+
+/* Parse partition configuration line in sfdisk format */
+#define DELIM ",;\n "
+static unsigned char parse_part_line(char *line, unsigned long *start,
+					unsigned long *size, int *act)
+{
+	char id = TYPE_LINUX, *val;
+
+	*act = 0;
+	*start = char2num(strsep(&line, DELIM));
+	*size = char2num(strsep(&line, DELIM));
+	val = strsep(&line, DELIM);
+
+	if (!val || !*val)
+		return id;
+
+	switch (*val) {
+	case 'X':
+	case 'E':
+		id = TYPE_EXT;
+		break;
+	case 'S':
+		id = TYPE_SWAP;
+		break;
+	case 'L':
+		id = TYPE_LINUX;
+		break;
+	default:
+		id = simple_strtoul(val, NULL, 16);
+	}
+	val = strsep(&line, DELIM);
+	if (!val)
+		return id;
+	*act = *val == '*' || *val == '_' ? 1 : 0;
+	return id;
+}
+
+static int do_sfdisk(int argc, char *argv[])
+{
+	/* Next sector for primary partition */
+	unsigned long pnext = FIRST_BOUNDARY;
+	/* Next relative sector for logic partition */
+	unsigned long lnext = 0;
+	/* Current primary and extended MBR index */
+	int prim = 0, ext = 0;
+	/* Previous EBR of the logic partition chain */
+	struct part *prev = NULL;
+	struct mbr mbr[MAX_PARTITIONS] = { { .active = 1 }, };
+	char *line, *device, *next;
+	void *buf;
+	size_t buflen;
+	int ret;
+
+	if (argc < 3)
+		return COMMAND_ERROR_USAGE;
+
+	ret = read_file_2(argv[1], &buflen, &buf, FILESIZE_MAX);
+	if (!buf || ret)
+		return COMMAND_ERROR_USAGE;
+
+	next = buf;
+	while (buflen > 0 && next[buflen-1] == '\n')
+		next[--buflen] = 0;
+
+	device = argv[2];
+	get_device_sectors(device);
+
+	for (line = buf; line; line = next) {
+		int act;
+		unsigned long start, size;
+		unsigned char type;
+
+		next = strchr(line, '\n');
+		if (next)
+			*next++ = 0;
+
+		type = parse_part_line(line, &start, &size, &act);
+		if (!ext) {
+			if (start)
+				pnext = start;
+			init_part(mbr->part + prim, act, type, pnext, size);
+			pnext = mbr->part[prim].start + mbr->part[prim].size;
+			if (type == TYPE_EXT) {
+				ext = PRIMARY_PARTITIONS;
+				lnext = mbr->part[prim].start + FIRST_BOUNDARY;
+				no_sectors = pnext;
+			}
+			if (prim++ >= PRIMARY_PARTITIONS) {
+				pr_err("Too much primary partitions\n");
+				free(buf);
+				return COMMAND_ERROR;
+			}
+		} else {
+			if (start)
+				lnext = start;
+			lnext = add_extended(mbr + ext, prev, type, lnext,
+						size) + BOUNDARY;
+			prev = mbr[ext].part + 1;
+			if (ext++ >= MAX_PARTITIONS) {
+				pr_err("Too much extended partitions\n");
+				free(buf);
+				return COMMAND_ERROR;
+			}
+		}
+	}
+	if (ext > 4) {
+		for (prim = 0; prim < PRIMARY_PARTITIONS; prim++) {
+			if (mbr->part[prim].type != TYPE_EXT)
+				continue;
+			pnext = mbr->part[prim].start;
+
+			while (ext-- > PRIMARY_PARTITIONS)
+				mbr[ext].part[1].start -= pnext;
+
+			if (!mbr->part[prim].size)
+				mbr->part[prim].size = lnext - pnext - BOUNDARY;
+			break;
+		}
+		if (prim >= PRIMARY_PARTITIONS) {
+			pr_err("No primary partition with type 'Extended'.\n");
+			free(buf);
+			return COMMAND_ERROR;
+		}
+
+	}
+	free(buf);
+
+	return write_partitions(device, mbr, MAX_PARTITIONS);
+}
+
+BAREBOX_CMD_HELP_START(sfdisk)
+BAREBOX_CMD_HELP_TEXT("Creates partitions on <device> described by")
+BAREBOX_CMD_HELP_TEXT("the sfdisk formatted <script file>.")
+BAREBOX_CMD_HELP_TEXT("The default for <device> is '/dev/mmc1'.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("Example script file entrys:")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("with sector defines:")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("8192,32768,b,*")
+BAREBOX_CMD_HELP_TEXT("40960,7593984,E")
+BAREBOX_CMD_HELP_TEXT("49152,14336")
+BAREBOX_CMD_HELP_TEXT("65536,14336")
+BAREBOX_CMD_HELP_TEXT("81920,620544")
+BAREBOX_CMD_HELP_TEXT("704512,3143680")
+BAREBOX_CMD_HELP_TEXT("3850240,3143680")
+BAREBOX_CMD_HELP_TEXT("6995968,620544,L")
+BAREBOX_CMD_HELP_TEXT("7618560,16384")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("with dynamic sized values:")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT(",16M,b,*")
+BAREBOX_CMD_HELP_TEXT(",,E")
+BAREBOX_CMD_HELP_TEXT(",7M,L")
+BAREBOX_CMD_HELP_TEXT(",7M,L")
+BAREBOX_CMD_HELP_TEXT(",303M,L")
+BAREBOX_CMD_HELP_TEXT(",1535M,L")
+BAREBOX_CMD_HELP_TEXT(",1535M,L")
+BAREBOX_CMD_HELP_TEXT(",303M,L")
+BAREBOX_CMD_HELP_TEXT(",,L")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(sfdisk)
+	.cmd = do_sfdisk,
+	BAREBOX_CMD_DESC("Create MBR formatted partition table")
+	BAREBOX_CMD_OPTS("<script file> <device>")
+	BAREBOX_CMD_GROUP(CMD_GRP_PART)
+	BAREBOX_CMD_HELP(cmd_sfdisk_help)
+BAREBOX_CMD_END
+
diff --git a/commands/uart_console.c b/commands/uart_console.c
new file mode 100644
index 00000000000..ea752866316
--- /dev/null
+++ b/commands/uart_console.c
@@ -0,0 +1,63 @@
+/*
+ * uart_console.c - command to activate a dedicated uart
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <of.h>
+#include <of_address.h>
+#include <command.h>
+#include <getopt.h>
+#include <console.h>
+
+static int do_uart_console(int argc, char *argv[])
+{
+	struct device_node *uart_node;
+	int uart_num = -1, opt;
+	char *alias_name;
+
+	while ((opt = getopt(argc, argv, "e:")) > 0) {
+		switch (opt) {
+		case 'e':
+			uart_num = simple_strtoul(optarg, NULL, 0);
+			break;
+		}
+	}
+
+	alias_name = basprintf("serial%d", uart_num);
+
+	uart_node = of_find_node_by_alias(of_get_root_node(), alias_name);
+	if (!uart_node)
+		return -ENODEV;
+
+	if (!of_device_enable_and_register(uart_node))
+		return -ENODEV;
+
+	return 0;
+}
+
+BAREBOX_CMD_HELP_START(uart_console)
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT("-e <NUM>", "enable uart<NUM> as console\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(uart_console)
+	.cmd		= do_uart_console,
+	BAREBOX_CMD_DESC("activate uart as console")
+	BAREBOX_CMD_OPTS("[-e]")
+	BAREBOX_CMD_GROUP(CMD_GRP_MISC)
+	BAREBOX_CMD_HELP(cmd_uart_console_help)
+BAREBOX_CMD_END
diff --git a/common/blspec.c b/common/blspec.c
index 158fd1e9a28..b84c03cd70d 100644
--- a/common/blspec.c
+++ b/common/blspec.c
@@ -21,6 +21,7 @@
 #include <linux/stat.h>
 #include <linux/err.h>
 #include <mtd/ubi-user.h>
+#include <libgen.h>
 
 /*
  * blspec_entry_var_set - set a variable to a value
@@ -513,16 +514,98 @@ static bool entry_is_match_machine_id(struct blspec_entry *entry)
 	return ret;
 }
 
+/*
+ * blspec_check_conf_file - check if config file is valid
+ *
+ * return 0 if config file not valid != 0 otherwise
+ */
+static int blspec_check_conf_file(struct bootentries *bootentries,
+				   char *configname)
+{
+	int ret = 0;
+	char *dot;
+	struct stat s;
+
+	pr_debug("%s: %s\n", __func__, configname);
+
+	dot = strrchr(configname, '.');
+	if (!dot)
+		goto out;
+
+	if (strcmp(dot, ".conf"))
+		goto out;
+
+	if (stat(configname, &s))
+		goto out;
+
+	if (!S_ISREG(s.st_mode))
+		goto out;
+
+	return !blspec_have_entry(bootentries, configname);
+out:
+	return ret;
+}
+
+/*
+ * blspec_get_entry - create and set content of blspec entry
+ *
+ * return NULL if error occur else valid blspech entry
+ */
+static struct blspec_entry *blspec_get_entry(struct bootentries *bootentries,
+					     char *configname, const char* root)
+{
+	struct blspec_entry *entry = NULL;
+	char *devname = NULL, *hwdevname = NULL;
+
+	entry = blspec_entry_open(bootentries, configname);
+	if (IS_ERR(entry))
+		goto out;
+
+	entry->rootpath = xstrdup(root);
+	entry->configpath = xstrdup(configname);
+	entry->cdev = get_cdev_by_mountpath(root);
+
+	if (!entry_is_of_compatible(entry))
+		goto err_out;
+
+	if (!entry_is_match_machine_id(entry))
+		goto err_out;
+
+	if (entry->cdev && entry->cdev->dev) {
+		devname = xstrdup(dev_name(entry->cdev->dev));
+		if (entry->cdev->dev->parent)
+			hwdevname = xstrdup(dev_name(entry->cdev->dev->parent));
+	}
+
+	entry->entry.title = xasprintf("%s (%s)", blspec_entry_var_get(entry, "title"),
+				       configname);
+	entry->entry.description = basprintf("blspec entry, device: %s hwdevice: %s",
+					    devname ? devname : "none",
+					    hwdevname ? hwdevname : "none");
+	free(devname);
+	free(hwdevname);
+
+	entry->entry.me.type = MENU_ENTRY_NORMAL;
+	entry->entry.release = blspec_entry_free;
+
+	return entry;
+
+err_out:
+	blspec_entry_free(&entry->entry);
+out:
+	return NULL;
+}
+
 /*
  * blspec_scan_directory - scan over a directory
  *
- * Given a root path collects all bootentries entries found under /bootentries/entries/.
+ * Given a root path collects all bootentries entries found under
+ * /loader/entries/.
  *
  * returns the number of entries found or a negative error value otherwise.
  */
 int blspec_scan_directory(struct bootentries *bootentries, const char *root)
 {
-	struct blspec_entry *entry;
 	DIR *dir;
 	struct dirent *d;
 	char *abspath;
@@ -546,93 +629,93 @@ int blspec_scan_directory(struct bootentries *bootentries, const char *root)
 	}
 
 	while ((d = readdir(dir))) {
+		struct blspec_entry *entry;
 		char *configname;
-		struct stat s;
-		char *dot;
-		char *devname = NULL, *hwdevname = NULL;
 
 		if (*d->d_name == '.')
 			continue;
 
 		configname = basprintf("%s/%s", abspath, d->d_name);
 
-		dot = strrchr(configname, '.');
-		if (!dot) {
+		ret = blspec_check_conf_file(bootentries, configname);
+		if (!ret) {
 			free(configname);
 			continue;
 		}
 
-		if (strcmp(dot, ".conf")) {
-			free(configname);
-			continue;
+		entry = blspec_get_entry(bootentries, configname, root);
+		if (entry) {
+			++found;
+			bootentries_add_entry(bootentries, &entry->entry);
 		}
+	}
 
-		ret = stat(configname, &s);
-		if (ret) {
-			free(configname);
-			continue;
-		}
+	ret = found;
 
-		if (!S_ISREG(s.st_mode)) {
-			free(configname);
-			continue;
-		}
+	closedir(dir);
+err_out:
+	if (!IS_ERR(nfspath))
+		free(nfspath);
+	free(abspath);
 
-		if (blspec_have_entry(bootentries, configname)) {
-			free(configname);
-			continue;
-		}
+	return ret;
+}
 
-		entry = blspec_entry_open(bootentries, configname);
-		if (IS_ERR(entry)) {
-			free(configname);
-			continue;
-		}
+/*
+ * blspec_scan_file - scan a certainly blspec config file
+ *
+ * returns the 1 if valid entrie found, 0 or a negative error value otherwise.
+ */
+int blspec_scan_file(struct bootentries *bootentries, const char *file)
+{
+	int ret = 0;
+	struct blspec_entry *entry;
+	char *abspath, *root = NULL;
+	char *sep, *confdir;
+	const char *dirname = "loader/entries";
 
-		entry->rootpath = xstrdup(root);
-		entry->configpath = configname;
-		entry->cdev = get_cdev_by_mountpath(root);
+	if (strncmp(file, "file://", 7)) {
+		ret = -EINVAL;
+		goto out;
+	}
 
-		if (!entry_is_of_compatible(entry)) {
-			blspec_entry_free(&entry->entry);
-			continue;
-		}
+	file += 7;
 
-		if (!entry_is_match_machine_id(entry)) {
-			blspec_entry_free(&entry->entry);
-			continue;
-		}
+	abspath = xstrdup(file);
 
-		found++;
+	ret = blspec_check_conf_file(bootentries, abspath);
+	if (!ret) {
+		ret = -EINVAL;
+		goto out_free;
+	}
 
-		if (entry->cdev && entry->cdev->dev) {
-			devname = xstrdup(dev_name(entry->cdev->dev));
-			if (entry->cdev->dev->parent)
-				hwdevname = xstrdup(dev_name(entry->cdev->dev->parent));
-		}
+	root = xstrdup(abspath);
 
-		entry->entry.title = xasprintf("%s (%s)", blspec_entry_var_get(entry, "title"),
-					       configname);
-		entry->entry.description = basprintf("blspec entry, device: %s hwdevice: %s",
-						    devname ? devname : "none",
-						    hwdevname ? hwdevname : "none");
-		free(devname);
-		free(hwdevname);
+	sep = strrchr(root, '/');
+	if (!sep) {
+		ret = -EINVAL;
+		goto out_free;
+	}
 
-		entry->entry.me.type = MENU_ENTRY_NORMAL;
-		entry->entry.release = blspec_entry_free;
+	*sep = 0;
+	confdir = sep - strlen(dirname);
 
-		bootentries_add_entry(bootentries, &entry->entry);
+	if (strncmp(confdir, dirname, strlen(dirname))) {
+		ret = -EINVAL;
+		goto out_free;
 	}
 
-	ret = found;
+	entry = blspec_get_entry(bootentries, abspath, root);
+	if (!entry)
+		goto out_free;
 
-	closedir(dir);
-err_out:
-	if (!IS_ERR(nfspath))
-		free(nfspath);
-	free(abspath);
+	bootentries_add_entry(bootentries, &entry->entry);
+	ret = 1;
 
+out_free:
+	free(root);
+	free(abspath);
+out:
 	return ret;
 }
 
@@ -851,6 +934,12 @@ static int blspec_bootentry_provider(struct bootentries *bootentries,
 			found += ret;
 	}
 
+	if (!strncmp(name, "file://", 7)) {
+		ret = blspec_scan_file(bootentries, name);
+		if (ret > 0)
+			found += ret;
+	}
+
 	return found;
 }
 
diff --git a/common/startup.c b/common/startup.c
index 871696968a1..5c668bd4598 100644
--- a/common/startup.c
+++ b/common/startup.c
@@ -278,6 +278,8 @@ enum autoboot_state do_autoboot_countdown(void)
 	else
 		autoboot_state = AUTOBOOT_ABORT;
 
+	set_autoboot_state(autoboot_state);
+
 	return autoboot_state;
 }
 
@@ -367,6 +369,29 @@ static int run_init(void)
 
 	console_ctrlc_allow();
 
+	/* Run scripts in /env/init_post_autoboot/ */
+	ret = glob("/env/init_post_autoboot/*", 0, NULL, &g);
+	if (!ret) {
+		for (i = 0; i < g.gl_pathc; i++) {
+			const char *path = g.gl_pathv[i];
+			char *scr;
+
+			ret = stat(path, &s);
+			if (ret)
+				continue;
+
+			if (!S_ISREG(s.st_mode))
+				continue;
+
+			pr_debug("Executing '%s'...\n", path);
+			scr = basprintf("source %s", path);
+			run_command(scr);
+			free(scr);
+		}
+
+		globfree(&g);
+	}
+
 	if (autoboot == AUTOBOOT_BOOT)
 		run_command("boot");
 
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart b/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart
new file mode 100644
index 00000000000..bb9b1881635
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart
@@ -0,0 +1,22 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+if [ "${global.pfc.debug_mode_active}" = "true" ]; then
+	echo -e ${warning} "uart debug mode active"
+	global.autoboot_timeout=3
+
+	# one some devices the debug uart interface is only
+	# available through the jtag interface. This is not
+	# always wired to the mainboard (e.g. PAC-Devices).
+	uart_console -e ${global.pfc.barebox_uart}
+
+	# on devices with usb interface enable the usb gadget, too.
+	usbgadget ${global.pfc.usbgadget_options}
+
+	# reduize max retries, enable ethernet and activate fastboot
+	# over ethernet.
+	global.dhcp.retries=2
+	ifup $global.pfc.eth
+	[ $? = 0 ] && fastboot_net
+fi
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot
new file mode 100644
index 00000000000..4f52f0aebb9
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# first switch of any previously activated leds
+led_mode -s -c yellow -v off
+led_mode -s -c red -v on
+
+global.pfc.boot_mode="broken"
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=abort
+uart_console -e ${global.pfc.barebox_uart}
+
+echo -e ${error} "$0: setting boot_mode to: ${global.pfc.boot_mode}"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot
new file mode 100644
index 00000000000..ee142a32fc9
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+led_mode -s -c yellow -v on
+
+global.autoboot_timeout=0
+global.boot.watchdog_timeout=${global.pfc.watchdog_timeout_linux_load}
+global.linux.bootargs.base="bootversion=${global.version} reset_state=${global.system.reset}"
+global.boot.default="bootchooser"
+
+sd_blspec="${global.pfc.sd_rootfs}/boot/sd/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+sd_legacy_uImage="${global.pfc.sd_boot}/uImage"
+
+emmc_blspec_rootfs0="${global.pfc.emmc_rootfs0}/boot/emmc0/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+emmc_blspec_rootfs1="${global.pfc.emmc_rootfs1}/boot/emmc1/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+
+nand_blspec_rootfs0="${global.pfc.nand_rootfs0}/boot/nand0/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+nand_blspec_rootfs1="${global.pfc.nand_rootfs1}/boot/nand1/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+
+if [ -e "${global.pfc.emmc}" ]; then
+	global.bootchooser.rootfs.1.boot="file://${emmc_blspec_rootfs0}"
+	global.bootchooser.rootfs.2.boot="file://${emmc_blspec_rootfs1}"
+
+elif [ -e "${global.pfc.nand}" ]; then
+	global.bootchooser.rootfs.1.boot="file://${nand_blspec_rootfs0}"
+	global.bootchooser.rootfs.2.boot="file://${nand_blspec_rootfs1}"
+else
+	# remove bootchooser from default boot source
+	global.boot.default=""
+	echo -e ${warning} "$0: no valid boot device found for bootchooser"
+fi
+
+if [ "${global.pfc.disable_sd_boot}" = 0 ]; then
+	if [ -e "${global.pfc.sd}" ] && [ -e "${sd_blspec}" ]; then
+		global.boot.default="file://${sd_blspec} bootchooser"
+
+	elif [ -e "${global.pfc.sd}" ] && [ -e "${sd_legacy_uImage}" ]; then
+		# disable watchdog in case of an legacy boot, because we dont know if the
+		# watchdog is disabled per default in legacy kernel.
+		global.boot.watchdog_timeout=0
+
+		global.bootm.boot_atag=true
+		global.boot.default="sd-legacy bootchooser"
+	fi
+fi
+
+if [ "${global.pfc.dhcpboot}" = 1 ]; then
+	global.boot.default="dhcp-boot $global.boot.default"
+fi
+
+if [ -z "${global.boot.default}" ]; then
+	echo -e ${error} "$0: no valid boot device available"
+	exit 1
+fi
+
+pfc-check-for-debug-uart
+pfc-set-linux-console
+
+echo -e ${info} "default boot order is: $global.boot.default"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot
new file mode 100644
index 00000000000..3ebde65812f
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+global.linux.bootargs.productionmode="production_mode=1"
+global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+global.linux.bootargs.watchdog=""
+global.boot.watchdog_timeout=0
+
+led_mode -m -c green
+pfc-config-setupfw-generic-boot
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot
new file mode 100644
index 00000000000..09d872be4ea
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+global.linux.bootargs.productionmode="production_mode=2"
+global.linux.bootargs.console="console="
+
+led_mode -m -c red
+pfc-config-setupfw-generic-boot
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot
new file mode 100644
index 00000000000..2be71c643ca
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+global.autoboot_timeout=3
+global.linux.bootargs.base="root=/dev/ram0 rdinit=/init.sh quiet macaddr=${eth0.ethaddr}"
+
+if [ -e "${global.pfc.sd}" ] &&
+   [ -e "${global.pfc.sd_boot}/setupfw" ] &&
+   [ -e "${global.pfc.sd_boot}/oftree-${global.board.variant}-setupfw.dtb" ] ; then
+	global.boot.default="sd-setupfw net-setupfw"
+
+else
+	global.boot.default="net-setupfw"
+fi
+
+echo -e ${info} "default boot order is: $global.boot.default"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode b/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode
new file mode 100644
index 00000000000..bb26941c53e
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+mode="unknown"
+let debug_mask="(1<<0)"
+
+while getopt "edh" opt; do
+	if [ ${opt} = e ]; then
+                mode="enable"
+	elif [ ${opt} = d ]; then
+                mode="disable"
+	elif [ ${opt} = h ]; then
+		mode="unknown"
+	fi
+done
+
+if [ "${mode}" = "unknown" ]; then
+	echo "usage: $0 [-ed]"
+	echo ""
+	echo "control debug uart mode. Mode is set persistent through eeprom bit "develop-mode-enable" in eeprom"
+	echo ""
+	echo "-e enable debug uart mode\n"
+	echo "-d disable debug uart mode\n"
+	echo ""
+	exit 1
+fi
+
+if [ "${mode}" = "enable" ]; then
+	let debug_enable="0x${global.pfc.boot_mode_id} | 0x${debug_mask}"
+else
+	let debug_enable="0x${global.pfc.boot_mode_id} & ~0x${debug_mask}"
+fi
+
+# write persistent to eeprom
+xsection.boot_mode_id=${debug_enable}
+
+# also update global variable
+global.pfc.boot_mode_id=${xsection.boot_mode_id}
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode b/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode
new file mode 100644
index 00000000000..ec2a4f5c8cd
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode
@@ -0,0 +1,50 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let setup_fw_mask="(1 << 5)"
+let setup_fw_enable="0x${global.pfc.boot_mode_id} & ${setup_fw_mask}"
+let setup_fw_disable="0x${global.pfc.boot_mode_id} & ~${setup_fw_mask}"
+
+let disable_sd_boot_mask="(1 << 0)"
+let disable_sd_boot="0x${global.pfc.boot_mode_id_ext} & ${disable_sd_boot_mask}"
+
+let dhcpboot_mask="(1 << 1)"
+let dhcpboot="0x${global.pfc.boot_mode_id_ext} & ${dhcpboot_mask}"
+
+pfc-validate-ethaddr
+
+if [ "${dhcpboot}" = "${dhcpboot_mask}" ]; then
+	global.pfc.dhcpboot=1
+	echo -e ${warning} "dhcpboot enabled."
+fi
+
+if [ "${disable_sd_boot}" = "${disable_sd_boot_mask}" ]; then
+	global.pfc.disable_sd_boot=1
+	echo -e ${warning} "booting from sd disabled"
+fi
+
+if [ "${global.pfc.ethaddr_is_valid}" = false ]; then
+        global.pfc.boot_mode="production"
+
+elif [ -e "${global.pfc.sd}" ] && [ "${global.pfc.disable_sd_boot}" = 0 ]; then
+
+	# if a downgrade.bin.<platform-suffix> file is found on the first
+	# sd/mmc boot partition, we execute it.
+	# if downgrading will be executed successfully,
+	# we never come back here.
+	if [ -e "${global.pfc.downgrade_img}" ]; then
+        	global.pfc.boot_mode="downgrade"
+
+	# if a custom setup script is in located in the
+	# first sd/mmc card partition (fat), execute it.
+	elif [ -e "${global.pfc.custom_sh}" ]; then
+        	global.pfc.boot_mode="custom"
+	fi
+
+elif [ "${setup_fw_enable}" = "${setup_fw_mask}" ]; then
+        global.pfc.boot_mode="setupfw"
+	xsection.boot_mode_id="${setup_fw_disable}"
+fi
+
+echo -e ${info} "detected boot_mode: ${global.pfc.boot_mode}"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata b/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata
new file mode 100644
index 00000000000..fcb2c80bc7b
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+source /env/data/print-msg-formats
+
+# on am35xx based targets we need to set the ecc-mode
+nand_bch8="/env/data/nand-ecc-bch8"
+
+ubi_image="$1"
+
+if [ -z ${ubi_image} ] || [ ! -e "${ubi_image}" ]; then
+	echo -e ${error} "$0: no ubi-image to flash given"
+	exit 1
+fi
+
+# detach ubi device if attached
+[ -e "${global.pfc.nand_ubidata}.ubi" ] && ubidetach ${global.pfc.nand_ubidata}
+
+erase ${global.pfc.nand_ubidata}
+
+# here we also need to set the ecc-mode on
+# am335x based targets.
+if [ -e "${nand_bch8}" ]; then
+	${nand_bch8}
+fi
+
+ubiformat -q ${global.pfc.nand_ubidata} -y -e 0 -f ${ubi_image}
+if [ $? -ne 0 ]; then
+        echo -e ${error} "$0: error due flashing ${ubi_image} on ${global.pfc.nand_ubidata}"
+        exit 1
+fi
+
+exit 0
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot
new file mode 100644
index 00000000000..6e1e87c309d
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+led_mode -m -c green
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=abort
+uart_console -e ${global.pfc.barebox_uart}
+
+echo -e ${info} "execute custom script: ${global.pfc.custom_sh}"
+
+${global.pfc.custom_sh}
+exit $?
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot
new file mode 100644
index 00000000000..329ed8bad56
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot
@@ -0,0 +1,193 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=abort
+
+downgrade_lzo="downgrade.bin.${global.board.variant}"
+downgrade_script="downgrade"
+
+###############################
+##### legacy parts ############
+###############################
+
+mtd_linux1="mtd0_raw_linux1"
+mtd_linux2="mtd0_raw_linux2"
+mtd_data="mtd2_fs_data"
+mtd_xload="mtd3_raw_xload"
+mtd_barebox="mtd4_raw_barebox"
+mtd_barebox_env="mtd5_raw_barebox-env"
+mtd_product="mtd6_raw_product"
+mtd_recovery="mtd7_raw_recovery"
+mtd_parts="${mtd_linux1} ${mtd_linux2} ${mtd_data} ${mtd_xload} ${mtd_barebox} ${mtd_barebox_env} ${mtd_product} ${mtd_recovery}"
+
+recovery_parts="512k@0k(${mtd_xload}),1024k@512k(${mtd_barebox}),256k@1536k(${mtd_barebox_env}),256k@1792k(${mtd_product}),40192k@2048k(${mtd_recovery}),4096k@42240k(${mtd_linux1}),4096k@46336k(${mtd_linux2}),-@50432k(${mtd_data})"
+
+mlo="downgrade.mlo--nand"
+barebox="downgrade.barebox.img"
+recovery="recovery"
+
+###############################
+
+nand_hamming="/env/data/nand-ecc-hamming"
+nand_bch8_legacy="/env/data/nand-ecc-bch8-legacy"
+
+led_mode -m -c red -t
+
+echo -e ${info} "starting firmware downgrade..."
+echo -e ${info} "checking the environment..."
+
+# check if mount point is at correct location
+if [ ! -e "${global.pfc.sd_boot}" ]; then
+
+	echo -e ${error} "mount point ${global.pfc.sd_boot} not available"
+	exit 1
+
+fi
+
+# check if all recovery files are available
+if [ ! -e "${global.pfc.sd_boot}/${mlo}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${mlo} not available"
+	exit 1
+
+fi
+
+if [ ! -e "${global.pfc.sd_boot}/${barebox}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${barebox} not available"
+	exit 1
+
+fi
+
+if [ ! -e "${global.pfc.sd_boot}/${recovery}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${recovery} not available"
+	exit 1
+
+fi
+
+# reset bootloader index in eeprom
+echo -e ${info} "restore bootloader index..."
+xsection.blidx=0
+
+echo -e ${info} "restore recovery partitions..."
+
+# delete current mlo partitions
+for partition in ${global.pfc.nand_mlo_parts}; do
+	nand -d ${partition}.bb
+	delpart ${partition}
+done
+
+# delete current boot partitions
+for partition in ${global.pfc.nand_boot_parts}; do
+	nand -d ${partition}.bb
+	delpart ${partition}
+done
+
+# delete current data partition
+nand -d ${global.pfc.nand_ubidata}.bb
+delpart ${global.pfc.nand_ubidata}
+
+# restore recovery partitions
+mtdparts-add -b -d nand0 -p ${recovery_parts}
+
+# do additional check for created recovery partitions
+for partition in ${mtd_parts}; do
+	if [ ! -e "${global.pfc.nand}.${partition}" ]; then
+		echo -e ${error} "recovery-partition ${global.pfc.nand}.${partition} not available"
+		exit 1
+	fi
+
+	if [ ! -e "${global.pfc.nand}.${partition}.bb" ]; then
+		echo -e ${error} "recovery-partition ${global.pfc.nand}.${partition}.bb not available"
+		exit 1
+	fi
+done
+
+# check if all nand ecc-modes are available
+[ ! -e "${nand_hamming}" ] && echo -e ${error} "ecc-mode ${nand_hamming} not available" && exit 1
+[ ! -e "${nand_bch8_legacy}" ] && echo -e ${error} "ecc-mode ${nand_bch8_legacy} not available" && exit 1
+
+echo ""
+echo -e ${warning} "####################################################################"
+echo -e ${warning} "ATTENTION: DO NOT SWITCH OFF THE DEVICE DURING ERASE AND FLASH STEPS"
+echo -e ${warning} "####################################################################"
+echo ""
+echo -e -n ${warning} "PRESS ANY KEY TO ABORT ERASE AND FLASH STEPS: "
+
+timeout -a 3
+res=$?
+if [ ${res} -eq 1 ]; then
+
+	echo -e ${warning} "ABORTED BY USER...BOOT TO SHELL"
+	exit 1
+
+fi
+
+echo -e ${warning} "erase bootloader partitions..."
+
+# erase all bootloader partitions
+erase ${global.pfc.nand}.${mtd_xload}
+erase ${global.pfc.nand}.${mtd_barebox}.bb
+
+echo -e ${warning} "flash mlo and barebox..."
+
+# flash mlo
+${nand_hamming}
+#    -- first  128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x0
+#    -- second 128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x20000
+#    -- third  128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x40000
+#    -- fourth 128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x60000
+
+
+# flash barebox
+${nand_bch8_legacy}
+memcpy -s ${global.pfc.sd_boot}/${barebox} -d ${global.pfc.nand}.${mtd_barebox}.bb 0x0 0x0
+
+echo -e ${warning} "flash recovery image..."
+erase ${global.pfc.nand}.${mtd_recovery}.bb 0x0
+memcpy -s ${global.pfc.sd_boot}/${recovery} -d ${global.pfc.nand}.${mtd_recovery}.bb 0x0 0x0
+
+echo -e ${warning} "done..."
+echo ""
+echo -e ${warning} "############################################################"
+echo -e ${warning} "ATTENTION: DO NOT SWITCH OFF THE DEVICE DURING FACTORY RESET"
+echo -e ${warning} "############################################################"
+echo ""
+
+
+# setup bootargs
+echo -e ${info} "setup bootargs"
+
+global linux.bootargs.dyn.root="root=/dev/ram0 rdinit=/init.sh"
+global linux.bootargs.dyn.ip=""
+global linux.bootargs.dyn.macaddr=""
+global linux.bootargs.bootmode="pac_boot_id=0x1"
+global linux.bootargs.productionmode="production_mode=2"
+global linux.bootargs.devconf="devconf=0x0"
+
+# we need to clear the console kernel parameter. Otherwise the recovery step will
+# fail and damage the internal nand partiton layout.
+global.linux.bootargs.console=""
+
+# load production-firmware from nand partition and start it
+echo -e ${info} "now boot recovery image in factory-reset-mode"
+echo ""
+
+global.bootm.boot_atag=true
+bootm -v -f ${global.pfc.nand}.${mtd_recovery}.bb
+if [ ! $? = "0" ]; then
+	echo -e ${error} "could not start recovery image...booting to shell..."
+	exit 1
+fi
+
+exit $?
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console b/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console
new file mode 100644
index 00000000000..e644823bd59
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let uart_mask="(1<<1)"
+let uart_enable="0x${global.pfc.boot_mode_id} & 0x${uart_mask}"
+
+if [ "${uart_enable}" = "${uart_mask}" ]; then
+	global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.linux_uart},115200n8"
+
+elif [ "${global.bootm.boot_atag}" = true ]; then
+	# in case of an legacy boot (e.g. kernel 3.6.11, FW < 5) we are not
+	# allowed to set console=null because this will break the init-process
+	# and the boot hangs.
+	global.linux.bootargs.console=""
+
+elif [ "${global.pfc.debug_mode_active}" = true ]; then
+	global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+else
+	global.linux.bootargs.console="console=null"
+fi
+
+echo -e ${info} "setting linux console to: $global.linux.bootargs.console"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console b/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console
new file mode 100644
index 00000000000..7a0d30d5603
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+mode="unknown"
+let uart_mask="(1<<1)"
+
+while getopt "edh" opt; do
+	if [ ${opt} = e ]; then
+                mode="enable"
+	elif [ ${opt} = d ]; then
+                mode="disable"
+	elif [ ${opt} = h ]; then
+		mode="unknown"
+	fi
+done
+
+if [ "${mode}" = "unknown" ]; then
+	echo "usage: $0 [-ed]"
+	echo ""
+	echo "control serial console bit. Mode is set persistent through eeprom bit "uart-enable" in eeprom"
+	echo ""
+	echo "-e enable linux uart mode\n"
+	echo "-d disable linux uart mode\n"
+	echo ""
+	exit 1
+fi
+
+if [ "${mode}" = "enable" ]; then
+	let uart_enable="0x${global.pfc.boot_mode_id} | 0x${uart_mask}"
+else
+	let uart_enable="0x${global.pfc.boot_mode_id} & ~0x${uart_mask}"
+fi
+
+# write persistent to eeprom
+xsection.boot_mode_id=${uart_enable}
+
+# also update global variable
+global.pfc.boot_mode_id=${xsection.boot_mode_id}
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr b/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr
new file mode 100644
index 00000000000..8ac486514a1
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+ethaddr_match -i eth0 -p "00:30:de"
+if [ "$?" = 0 ]; then
+        global.pfc.ethaddr_is_valid="true"
+else
+        global.pfc.ethaddr_is_valid="false"
+fi
+
+echo -e ${info} "ethaddr is valid: $global.pfc.ethaddr_is_valid"
diff --git a/defaultenv/defaultenv-pfc-base/boot/dhcp-boot b/defaultenv/defaultenv-pfc-base/boot/dhcp-boot
new file mode 100644
index 00000000000..a341a2600da
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/dhcp-boot
@@ -0,0 +1,22 @@
+#!/bin/sh
+
+# disable watchdog, otherwise the device will be resettet when the dhcp-request
+# takes to long.
+wd 0
+
+# send magic string with the dhcp-request to signal the dhcp-boot state
+global.dhcp.option224="cit-recover"
+
+ifup eth0
+
+if [ ! -z "${global.dhcp.bootfile}" ]; then
+	echo -e ${info} "enter DHCPBOOT now"
+
+	tftp ${global.dhcp.bootfile}
+
+	echo -e ${info} "DHCPBOOT: exec <${global.dhcp.bootfile}>"
+	./${global.dhcp.bootfile}
+fi
+
+# enable watchdog again, if the dhcp-server does not provide any bootfile.
+wd $global.pfc.watchdog_timeout_linux_load
diff --git a/defaultenv/defaultenv-pfc-base/boot/net-setupfw b/defaultenv/defaultenv-pfc-base/boot/net-setupfw
new file mode 100644
index 00000000000..a28eca3b738
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/net-setupfw
@@ -0,0 +1,94 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+global.dhcp.retries=1000
+global.dhcp.vendor_id="750-8206"
+global.dhcp.option224="barebox running"
+
+ifup ${global.pfc.eth}
+
+if [ ${eth0.ipaddr} != "0.0.0.0" ] && [ ${eth0.serverip} != "0.0.0.0" ] &&
+  				      [ ! -z "${global.dhcp.bootfile}"  ]; then
+
+	echo -e ${info} "get ${global.dhcp.bootfile} from tftp server ${eth0.serverip}."
+
+	tftp ${global.dhcp.bootfile}
+	if [ "$?" = 0 ]; then
+
+		# Flash PFC200v3 G2 EMMC
+		if [ -e "${global.pfc.emmc}" ]; then
+			echo -e ${info} "flash ${global.pfc.bootfile} to ${global.pfc.emmc}"
+			umount /boot
+			umount ${global.pfc.emmc}.0
+			delpart ${global.pfc.emmc}.0
+
+			cp ${global.dhcp.bootfile} ${global.pfc.emmc}
+			if [ $? -ne 0 ]; then
+				echo -e ${error} "$0: error while flashing ${global.dhcp.bootfile} on ${global.pfc.emmc}"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			# normally there are no available partitions on emmc devices at the commissioner.
+			# With the result that we dont see any partitions under /dev. After we flashed the
+			# emmc image to the device we need to rescan the partiton tables and add the new
+			# flashed partitions under /dev.
+			${global.pfc.emmc_name}.scan=1
+			if [ $? -ne 0 ]; then
+				echo -e ${PRINT_ERROR} "error scanning partitions"
+				all_lights -s 1 -c red
+				exit 1
+			fi
+
+			# set setupfw image and dtb file to newly flashed emmc image files
+			if [ ! -e "${global.pfc.emmc_boot}/setupfw" ] ||
+			   [ ! -e "${global.pfc.emmc_boot}/oftree-${global.board.variant}-setupfw.dtb" ]; then
+				echo -e ${error} "$0: no setupfw on newly flashed emmc found"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			global.bootm.image="${global.pfc.emmc_boot}/setupfw"
+			global.bootm.oftree="${global.pfc.emmc_boot}/oftree-${global.board.variant}-setupfw.dtb"
+
+		# Flash NAND flash devices, like SRC
+		elif [ -e "${global.pfc.nand}" ]; then
+
+			echo -e ${info} "flash ${global.dhcp.bootfile} to ${global.pfc.nand_ubidata}"
+
+			pfc-erase-flash-ubidata ${global.dhcp.bootfile}
+			if [ $? -ne 0 ]; then
+				echo -e ${error} "$0: error while flashing ${global.dhcp.bootfile} on ${global.pfc.nand_ubidata}"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			automount -d ${global.pfc.nand_boot} "ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_boot} ${global.pfc.nand_boot}"
+
+			# set setupfw image and dtb file to newly flashed nand image files
+			if [ ! -e "${global.pfc.nand_boot}/setupfw" ] ||
+			   [ ! -e "${global.pfc.nand_boot}/oftree-${global.board.variant}-setupfw.dtb" ]; then
+				echo -e ${error} "$0: no setupfw on newly flashed nand found"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			global.bootm.image="${global.pfc.nand_boot}/setupfw"
+			global.bootm.oftree="${global.pfc.nand_boot}/oftree-${global.board.variant}-setupfw.dtb"
+
+		else
+			echo -e ${error} "$0: No EMMC nor FLASH found. Nothing useful to do here, bailing out ..."
+			#all_lights -s 1 -c red
+			exit 1
+		fi
+	else
+		echo -e ${error} "$0: tftp download failed."
+		#all_lights -s 1 -c red
+		exit 1
+	fi
+else
+	echo -e ${error} "$0: dhcp configuration not set correctly."
+	#all_lights -s 1 -c red
+	exit 1
+fi
diff --git a/defaultenv/defaultenv-pfc-base/boot/sd-legacy b/defaultenv/defaultenv-pfc-base/boot/sd-legacy
new file mode 100644
index 00000000000..04c4223c333
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/sd-legacy
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+# We need to define an imaginary mtd-partition
+# to protect our flash if an FW < 5 is booted via sd-card. The customer could
+# break his device when the create-boot-image is executed via e.g. wbm.
+
+global.bootm.image="${global.pfc.sd_boot}/uImage"
+global.linux.bootargs.base="rw root=/dev/mmcblk0p2 rootfstype=ext3 rootwait mtdparts=omap2-nand.0:-(nand_not_valid)ro pxc_boot_id=0x82 bootversion=${global.version} devconf=0x${global.pfc.devconf} macaddr=${eth0.ethaddr}"
diff --git a/defaultenv/defaultenv-pfc-base/boot/sd-setupfw b/defaultenv/defaultenv-pfc-base/boot/sd-setupfw
new file mode 100644
index 00000000000..249247a3728
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/sd-setupfw
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+global.bootm.image="${global.pfc.sd_boot}/setupfw"
+global.bootm.oftree="${global.pfc.sd_boot}/oftree-${global.board.variant}-setupfw.dtb"
diff --git a/defaultenv/defaultenv-pfc-base/data/print-msg-formats b/defaultenv/defaultenv-pfc-base/data/print-msg-formats
new file mode 100644
index 00000000000..3442e996794
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/data/print-msg-formats
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+# here we are defining some print messages formats,
+# that are sourced and used in scripts.
+
+info="\e[00;32mINFO: PFC\e[00m: "
+error="\e[00;31mERROR: PFC\e[00m: "
+warning="\e[00;33mWARN: PFC\e[00m: "
+
diff --git a/defaultenv/defaultenv-pfc-base/init/a-config-pfc b/defaultenv/defaultenv-pfc-base/init/a-config-pfc
new file mode 100644
index 00000000000..da37f4ca05a
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/a-config-pfc
@@ -0,0 +1,234 @@
+#!/bin/sh
+
+# Here we setup the pfc environment for the start up scripts. Use global
+# variables because they make the sub-scripts more readable and can be
+# evaluated via commandline (e.g. magicvar command) if only booted to shell.
+
+############################
+# global variable definition
+############################
+global pfc.boot_mode
+global pfc.devconf
+global pfc.boot_mode_id
+global pfc.boot_mode_id_ext
+global pfc.ethaddr_is_valid
+global pfc.downgrade_img
+global pfc.custom_sh
+global pfc.sd
+global pfc.sd_boot
+global pfc.sd_rootfs
+global pfc.sd_dev_boot
+global pfc.sd_dev_rootfs
+global pfc.emmc_name
+global pfc.emmc
+global pfc.emmc_dev_boot
+global pfc.emmc_dev_rootfs0
+global pfc.emmc_dev_rootfs1
+global pfc.emmc_dev_home0
+global pfc.emmc_dev_home1
+global pfc.emmc_boot
+global pfc.emmc_rootfs0
+global pfc.emmc_rootfs1
+global pfc.nand
+global pfc.nand_ubidata
+global pfc.nand_ubidata_rootfs0
+global pfc.nand_ubidata_rootfs1
+global pfc.nand_ubidata_boot
+global pfc.nand_rootfs0
+global pfc.nand_rootfs1
+global pfc.nand_boot
+global pfc.nand_mlo_parts
+global pfc.nand_boot_parts
+global pfc.barebox_uart
+global pfc.barebox_linux_uart
+global pfc.linux_uart
+global pfc.eth
+global pfc.debug_mode_active
+global pfc.watchdog_timeout_linux_load
+global pfc.watchdog_timeout_linux_boot
+global pfc.linux_uart_device
+global pfc.eeprom_dev
+global pfc.usbgadget_options
+global pfc.disable_sd_boot
+global pfc.dhcpboot
+
+global bootchooser.rootfs.1.boot
+global bootchooser.rootfs.2.boot
+global linux.bootargs.productionmode
+global linux.bootargs.watchdog
+
+################################
+# global variable description
+################################
+magicvar -a global.pfc.boot_mode	"indicates boot state of this pfc device
+                                         possible values are:
+					 <default, production, setupfw, broken>"
+
+magicvar -a global.pfc.devconf		"copy value from eeprom xsection"
+magicvar -a global.pfc.boot_mode_id	"copy value from eeprom xsection"
+magicvar -a global.pfc.boot_mode_id_ext	"copy value from eeprom xsection"
+
+magicvar -a global.pfc.ethaddr_is_valid	"indicates if the configured ethaddr of
+					 eth0 is valid. Is valid when it matches
+					 the pattern 00:30:de possible values
+					 are: <valid, not_valid>"
+
+magicvar -a global.pfc.downgrade_img	"path to the downgrade image file on the
+					 sd card vfat boot partition"
+
+magicvar -a global.pfc.custom_sh	"path to the custom-setup script file on
+					 the sd card vfat boot partition"
+
+magicvar -a global.pfc.sd		"path to the sd card device"
+magicvar -a global.pfc.sd_boot		"path to the sd cards boot partition"
+magicvar -a global.pfc.sd_rootfs	"path to the sd cards rootfs partition"
+magicvar -a global.pfc.sd_dev_boot	"path to the sd cards boot partition
+					 device"
+
+magicvar -a global.pfc.sd_dev_rootfs	"path to the sd cards rootfs partition
+					 device"
+
+magicvar -a global.pfc.emmc_name	"name of the emmc in /dev"
+magicvar -a global.pfc.emmc		"path to the emmc device"
+magicvar -a global.pfc.emmc_dev_boot	"path to the emmc boot device"
+magicvar -a global.pfc.emmc_dev_rootfs0	"path to the emmc rootfs0 device"
+magicvar -a global.pfc.emmc_dev_rootfs1	"path to the emmc rootfs1 device"
+magicvar -a global.pfc.emmc_dev_home0	"path to the emmc home0 device"
+magicvar -a global.pfc.emmc_dev_home1	"path to the emmc home1 device"
+magicvar -a global.pfc.emmc_boot	"path to emmcs boot partition"
+magicvar -a global.pfc.emmc_rootfs0	"path to emmcs rootfs0 partition"
+magicvar -a global.pfc.emmc_rootfs1	"path to emmcs rootfs1 partition"
+magicvar -a global.pfc.nand		"path to the nand device"
+magicvar -a global.pfc.nand_ubidata	"path to the nand ubidata device"
+magicvar -a global.pfc.nand_ubidata_rootfs0 "path to the nand ubidata rootfs0
+					     device"
+
+magicvar -a global.pfc.nand_ubidata_rootfs1 "path to the nand ubidata rootfs1
+					     device"
+
+magicvar -a global.pfc.nand_ubidata_boot "path to the nand ubidata boot device"
+
+magicvar -a global.pfc.nand_rootfs0	"path to the nand rootfs0 partition"
+magicvar -a global.pfc.nand_rootfs1	"path to the nand rootfs1 partition"
+magicvar -a global.pfc.nand_boot	"path to the nand boot partition"
+magicvar -a global.pfc.nand_mlo_parts	"list of mlo partition paths"
+magicvar -a global.pfc.nand_boot_parts  "list of barebox (2nd stage) partition paths"
+magicvar -a global.pfc.barebox_uart	"uart device that is used in barebox for
+					 console messages"
+
+magicvar -a global.pfc.barebox_linux_uart "uart device that is used in linux for
+					    console messages, when uart bit is
+					    disabled and developer bit is
+					    enabled. E.g. in AM35xx barebox uart
+					    is 3 but corrosponding linux uart is
+					    2."
+
+
+magicvar -a global.pfc.linux_uart	"uart device that that the kernel uses
+					 for console messages"
+
+magicvar -a global.pfc.eth		"ethernet device that is used in all pfc
+					 devices"
+
+magicvar -a global.pfc.debug_mode_active "true if debug mode bit in boot_mode_id
+					  is set; false otherwise"
+
+magicvar -a global.pfc.watchdog_timeout_linux_load "watchdog timeout when trying
+						    to load the linux kernel in
+						    to ram"
+
+magicvar -a global.pfc.watchdog_timeout_linux_boot "watchdog timeout when trying
+						    to boot the linux kernel. Is
+						    resetted when the kernel driver
+						    is probed"
+
+magicvar -a global.pfc.linux_uart_device "uart device string that is used when
+					  configuring the kernel parameter (e.g
+					  ttyO, ttymxc)."
+
+
+magicvar -a global.linux.bootargs.productionmode "parameter for starting setupfw
+						  in production or wsc mode"
+magicvar -a global.linux.bootargs.watchdog "board specific watchdog kernel parameter"
+magicvar -a global.pfc.eeprom_dev "path to eeprom device"
+magicvar -a global.pfc.usbgadget_options "options to activate when usbgadget is
+					  used. By default fastboot-, fastboot
+					  bbu- and CDC ACM-Functions are
+					  activated"
+magicvar -a global.pfc.disable_sd_boot "is set during boot phase and disables sd
+					firmware boot, Mode is derived from
+					boot-mode-id-ext."
+magicvar -a global.pfc.dhcpboot "is set during boot and enables dhcpboot mode
+				based on the flag in boot-mode-id-ext."
+
+
+
+################################
+# global variable initialisation
+################################
+[ -z "${global.pfc.boot_mode}" ] && global.pfc.boot_mode="${bootmatrix.mode}"
+[ -z "${global.pfc.devconf}" ] && global.pfc.devconf="${xsection.devconf}"
+[ -z "${global.pfc.boot_mode_id}" ] && global.pfc.boot_mode_id="${xsection.boot_mode_id}"
+[ -z "${global.pfc.boot_mode_id_ext}" ] && global.pfc.boot_mode_id_ext="${xsection.boot_mode_id_ext}"
+[ -z "${global.pfc.ethaddr_is_valid}" ] && global.pfc.ethaddr_is_valid=false
+[ -z "${global.pfc.sd}" ] && global.pfc.sd="/dev/mmc0"
+[ -z "${global.pfc.sd_boot}" ] && global.pfc.sd_boot="/mnt/sd_boot"
+[ -z "${global.pfc.sd_rootfs}" ] && global.pfc.sd_rootfs="/mnt/sd_rootfs"
+[ -z "${global.pfc.sd_dev_boot}" ] && global.pfc.sd_dev_boot="${global.pfc.sd}.0"
+[ -z "${global.pfc.sd_dev_rootfs}" ] && global.pfc.sd_dev_rootfs="${global.pfc.sd}.1"
+[ -z "${global.pfc.emmc_name}" ] && global.pfc.emmc_name="mmc1"
+[ -z "${global.pfc.emmc}" ] && global.pfc.emmc="/dev/${global.pfc.emmc_name}"
+[ -z "${global.pfc.emmc_dev_boot}" ] && global.pfc.emmc_dev_boot="${global.pfc.emmc}.0"
+[ -z "${global.pfc.emmc_dev_rootfs0}" ] && global.pfc.emmc_dev_rootfs0="${global.pfc.emmc}.4"
+[ -z "${global.pfc.emmc_dev_rootfs1}" ] && global.pfc.emmc_dev_rootfs1="${global.pfc.emmc}.7"
+[ -z "${global.pfc.emmc_dev_home0}" ] && global.pfc.emmc_dev_home0="${global.pfc.emmc}.5"
+[ -z "${global.pfc.emmc_dev_home1}" ] && global.pfc.emmc_dev_home1="${global.pfc.emmc}.6"
+[ -z "${global.pfc.emmc_boot}" ] && global.pfc.emmc_boot="/mnt/mmc1.0"
+[ -z "${global.pfc.emmc_rootfs0}" ] && global.pfc.emmc_rootfs0="/mnt/emmc_rootfs0"
+[ -z "${global.pfc.emmc_rootfs1}" ] && global.pfc.emmc_rootfs1="/mnt/emmc_rootfs1"
+[ -z "${global.pfc.nand}" ] && global.pfc.nand="/dev/nand0"
+[ -z "${global.pfc.nand_ubidata}" ] && global.pfc.nand_ubidata="${global.pfc.nand}.ubidata"
+[ -z "${global.pfc.nand_ubidata_rootfs0}" ] && global.pfc.nand_ubidata_rootfs0="${global.pfc.nand}.ubidata.ubi.rootfs.1"
+[ -z "${global.pfc.nand_ubidata_rootfs1}" ] && global.pfc.nand_ubidata_rootfs1="${global.pfc.nand}.ubidata.ubi.rootfs.2"
+[ -z "${global.pfc.nand_ubidata_boot}" ] && global.pfc.nand_ubidata_boot="${global.pfc.nand}.ubidata.ubi.boot"
+[ -z "${global.pfc.nand_rootfs0}" ] && global.pfc.nand_rootfs0="/mnt/ubi_rootfs0"
+[ -z "${global.pfc.nand_rootfs1}" ] && global.pfc.nand_rootfs1="/mnt/ubi_rootfs1"
+[ -z "${global.pfc.nand_boot}" ] && global.pfc.nand_boot="/mnt/ubi_boot"
+[ -z "${global.pfc.nand_mlo_parts}" ] && global.pfc.nand_mlo_parts="${global.pfc.nand}.mlo0 ${global.pfc.nand}.mlo1 ${global.pfc.nand}.mlo2 ${global.pfc.nand}.mlo3"
+[ -z "${global.pfc.nand_boot_parts}" ] && global.pfc.nand_boot_parts="${global.pfc.nand}.boot0 ${global.pfc.nand}.boot1 ${global.pfc.nand}.boot2 ${global.pfc.nand}.boot3"
+[ -z "${global.pfc.eeprom_dev}" ] && global.pfc.eeprom_dev="/dev/eeprom0"
+
+[ -z "${global.pfc.downgrade_img}" ] && global.pfc.downgrade_img="${global.pfc.sd_boot}/downgrade.bin.$global.board.variant"
+[ -z "${global.pfc.custom_sh}" ] && global.pfc.custom_sh="${global.pfc.sd_boot}/custom_setup.sh"
+[ -z "${global.pfc.barebox_uart}" ] && global.pfc.barebox_uart="0"
+[ -z "${global.pfc.barebox_linux_uart}" ] && global.pfc.barebox_linux_uart="0"
+[ -z "${global.pfc.linux_uart}" ] && global.pfc.linux_uart="1"
+[ -z "${global.pfc.eth}" ] && global.pfc.eth="eth0"
+
+let debug_mode_mask="(1<<0)"
+let debug_mode_enable="0x${global.pfc.boot_mode_id} & 0x${debug_mode_mask}"
+if [ -z "${global.pfc.debug_mode_active}" ]; then
+        global.pfc.debug_mode_active=false
+
+        if [ "${debug_mode_enable}" = "${debug_mode_mask}" ]; then
+                global.pfc.debug_mode_active=true
+	fi
+fi
+
+[ -z "${global.pfc.watchdog_timeout_linux_load}" ] && global.pfc.watchdog_timeout_linux_load=20
+[ -z "${global.pfc.watchdog_timeout_linux_boot}" ] && global.pfc.watchdog_timeout_linux_boot=30
+[ -z "${global.pfc.linux_uart_device}" ] && global.pfc.linux_uart_device="ttyO"
+[ -z "${global.pfc.usbgadget_options}" ] && global.pfc.usbgadget_options="-A -b -a"
+[ -z "${global.pfc.disable_sd_boot}" ] && global.pfc.disable_sd_boot=0
+[ -z "${global.pfc.dhcpboot}" ] && global.pfc.dhcpboot=0
+
+[ -z "${global.bootchooser.targets}" ] && global.bootchooser.targets="rootfs.1 rootfs.2"
+[ -z "${global.bootchooser.state_prefix}" ] && global.bootchooser.state_prefix="bootstate"
+[ -z "${global.bootchooser.reset_attempts}" ] && global.bootchooser.reset_attempts="all-zero power-on"
+[ -z "${global.bootchooser.reset_priorities}" ] && global.bootchooser.reset_priorities="all-zero"
+[ -z "${global.bootchooser.disable_on_zero_attempts}" ] && global.bootchooser.disable_on_zero_attempts=0
+[ -z "${global.bootchooser.retry}" ] && global.bootchooser.retry=1
+
+[ -z "${global.linux.bootargs.watchdog}" ] && global.linux.bootargs.watchdog="omap_wdt.early_enable omap_wdt.timer_margin=${global.pfc.watchdog_timeout_linux_boot}"
+[ -z "${global.fastboot.bbu}" ] && global.fastboot.bbu=1
+[ -z "${global.fastboot.partitions}" ] && global.fastboot.partitions="/kernel(kernel)c,/initrd(initrd)c,/devicetree(devicetree)c,${global.pfc.emmc_dev_boot}(boot)c,${global.pfc.emmc_dev_rootfs0}(rootfs1)c,${global.pfc.emmc_dev_rootfs1}(rootfs2)c,${global.pfc.sd_dev_boot}(boot_sd)c,${global.pfc.sd_dev_rootfs}(rootfs_sd)c,${global.pfc.eeprom_dev}(eeprom)c,${global.pfc.emmc_dev_home0}(home1)c,${global.pfc.emmc_dev_home1}(home2)c,/parttable(parttable)c"
diff --git a/defaultenv/defaultenv-pfc-base/init/automount b/defaultenv/defaultenv-pfc-base/init/automount
new file mode 100644
index 00000000000..527b363de77
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/automount
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+[ -e "${global.pfc.nand_ubidata}" ] && automount -d ${global.pfc.nand_rootfs0} "[ ! -e ${global.pfc.nand_ubidata_rootfs0} ] && ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_rootfs0} ${global.pfc.nand_rootfs0}"
+[ -e "${global.pfc.nand_ubidata}" ] && automount -d ${global.pfc.nand_rootfs1} "[ ! -e ${global.pfc.nand_ubidata_rootfs1} ] && ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_rootfs1} ${global.pfc.nand_rootfs1}"
+[ -e "${global.pfc.emmc_dev_rootfs0}" ] && automount -d ${global.pfc.emmc_rootfs0} "mount ${global.pfc.emmc_dev_rootfs0} ${global.pfc.emmc_rootfs0}"
+[ -e "${global.pfc.emmc_dev_rootfs1}" ] && automount -d ${global.pfc.emmc_rootfs1} "mount ${global.pfc.emmc_dev_rootfs1} ${global.pfc.emmc_rootfs1}"
+[ -e "${global.pfc.sd_dev_rootfs}" ] && automount -d ${global.pfc.sd_rootfs} "mount ${global.pfc.sd_dev_rootfs} ${global.pfc.sd_rootfs}"
+[ -e "${global.pfc.sd_dev_boot}" ] && automount -d ${global.pfc.sd_boot} "mount ${global.pfc.sd_dev_boot} ${global.pfc.sd_boot}"
diff --git a/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize b/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize
new file mode 100644
index 00000000000..1045e1acf77
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+global.tftp.blocksize=1432
diff --git a/defaultenv/defaultenv-pfc-base/init/y-generic-board-info b/defaultenv/defaultenv-pfc-base/init/y-generic-board-info
new file mode 100644
index 00000000000..20dbe276c5c
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/y-generic-board-info
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# Rewrite the compatible string in the internal barebox device-tree
+# (located in ram), and add the eeprom devconf as suffix. This string
+# is used by the bootloader-spec module to search for correct bootloader-spec
+# entry to load the corrosponding kernel device-tree.
+board_info -r ${xsection.devconf}
+if [ $? -ne 0 ]; then
+        echo -e ${warning} "could not rewrite compatible string"
+fi
+
+board_info -b board.variant
+# export board_variant from oftree to global variable list
+if [ $? -ne 0 ]; then
+        echo -e ${warning} "could not export board variant id"
+fi
+
+# export switch reset gpio from oftree to global variable list
+board_info -s pfc.sw_reset_gpio
+if [ $? -ne 0 ]; then
+        echo -e ${warning} "could not export switch reset gpio"
+fi
diff --git a/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup b/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup
new file mode 100644
index 00000000000..d597e55ef39
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+pfc-detect-boot-mode
+
+if [ "${global.pfc.boot_mode}" = "default" ]; then
+	pfc-config-default-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: could not configure default boot"
+		pfc-config-broken-boot
+		exit 1
+	fi
+
+elif [ "${global.pfc.boot_mode}" = "production" ]; then
+	pfc-config-production-boot
+
+elif [ "${global.pfc.boot_mode}" = "setupfw" ]; then
+	pfc-config-setupfw-boot
+
+elif [ "${global.pfc.boot_mode}" = "downgrade" ]; then
+	pfc-exec-downgrade-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: failed to execute downgrade boot"
+		led_mode -s -c yellow -v off
+		led_mode -s -c red -v on
+		exit 1
+	fi
+
+elif [ "${global.pfc.boot_mode}" = "custom" ]; then
+	pfc-exec-custom-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: failed to execute custom script"
+		led_mode -s -c yellow -v off
+		led_mode -s -c red -v on
+		exit 1
+	fi
+
+else
+	pfc-config-broken-boot
+	exit 1
+fi
+
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset b/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset
new file mode 100644
index 00000000000..587a61d1657
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# Hint: on am35xx based devices we do not need to get the switch out of reset
+# manually. This is already done by the hardware reset-logic.
+
+if [ "${global.autoboot}" = "boot" -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+if [ ${global.pfc.sw_reset_gpio} -eq -1 ]; then
+	echo -e ${warning} "no switch reset pin defined for board \e[00;32m${global.board.variant}\e[00m"
+	exit 0
+else
+	echo -n -e ${info} "reset switch for board \e[00;32m${global.board.variant}\e[00m with gpio pin "
+	echo "${global.pfc.sw_reset_gpio}"
+fi
+
+gpio_direction_output "${global.pfc.sw_reset_gpio}" 0
+msleep 1
+gpio_direction_output "${global.pfc.sw_reset_gpio}" 1
+# give the switch and phys some time to wakeup from reset
+msleep 1000
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg
new file mode 100644
index 00000000000..9d9856a314f
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+if [ "${global.autoboot}" != "boot" ] || [ "${global.pfc.boot_mode}" != "default" ] && [ "${global.pfc.boot_mode}" != "broken" ]; then
+	global.boot.watchdog_timeout=0
+fi
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup
new file mode 100644
index 00000000000..e4687a02f54
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+# To determine if we are on a micrel ks8863 based device we can not read then
+# switch identifier register. This lack comes due to an unssported operation code
+# of the cpu to get the values from the micrel ethernet switch. Instead we read
+# the interal phy_id registers of the micrel switch.
+
+source env/data/print-msg-formats
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+phy_x1_addr=1
+phy_x2_addr=2
+
+# registers
+control_reg=0
+phy_id_high_reg=2
+phy_id_low_reg=3
+
+# register values
+#
+# Init values according to Data Sheet:
+# "AN enable" (Auto-negotiation enabled) = 1
+# "Hp_mdix" (HP Auto MDI/MDI-X mode) = 1
+#
+auto_neg_mdi_enable=4128	# 0x1020
+phy_id_high_val=34		# 0x22
+phy_id_low_val=5168		# 0x1430
+
+if [ "${global.autoboot}" = "boot" -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+# read phy id regs to check if we are on a micrel based device. Its sufficient to
+# read only the phy id of phy_x1.
+miitool -x "${mii_bus}:${phy_x1_addr}:${phy_id_high_reg}" -p read_phy_id_high_val
+miitool -x "${mii_bus}:${phy_x1_addr}:${phy_id_low_reg}" -p read_phy_id_low_val
+
+if [ "${read_phy_id_high_val}" != "${phy_id_high_val}" ] && [ "${read_phy_id_low_val}" != "${phy_id_low_reg}" ]; then
+	exit 0
+fi
+
+echo -e ${info} "Micrel KSZ8863 switch detected"
+
+# enable auto-negotiation and auto-mdi-x mode
+miitool -w "${mii_bus}:${phy_x1_addr}:${control_reg}" -p auto_neg_mdi_enable
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable auto-neg-mdi PHY of port X1"
+	exit 1
+fi
+
+miitool -w "${mii_bus}:${phy_x2_addr}:${control_reg}" -p auto_neg_mdi_enable
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable auto-neg-mdi PHY of port X2"
+	exit 1
+fi
+
+exit 0
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup
new file mode 100644
index 00000000000..49b4b90360f
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup
@@ -0,0 +1,173 @@
+#!/bin/sh
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+sw_port0_addr=16
+g2_addr=28
+
+# mii registers
+sw_id_reg=3
+sw_port_status_reg=0
+g2_smi_cmd_reg=24
+g2_smi_data_reg=25
+
+# constants / flags
+mv88e6321_product_id=784
+
+sw_port_phy_detect_flag="0x1000"
+
+smi_busy_flag="0x8000"
+smi_cmd_c22_mode="0x1000"
+smi_cmd_write="0x400"
+smi_cmd_read="0x800"
+
+phy_power_down_flag="0x800"
+
+source env/data/print-msg-formats
+
+if [ "${global.autoboot}" = "boot" -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+miitool -x "${mii_bus}:${sw_port0_addr}:${sw_id_reg}" -p switch_id
+if [ "$?" != 0 ]; then
+	exit 0
+fi
+
+# ignore chip reversion
+let switch_product_id="${switch_id} >> 4"
+
+if [ ${switch_product_id} != ${mv88e6321_product_id} ]; then
+	exit 0
+fi
+
+echo -e ${info} "Marvel MV88E6321 switch detected"
+
+# set phy detection flag
+miitool -x "${mii_bus}:${sw_port0_addr}:${sw_port_status_reg}" -p sw_port0_status
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not read switch port0 status"
+	exit 1
+fi
+
+let sw_port0_new_status="${sw_port0_status} | ${sw_port_phy_detect_flag}"
+
+miitool -w "${mii_bus}:${sw_port0_addr}:${sw_port_status_reg}" -p sw_port0_new_status
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not write new switch port0 status"
+	exit 1
+fi
+
+# power up external phy
+
+# wait for SMI command ready
+smi_busy=1
+smi_tries=3
+
+# the device address is in bits 9:5 of the smi command
+# ports 0, 1, 3, 4
+for device_address in 0 32 96 128; do
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+
+	# set power down of phy control register to zero
+	let g2_smi_cmd="${smi_busy_flag} | ${smi_cmd_c22_mode} | ${smi_cmd_read} | ${device_address}"
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI command"
+		exit 1
+	fi
+
+	miitool -x "${mii_bus}:${g2_addr}:${g2_smi_data_reg}" -p g2_smi_data
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not read G2 SMI data"
+		exit 1
+	fi
+
+	let g2_smi_data="${g2_smi_data} & ~${phy_power_down_flag}"
+
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_data_reg}" -p g2_smi_data
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI data"
+		exit 1
+	fi
+
+	smi_busy=1
+	smi_tries=3
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+
+	let g2_smi_cmd="${smi_busy_flag} | ${smi_cmd_c22_mode} | ${smi_cmd_write} | ${device_address}"
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI command"
+		exit 1
+	fi
+
+	# wait until phy is ready
+	smi_busy=1
+	smi_ties=3
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+done
+
+exit 0
diff --git a/drivers/bus/omap-gpmc.c b/drivers/bus/omap-gpmc.c
index cd5b6d5e030..20a24653904 100644
--- a/drivers/bus/omap-gpmc.c
+++ b/drivers/bus/omap-gpmc.c
@@ -453,6 +453,12 @@ static struct dt_eccmode modes[] = {
 		.name = "bch16",
 		.mode = OMAP_ECC_BCH16_CODE_HW,
 	},
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+	{
+		.name = "bch8-hw-det-sw",
+		.mode = OMAP_ECC_BCH8_CODE_HW_DETECTION_SW,
+	},
+#endif
 };
 
 static int gpmc_probe_nand_child(struct device_d *dev,
diff --git a/drivers/eeprom/at24.c b/drivers/eeprom/at24.c
index 1d35088c6bb..a11780afedd 100644
--- a/drivers/eeprom/at24.c
+++ b/drivers/eeprom/at24.c
@@ -464,6 +464,12 @@ static int at24_probe(struct device_d *dev)
 		enum of_gpio_flags flags;
 		at24->wp_gpio = of_get_named_gpio_flags(dev->device_node,
 				"wp-gpios", 0, &flags);
+
+		if (at24->wp_gpio == -EPROBE_DEFER) {
+			err = at24->wp_gpio;
+			goto err_probe_defer;
+		}
+
 		if (gpio_is_valid(at24->wp_gpio)) {
 			at24->wp_active_low = flags & OF_GPIO_ACTIVE_LOW;
 			gpio_request(at24->wp_gpio, "eeprom-wp");
@@ -510,6 +516,7 @@ err_clients:
 
 	if (gpio_is_valid(at24->wp_gpio))
 		gpio_free(at24->wp_gpio);
+err_probe_defer:
 	kfree(at24->writebuf);
 err_device_name:
 	kfree(at24);
diff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c
index d3f525f333c..a0b61e13d03 100644
--- a/drivers/i2c/busses/i2c-omap.c
+++ b/drivers/i2c/busses/i2c-omap.c
@@ -1121,7 +1121,11 @@ i2c_omap_probe(struct device_d *pdev)
 	 * Also since the omap_i2c_read_reg uses reg_map_ip_* a
 	 * raw_readw is done.
 	 */
-	rev = __raw_readw(i2c_omap->base + 0x04);
+	if (!of_machine_is_compatible("ti,omap3") &&
+					!of_machine_is_compatible("ti,omap2"))
+		rev = __raw_readw(i2c_omap->base + 0x04);
+	else
+		rev = 0;
 
 	i2c_omap->scheme = OMAP_I2C_SCHEME(rev);
 	switch (i2c_omap->scheme) {
diff --git a/drivers/mci/mci-core.c b/drivers/mci/mci-core.c
index 92a73c8f1df..916c700202e 100644
--- a/drivers/mci/mci-core.c
+++ b/drivers/mci/mci-core.c
@@ -19,6 +19,8 @@
 #include <block.h>
 #include <disks.h>
 #include <of.h>
+#include <of_gpio.h>
+#include <gpio.h>
 #include <linux/err.h>
 #include <linux/sizes.h>
 #include <dma.h>
@@ -1665,29 +1667,39 @@ static const char *mci_boot_names[] = {
 	"user",
 };
 
-static int mci_register_partition(struct mci_part *part)
+static int mci_card_present(struct mci_host *host)
 {
-	struct mci *mci = part->mci;
+	if (host->non_removable)
+		return 1;
+
+	if (!gpio_is_valid(host->cd_gpio) ||
+					gpio_direction_input(host->cd_gpio))
+		return 0;
+
+	return host->cd_inverted ? !gpio_get_value(host->cd_gpio) :
+						gpio_get_value(host->cd_gpio);
+}
+
+static int mci_get_cd(struct param_d *param, void *priv)
+{
+	struct mci *mci = priv;
 	struct mci_host *host = mci->host;
-	const char *partnodename = NULL;
-	struct device_node *np;
-	int rc;
 
-	/*
-	 * An MMC/SD card acts like an ordinary disk.
-	 * So, re-use the disk driver to gain access to this media
-	 */
-	part->blk.dev = &mci->dev;
-	part->blk.ops = &mci_ops;
+	if (host->card_present)
+		mci->cd = host->card_present(host);
+	else
+		mci->cd = 0;
 
-	rc = blockdevice_register(&part->blk);
-	if (rc != 0) {
-		dev_err(&mci->dev, "Failed to register MCI/SD blockdevice\n");
-		return rc;
-	}
-	dev_info(&mci->dev, "registered %s\n", part->blk.cdev.name);
+	return 0;
+}
 
-	np = host->hw_dev->device_node;
+static void mci_create_partitions_ondemand(struct mci_part *part)
+{
+	struct mci *mci = part->mci;
+	struct mci_host *host = mci->host;
+	struct device_node *np = host->hw_dev->device_node;
+	const char *partnodename = NULL;
+	int rc;
 
 	/* create partitions on demand */
 	switch (part->area_type) {
@@ -1705,7 +1717,7 @@ static int mci_register_partition(struct mci_part *part)
 	case MMC_BLK_DATA_AREA_GP:
 		break;
 	default:
-		return 0;
+		return;
 	}
 
 	rc = parse_partition_table(&part->blk);
@@ -1723,6 +1735,46 @@ static int mci_register_partition(struct mci_part *part)
 		if (part->area_type != MMC_BLK_DATA_AREA_BOOT)
 			of_partitions_register_fixup(&part->blk.cdev);
 	}
+}
+
+static int mci_register_partition(struct mci_part *part)
+{
+	struct mci *mci = part->mci;
+	int rc;
+
+	/*
+	 * An MMC/SD card acts like an ordinary disk.
+	 * So, re-use the disk driver to gain access to this media
+	 */
+	part->blk.dev = &mci->dev;
+	part->blk.ops = &mci_ops;
+
+	rc = blockdevice_register(&part->blk);
+	if (rc != 0) {
+		dev_err(&mci->dev, "Failed to register MCI/SD blockdevice\n");
+		return rc;
+	}
+	dev_info(&mci->dev, "registered %s\n", part->blk.cdev.name);
+
+	mci_create_partitions_ondemand(part);
+
+	return 0;
+}
+
+static int mci_set_scan(struct param_d *param, void *priv)
+{
+	struct mci *mci = priv;
+	int rc, i;
+
+	if (!mci->scan)
+		return 0;
+
+	rc = mci_check_if_already_initialized(mci);
+	if (rc == 0)
+		return rc;
+
+	for (i = 0; i < mci->nr_parts; i++)
+		mci_create_partitions_ondemand(&mci->part[i]);
 
 	return 0;
 }
@@ -1818,6 +1870,10 @@ static int mci_card_probe(struct mci *mci)
 		}
 	}
 
+	if (!mci->param_cd)
+		mci->param_cd = dev_add_param_bool(&mci->dev, "cd", NULL,
+						mci_get_cd, &mci->cd, mci);
+
 	dev_dbg(&mci->dev, "SD Card successfully added\n");
 
 on_error:
@@ -1918,6 +1974,9 @@ int mci_register(struct mci_host *host)
 	if (!hw_dev->detect)
 		hw_dev->detect = mci_hw_detect;
 
+	if (!mci->host->card_present)
+		mci->host->card_present = mci_card_present;
+
 	host->supply = regulator_get(hw_dev, "vmmc");
 	if (IS_ERR(host->supply)) {
 		dev_err(&mci->dev, "Failed to get 'vmmc' regulator.\n");
@@ -1939,6 +1998,14 @@ int mci_register(struct mci_host *host)
 		goto err_unregister;
 	}
 
+	mci->param_scan = dev_add_param_bool(&mci->dev, "scan",
+			mci_set_scan, NULL, &mci->scan, mci);
+
+	if (IS_ERR(mci->param_scan) && PTR_ERR(mci->param_scan) != -ENOSYS) {
+		dev_err(&mci->dev, "Failed to add 'scan' parameter to the MCI device\n");
+		goto err_unregister;
+	}
+
 	if (IS_ENABLED(CONFIG_MCI_INFO))
 		mci->dev.info = mci_info;
 
@@ -2015,6 +2082,8 @@ void mci_of_parse_node(struct mci_host *host,
 	host->non_removable = of_property_read_bool(np, "non-removable");
 	host->no_sd = of_property_read_bool(np, "no-sd");
 	host->disable_wp = of_property_read_bool(np, "disable-wp");
+	host->cd_gpio = of_get_named_gpio(np, "cd-gpios", 0);
+	host->cd_inverted = of_property_read_bool(np, "cd-inverted");
 }
 
 void mci_of_parse(struct mci_host *host)
diff --git a/drivers/mci/omap_hsmmc.c b/drivers/mci/omap_hsmmc.c
index 61a1f468053..c8332d74cc5 100644
--- a/drivers/mci/omap_hsmmc.c
+++ b/drivers/mci/omap_hsmmc.c
@@ -609,6 +609,9 @@ static int omap_mmc_probe(struct device_d *dev)
 
 		if (pdata->devname)
 			hsmmc->mci.devname = pdata->devname;
+
+		hsmmc->mci.cd_gpio = pdata->cd_gpio;
+		hsmmc->mci.cd_inverted = pdata->cd_inverted;
 	}
 
 	mci_of_parse(&hsmmc->mci);
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 7426dfc4639..e94477614f6 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -52,4 +52,21 @@ config STARFIVE_PWRSEQ
 	  be accessed over /dev/mem or used from kernels which still depend
 	  on bootloader for initialization.
 
+config XSECTION
+	bool "Xsection driver"
+	select I2C
+	select I2C_OMAP if ARCH_OMAP
+	select I2C_IMX if ARCH_IMX
+	select I2C_STM32 if ARCH_STM32MP
+	select EEPROM_AT24
+	help
+	  Controls the XSECTION items that are located e.g. in eeprom like
+	  devconf, boot-mode-id and ethaddr.
+
+config BOOTMATRIX
+	bool "Bootmatrix Driver"
+	help
+	  Detects the boot mode based on pressed keys and exports the boot mode
+	  as a device parameter.
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 36743e6ae6a..5ecf7bd5fe7 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -9,3 +9,5 @@ obj-$(CONFIG_DEV_MEM)		+= mem.o
 obj-$(CONFIG_UBOOTVAR)		+= ubootvar.o
 obj-$(CONFIG_ACPI_TEST)		+= acpi-test.o
 obj-$(CONFIG_STARFIVE_PWRSEQ)	+= starfive-pwrseq.o
+obj-$(CONFIG_XSECTION)		+= xsection.o
+obj-$(CONFIG_BOOTMATRIX) 	+= bootmatrix.o
diff --git a/drivers/misc/bootmatrix.c b/drivers/misc/bootmatrix.c
new file mode 100644
index 00000000000..57bfd89eebe
--- /dev/null
+++ b/drivers/misc/bootmatrix.c
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <init.h>
+#include <malloc.h>
+#include <of.h>
+#include <libbb.h>
+#include <fcntl.h>
+#include <linux/err.h>
+#include <gpio.h>
+#include <of_gpio.h>
+#include <linux/types.h>
+#include <linux/bitmap.h>
+#include <bootmatrix.h>
+#include <led_mode.h>
+
+#define MAX_KEY_BITS 8
+
+enum bootmatrix_states {
+	INIT,
+	MULTI_KEY_MODE,
+	SINGLE_KEY_MODE_STAGE1,
+	SINGLE_KEY_MODE_STAGE2,
+};
+
+enum bootmatrix_key_num {
+	RST = 0,
+	RUN,
+	STOP,
+	RESET,
+};
+
+struct bootmatrix_key {
+	int gpio;
+	int active_low;
+};
+
+struct bootmatrix {
+	struct device_d dev;
+	struct bootmatrix_key *keys;
+	struct param_d *param_mode;
+	int num_bootmatrix_keys;
+	int rst_timeout;
+	int mode;
+	bool single_key_mode;
+	DECLARE_BITMAP(matrix, MAX_KEY_BITS);
+};
+
+struct bootmatrix *bootmatrix;
+
+static void bootmatrix_get_current_key_values(struct bootmatrix *bootmatrix)
+{
+	int i, val, pressed;
+	struct bootmatrix_key *key;
+
+	bitmap_zero(bootmatrix->matrix, MAX_KEY_BITS);
+
+	for (i = RST; i < bootmatrix->num_bootmatrix_keys; i++) {
+
+		key = &bootmatrix->keys[i];
+		val = gpio_get_value(key->gpio);
+		pressed = val != key->active_low;
+
+		if (pressed)
+			set_bit(i, bootmatrix->matrix);
+	}
+}
+
+/* We implement the following two logics to detect the bootmode:
+ *
+ * SINGLE_KEY_MODE: some device have only one RST-key implemented. In this case
+ * the production mode is detected when the half of the configured timeout is
+ * reached. The setupfw mode is detected when the full configured timeout is
+ * reached.
+ *
+ * MULTI_KEY_MODE: this mode is the original mode for devices that have the keys
+ * RUN,STOP,RESET and RST implemented. For entering the setupfw mode one has to
+ * hold RST and RESET for a minimum of 7 sec. If one releases the RESET key the
+ * device enters production mode. In all other cases we will fallback into the
+ * default mode.
+ */
+static enum bootmatrix_mode bootmatrix_detect_mode(struct bootmatrix
+							*bootmatrix)
+{
+	enum bootmatrix_mode mode = DEFAULT;
+	enum bootmatrix_states state = INIT;
+	unsigned long *matrix = bootmatrix->matrix;
+	bool exit = false;
+	bool single_key = bootmatrix->single_key_mode;
+	int timeout = bootmatrix->rst_timeout;
+	uint64_t start;
+
+	bootmatrix_get_current_key_values(bootmatrix);
+	if (test_bit(RST, matrix) && (test_bit(RESET, matrix) || single_key)) {
+
+		led_mode_static("green", true);
+
+		start = get_time_ns();
+		while (!exit) {
+
+			bootmatrix_get_current_key_values(bootmatrix);
+			switch (state) {
+			case INIT:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (single_key && test_bit(RST, matrix)) {
+					state = SINGLE_KEY_MODE_STAGE1;
+				} else if (test_bit(RST, matrix) &&
+						test_bit(RESET, matrix)) {
+					state = MULTI_KEY_MODE;
+				}
+				break;
+
+			case SINGLE_KEY_MODE_STAGE1:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (is_timeout(start, (timeout / 2) *
+								      SECOND)) {
+					mode = PRODUCTION;
+					state = SINGLE_KEY_MODE_STAGE2;
+					led_mode_static("green", false);
+				}
+				break;
+
+			case SINGLE_KEY_MODE_STAGE2:
+				if (!test_bit(RST, matrix)) {
+					exit = true;
+				} else if (is_timeout(start, timeout * SECOND)) {
+					mode = SETUPFW;
+					exit = true;
+				}
+				break;
+
+			case MULTI_KEY_MODE:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (!test_bit(RESET, matrix) &&
+							test_bit(STOP, matrix)) {
+					mode = PRODUCTION;
+					exit = true;
+				} else if (is_timeout(start, timeout * SECOND)) {
+					mode = SETUPFW;
+					exit = true;
+				}
+				break;
+			}
+		}
+	}
+
+	return mode;
+}
+
+enum bootmatrix_mode bootmatrix_get_mode()
+{
+	if (!bootmatrix)
+		return -ENODEV;
+
+	if (bootmatrix->mode == UNKNOWN)
+		return -EPROBE_DEFER;
+
+	return bootmatrix->mode;
+}
+
+static int bootmatrix_probe_key(struct device_node *node,
+					struct bootmatrix_key *key, char *name)
+{
+	struct device_node *child;
+	enum of_gpio_flags flags;
+	int ret = 0;
+
+	child = of_find_node_by_name(node, name);
+	if (!child) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	key->gpio = of_get_named_gpio_flags(child, "gpios", 0, &flags);
+	if (key->gpio < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (flags & OF_GPIO_ACTIVE_LOW)
+		key->active_low = 1;
+
+	ret = gpio_request(key->gpio, name);
+	if (ret)
+		goto out;
+
+	ret = gpio_direction_input(key->gpio);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int bootmatrix_probe_dt(struct bootmatrix *bootmatrix,
+				   struct device_node *node)
+{
+	int ret = 0;
+
+	bootmatrix->num_bootmatrix_keys = of_get_child_count(node);
+	bootmatrix->keys = xzalloc(bootmatrix->num_bootmatrix_keys *
+						sizeof(*bootmatrix->keys));
+
+	if (bootmatrix->num_bootmatrix_keys < 1) {
+		ret = -ENODEV;
+		goto out_free;
+	} else if (bootmatrix->num_bootmatrix_keys == 1) {
+		bootmatrix->single_key_mode = true;
+	} else {
+		bootmatrix->single_key_mode = false;
+	}
+
+	ret = of_property_read_u32(node, "rst-timeout-secs",
+						&bootmatrix->rst_timeout);
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RST], "rst");
+	if (ret)
+		goto out_free;
+
+	/* in single-key-mode we need only the rst key. if we found this key
+	 * terminate here.
+	 */
+	if (bootmatrix->single_key_mode)
+		goto out;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RUN], "run");
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[STOP], "stop");
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RESET], "reset");
+	if (ret)
+		goto out_free;
+
+out:
+	return 0;
+
+out_free:
+	free(bootmatrix->keys);
+	return ret;
+}
+
+static const char *bootmatrix_mode_names[] = {
+	"unknown",
+	"default",
+	"production",
+	"setupfw",
+};
+
+static int bootmatrix_probe(struct device_d *dev)
+{
+	int ret;
+	const char *alias;
+	struct device_node *np = dev->device_node;
+
+	bootmatrix = xzalloc(sizeof(*bootmatrix));
+	bootmatrix->dev.id = DEVICE_ID_SINGLE;
+	bootmatrix->dev.parent = dev;
+	dev->priv = bootmatrix;
+
+	if (!np) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = bootmatrix_probe_dt(bootmatrix, np);
+	if (ret)
+		goto out;
+
+	alias = of_alias_get(np);
+	if (!alias) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	dev_set_name(&bootmatrix->dev, alias);
+
+	ret = register_device(&bootmatrix->dev);
+	if (ret)
+		goto out;
+
+	bootmatrix->param_mode = dev_add_param_enum(&bootmatrix->dev, "mode",
+				NULL, NULL,
+				&bootmatrix->mode,
+				bootmatrix_mode_names,
+				ARRAY_SIZE(bootmatrix_mode_names),
+				bootmatrix);
+
+	if (IS_ERR(bootmatrix->param_mode)) {
+		ret = -ENODEV;
+		goto out_unreg;
+	}
+
+	bootmatrix->mode = bootmatrix_detect_mode(bootmatrix);
+
+	return 0;
+
+out_unreg:
+	unregister_device(&bootmatrix->dev);
+
+out:
+	free(bootmatrix);
+	dev_err(dev, "failed to probe %d\n", ret);
+
+	return ret;
+}
+
+static void bootmatrix_remove(struct device_d *dev)
+{
+	struct bootmatrix *bootmatrix = dev->priv;
+
+	dev_remove_parameters(&bootmatrix->dev);
+	unregister_device(&bootmatrix->dev);
+	free(bootmatrix->keys);
+	free(bootmatrix);
+}
+
+static __maybe_unused struct of_device_id bootmatrix_ids[] = {
+	{
+		.compatible = "bootmatrix",
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct driver_d bootmatrix_driver = {
+	.name = "bootmatrix",
+	.probe = bootmatrix_probe,
+	.remove = bootmatrix_remove,
+	.of_compatible = DRV_OF_COMPAT(bootmatrix_ids),
+};
+device_platform_driver(bootmatrix_driver);
diff --git a/drivers/misc/xsection.c b/drivers/misc/xsection.c
new file mode 100644
index 00000000000..79c43f0df81
--- /dev/null
+++ b/drivers/misc/xsection.c
@@ -0,0 +1,459 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <init.h>
+#include <malloc.h>
+#include <of.h>
+#include <libbb.h>
+#include <fcntl.h>
+#include <linux/err.h>
+#include <net.h>
+#include <xsection.h>
+#include <fs.h>
+
+struct xsection_item {
+	struct cdev *cdev;
+	char *value_param;
+};
+
+struct xsection {
+	struct device_d dev;
+	struct xsection_item boot_mode_id;
+	struct xsection_item boot_mode_id_ext;
+	struct xsection_item devconf;
+	struct xsection_item ethaddr1;
+	struct xsection_item ethaddr2;
+	struct xsection_item blidx;
+	struct xsection_item blp_uii;
+};
+
+static struct xsection *xsection;
+
+static int xsection_access_item(struct xsection_item *xitem, void *buf,
+								int flags)
+{
+	int ret = 0;
+
+	if (!xitem || !buf || flags < 0)
+		return -EINVAL;
+
+	switch (flags) {
+	case O_RDONLY:
+		ret = cdev_read(xitem->cdev, buf, xitem->cdev->size, 0, 0);
+		break;
+	case O_WRONLY:
+		ret = cdev_write(xitem->cdev, buf, xitem->cdev->size, 0, 0);
+		break;
+	}
+
+	return ret;
+}
+
+int xsection_get_boot_mode_id(u8 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_boot_mode_id(u8 *value)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id, value,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_boot_mode_id_ext(u8 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id_ext, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_boot_mode_id_ext(u8 *value)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id_ext, value,
+							O_WRONLY) : -ENODEV;
+}
+int xsection_get_devconf(u16 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->devconf, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_devconf(u16 *value)
+{
+	return xsection ? xsection_access_item(&xsection->devconf, value,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_ethaddr1(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr1, ethaddr,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_ethaddr1(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr1, ethaddr,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_ethaddr2(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr2, ethaddr,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_ethaddr2(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr2, ethaddr,
+							O_WRONLY) : -ENODEV;
+}
+
+static int xsection_param_get_ethaddr(struct xsection_item *xitem)
+{
+	int ret;
+	u8 buf[6];
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = xzalloc(sizeof("xx:xx:xx:xx:xx:xx"));
+
+	ethaddr_to_string(buf, xitem->value_param);
+
+	return 0;
+}
+
+static int xsection_param_set_ethaddr(struct xsection_item *xitem)
+{
+	int ret;
+	u8 buf[6];
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	ret = string_to_ethaddr(xitem->value_param, buf);
+	if (ret)
+		return ret;
+
+	ret = xsection_access_item(xitem, &buf, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_ethaddr2(struct param_d *p, void *priv)
+{
+	return xsection_param_get_ethaddr(priv);
+}
+
+static int xsection_param_set_ethaddr2(struct param_d *p, void *priv)
+{
+	return xsection_param_set_ethaddr(priv);
+}
+
+static int xsection_param_get_ethaddr1(struct param_d *p, void *priv)
+{
+	return xsection_param_get_ethaddr(priv);
+}
+
+static int xsection_param_set_ethaddr1(struct param_d *p, void *priv)
+{
+	return xsection_param_set_ethaddr(priv);
+}
+
+static int xsection_param_get_boot_mode_id(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%02x", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_boot_mode_id(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_devconf(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u16 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%04x", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_devconf(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u16 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_blidx(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%d", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_blidx(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_blp_uii(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf[40];
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	/* replace last byte with terminating null byte to avoid garbage in the
+	 * string device parameter.
+	 */
+	buf[39] = '\0';
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%s", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_blp_uii(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+
+	if (!strcmp(xitem->value_param, "") || strlen(xitem->value_param) != 39)
+		return -EINVAL;
+
+	/* we need to set a <EOT> sign at the end per definition */
+	xitem->value_param[39] = 0x04;
+	ret = xsection_access_item(xitem, xitem->value_param, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+static int xsection_add_dev_param(struct device_node *np,
+				struct xsection *xsection,
+				struct xsection_item *xitem, char *param_name,
+				int (*set)(struct param_d *p, void *priv),
+				int (*get)(struct param_d *p, void *priv))
+{
+	struct device_node *partition_node;
+	struct cdev *cdev;
+	struct param_d *param;
+	int ret = 0;
+	char *device_path;
+
+	partition_node = of_parse_phandle(np, param_name, 0);
+	if (!partition_node) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = of_find_path_by_node(partition_node, &device_path, 0);
+	if (ret == -EPROBE_DEFER)
+		goto out;
+
+	cdev = cdev_by_name(devpath_to_name(device_path));
+	if (!cdev) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	param = dev_add_param_string(&xsection->dev, param_name, set, get,
+				&xitem->value_param, xitem);
+
+	if (IS_ERR(param)) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	xitem->cdev = cdev;
+
+out:
+	return ret;
+}
+
+static int xsection_probe(struct device_d *dev)
+{
+	struct device_node *np = dev->device_node;
+	const char *alias;
+	int ret;
+
+	xsection = xzalloc(sizeof(*xsection));
+	xsection->dev.id = DEVICE_ID_SINGLE;
+	xsection->dev.parent = dev;
+	dev->priv = xsection;
+
+	alias = of_alias_get(np);
+	if (!alias) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	dev_set_name(&xsection->dev, alias);
+
+	ret = register_device(&xsection->dev);
+	if (ret)
+		goto out;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->boot_mode_id,
+					"boot_mode_id",
+					xsection_param_set_boot_mode_id,
+					xsection_param_get_boot_mode_id);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->boot_mode_id_ext,
+					"boot_mode_id_ext",
+					xsection_param_set_boot_mode_id,
+					xsection_param_get_boot_mode_id);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->devconf,
+					"devconf",
+					xsection_param_set_devconf,
+					xsection_param_get_devconf);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->ethaddr1,
+					"ethaddr1",
+					 xsection_param_set_ethaddr1,
+					 xsection_param_get_ethaddr1);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->ethaddr2,
+					"ethaddr2",
+					 xsection_param_set_ethaddr2,
+					 xsection_param_get_ethaddr2);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->blidx,
+					"blidx",
+					 xsection_param_set_blidx,
+					 xsection_param_get_blidx);
+	if (ret)
+		goto out_unreg;
+
+	/* blp_uii is currently only used in pfc200 adv devices. So it's ok when
+	 * no "blp_uii" partition is found.
+	 */
+	xsection_add_dev_param(np, xsection, &xsection->blp_uii,
+					"blp_uii",
+					 xsection_param_set_blp_uii,
+					 xsection_param_get_blp_uii);
+
+	return 0;
+
+out_unreg:
+	unregister_device(&xsection->dev);
+out:
+	free(xsection);
+	xsection = NULL;
+
+	if (ret != -EPROBE_DEFER)
+		dev_err(dev, "failed to probe %d\n", ret);
+
+	return ret;
+}
+
+static void xsection_remove(struct device_d *dev)
+{
+	struct xsection *xsection = dev->priv;
+
+	dev_remove_parameters(&xsection->dev);
+	unregister_device(&xsection->dev);
+	free(xsection);
+	xsection = NULL;
+}
+
+static __maybe_unused struct of_device_id xsection_ids[] = {
+	{
+		.compatible = "xsection",
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct driver_d xsection_driver = {
+	.name = "xsection",
+	.probe = xsection_probe,
+	.remove = xsection_remove,
+	.of_compatible = DRV_OF_COMPAT(xsection_ids),
+};
+device_platform_driver(xsection_driver);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index c69e5ce4e1d..6cc095aa209 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -17,6 +17,16 @@ config MTD_NAND_ECC_SW_BCH
 	bool
 	prompt "Support software BCH ecc"
 
+config NAND_BCH_SUPPORT
+	bool
+	default y
+	prompt "Support for omap BCH handling"
+
+config NAND_ECC_HW_SW_ERR_DETECTION
+	bool
+	select BCH
+	prompt "Enable software error detection"
+
 config NAND_ECC_HW_SYNDROME
 	bool
 	prompt "Support syndrome hardware ecc controllers"
diff --git a/drivers/mtd/nand/nand_omap_gpmc.c b/drivers/mtd/nand/nand_omap_gpmc.c
index 0f3ffa1c0ee..c8d613d21cb 100644
--- a/drivers/mtd/nand/nand_omap_gpmc.c
+++ b/drivers/mtd/nand/nand_omap_gpmc.c
@@ -75,6 +75,10 @@
 
 #include "nand_omap_bch_decoder.h"
 
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+#include <linux/bch.h>
+#endif
+
 #define GPMC_ECC_CONFIG_ECCENABLE		(1 << 0)
 #define GPMC_ECC_CONFIG_ECCCS(x)		(((x) & 0x7) << 1)
 #define GPMC_ECC_CONFIG_ECCTOPSECTOR(x)		(((x) & 0x7) << 4)
@@ -93,18 +97,31 @@
 
 #define BADBLOCK_MARKER_LENGTH 2
 
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 static const uint8_t bch8_vector[] = {0xf3, 0xdb, 0x14, 0x16, 0x8b, 0xd2,
 		0xbe, 0xcc, 0xac, 0x6b, 0xff, 0x99, 0x7b};
 static u_char bch16_vector[] = {0xf5, 0x24, 0x1c, 0xd0, 0x61, 0xb3, 0xf1, 0x55,
 				0x2e, 0x2c, 0x86, 0xa3, 0xed, 0x36, 0x1b, 0x78,
 				0x48, 0x76, 0xa9, 0x3b, 0x97, 0xd1, 0x7a, 0x93,
 				0x07, 0x0e};
+#endif
+
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+static uint8_t bch8_polynomial[] = {0xef, 0x51, 0x2e, 0x09, 0xed, 0x93, 0x9a, 0xc2,
+				    0x97, 0x79, 0xe5, 0x24, 0xb5};
+#else
+int omap_gpmc_decode_bch(int select_4_8, unsigned char *ecc, unsigned int *err_loc);
+#endif
+#endif
 
 static const char *ecc_mode_strings[] = {
 	"software",
 	"hamming_hw_romcode",
 	"bch8_hw",
 	"bch8_hw_romcode",
+	"bch8_hw_detsw",
+	"bch8_hw_detsw_legacy",
 	"bch16_hw",
 };
 
@@ -240,9 +257,17 @@ static int __omap_calculate_ecc(struct nand_chip *nand, uint8_t *ecc_code,
 	unsigned int val1 = 0x0, val2 = 0x0;
 	unsigned int val3 = 0x0, val4 = 0x0;
 	int ecc_size = 8;
+#if defined(CONFIG_NAND_BCH_SUPPORT) && defined(CONFIG_NAND_ECC_HW_SW_ERR_DETECTION)
+	int i;
+#endif
+
+	uint8_t *ecode = ecc_code;
 
 	switch (oinfo->ecc_mode) {
+#ifdef CONFIG_NAND_BCH_SUPPORT
 	case OMAP_ECC_BCH8_CODE_HW:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
 	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
 		/*
 		 * Reading HW ECC_BCH_Results
@@ -270,6 +295,7 @@ static int __omap_calculate_ecc(struct nand_chip *nand, uint8_t *ecc_code,
 		*ecc_code++ = ((val1 >> 8) & 0xFF);
 		*ecc_code++ = (val1 & 0xFF);
 		break;
+#endif
 	case OMAP_ECC_HAMMING_CODE_HW_ROMCODE:
 		/* read ecc result */
 		val1 = readl(oinfo->gpmc_base + GPMC_ECC1_RESULT);
@@ -321,6 +347,21 @@ static int __omap_calculate_ecc(struct nand_chip *nand, uint8_t *ecc_code,
 		return -EINVAL;
 	}
 
+	/* reset ptr */
+	ecc_code = ecode;
+
+#if defined(CONFIG_NAND_BCH_SUPPORT) && defined(CONFIG_NAND_ECC_HW_SW_ERR_DETECTION)
+	switch (oinfo->ecc_mode) {
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
+		for (i = 0; i < nand->ecc.total; i++)
+			*(ecc_code + i) = *(ecc_code + i) ^ bch8_polynomial[i];
+		break;
+	default:
+		break;
+	}
+#endif
+
 	return 0;
 }
 
@@ -330,6 +371,37 @@ static int omap_calculate_ecc(struct nand_chip *nand, const uint8_t *dat,
 	return __omap_calculate_ecc(nand, ecc_code, 0);
 }
 
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+static int omap_correct_bch_sw(struct nand_chip *nand, uint8_t *data,
+			     uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+	unsigned int errloc[8];
+	int i, count;
+
+	count = decode_bch((struct bch_control*) nand->ecc.priv, NULL, nand->ecc.size, read_ecc , calc_ecc,
+			   NULL, errloc);
+
+	pr_debug("%s: count %d, ecc.size %d, ecc.bytes %d\n",
+		__func__, count, nand->ecc.size, nand->ecc.bytes);
+
+	if (count > 0) {
+		/* correct errors */
+		for (i = 0; i < count; i++) {
+			/* correct data only, not ecc bytes */
+			if (errloc[i] < (8 * 512))
+				data[errloc[i]/8] ^= 1 << (errloc[i] & 7);
+			pr_info("corrected bitflip %u\n", errloc[i]);
+		}
+	} else if (count < 0) {
+		pr_info("ecc unrecoverable error\n");
+	}
+
+	return count;
+}
+
+#else
+
 static int omap_correct_bch(struct nand_chip *nand, uint8_t *dat,
 			     uint8_t *read_ecc, uint8_t *calc_ecc)
 {
@@ -402,6 +474,8 @@ static int omap_correct_bch(struct nand_chip *nand, uint8_t *dat,
 
 	return bitflip_count;
 }
+#endif	/* CONFIG_NAND_ECC_HW_SW_ERR_DETECTION */
+#endif	/* CONFIG_NAND_BCH_SUPPORT */
 
 static int omap_correct_hamming(struct nand_chip *nand, uint8_t *dat,
 			     uint8_t *read_ecc, uint8_t *calc_ecc)
@@ -464,8 +538,29 @@ static int omap_correct_data(struct nand_chip *nand, uint8_t *dat,
 {
 	struct gpmc_nand_info *oinfo = (struct gpmc_nand_info *)(nand->priv);
 
-	if (oinfo->ecc_mode != OMAP_ECC_HAMMING_CODE_HW_ROMCODE)
+	switch (oinfo->ecc_mode) {
+	case OMAP_ECC_HAMMING_CODE_HW_ROMCODE:
+		return omap_correct_hamming(nand, dat, read_ecc, calc_ecc);
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+	case OMAP_ECC_BCH8_CODE_HW:
+	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
+		/*
+		 * The nand layer already called omap_calculate_ecc,
+		 * but before it has read the oob data. Do it again,
+		 * this time with oob data.
+		 */
+		omap_calculate_ecc(nand, dat, calc_ecc);
+		return omap_correct_bch(nand, dat, read_ecc, calc_ecc);
+#else
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
+		return omap_correct_bch_sw(nand, dat, read_ecc, calc_ecc);
+#endif
+#endif
+	default:
 		return -EINVAL;
+	}
 
 	return omap_correct_hamming(nand, dat, read_ecc, calc_ecc);
 
@@ -482,7 +577,10 @@ static void omap_enable_hwecc(struct nand_chip *nand, int mode)
 	int cs = 0;
 
 	switch (oinfo->ecc_mode) {
+#ifdef CONFIG_NAND_BCH_SUPPORT
 	case OMAP_ECC_BCH8_CODE_HW:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
 	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
 		if (mode == NAND_ECC_READ) {
 			eccsize0 = 24;
@@ -508,9 +606,11 @@ static void omap_enable_hwecc(struct nand_chip *nand, int mode)
 			eccsize1 = 52; /* OOB bits in nibbles per sector */
 		}
 		break;
+#endif
 	case OMAP_ECC_HAMMING_CODE_HW_ROMCODE:
 		eccsize1 = ((ecc_size >> 1) - 1) << 22;
 		break;
+	default:
 	case OMAP_ECC_SOFT:
 		return;
 	}
@@ -530,7 +630,9 @@ static void omap_enable_hwecc(struct nand_chip *nand, int mode)
 			GPMC_ECC_SIZE_CONFIG_ECCSIZE0(0xff);
 		ecc_conf_val = dev_width | GPMC_ECC_CONFIG_ECCCS(cs) |
 			GPMC_ECC_CONFIG_ECCENABLE;
-	} else {
+	}
+#ifdef CONFIG_NAND_BCH_SUPPORT
+	else {
 		writel(GPMC_ECC_CONTROL_ECCPOINTER(1),
 				oinfo->gpmc_base + GPMC_ECC_CONTROL);
 
@@ -545,6 +647,7 @@ static void omap_enable_hwecc(struct nand_chip *nand, int mode)
 				GPMC_ECC_CONFIG_ECCCS(cs) |
 				GPMC_ECC_CONFIG_ECCENABLE);
 	}
+#endif
 
 	writel(ecc_size_conf_val, oinfo->gpmc_base + GPMC_ECC_SIZE_CONFIG);
 	writel(ecc_conf_val, oinfo->gpmc_base + GPMC_ECC_CONFIG);
@@ -552,6 +655,7 @@ static void omap_enable_hwecc(struct nand_chip *nand, int mode)
 			oinfo->gpmc_base + GPMC_ECC_CONTROL);
 }
 
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 static int omap_gpmc_read_buf_manual(struct nand_chip *chip,
 		void *buf, int bytes, int result_reg)
 {
@@ -568,6 +672,7 @@ static int omap_gpmc_read_buf_manual(struct nand_chip *chip,
 
 	return bytes;
 }
+#endif
 
 /**
  * omap_read_buf_pref - read data from NAND controller into buffer
@@ -663,6 +768,8 @@ static void omap_write_buf_pref(struct nand_chip *nand_chip,
 	gpmc_prefetch_reset(info->gpmc_cs);
 }
 
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 /*
  * read a page with the ecc layout used by the OMAP4 romcode. The
  * romcode expects an unusual ecc layout (f = free, e = ecc):
@@ -748,6 +855,8 @@ static int omap_gpmc_read_page_bch_rom_mode(struct nand_chip *chip, uint8_t *buf
 
 	return max_bitflips;
 }
+#endif	/* CONFIG_NAND_ECC_HW_SW_ERR_DETECTION */
+#endif	/* CONFIG_NAND_BCH_SUPPORT */
 
 /**
  * erased_sector_bitflips - count bit flips
@@ -759,6 +868,7 @@ static int omap_gpmc_read_page_bch_rom_mode(struct nand_chip *chip, uint8_t *buf
  * If falls below, report the page as erased with correctable bit
  * flip, else report as uncorrectable page.
  */
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 static int erased_sector_bitflips(u_char *data, u_char *oob,
 		struct gpmc_nand_info *oinfo)
 {
@@ -787,7 +897,9 @@ static int erased_sector_bitflips(u_char *data, u_char *oob,
 
 	return flip_bits;
 }
+#endif
 
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 /**
  * omap_elm_correct_data - corrects page data area in case error reported
  * @chip:	NAND chip object
@@ -950,7 +1062,9 @@ static int omap_elm_correct_data(struct nand_chip *chip, u_char *data,
 
 	return (err) ? err : stat;
 }
+#endif
 
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 static int gpmc_read_page_hwecc_elm(struct nand_chip *chip, uint8_t *buf,
 				    int oob_required, int page)
 {
@@ -985,6 +1099,7 @@ static int gpmc_read_page_hwecc_elm(struct nand_chip *chip, uint8_t *buf,
 
 	return omap_elm_correct_data(chip, buf, ecc_code, ecc_calc);
 }
+#endif
 
 static int gpmc_read_page_hwecc(struct nand_chip *chip, uint8_t *buf,
 				int oob_required, int page)
@@ -1017,7 +1132,13 @@ static int gpmc_read_page_hwecc(struct nand_chip *chip, uint8_t *buf,
 		int stat;
 
 		__omap_calculate_ecc(chip, &ecc_calc[i * eccbytes], i);
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+		stat = omap_correct_bch_sw(chip, p, &ecc_code[i * eccbytes], &ecc_calc[i * eccbytes]);
+#else
 		stat = omap_correct_bch(chip, p, &ecc_code[i * eccbytes], &ecc_calc[i * eccbytes]);
+#endif
+#endif
 		if (stat < 0) {
 			mtd->ecc_stats.failed++;
 		} else {
@@ -1033,8 +1154,11 @@ static int omap_gpmc_eccmode(struct gpmc_nand_info *oinfo,
 {
 	struct nand_chip *nand = &oinfo->nand;
 	struct mtd_info *minfo = nand_to_mtd(nand);
-	int offset, err;
-	int i, j;
+	int offset;
+	int i;
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+	int j, err;
+#endif
 
 	if (nand->options & NAND_BUSWIDTH_16)
 		nand->badblock_pattern = &bb_descrip_flashbased;
@@ -1078,6 +1202,51 @@ static int omap_gpmc_eccmode(struct gpmc_nand_info *oinfo,
 		omap_oobinfo.oobfree->length = minfo->oobsize -
 					offset - omap_oobinfo.eccbytes;
 		break;
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+		/* Init post-processing engine */
+		nand->ecc.priv = init_bch(13, BCH8_MAX_ERROR, 0); /* use default primitive
+								     polynomial (0x201b, m=13) */
+		oinfo->nand.ecc.bytes    = 13;
+		oinfo->nand.ecc.size     = 512;
+		oinfo->nand.ecc.strength = BCH8_MAX_ERROR;
+
+		oinfo->nand.ecc.steps = minfo->writesize / oinfo->nand.ecc.size;
+		oinfo->nand.ecc.total = oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes;
+		omap_oobinfo.eccbytes = oinfo->nand.ecc.total;
+
+		omap_oobinfo.oobfree->offset = offset; /* =1 */
+
+		if (mode == OMAP_ECC_BCH8_CODE_HW_DETECTION_SW)
+			omap_oobinfo.oobfree->length = minfo->oobsize -
+						offset - omap_oobinfo.eccbytes;
+		else
+			omap_oobinfo.oobfree->length = minfo->oobsize -
+						offset - oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes; //eccbytes
+
+#define BADBLOCK_MARKER_LENGTH    2
+		{
+			unsigned oob_index = BADBLOCK_MARKER_LENGTH;
+
+			if (mode == OMAP_ECC_BCH8_CODE_HW_DETECTION_SW) {
+				for (i = 0; i < omap_oobinfo.eccbytes; i++, oob_index++) {
+					omap_oobinfo.eccpos[i] = oob_index;
+					if (((i + 1) % oinfo->nand.ecc.bytes) == 0)
+						oob_index++;
+				}
+			} else { /* OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY */
+
+				oob_index = minfo->oobsize - oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes;
+
+				for (i = 0; i < oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes; i++)
+				        omap_oobinfo.eccpos[i] = i + oob_index;
+			}
+		}
+
+		break;
+#endif
 	case OMAP_ECC_BCH8_CODE_HW:
 		oinfo->nand.ecc.bytes    = 13;
 		oinfo->nand.ecc.size     = 512;
@@ -1094,7 +1263,9 @@ static int omap_gpmc_eccmode(struct gpmc_nand_info *oinfo,
 
 		for (i = 0; i < oinfo->nand.ecc.total; i++)
 			omap_oobinfo.eccpos[i] = i + offset;
+
 		break;
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
 		oinfo->nand.ecc.bytes    = 13 + 1;
 		oinfo->nand.ecc.size     = 512;
@@ -1137,6 +1308,8 @@ static int omap_gpmc_eccmode(struct gpmc_nand_info *oinfo,
 		nand->ecc.read_page = gpmc_read_page_hwecc_elm;
 
 		break;
+#endif
+#endif
 	case OMAP_ECC_SOFT:
 		minfo->ecclayout = NULL;
 		nand->ecc.mode = NAND_ECC_SOFT;
diff --git a/drivers/net/cpsw.c b/drivers/net/cpsw.c
index b01e7ac7a85..4a8f9e67d6f 100644
--- a/drivers/net/cpsw.c
+++ b/drivers/net/cpsw.c
@@ -901,13 +901,13 @@ static int cpsw_open(struct eth_device *edev)
 
 	dev_dbg(&slave->dev, "* %s\n", __func__);
 
+	cpsw_slave_init(slave, priv);
+
 	ret = phy_device_connect(edev, NULL, slave->phy_id,
 				 cpsw_adjust_link, 0, slave->phy_if);
 	if (ret)
 		return ret;
 
-	cpsw_slave_init(slave, priv);
-
 	return 0;
 }
 
diff --git a/drivers/net/davinci_emac.c b/drivers/net/davinci_emac.c
index ff35b746e21..c0fd4cb7179 100644
--- a/drivers/net/davinci_emac.c
+++ b/drivers/net/davinci_emac.c
@@ -113,6 +113,9 @@ static int wait_for_user_access(struct davinci_mdio_priv *priv, uint32_t *val)
 	u32 tmp;
 	uint64_t start = get_time_ns();
 
+	if(readl(priv->adap_mdio + EMAC_MDIO_CONTROL) & MDIO_CONTROL_IDLE)
+		davinci_eth_mdio_enable(priv);
+
 	do {
 		tmp = readl(priv->adap_mdio + EMAC_MDIO_USERACCESS0);
 
diff --git a/drivers/usb/gadget/multi.c b/drivers/usb/gadget/multi.c
index 04b3c2604ef..3cbabd24315 100644
--- a/drivers/usb/gadget/multi.c
+++ b/drivers/usb/gadget/multi.c
@@ -210,6 +210,7 @@ static int multi_bind(struct usb_composite_dev *cdev)
 
 	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
 	device_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;
+	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
 
 	config.label          = strings_dev[STRING_DESCRIPTION_IDX].s;
 	config.iConfiguration = strings_dev[STRING_DESCRIPTION_IDX].id;
diff --git a/fs/fs.c b/fs/fs.c
index b6431227d60..d3a68130f1e 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -3000,16 +3000,15 @@ int umount(const char *pathname)
 {
 	struct fs_device_d *fsdev = NULL, *f;
 	struct path path = {};
+	bool is_root = false;
 	int ret;
 
 	ret = filename_lookup(AT_FDCWD, getname(pathname), LOOKUP_FOLLOW, &path);
 	if (ret)
 		return ret;
 
-	if (path.dentry == d_root) {
-		path_put(&path);
-		return -EBUSY;
-	}
+	if (path.dentry == d_root)
+		is_root = true;
 
 	for_each_fs_device(f) {
 		if (path.dentry == f->vfsmount.mnt_root) {
@@ -3034,7 +3033,14 @@ int umount(const char *pathname)
 		return -EFAULT;
 	}
 
-	return fsdev_umount(fsdev);
+	ret = fsdev_umount(fsdev);
+	if (ret)
+		return ret;
+
+	if (is_root)
+		d_root = NULL;
+
+	return ret;
 }
 EXPORT_SYMBOL(umount);
 
diff --git a/fs/tftp.c b/fs/tftp.c
index d186e7983a6..5b0329efdaa 100644
--- a/fs/tftp.c
+++ b/fs/tftp.c
@@ -31,6 +31,8 @@
 #include <linux/err.h>
 #include <kfifo.h>
 #include <linux/sizes.h>
+#include <magicvar.h>
+#include <globalvar.h>
 
 #define TFTP_PORT	69	/* Well known TFTP port number */
 
@@ -64,10 +66,15 @@
 #define STATE_DONE	8
 
 #define TFTP_BLOCK_SIZE		512	/* default TFTP block size */
+#define TFTP_MIN_BLOCK_SIZE	30	/* this range was empirically determined */
+#define TFTP_MAX_BLOCK_SIZE	1468
+
 #define TFTP_FIFO_SIZE		4096
 
 #define TFTP_ERR_RESEND	1
 
+static int global_tftp_block_size = TFTP_BLOCK_SIZE;
+
 struct file_priv {
 	struct net_connection *tftp_con;
 	int push;
@@ -134,14 +141,15 @@ static int tftp_send(struct file_priv *priv)
 				"tsize%c"
 				"%lld%c"
 				"blksize%c"
-				"1432",
+				"%d",
 				priv->filename + 1, 0,
 				0,
 				0,
 				TIMEOUT, 0,
 				0,
 				priv->filesize, 0,
-				0);
+				0,
+				priv->blocksize);
 		pkt++;
 		len = pkt - xp;
 		break;
@@ -379,6 +387,15 @@ static struct file_priv *tftp_do_open(struct device_d *dev,
 
 	priv = xzalloc(sizeof(*priv));
 
+	if (global_tftp_block_size < TFTP_MIN_BLOCK_SIZE ||
+			global_tftp_block_size > TFTP_MAX_BLOCK_SIZE) {
+		pr_err("error: blocksize is unvalid (use: %d-%d)\n",
+				TFTP_MIN_BLOCK_SIZE,
+				TFTP_MAX_BLOCK_SIZE);
+		ret = -EINVAL;
+		goto out;
+	}
+
 	switch (accmode & O_ACCMODE) {
 	case O_RDONLY:
 		priv->push = 0;
@@ -396,7 +413,7 @@ static struct file_priv *tftp_do_open(struct device_d *dev,
 	priv->block = 1;
 	priv->err = -EINVAL;
 	priv->filename = dpath(dentry, fsdev->vfsmount.mnt_root);
-	priv->blocksize = TFTP_BLOCK_SIZE;
+	priv->blocksize = global_tftp_block_size;
 	priv->block_requested = -1;
 
 	priv->fifo = kfifo_alloc(TFTP_FIFO_SIZE);
@@ -748,6 +765,10 @@ static struct fs_driver_d tftp_driver = {
 
 static int tftp_init(void)
 {
+	globalvar_add_simple_int("tftp.blocksize", &global_tftp_block_size, "%u");
+
 	return register_fs_driver(&tftp_driver);
 }
 coredevice_initcall(tftp_init);
+
+BAREBOX_MAGICVAR(global.tftp.blocksize, "TFTP Blocksize Option");
diff --git a/images/Makefile.am33xx b/images/Makefile.am33xx
index 1de2474df5c..4eaa7b094eb 100644
--- a/images/Makefile.am33xx
+++ b/images/Makefile.am33xx
@@ -135,6 +135,38 @@ pblb-$(CONFIG_MACH_VSCOM_BALTOS) += start_am33xx_baltos_sram
 FILE_barebox-am33xx-baltos-mlo.img = start_am33xx_baltos_sram.pblb.mlo
 am33xx-mlo-$(CONFIG_MACH_VSCOM_BALTOS) += barebox-am33xx-baltos-mlo.img
 
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += start_am33xx_pfc_750_810x_sdram
+FILE_barebox-am33xx-pfc-750-810x.img = start_am33xx_pfc_750_810x_sdram.pblb
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += barebox-am33xx-pfc-750-810x.img
+
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += start_am33xx_pfc_750_810x_sram_256mb
+FILE_barebox-am33xx-pfc-750-810x-mlo.img = start_am33xx_pfc_750_810x_sram_256mb.pblb.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += barebox-am33xx-pfc-750-810x-mlo.img
+
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += start_am33xx_pfc_750_8208_sdram
+FILE_barebox-am33xx-pfc-750-8208.img = start_am33xx_pfc_750_8208_sdram.pblb
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += barebox-am33xx-pfc-750-8208.img
+
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += start_am33xx_pfc_750_8208_sram_256mb
+FILE_barebox-am33xx-pfc-750-8208-mlo.img = start_am33xx_pfc_750_8208_sram_256mb.pblb.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += barebox-am33xx-pfc-750-8208-mlo.img
+
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += start_am33xx_pfc_750_821x_sdram
+FILE_barebox-am33xx-pfc-750-821x.img = start_am33xx_pfc_750_821x_sdram.pblb
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += barebox-am33xx-pfc-750-821x.img
+
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += start_am33xx_pfc_750_821x_sram_512mb
+FILE_barebox-am33xx-pfc-750-821x-mlo.img = start_am33xx_pfc_750_821x_sram_512mb.pblb.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += barebox-am33xx-pfc-750-821x-mlo.img
+
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += start_am33xx_pfc_768_330x_sdram
+FILE_barebox-am33xx-pfc-768-330x.img = start_am33xx_pfc_768_330x_sdram.pblb
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += barebox-am33xx-pfc-768-330x.img
+
+pblb-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += start_am33xx_pfc_768_330x_sram_512mb
+FILE_barebox-am33xx-pfc-768-330x-mlo.img = start_am33xx_pfc_768_330x_sram_512mb.pblb.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += barebox-am33xx-pfc-768-330x-mlo.img
+
 ifdef CONFIG_OMAP_BUILD_IFT
 image-y += $(am33xx-mlo-y)
 else
diff --git a/images/Makefile.imx b/images/Makefile.imx
index dd927aba553..ca9a36fd565 100644
--- a/images/Makefile.imx
+++ b/images/Makefile.imx
@@ -383,6 +383,11 @@ CFG_start_zii_vf610_dev.pblb.imximg = $(board)/zii-vf610-dev/flash-header-zii-vf
 FILE_barebox-zii-vf610-dev.img = start_zii_vf610_dev.pblb.imximg
 image-$(CONFIG_MACH_ZII_VF610_DEV) += barebox-zii-vf610-dev.img
 
+pblb-$(CONFIG_MACH_WAGO_VTPCTP_MX6) += imx6q_vtpctp_start
+CFG_start_imx6q_vtpctp.pblb.imximg = $(board)/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg
+FILE_barebox-imx6q-vtpctp.img = start_imx6q_vtpctp.pblb.imximg
+image-$(CONFIG_MACH_WAGO_VTPCTP_MX6) += barebox-imx6q-vtpctp.img
+
 # ----------------------- i.MX7 based boards ---------------------------
 pblb-$(CONFIG_MACH_AC_SXB) += start_ac_sxb
 CFG_start_ac_sxb.pblb.imximg = $(board)/ac-sxb/flash-header-mx7d-lpddr2.imxcfg
diff --git a/images/Makefile.stm32mp b/images/Makefile.stm32mp
index 3384f5014bb..7b74408d481 100644
--- a/images/Makefile.stm32mp
+++ b/images/Makefile.stm32mp
@@ -32,3 +32,8 @@ pblb-$(CONFIG_MACH_STM32MP15X_EV1) += start_stm32mp15x_ev1
 FILE_barebox-stm32mp15x-ev1.img = start_stm32mp15x_ev1.pblb.stm32
 OPTS_start_stm32mp15x_ev1.pblb.stm32 = $(STM32MP1_OPTS)
 image-$(CONFIG_MACH_STM32MP15X_EV1) += barebox-stm32mp15x-ev1.img
+
+pblb-$(CONFIG_MACH_STM32MP151_CC100) += start_stm32mp151_cc100
+FILE_barebox-stm32mp151-cc100.img = start_stm32mp151_cc100.pblb.stm32
+OPTS_start_stm32mp151_cc100.pblb.stm32 = $(STM32MP1_OPTS)
+image-$(CONFIG_MACH_STM32MP151_CC100) += barebox-stm32mp151-cc100.img
diff --git a/include/blspec.h b/include/blspec.h
index 37076cd47c9..6815943de92 100644
--- a/include/blspec.h
+++ b/include/blspec.h
@@ -23,5 +23,6 @@ int blspec_scan_devices(struct bootentries *bootentries);
 int blspec_scan_device(struct bootentries *bootentries, struct device_d *dev);
 int blspec_scan_devicename(struct bootentries *bootentries, const char *devname);
 int blspec_scan_directory(struct bootentries *bootentries, const char *root);
+int blspec_scan_file(struct bootentries *bootentries, const char *file);
 
 #endif /* __LOADER_H__ */
diff --git a/include/bootmatrix.h b/include/bootmatrix.h
new file mode 100644
index 00000000000..b71121aae29
--- /dev/null
+++ b/include/bootmatrix.h
@@ -0,0 +1,13 @@
+#ifndef __BOOTMATRIX_H
+#define __BOOTMATRIX_H
+
+enum bootmatrix_mode {
+	UNKNOWN = 0,
+	DEFAULT,
+	PRODUCTION,
+	SETUPFW,
+};
+
+enum bootmatrix_mode bootmatrix_get_mode(void);
+
+#endif /* __BOOTMATRIX_H */
diff --git a/include/globalvar.h b/include/globalvar.h
index 476bb920f3e..80009f56412 100644
--- a/include/globalvar.h
+++ b/include/globalvar.h
@@ -100,6 +100,7 @@ static inline char *globalvar_get_match(const char *match, const char *separator
 }
 
 static inline void globalvar_set_match(const char *match, const char *val) {}
+static inline void globalvar_set(const char *name, const char *val) {}
 
 static inline int nvvar_load(void)
 {
diff --git a/include/led_mode.h b/include/led_mode.h
new file mode 100644
index 00000000000..6a4e259f699
--- /dev/null
+++ b/include/led_mode.h
@@ -0,0 +1,10 @@
+#ifndef __LED_MODE_H
+#define __LED_MODE_H
+
+/* valid color strings are: red, green, yellow */
+int led_mode_static(char *color, bool state);
+
+/* valid color strings are: red, green */
+int led_mode_moving(char *color, unsigned int duration_ms, bool turn_off_anc);
+
+#endif /* __LED_MODE_H */
diff --git a/include/mci.h b/include/mci.h
index 922aeaecf3d..4c72fb1bc03 100644
--- a/include/mci.h
+++ b/include/mci.h
@@ -404,9 +404,11 @@ struct mci_host {
 	unsigned max_req_size;
 	unsigned dsr_val;	/**< optional dsr value */
 	int use_dsr;		/**< optional dsr usage flag */
+	int cd_gpio;		/**< card detection gpio pin */
 	bool non_removable;	/**< device is non removable */
 	bool no_sd;		/**< do not send SD commands during initialization */
 	bool disable_wp;	/**< ignore write-protect detection logic */
+	bool cd_inverted;	/**< inverts cd_gpio value */
 	struct regulator *supply;
 
 	/** init the host interface */
@@ -462,7 +464,11 @@ struct mci {
 	int dsr_imp;		/**< DSR implementation state from CSD */
 	u8 *ext_csd;
 	int probe;
+	int cd;
+	int scan;
 	struct param_d *param_boot;
+	struct param_d *param_cd;
+	struct param_d *param_scan;
 	int bootpart;
 
 	struct mci_part part[MMC_NUM_PHY_PARTITION];
diff --git a/include/xsection.h b/include/xsection.h
new file mode 100644
index 00000000000..dfb3708dcba
--- /dev/null
+++ b/include/xsection.h
@@ -0,0 +1,19 @@
+#ifndef __XSECTION_H
+#define __XSECTION_H
+
+int xsection_get_boot_mode_id(u8 *buf);
+int xsection_set_boot_mode_id(u8 *value);
+
+int xsection_get_boot_mode_id_ext(u8 *buf);
+int xsection_set_boot_mode_id_ext(u8 *value);
+
+int xsection_get_devconf(u16 *buf);
+int xsection_set_devconf(u16 *value);
+
+int xsection_get_ethaddr1(u8 ethaddr[6]);
+int xsection_set_ethaddr1(u8 ethaddr[6]);
+
+int xsection_get_ethaddr2(u8 ethaddr[6]);
+int xsection_set_ethaddr2(u8 ethaddr[6]);
+
+#endif /* __XSECTION_H */
diff --git a/jenkins/Makefile b/jenkins/Makefile
new file mode 100644
index 00000000000..a96fdc5ef40
--- /dev/null
+++ b/jenkins/Makefile
@@ -0,0 +1,191 @@
+# Usage:
+#
+#      make -f jenkins/Makefile CROSS_COMPILE <target>
+# i.e. make -f jenkins/Makefile CROSS_COMPILE=/opt/LINARO.Toolchain.2017.10/arm-linux-gnueabihf/bin/arm-linux-gnueabihf- \
+#								images/arm/configs/am335x_pfc_defconfig images/arm/configs/am335x_pfc_mlo_defconfig
+#
+# or
+#
+#      make -f jenkins/Makefile [all|clean|...] DEFCONFIG="<defconfig1> <defconfig2>"
+# i.e. make -f jenkins/Makefile CROSS_COMPILE=/opt/LINARO.Toolchain-2017.10/arm-linux-gnueabihf/bin/arm-linux-gnueabihf- \
+#							    DEFCONFIG="arm/configs/am335x_pfc_defconfig arm/configs/am335x_pfc_mlo_defconfig" \
+#							    dist
+#
+# CROSS_COMPILE = default empty
+# ARCH = default auto detect using device config
+# VERBOSE = default off
+
+SHELL := /bin/sh
+
+.PHONY: default
+default: all
+
+space := 
+space += 
+
+TOOLCHAIN_PREFIX = 
+CROSS_COMPILE ?= $(TOOLCHAIN_PREFIX)
+ARCH ?= $(firstword $(subst /,$(space),$(DEFCONFIG)))
+
+VERBOSE =
+BUILDDIR = .build
+SRCDIR = .
+PROJECTNAME = $(notdir $(realpath $(SRCDIR)))
+SNAPSHOT_SUFFIX ?= $(addprefix -next.,$(SNAPSHOT))
+
+CONFIGURE_TARGETS  =
+CONFIGURE_TARGETS += $(addprefix $(BUILDDIR),$(defconfigsuffix))
+
+BUILD_TARGETS  =
+BUILD_TARGETS += $(kbuild_buildtargets)
+
+CHECK_TARGETS  =
+
+DIST_TARGETS  = 
+DIST_TARGETS += package_source
+DIST_TARGETS += package_binaries
+
+CLEAN_TARGETS  =
+CLEAN_TARGETS += $(addprefix clean,$(defconfigsuffix))
+
+#INSTALL_TARGETS  =
+#INSTALL_TARGETS += $(addprefix install,$(defconfigsuffix))
+
+########################################################################################################################
+# Internal macros and definitions
+packagesource_excludes  = 
+packagesource_excludes += '.git'
+packagesource_excludes += '.git/*'
+packagesource_excludes += 'jenkins'
+packagesource_excludes += 'jenkins/*'
+packagesource_excludes += '$(BUILDDIR)'
+packagesource_excludes += '$(BUILDDIR)/*'
+
+defconfigdir = $(SRCDIR)/arch
+defconfigfiles = $(shell find $(defconfigdir) -type f -name '*_defconfig')
+defconfigs = $(patsubst $(defconfigdir)/%,%,$(defconfigfiles))
+defconfigsuffix = $(addprefix /,$(filter $(DEFCONFIG),$(defconfigs)))
+
+kbuild_configuretargets  =
+kbuild_configuretargets += $(addprefix $(BUILDDIR)/,$(defconfigs))
+
+kbuild_buildtargets  = images
+
+kbuild_targets  = $(kbuild_buildtargets)
+kbuild_targets += clean
+
+# $(call makecmd,outputdir,targets[,makeflags])
+makecmd = $(MAKE) $(MFLAGS) $3 '-C$(SRCDIR)' 'O=$1' $2
+# $(call tgzcmd,outputfile,inputdir[,archive-root][,excludes...][,inputs])
+tgzcmd = tar \
+  -P \
+  -I 'gzip -n' \
+  --sort name \
+  $(addprefix --mtime @,$(SOURCE_DATE_EPOCH)) \
+  --owner 0 \
+  --group 0 \
+  $(addprefix --exclude ,$4) \
+  --transform 's/$(subst /,\/,$(realpath $2))/$(subst /,\/,$(or $3,$(notdir $2)))/' \
+  -cvf \
+  $1 \
+  $(realpath $(or $(wildcard $(addprefix $2/,$5)),$2))
+
+# $(call stage_suffix,defconfig)
+stage_suffix = $(if $(findstring _mlo_,$(lastword $(subst /,$(space),$(1)))),-mlo,)
+
+# Force eager evaluation
+defconfigs := $(defconfigs)
+VERSIONSUFFIX := $(VERSIONSUFFIX)
+CROSS_COMPILE := $(CROSS_COMPILE)
+
+ifeq ($(VERBOSE),1)
+  Q =
+else
+  Q = @
+endif
+
+ifeq ($(strip $(MAKE_RESTARTS)),)
+  ifeq ($(strip $(ARCH)),)
+    $(error ARCH='$(ARCH)' invalid)
+  endif
+  ifeq ($(strip $(defconfigsuffix)),)
+    $(info DEFCONFIG='$(DEFCONFIG)' not found)
+  endif
+endif
+
+export ARCH
+export CROSS_COMPILE
+
+########################################################################################################################
+# Rules
+
+-include $(BUILDDIR)/rules.mk
+
+.PHONY: configure all check dist install clean distclean
+
+$(BUILDDIR)/rules.mk: $(defconfigfiles) $(filter-out $(BUILDDIR)/rules.mk,$(MAKEFILE_LIST)) | $(BUILDDIR)
+	@ \
+	{ \
+	  printf '.NOTPARALLEL:\n'; \
+	  $(foreach target,$(kbuild_targets), \
+	    printf '.PHONY: $(target)\n'; \
+	    printf   '$(target) : $$(addprefix $(target),$$(defconfigsuffix))\n'; \
+	    printf   '\n'; \
+	    $(foreach defconfig,$(defconfigs), \
+	      printf '.PHONY: $(target)/$(defconfig)\n'; \
+	      printf '$(target)/$(defconfig): $$(MAKEFILE_LIST) | $$(BUILDDIR)/$(defconfig)\n'; \
+	      printf   '\t+$$(Q)$$(call makecmd,$$(BUILDDIR)/$(defconfig),$(target) $$(MAKEOVERRIDES))\n'; \
+	      printf   '\n'; \
+	    ) \
+	  ) \
+	} > $@
+	@{ \
+	  printf '\n'; \
+	  $(foreach defconfig,$(defconfigs), \
+	  printf '.PHONY: $$(BUILDDIR)/$(defconfig)/barebox-Binaries.tgz\n'; \
+	    printf '$$(BUILDDIR)/$(defconfig)/barebox-Binaries.tgz: $$(BUILDDIR)/$(defconfig)/include/config/kernel.release $(addsuffix /$(defconfig),images) $$(MAKEFILE_LIST) | $$(BUILDDIR)/$(defconfig)\n'; \
+		printf   '\t$$(Q)$$(call tgzcmd,$$@,$$(BUILDDIR)/$(defconfig)/images,,$$(packagebinary_excludes),*.img) \\\n'; \
+	    printf   '\t  && cp -f $$(abspath $$@) $$(BUILDDIR)/$(defconfig)/barebox-Binaries$(call stage_suffix,$(defconfig))-"$$$$(cat $$<)"$$(SNAPSHOT_SUFFIX).tgz\n'; \
+	    printf   '\n'; \
+	    printf '.PHONY: $$(BUILDDIR)/$(defconfig)/barebox-Source.tgz\n'; \
+	    printf '$$(BUILDDIR)/$(defconfig)/barebox-Source.tgz: $$(BUILDDIR)/$(defconfig)/include/config/kernel.release $$(BUILDDIR)/barebox-Source.tgz $$(MAKEFILE_LIST) | $$(BUILDDIR)/$(defconfig)\n'; \
+	    printf   '\t$$(Q)cp -f $$(abspath $$(BUILDDIR)/barebox-Source.tgz) $$(BUILDDIR)/$(defconfig)/barebox-Source-"$$$$(cat $$<)"$$(SNAPSHOT_SUFFIX).tgz\n'; \
+	    printf   '\n'; \
+		printf '$$(BUILDDIR)/$(defconfig)/include/config/kernel.release:\n'; \
+	    printf   '\t+$$(Q)$$(call makecmd,$$(BUILDDIR)/$(defconfig),include/config/kernel.release $$(MAKEOVERRIDES))\n'; \
+	    printf   '\n'; \
+	    ) \
+	} >> $@
+
+$(kbuild_configuretargets): $(MAKEFILE_LIST)
+	+$(Q)$(call makecmd,$@,$(notdir $@) $(MAKEOVERRIDES))
+
+.PHONY: $(BUILDDIR)/barebox-Source.tgz
+$(BUILDDIR)/barebox-Source.tgz: $(SRCDIR) $(MAKEFILE_LIST)
+	$(Q)$(call tgzcmd,$@,$<,$(PROJECTNAME),$(packagesource_excludes))
+
+.PHONY: package_binaries
+package_binaries: $(addsuffix /barebox-Binaries.tgz,$(addprefix $(BUILDDIR),$(defconfigsuffix)))
+
+.PHONY: package_source
+package_source : $(addsuffix /barebox-Source.tgz,$(addprefix $(BUILDDIR),$(defconfigsuffix)))
+
+configure: $(CONFIGURE_TARGETS)
+
+all: $(BUILD_TARGETS)
+
+check: $(CHECK_TARGETS)
+
+dist: configure $(DIST_TARGETS)
+
+clean: $(CLEAN_TARGETS)
+
+distclean:
+	$(Q)-rm -rf $(BUILDDIR)
+
+$(BUILDDIR):
+	$(Q)mkdir -p $@
+
+debug-print-%:
+	@printf '%s:\n' $*; \
+	 printf '%s\n' $($*)
diff --git a/jenkins/am335x_pfc.jenkinsfile b/jenkins/am335x_pfc.jenkinsfile
new file mode 100644
index 00000000000..1ab9e95c1a0
--- /dev/null
+++ b/jenkins/am335x_pfc.jenkinsfile
@@ -0,0 +1,94 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "am335x_pfc"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig", "arm/configs/${defConfigName}_mlo_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*",
+                                        ".build/${defConfigs[1]}/images/*.img",
+                                        ".build/${defConfigs[1]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'oliver.rohe@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/jenkins/am335x_pfc_adv.jenkinsfile b/jenkins/am335x_pfc_adv.jenkinsfile
new file mode 100644
index 00000000000..8aef0a8dfaa
--- /dev/null
+++ b/jenkins/am335x_pfc_adv.jenkinsfile
@@ -0,0 +1,94 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "am335x_pfc_adv"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig", "arm/configs/${defConfigName}_mlo_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*",
+                                        ".build/${defConfigs[1]}/images/*.img",
+                                        ".build/${defConfigs[1]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'heinrich.toews@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/jenkins/am35xx_pfc.jenkinsfile b/jenkins/am35xx_pfc.jenkinsfile
new file mode 100644
index 00000000000..c4ceb27ba85
--- /dev/null
+++ b/jenkins/am35xx_pfc.jenkinsfile
@@ -0,0 +1,94 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "am35xx_pfc"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig", "arm/configs/${defConfigName}_mlo_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*",
+                                        ".build/${defConfigs[1]}/images/*.img",
+                                        ".build/${defConfigs[1]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'heinrich.toews@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/jenkins/imx6_vtpctp.jenkinsfile b/jenkins/imx6_vtpctp.jenkinsfile
new file mode 100644
index 00000000000..9eb65dd1539
--- /dev/null
+++ b/jenkins/imx6_vtpctp.jenkinsfile
@@ -0,0 +1,92 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "imx6_vtpctp"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'heinrich.toews@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/jenkins/stm32mp1_cc100.jenkinsfile b/jenkins/stm32mp1_cc100.jenkinsfile
new file mode 100644
index 00000000000..20b48faddea
--- /dev/null
+++ b/jenkins/stm32mp1_cc100.jenkinsfile
@@ -0,0 +1,92 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "stm32mp_cc100"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'oliver.rohe@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/localversion-wago b/localversion-wago
new file mode 100644
index 00000000000..acd29a52237
--- /dev/null
+++ b/localversion-wago
@@ -0,0 +1 @@
+w04.00.00_14
