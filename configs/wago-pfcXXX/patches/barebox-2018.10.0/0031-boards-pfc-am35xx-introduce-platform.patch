From dafb6d808683e512f33b6a67ac4053aef772e3db Mon Sep 17 00:00:00 2001
From: Heinrich Toews <heinrich.toews@wago.com>
Date: Mon, 18 Jun 2018 13:50:30 +0200
Subject: [PATCH] boards: pfc-am35xx: introduce platform

This commit introduces the wago pfc-am35xx based platform
which covers 820x products that implement the AM3505 SoC.

As the first stage loader (MLO) must reside in a 64k SRAM
it was not possible to shrink the code in a way that OFTREE
support would fit in it. This means the whole device
registration must be held in the board code.

Also the 2nd stage loader is registering some devices in
board code as e.g. davinci emac driver supports no OFTREE.

This code is prepared to use the bootchooser framework
and boots into Shell.

Signed-off-by: Heinrich Toews <heinrich.toews@wago.com>
---
 arch/arm/boards/Makefile                           |   1 +
 arch/arm/boards/wago-pfc-am35xx/Makefile           |  13 +
 arch/arm/boards/wago-pfc-am35xx/board-mlo.c        | 126 +++++
 arch/arm/boards/wago-pfc-am35xx/board.c            | 302 +++++++++++
 .../init/d-pfc-setup-board-env                     |   6 +
 arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c     | 451 ++++++++++++++++
 arch/arm/boards/wago-pfc-am35xx/lowlevel.c         |  94 ++++
 arch/arm/boards/wago-pfc-am35xx/nand_ids.c         |  45 ++
 arch/arm/boards/wago-pfc-am35xx/pfcxxx.h           |  37 ++
 arch/arm/configs/am35xx_pfc200_defconfig           | 127 +++++
 arch/arm/configs/am35xx_pfc200_xload_defconfig     |  37 ++
 arch/arm/dts/Makefile                              |   2 +-
 arch/arm/dts/am35xx-pfc-750_820x.dts               | 577 +++++++++++++++++++++
 arch/arm/dts/am3xxx-pfc-nandparts.dtsi             |  98 ++--
 arch/arm/mach-omap/Kconfig                         |   9 +
 arch/arm/mach-omap/include/mach/emif4.h            |  79 +++
 arch/arm/mach-omap/include/mach/omap3-mux.h        |  49 +-
 arch/arm/tools/mach-types                          |   1 +
 images/Makefile                                    |   1 +
 images/Makefile.am35xx                             |  28 +
 include/net/davinci_emac.h                         |  10 +
 21 files changed, 2043 insertions(+), 50 deletions(-)
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/Makefile
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/board-mlo.c
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/board.c
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/lowlevel.c
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/nand_ids.c
 create mode 100644 arch/arm/boards/wago-pfc-am35xx/pfcxxx.h
 create mode 100644 arch/arm/configs/am35xx_pfc200_defconfig
 create mode 100644 arch/arm/configs/am35xx_pfc200_xload_defconfig
 create mode 100644 arch/arm/dts/am35xx-pfc-750_820x.dts
 create mode 100644 arch/arm/mach-omap/include/mach/emif4.h
 create mode 100644 images/Makefile.am35xx
 create mode 100644 include/net/davinci_emac.h

diff --git a/arch/arm/boards/Makefile b/arch/arm/boards/Makefile
index a8b9344..895191d 100644
--- a/arch/arm/boards/Makefile
+++ b/arch/arm/boards/Makefile
@@ -155,3 +155,4 @@ obj-$(CONFIG_MACH_ZII_RDU1)			+= zii-imx51-rdu1/
 obj-$(CONFIG_MACH_ZII_RDU2)			+= zii-imx6q-rdu2/
 obj-$(CONFIG_MACH_ZII_VF610_DEV)		+= zii-vf610-dev/
 obj-$(CONFIG_MACH_WAGO_PFC_AM335X)		+= wago-pfc-am335x/
+obj-$(CONFIG_MACH_WAGO_PFC_AM35XX)		+= wago-pfc-am35xx/
diff --git a/arch/arm/boards/wago-pfc-am35xx/Makefile b/arch/arm/boards/wago-pfc-am35xx/Makefile
new file mode 100644
index 0000000..180ca5a
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/Makefile
@@ -0,0 +1,13 @@
+# ifdef CONFIG_OMAP_BUILD_IFT
+# lwl-y += lowlevel-mlo.o
+# obj-y += board-mlo.o
+# else
+lwl-y += lowlevel-mlo.o lowlevel.o
+ifdef CONFIG_OMAP_BUILD_IFT
+obj-y += board-mlo.o
+else
+obj-y += board.o
+endif
+obj-$(CONFIG_NAND_USE_CUSTOM_IDS) += nand_ids.o
+# endif
+bbenv-y += defaultenv-pfc-am35xx
diff --git a/arch/arm/boards/wago-pfc-am35xx/board-mlo.c b/arch/arm/boards/wago-pfc-am35xx/board-mlo.c
new file mode 100644
index 0000000..f72d1d3
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/board-mlo.c
@@ -0,0 +1,126 @@
+/**
+ * @file
+ * @brief Board Initialization routines for PFC200.
+ *
+ * This board is based on OMAP3530.
+ * More on OMAP3530 (including documentation can be found here):
+ * http://focus.ti.com/docs/prod/folders/print/omap3530.html
+ *
+ * This file provides initialization in two stages:
+ * @li Boot time initialization - just get SDRAM working.
+ * This is run from SRAM - so no case constructs and global vars can be used.
+ * @li Run time initialization - this is for the rest of the initializations
+ * such as flash, uart etc.
+ *
+ * Boot time initialization includes:
+ * @li SDRAM initialization.
+ * @li Pin Muxing relevant for the EVM.
+ *
+ * Run time initialization includes
+ * @li serial @ref serial_ns16550.c driver device definition
+ *
+ * Originally from arch/arm/boards/omap/board-beagle.c
+ */
+
+/*
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Sanjeev Premi <premi@ti.com>
+ *
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#include <bootsource.h>
+#include <common.h>
+#include <console.h>
+#include <init.h>
+#include <driver.h>
+#include <io.h>
+#include <linux/sizes.h>
+#include <config/driver/serial/ns16550.h>
+#include <asm/armlinux.h>
+#include <mach/omap3-silicon.h>
+#include <mach/omap3-mux.h>
+#include <mach/gpmc.h>
+#include <mach/gpmc_nand.h>
+#include <errno.h>
+#include <generated/mach-types.h>
+#include <mach/omap3-devices.h>
+#include <mach/generic.h>
+
+/* map first four erase blocks */
+static struct omap_barebox_part pfc200_mlo_part = {
+	/* start of boot0..boot3 (stage2 bootcode),
+	 * we have 4x partitions
+	 */
+	.nand_offset = 4 * SZ_128K,
+	.nand_size = 4 * SZ_128K,
+};
+
+/**
+ * @brief Initialize the serial port to be used as console.
+ *
+ * @return result of device registration
+ */
+static int pfc200_init_console(void)
+{
+	barebox_set_model("Wago PFC200 MLO Stage #1");
+	barebox_set_hostname("pfc200-mlo");
+
+	omap3_add_uart3();
+
+	return 0;
+}
+console_initcall(pfc200_init_console);
+
+static int pfc200_mem_init(void)
+{
+	omap_add_ram0(SZ_256M);
+
+	return 0;
+}
+mem_initcall(pfc200_mem_init);
+
+static struct gpmc_nand_platform_data nand_plat = {
+	.cs = 0,
+	.device_width = 8,
+	.ecc_mode = OMAP_ECC_BCH8_CODE_HW_DETECTION_SW,
+	.nand_cfg = &omap3_nand_cfg,
+};
+
+static int pfc200_init_devices(void)
+{
+#ifdef CONFIG_OMAP_GPMC
+	/*
+	 * WP is made high and WAIT1 active Low
+	 */
+	gpmc_generic_init(0x10);
+#endif
+	omap_add_gpmc_nand_device(&nand_plat);
+	omap_set_barebox_part(&pfc200_mlo_part);
+
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
+	}
+
+	omap3_add_mmc1(NULL);
+
+        armlinux_set_architecture(MACH_TYPE_PFC_AM35XX);
+
+	return 0;
+}
+device_initcall(pfc200_init_devices);
diff --git a/arch/arm/boards/wago-pfc-am35xx/board.c b/arch/arm/boards/wago-pfc-am35xx/board.c
new file mode 100644
index 0000000..fc13c3c
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/board.c
@@ -0,0 +1,302 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Raghavendra KH <r-khandenahally@ti.com>
+ *
+ * Copyright (C) 2012 Jan Luebbe <j.luebbe@pengutronix.de>
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/**
+ * @file
+ * @brief PFCxxx Specific Board Initialization routines
+ */
+
+#include <bootsource.h>
+#include <common.h>
+#include <init.h>
+#include <driver.h>
+#include <envfs.h>
+#include <environment.h>
+#include <globalvar.h>
+#include <linux/sizes.h>
+#include <net.h>
+#include <envfs.h>
+#include <bootsource.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/gpmc.h>
+#include <linux/err.h>
+#include <gpio.h>
+
+#include <net/davinci_emac.h>
+#include <mach/emac_defs.h>
+#include <mach/omap3-devices.h>
+
+#include <mach/am33xx-clock.h>
+#include <mach/omap3-devices.h>
+#include <mach/bbu.h>
+#include <globalvar.h>
+#include <xsection.h>
+
+#include "pfcxxx.h"
+
+#define PFCXXX_AM35XX_GPIO_SEL_RS232_EN 176 /* 0:RS485 1:RS232 */
+
+static struct omap_barebox_part pfc_barebox_part = {
+	.nand_offset = SZ_512K,
+	.nand_size = SZ_512K,
+};
+
+static char *xloadslots[] = {
+	"/dev/nand0.mlo0.bb",
+	"/dev/nand0.mlo1.bb",
+	"/dev/nand0.mlo2.bb",
+	"/dev/nand0.mlo3.bb"
+};
+
+static char *nandslots[] = {
+	"/dev/nand0.boot0.bb",
+	"/dev/nand0.boot1.bb",
+	"/dev/nand0.boot2.bb",
+	"/dev/nand0.boot3.bb"
+};
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+
+static int pfc200_coredevice_init(void)
+{
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
+		return 0;
+
+	return 0;
+}
+coredevice_initcall(pfc200_coredevice_init);
+
+static int pfc200_mem_init(void)
+{
+	uint32_t sdram_size;
+
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
+		return 0;
+
+	sdram_size = SZ_256M;
+
+	arm_add_mem_device("ram0", 0x80000000, sdram_size);
+	return 0;
+}
+mem_initcall(pfc200_mem_init);
+
+#define SZ_2K				0x00000800
+static struct resource pfc_emac_resources[] = {
+	{
+		.start	= EMAC_BASE_ADDR,
+		.end	= EMAC_BASE_ADDR + SZ_2K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= EMAC_WRAPPER_BASE_ADDR,
+		.end	= EMAC_WRAPPER_BASE_ADDR + 0xFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= EMAC_MDIO_BASE_ADDR,
+		.end	= EMAC_MDIO_BASE_ADDR + 0xFF,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= EMAC_WRAPPER_RAM_ADDR,
+		.end	= EMAC_WRAPPER_RAM_ADDR + SZ_8K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+struct davinci_emac_platform_data pfc_emac_pdata = {
+	.phy_addr = 0x2, 	/* htoews: FIXME: we support only the first one? */
+	.force_link = 0,  	/* set to '1' if problems occur */
+	.interface_rmii = 1,
+};
+
+struct device_d pfc_emac_device = {
+	.id		= DEVICE_ID_DYNAMIC,
+	.name		= "davinci_emac",
+	.num_resources	= ARRAY_SIZE(pfc_emac_resources),
+	.resource	= pfc_emac_resources,
+	.platform_data	= &pfc_emac_pdata,
+};
+
+#if 0
+static int pfcxxx_am35xx_console_init(int uart)
+{
+	switch(uart)
+	{
+		default:
+		case 1: /* ttyO0 */
+			gpio_direction_output(PFCXXX_AM35XX_GPIO_SEL_RS232_EN, 1);
+			omap3_add_uart1();
+		break;
+
+		case 2:
+			omap3_add_uart2();
+		break;
+
+		case 3: /* ttyO2 */
+			omap3_add_uart3();
+		break;
+	}
+
+	return 0;
+}
+#endif
+
+static int pfc_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static int pfc_export_board_variant(void)
+{
+	struct device_node *root;
+	int ret;
+	char const *variant;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string(root, "board-variant", &variant);
+	if (ret < 0)
+		goto out;
+
+	ret = globalvar_add_simple("board.variant", variant);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int pfc_rewrite_compatible(void)
+{
+	struct device_node *root;
+	int ret;
+	u16 devconf;
+	char const *first_compat_str;
+	char *new_string;
+
+	ret = xsection_get_devconf(&devconf);
+	if (ret < 0)
+		goto out;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string_index(root, "compatible", 0, &first_compat_str);
+	if (ret < 0)
+		goto out;
+
+	new_string = basprintf("%s-%04x", first_compat_str, devconf);
+	if (!new_string) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = of_property_write_string(root, "compatible", new_string);
+	free(new_string);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int pfc200_devices_init(void)
+{
+	int ret;
+
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
+		return 0;
+
+	/* Do this also in mlo, because the pfc startup code needs this
+	 * information to get the right barebox image.
+	 */
+	ret = pfc_export_board_variant();
+	if (ret < 0)
+		pr_err("failed to export board.variant\n");
+
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
+	}
+
+	am33xx_bbu_emmc_mlo_register_handler("mlo.emmc", "/dev/mmc1");
+	am33xx_bbu_nand_xloadslots_register_handler("mlo.nand",
+					xloadslots, ARRAY_SIZE(xloadslots));
+	am33xx_bbu_nand_slots_register_handler("barebox.nand", nandslots,
+							ARRAY_SIZE(nandslots));
+
+	printf("register davinci emac driver via old method\n");
+	platform_device_register(&pfc_emac_device);
+
+	omap_set_barebox_part(&pfc_barebox_part);
+	defaultenv_append_directory(defaultenv_pfc_am35xx);
+
+	armlinux_set_architecture(MACH_TYPE_PFC_AM35XX);
+	barebox_set_hostname("pfc");
+
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		/* Set MAC address for ethernet0 from eeprom. If no valid MAC
+		 * address could read, use the randomized one. Dont do this in
+		 * mlo, because this is useless there.
+		 */
+		ret = pfc_set_ethaddr();
+		if (ret < 0) {
+			pr_info("no valid ethaddr in eeprom found. Using "
+				"randomized MAC address\n");
+		}
+	}
+
+	/* Rewrite the compatible string in the internal barebox device-tree
+	 * (located in ram), and add the eeprom devconf as suffix. This string
+	 * is used by the bootloader-spec module to search for correct bootloader-spec
+	 * entry to load the corrosponding kernel device-tree.
+	 */
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		ret = pfc_rewrite_compatible();
+		if (ret < 0)
+			pr_err("failed to rewrite the internal compatible string "
+				"with devconf from eeprom \n");
+	}
+
+	return 0;
+}
+device_initcall(pfc200_devices_init);
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env
new file mode 100644
index 0000000..1fb15ef
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+# put here board specific variables or overwrite global variables
+
+global.pfc.linux_uart="0"
+
diff --git a/arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c b/arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c
new file mode 100644
index 0000000..71233c8
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c
@@ -0,0 +1,451 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <io.h>
+#include <init.h>
+#include <linux/sizes.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/generic.h>
+#include <mach/omap3-mux.h>
+#include <mach/sdrc.h>
+#include <mach/control.h>
+#include <mach/syslib.h>
+#include <mach/omap3-silicon.h>
+#include <mach/omap3-generic.h>
+#include <mach/sys_info.h>
+#include <asm/common.h>
+#include <asm-generic/memory_layout.h>
+#include <mach/omap3-devices.h>
+#include <debug_ll.h>
+#include <mach/omap3-clock.h>
+
+#include "pfcxxx.h"
+/*
+ * Boot-time initialization(s)
+ */
+
+#include <mach/emif4.h>
+
+/* Code from U-Boot 2012.07 */
+/* EMIF4 */
+typedef struct emif4 {
+	unsigned int emif_mod_id_rev;
+	unsigned int sdram_sts;
+	unsigned int sdram_config;
+	unsigned int res1;
+	unsigned int sdram_refresh_ctrl;
+	unsigned int sdram_refresh_ctrl_shdw;
+	unsigned int sdram_time1;
+	unsigned int sdram_time1_shdw;
+	unsigned int sdram_time2;
+	unsigned int sdram_time2_shdw;
+	unsigned int sdram_time3;
+	unsigned int sdram_time3_shdw;
+	unsigned char res2[8];
+	unsigned int sdram_pwr_mgmt;
+	unsigned int sdram_pwr_mgmt_shdw;
+	unsigned char res3[32];
+	unsigned int sdram_iodft_tlgc;
+	unsigned char res4[128];
+	unsigned int ddr_phyctrl1;
+	unsigned int ddr_phyctrl1_shdw;
+	unsigned int ddr_phyctrl2;
+} emif4_t;
+
+static emif4_t *emif4_base = (emif4_t *)OMAP3_SDRC_BASE;
+
+/*
+ * do_pac200_emif4_init -
+ *  - Init the emif4 module for DDR access
+ *  - Early init routines, called from flash or SRAM.
+ */
+void emif4_init(void)
+{
+	unsigned int regval;
+	/* Set the DDR PHY parameters in PHY ctrl registers */
+	regval = (EMIF4_DDR1_READ_LAT | EMIF4_DDR1_PWRDN_DIS |
+		EMIF4_DDR1_EXT_STRB_DIS);
+	writel(regval, &emif4_base->ddr_phyctrl1);
+	writel(regval, &emif4_base->ddr_phyctrl1_shdw);
+	writel(0, &emif4_base->ddr_phyctrl2);
+
+	/* Reset the DDR PHY and wait till completed */
+	regval = readl(&emif4_base->sdram_iodft_tlgc);
+	regval |= (1<<10);
+	writel(regval, &emif4_base->sdram_iodft_tlgc);
+	/*Wait till that bit clears*/
+	while ((readl(&emif4_base->sdram_iodft_tlgc) & (1<<10)) == 0x1);
+	/*Re-verify the DDR PHY status*/
+	while ((readl(&emif4_base->sdram_sts) & (1<<2)) == 0x0);
+
+	regval |= (1<<0);
+	writel(regval, &emif4_base->sdram_iodft_tlgc);
+	/* Set SDR timing registers */
+	regval = (EMIF4_TIM1_T_WTR | EMIF4_TIM1_T_RRD |
+		EMIF4_TIM1_T_RC | EMIF4_TIM1_T_RAS |
+		EMIF4_TIM1_T_WR | EMIF4_TIM1_T_RCD |
+		EMIF4_TIM1_T_RP);
+	writel(regval, &emif4_base->sdram_time1);
+	writel(regval, &emif4_base->sdram_time1_shdw);
+
+	regval = (EMIF4_TIM2_T_CKE | EMIF4_TIM2_T_RTP |
+		EMIF4_TIM2_T_XSRD | EMIF4_TIM2_T_XSNR |
+		EMIF4_TIM2_T_ODT | EMIF4_TIM2_T_XP);
+	writel(regval, &emif4_base->sdram_time2);
+	writel(regval, &emif4_base->sdram_time2_shdw);
+
+	regval = (EMIF4_TIM3_T_RAS_MAX | EMIF4_TIM3_T_RFC);
+	writel(regval, &emif4_base->sdram_time3);
+	writel(regval, &emif4_base->sdram_time3_shdw);
+
+	/* Set the PWR control register */
+	regval = (EMIF4_PWR_PM_TIM | EMIF4_PWR_LP_MODE |
+		EMIF4_PWR_DPD_DIS | EMIF4_PWR_IDLE_MODE);
+	writel(regval, &emif4_base->sdram_pwr_mgmt);
+	writel(regval, &emif4_base->sdram_pwr_mgmt_shdw);
+
+	/* Set the DDR refresh rate control register */
+	regval = (EMIF4_REFRESH_RATE | EMIF4_INITREF_DIS);
+	writel(regval, &emif4_base->sdram_refresh_ctrl);
+	writel(regval, &emif4_base->sdram_refresh_ctrl_shdw);
+
+	/* set the SDRAM configuration register */
+	regval = (EMIF4_CFG_PGSIZE | EMIF4_CFG_EBANK |
+		EMIF4_CFG_IBANK | EMIF4_CFG_ROWSIZE |
+		EMIF4_CFG_CL | EMIF4_CFG_NARROW_MD |
+		EMIF4_CFG_SDR_DRV | EMIF4_CFG_DDR_DIS_DLL |
+		EMIF4_CFG_DDR2_DDQS | EMIF4_CFG_DDR_TERM |
+		EMIF4_CFG_IBANK_POS | EMIF4_CFG_SDRAM_TYP);
+	writel(regval, &emif4_base->sdram_config);
+
+
+}
+
+#define PFC200_MUX_DDR2
+#define PFC200_MUX_GPMC
+#undef PFC200_MUX_EMAC
+
+/**
+ * @brief Do the pin muxing required for Board operation.
+ * We enable ONLY the pins we require to set. OMAP provides pins which do not
+ * have alternate modes. Such pins done need to be set.
+ *
+ * See @ref MUX_VAL for description of the muxing mode.
+ *
+ * @return void
+ */
+void mux_config(void)
+{
+       /*
+	* IEN  - Input Enable
+	* IDIS - Input Disable
+	* PTD  - Pull type Down
+	* PTU  - Pull type Up
+	* DIS  - Pull type selection is inactive
+	* EN   - Pull type selection is active
+	* M0   - Mode 0
+	* The commented string gives the final mux configuration for that pin
+	*/
+
+#ifdef PFC200_MUX_EMAC
+	/* Ethernet Switch: Core */
+	MUX_VAL(CP(D2D_MCAD13),		(IEN  | PTD | DIS | M0));   //    RMII_MDIO_DATA-> RMII_MD_DATA
+	MUX_VAL(CP(D2D_MCAD14),		(IDIS | PTU | EN  | M0));   //    RMII_MDIO_CLK -> RMII_MD_CLK
+	MUX_VAL(CP(D2D_MCAD15),		(IEN  | PTD | DIS | M0));   //    RMII_RXD0     -> RMII_RxD0
+	MUX_VAL(CP(D2D_MCAD16),		(IEN  | PTD | DIS | M0));   //    RMII_RXD1     -> RMII_RxD1
+	MUX_VAL(CP(D2D_MCAD17),		(IEN  | PTD | DIS | M0));   //    RMII_CRS_DV   -> RMII_CRS_DV
+	MUX_VAL(CP(D2D_MCAD18),		(IEN  | PTD | DIS | M0));   //    RMII_RXER     -> RMII_RXER
+	MUX_VAL(CP(D2D_MCAD19), 	(IDIS | PTU | EN  | M0));   //    RMII_TXD0     -> RMII_TxD0
+	MUX_VAL(CP(D2D_MCAD20),		(IEN  | PTD | DIS | M0));   //    RMII_TXD1     -> RMII_TxD1
+	MUX_VAL(CP(D2D_MCAD21),		(IEN  | PTD | DIS | M0));   //    RMII_TXEN     -> RMII_TXEN
+	MUX_VAL(CP(D2D_MCAD22),		(IEN  | PTD | DIS | M0));   //    MII_50MHZ_CLK -> RMII_50MHz_CLK
+	/* ETHERNET SWITCH */
+	MUX_VAL(CP(MMC2_DAT4),		(IDIS | PTU | DIS | M4)); /* nRSTSwitch (GPIO_136) */
+	MUX_VAL(CP(MMC2_DAT6),	        (IEN  | PTD | DIS | M4)); /* nINTSwitch (GPIO_138) */
+#endif
+#ifdef PFC200_MUX_DDR2
+	/* SDRC */
+	MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS0N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_DQS1N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_DQS2N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_DQS3N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_CKE0),		(M0));
+	MUX_VAL(CP(SDRC_CKE1),		(M0));
+	/* sdrc_strben_dly0 */
+	MUX_VAL(CP(STRBEN_DLY0),	(IEN  | PTD | EN  | M0));
+	 /*sdrc_strben_dly1*/
+	MUX_VAL(CP(STRBEN_DLY1),	(IEN  | PTD | EN  | M0));
+#endif /* PFC200_MUX_DDR2 */
+#ifdef PFC200_MUX_GPMC
+	/* GPMC */
+	MUX_VAL(CP(GPMC_A1),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A2),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A3),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A4),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A5),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A6),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A7),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A8),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A9),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A10),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D0),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D1),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D2),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D3),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D4),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D5),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D6),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D7),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D8),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D9),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D10),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D11),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D12),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D13),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D14),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D15),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS4),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_CLK),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_WAIT0),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_WAIT1),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_WAIT2),		(IEN  | PTU | EN  | M4)); /*GPIO_64*/
+							 /* - ETH_nRESET*/
+	MUX_VAL(CP(GPMC_WAIT3),		(IEN  | PTU | EN  | M0));
+#endif /* PFC200_MUX_GPMC */
+	/* MMC */
+	MUX_VAL(CP(MMC1_CLK),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | DIS | M0));
+	/* MMC GPIOs */
+	MUX_VAL(CP(MCBSP2_FSX),		(IEN  | PTD | DIS | M4)); /* McBSP2_FSX    -> SD-MMC1-CD (GPIO_116) */
+	MUX_VAL(CP(MCBSP2_CLKX),	(IDIS | PTU | DIS | M4)); /* McBSP2_CLKX   -> SD-MMC1-EN (GPIO_117) */
+	MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M4)); /* McBSP2_DR     -> SD-MMC1-WP (GPIO_118) */
+	MUX_VAL(CP(MMC2_DAT7),		(IDIS | PTU | DIS | M4)); /* MMC2_DAT7     -> SD-MMC1-RW (GPIO_139) */
+	/* UART1 */
+#ifndef PFC200_UART1_SAFEMODE
+	MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M0)); /* M4, GPIO_149 */
+	MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0));
+#endif
+	MUX_VAL(CP(MCSPI1_CS2),		(IDIS | PTU | DIS | M4)); /* MCSPI1_CS2    -> SEL_RS232/485_GPIO176 (GPIO_176) */
+	/* UART2 */
+	MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M0));
+	/* UART3 */
+	//MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0));
+	//MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0));
+	/* WATCHDOG */
+	MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M4)); /* Trigger Event <1,6s */
+	MUX_VAL(CP(UART3_CTS_RCTX),	(IDIS | PTD | DIS | M4)); /* Enable */
+	/* I2C1: PMIC */
+	MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M4)); /* SYS_nIRQ      -> PMIC_nINT1      (GPIO_0) */
+	/* I2C2: RTC, EEPROM */
+	MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)); /* RTC_EEPROM_SCL2 */
+	MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)); /* RTC_EEPROM_SDA2 */
+	MUX_VAL(CP(HDQ_SIO),		(IDIS | PTD | DIS  | M4)); /* HDQ_SIO       -> WD_nWP   GPIO_170 */
+	MUX_VAL(CP(SYS_CLKREQ),		(IEN  | PTD | DIS | M4));  /* SYS_CLKREQ    -> RTC_nINT (GPIO_1) */
+	/* I2C3 */
+	MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)); //    I2C3_SCL      -> FB_SCL3 (not used)
+	MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)); //    I2C3_SDA      -> FB_SDA3 (not used)
+
+	/* GPIO_BANK3: Betriebsartenschalter und Reset All Taster */
+	MUX_VAL(CP(DSS_DATA20),  (IEN  | PTU | EN  | M4));  //    DSS_DATA20    -> BAS_RUN      /* GPIO 90 */ (sync, changed)
+	MUX_VAL(CP(DSS_DATA21),  (IEN  | PTU | EN  | M4));  //    DSS_DATA21    -> BAS_STOP     /* GPIO 91 */ (sync, changed)
+	MUX_VAL(CP(DSS_DATA22),  (IEN  | PTU | EN  | M4));  //    DSS_DATA22    -> BAS_RESET    /* GPIO 92 */ (sync, changed)
+	MUX_VAL(CP(DSS_DATA23),  (IEN  | PTU | EN  | M4));  //    DSS_DATA23    -> RESET_ALL    /* GPIO 93 */ (sync, changed)
+	MUX_VAL(CP(CCDC_PCLK) , (IEN  | PTU | EN  | M4));   //    CCDC_PCLK     -> System Reset /* GPIO 94 */ (sync, changed) Reserved for later use!
+
+	/* *********** ADDED FOR JTAG DEBUGGING ************* */
+	MUX_VAL(CP(SYS_NRESWARM),     	(IDIS | PTU | DIS | M4));
+}
+
+void mux_config_leds(void)
+{
+	/* GPIO_BANK3: LEDS */
+	MUX_VAL(CP(DSS_PCLK)  ,	(IDIS | PTD | EN | M4));  //    DSS_PCLK      -> LED_1_1_GREEN   (GPIO_66)
+	MUX_VAL(CP(DSS_HSYNC) ,	(IDIS | PTD | EN | M4));  //    DSS_HSYNC     -> LED_1_1_RED     (GPIO_67)
+	MUX_VAL(CP(DSS_VSYNC) ,	(IDIS | PTD | EN | M4));  //    DSS_VSYNC     -> LED_1_2_GREEN   (GPIO_68)
+	MUX_VAL(CP(DSS_ACBIAS), (IDIS | PTD | EN | M4));  //    DSS_ACBIAS    -> LED_1_2_RED     (GPIO_69)
+	MUX_VAL(CP(DSS_DATA0) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA0     -> LED_2_1_GREEN   (GPIO_70)
+	MUX_VAL(CP(DSS_DATA1) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA1     -> LED_2_1_RED     (GPIO_71)
+	MUX_VAL(CP(DSS_DATA2) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA2     -> LED_2_2_GREEN   (GPIO_72)
+	MUX_VAL(CP(DSS_DATA3) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA3     -> LED_2_2_RED     (GPIO_73)
+	MUX_VAL(CP(DSS_DATA4) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA4     -> LED_3_1_GREEN   (GPIO_74)
+	MUX_VAL(CP(DSS_DATA5) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA5     -> LED_3_1_RED     (GPIO_75)
+	MUX_VAL(CP(DSS_DATA6) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA6     -> LED_3_2_GREEN   (GPIO_76)
+	MUX_VAL(CP(DSS_DATA7) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA7     -> LED_3_2_RED     (GPIO_77)
+	MUX_VAL(CP(DSS_DATA8) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA8     -> LED_4_1_GREEN   (GPIO_78)
+	MUX_VAL(CP(DSS_DATA9) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA9     -> LED_4_1_RED     (GPIO_79)
+	MUX_VAL(CP(DSS_DATA10), (IDIS | PTD | EN | M4));  //    DSS_DATA10    -> LED_4_2_GREEN   (GPIO_80)
+	MUX_VAL(CP(DSS_DATA11), (IDIS | PTD | EN | M4));  //    DSS_DATA11    -> LED_4_2_RED     (GPIO_81)
+	MUX_VAL(CP(DSS_DATA12), (IDIS | PTD | EN | M4));  //    DSS_DATA12    -> LED_5_1_GREEN   (GPIO_82)
+	MUX_VAL(CP(DSS_DATA13), (IDIS | PTD | EN | M4));  //    DSS_DATA13    -> LED_5_1_RED     (GPIO_83)
+	MUX_VAL(CP(DSS_DATA14), (IDIS | PTD | EN | M4));  //    DSS_DATA14    -> LED_5_2_GREEN   (GPIO_84)
+	MUX_VAL(CP(DSS_DATA15), (IDIS | PTD | EN | M4));  //    DSS_DATA15    -> LED_5_2_RED     (GPIO_85)
+	MUX_VAL(CP(DSS_DATA16), (IDIS | PTD | EN | M4));  //    DSS_DATA16    -> LED_6_1_GREEN   (GPIO_86)
+	MUX_VAL(CP(DSS_DATA17), (IDIS | PTD | EN | M4));  //    DSS_DATA17    -> LED_6_1_RED     (GPIO_87)
+	MUX_VAL(CP(DSS_DATA18), (IDIS | PTD | EN | M4));  //    DSS_DATA18    -> LED_6_2_GREEN   (GPIO_88)
+	MUX_VAL(CP(DSS_DATA19), (IDIS | PTD | EN | M4));  //    DSS_DATA19    -> LED_6_2_RED     (GPIO_89)
+}
+
+#ifdef CONFIG_DEBUG_LL
+/* UART Defines */
+#define UART_SYSCFG_OFFSET	0x54
+#define UART_SYSSTS_OFFSET	0x58
+
+#define UART_CLK_RUNNING_MASK	0x1
+#define UART_RESET		(0x1 << 1)
+#define UART_SMART_IDLE_EN	(0x1 << 0x3)
+
+void am35xx_uart_soft_reset(void __iomem *uart_base)
+{
+	int reg;
+
+	reg = readl(uart_base + UART_SYSCFG_OFFSET);
+	reg |= UART_RESET;
+	writel(reg, (uart_base + UART_SYSCFG_OFFSET));
+
+	while ((readl(uart_base + UART_SYSSTS_OFFSET) &
+		UART_CLK_RUNNING_MASK) != UART_CLK_RUNNING_MASK)
+		;
+
+	/* Disable smart idle */
+	reg = readl((uart_base + UART_SYSCFG_OFFSET));
+	reg |= UART_SMART_IDLE_EN;
+	writel(reg, (uart_base + UART_SYSCFG_OFFSET));
+}
+
+void early_gpio3_init(void)
+{
+	/* static inline void sr32(u32 addr, u32 start_bit, u32 num_bits, u32 value) */
+	sr32(OMAP3_CM_REG(FCLKEN_PER), 14, 1, 1);
+	sr32(OMAP3_CM_REG(ICLKEN_PER), 14, 1, 1);
+	sr32(OMAP3_CM_REG(AUTOIDLE_PER), 14, 1, 1);
+	wait_on_value((0x1 << 14), 0x4000, OMAP3_CM_REG(IDLEST_PER), 14);
+
+	/* clear gpios */
+	writel(0xffffffff, OMAP3_GPIO3_BASE + OMAP_GPIO_CLEARDATAOUT);
+
+	/* Set Output Enable for GPIO_66..89 */
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_OE, 2, 24, 0);
+}
+#endif
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+int pfc200_board_init(void)
+{
+	int in_sdram = omap3_running_in_sdram();
+	u32 r0;
+
+#ifdef CONFIG_DEBUG_LL
+#if 0
+	sr32(OMAP3_CM_REG(FCLKEN_PER), 11, 1, 1);
+	sr32(OMAP3_CM_REG(ICLKEN_PER), 11, 1, 1);
+	sr32(OMAP3_CM_REG(AUTOIDLE_PER), 11, 1, 1);
+	wait_on_value((0x1 << 11), 0x800, OMAP3_CM_REG(IDLEST_PER), 11);
+#endif
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_DATAOUT, 3, 1, 1); // turn on LED_1_1_RED
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_DATAOUT, 5, 1, 1); // turn on LED_1_2_RED
+#endif
+
+	omap3_core_init();
+
+	mux_config();
+
+#define CONTROL_DEVCONF3   0x48002584
+	/* DDR2 CPU Terminierung aktivieren */
+	r0 = readl(CONTROL_DEVCONF3);
+	writel(r0 | 0x2, CONTROL_DEVCONF3);
+
+	/* Dont reconfigure SDRAM while running in SDRAM! */
+	if (!in_sdram) {
+		emif4_init();	/* AM35xx has EMIF4 Interface */
+	}
+
+#ifdef CONFIG_DEBUG_LL
+	am35xx_uart_soft_reset((void *)OMAP3_UART3_BASE);	/* 49020000 */
+	omap_uart_lowlevel_init((void *)OMAP3_UART3_BASE);
+	putc_ll('>');
+	putc_ll('*');
+	putc_ll('*');
+#endif
+
+	return 0;
+}
diff --git a/arch/arm/boards/wago-pfc-am35xx/lowlevel.c b/arch/arm/boards/wago-pfc-am35xx/lowlevel.c
new file mode 100644
index 0000000..ea4ee9c
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/lowlevel.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <init.h>
+#include <linux/sizes.h>
+#include <io.h>
+#include <linux/string.h>
+#include <debug_ll.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/generic.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/wdt.h>
+#include <mach/omap3-mux.h>
+#include <mach/omap3-silicon.h>
+#include <mach/omap3-generic.h>
+#include <mach/control.h>
+#include <asm/common.h>
+#include <asm-generic/memory_layout.h>
+
+#include "pfcxxx.h"
+
+extern int pfc200_board_init(void);
+extern void early_gpio3_init(void);
+extern void mux_config_leds(void);
+
+ENTRY_FUNCTION(start_am35xx_pfc200_sram, bootinfo, r1, r2)
+{
+#if 0
+	arm_cpu_lowlevel_init();
+	arm_setup_stack(0x4020FBF0);
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+	mux_config_leds();
+
+	early_gpio3_init();
+
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_DATAOUT, 3, 1, 1); // turn on LED_1_1_RED
+#endif
+
+	omap3_save_bootinfo((void *)bootinfo);
+
+	/*
+	 * Setup C environment, the board init code uses global variables.
+	 * Stackpointer has already been initialized by the ROM code.
+	 */
+	relocate_to_current_adr();
+	setup_c();
+
+	pfc200_board_init();
+
+	barebox_arm_entry(0x80000000, SZ_256M, NULL);
+}
+
+#ifndef CONFIG_OMAP_BUILD_IFT
+extern char __dtb_am35xx_pfc_750_820x_start[];
+ENTRY_FUNCTION(start_am35xx_pfc200_sdram, r0, r1, r2)
+{
+	uint32_t sdram_size;
+	void *fdt;
+
+	sdram_size = SZ_256M;
+	fdt = __dtb_am35xx_pfc_750_820x_start;
+
+	arm_setup_stack(0x4020FBF0);
+
+	/*
+	 * Setup C environment, the board init code uses global variables.
+	 * Stackpointer has already been initialized by the ROM code.
+	 */
+	relocate_to_current_adr();
+	setup_c();
+	arm_cpu_lowlevel_init();
+
+	fdt -= get_runtime_offset();
+
+	barebox_arm_entry(0x80000000, sdram_size, fdt);
+}
+#endif
diff --git a/arch/arm/boards/wago-pfc-am35xx/nand_ids.c b/arch/arm/boards/wago-pfc-am35xx/nand_ids.c
new file mode 100644
index 0000000..67ce09e
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/nand_ids.c
@@ -0,0 +1,45 @@
+/*
+ *  drivers/mtd/nandids.c
+ *
+ *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <common.h>
+#include <sizes.h>
+#include <linux/mtd/nand.h>
+
+#ifdef CONFIG_NAND_INFO
+#define __STR(str) str
+#else
+#define __STR(str) ""
+#endif
+
+#define LP_OPTIONS NAND_SAMSUNG_LP_OPTIONS
+#define LP_OPTIONS16 (LP_OPTIONS | NAND_BUSWIDTH_16)
+
+#define SP_OPTIONS NAND_NEED_READRDY
+#define SP_OPTIONS16 (SP_OPTIONS | NAND_BUSWIDTH_16)
+
+/*
+ * The chip ID list:
+ *    name, device ID, page size, chip size in MiB, eraseblock size, options
+ *
+ * If page size and eraseblock size are 0, the sizes are taken from the
+ * extended chip ID.
+ */
+struct nand_flash_dev custom_nand_ids[] = {
+	/* 2 Gigabit */
+	EXTENDED_ID_NAND(__STR("NAND 256MiB 3,3V 8-bit"),  0xDA, 256, LP_OPTIONS),
+
+	{NULL}
+};
+
+EXPORT_SYMBOL(custom_nand_ids);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Heinrich Toews <heinrich.toews@wago.com>");
+MODULE_DESCRIPTION("Nand device & manufacturer IDs");
diff --git a/arch/arm/boards/wago-pfc-am35xx/pfcxxx.h b/arch/arm/boards/wago-pfc-am35xx/pfcxxx.h
new file mode 100644
index 0000000..c93a265
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/pfcxxx.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __BOARD_PFCXXX_H
+#define __BOARD_PFCXXX_H
+
+#include <mach/am33xx-generic.h>
+
+#define OMAP_GPIO_OE		0x0034
+#define OMAP_GPIO_DATAIN	0x0038
+#define OMAP_GPIO_DATAOUT	0x003c
+#define OMAP_GPIO_CLEARDATAOUT	0x0090
+#define OMAP_GPIO_SETDATAOUT	0x0094
+
+
+static inline int is_pfc(void)
+{
+#ifdef CONFIG_TARGET_PFC100
+	return 1;
+#else
+	return 0;
+#endif
+}
+
+#endif /* __BOARD_PFCXXX_H */
diff --git a/arch/arm/configs/am35xx_pfc200_defconfig b/arch/arm/configs/am35xx_pfc200_defconfig
new file mode 100644
index 0000000..422d022
--- /dev/null
+++ b/arch/arm/configs/am35xx_pfc200_defconfig
@@ -0,0 +1,127 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_BAREBOX_UPDATE_AM33XX_NAND=y
+CONFIG_MACH_WAGO_PFC_AM35XX=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_UBIFORMAT=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_NANDTEST=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_RESOLV=y
+CONFIG_OFDEVICE=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_NET_DAVINCI_EMAC=y
+CONFIG_I2C=y
+CONFIG_I2C_OMAP=y
+CONFIG_MTD=y
+CONFIG_MTD_M25P80=y
+CONFIG_NAND=y
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_EEPROM_AT24=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_BUS_OMAP_GPMC=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_UBIFS=y
+CONFIG_FS_UBIFS_COMPRESSION_LZO=y
diff --git a/arch/arm/configs/am35xx_pfc200_xload_defconfig b/arch/arm/configs/am35xx_pfc200_xload_defconfig
new file mode 100644
index 0000000..f09495f
--- /dev/null
+++ b/arch/arm/configs/am35xx_pfc200_xload_defconfig
@@ -0,0 +1,37 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_MACH_WAGO_PFC_AM35XX=y
+# CONFIG_ARM_EXCEPTIONS is not set
+CONFIG_MMU=y
+CONFIG_STACK_SIZE=0xc00
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_DUMMY=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="X-load pfc200>"
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_CONSOLE_SIMPLE=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_MTD=y
+# CONFIG_MTD_WRITE is not set
+# CONFIG_MTD_OOB_DEVICE is not set
+CONFIG_NAND=y
+# CONFIG_NAND_ECC_SOFT is not set
+CONFIG_NAND_ECC_HW_SW_ERR_DETECTION=y
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
+# CONFIG_NAND_INFO is not set
+# CONFIG_NAND_BBT is not set
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_OMAP_HSMMC=y
+# CONFIG_FS_RAMFS is not set
+# CONFIG_FS_DEVFS is not set
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 187d668..8e7bbd9 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -116,5 +116,5 @@ pbl-dtb-$(CONFIG_MACH_AT91SAM9X5EK) += at91sam9x5ek.dtb.o
 pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM335X) += am335x-pfc-750_810x.dtb.o am335x-pfc-750_810x-mlo.dtb.o \
 	am335x-pfc-750_8208.dtb.o am335x-pfc-750_8208-mlo.dtb.o am335x-pfc-750_821x.dtb.o \
 	am335x-pfc-750_821x-mlo.dtb.o
-
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM35XX) += am35xx-pfc-750_820x.dtb.o
 clean-files := *.dtb *.dtb.S .*.dtc .*.pre .*.dts *.dtb.lzo
diff --git a/arch/arm/dts/am35xx-pfc-750_820x.dts b/arch/arm/dts/am35xx-pfc-750_820x.dts
new file mode 100644
index 0000000..4358a17
--- /dev/null
+++ b/arch/arm/dts/am35xx-pfc-750_820x.dts
@@ -0,0 +1,577 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include <arm/am3517.dtsi>
+
+/ {
+	model = "PFC-750-820x";
+	compatible =  "wago,am3505-pfc-750_820x", "wago,am35xx-pfc", "ti,am3517", "ti,omap3";
+	board-variant = "pfc200";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+        vmmc_fixed: vmmc {
+                compatible = "regulator-fixed";
+                regulator-name = "vmmc_fixed";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+        };
+
+	aliases {
+                gpio0 = &gpio1;
+                gpio1 = &gpio2;
+                gpio2 = &gpio3;
+                gpio3 = &gpio4;
+                gpio4 = &gpio5;
+                gpio5 = &gpio6;
+		mmc0 = &mmc1;
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+	};
+
+	chosen {
+		stdout-path = &uart3;
+
+		environment_sd: environment-sd {
+			compatible = "barebox,environment";
+			device-path = &mmc1, "partname:0";
+			file-path = "barebox.env";
+			status = "okay";
+		};
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bas_pins>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpio3 26 GPIO_ACTIVE_HIGH>; };
+		stop:  stop  { gpios = <&gpio3 27 GPIO_ACTIVE_HIGH>; };
+		reset: reset { gpios = <&gpio3 28 GPIO_ACTIVE_HIGH>; };
+		rst:   rst   { gpios = <&gpio3 29 GPIO_ACTIVE_HIGH>; };
+	};
+
+	bootstate: bootstate {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		magic = <0x3f45620e>;
+		compatible = "barebox,state";
+		backend-type = "raw";
+		backend = <&backend_state_eeprom>;
+		backend-storage-type = "direct";
+		backend-stridesize = <0x40>;
+
+		last_chosen@0 {
+			reg = <0x0 0x4>;
+			type = "uint32";
+		};
+
+		system0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@4 {
+				reg = <0x4 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@8 {
+				reg = <0x8 0x4>;
+				type = "uint32";
+				default = <20>;
+			};
+		};
+
+		system1 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@C {
+				reg = <0xC 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@10 {
+				reg = <0x10 0x4>;
+				type = "uint32";
+				default = <20>;
+			};
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_pins>;
+
+		u1-green@0 {
+			label = "u1-green";
+			gpios = <&gpio3 22 0>;
+			linux,default-trigger = "none";
+		};
+
+		u1-red@1 {
+			label = "u1-red";
+			gpios = <&gpio3 23 0>;
+			linux,default-trigger = "none";
+		};
+
+		u2-green@2 {
+			label = "u2-green";
+			gpios = <&gpio3 18 0>;
+			linux,default-trigger = "none";
+		};
+
+		u2-red@3 {
+			label = "u2-red";
+			gpios = <&gpio3 19 0>;
+			linux,default-trigger = "none";
+		};
+
+		u3-green@4 {
+			label = "u3-green";
+			gpios = <&gpio3 14 0>;
+			linux,default-trigger = "none";
+		};
+
+		u3-red@5 {
+			label = "u3-red";
+			gpios = <&gpio3 15 0>;
+			linux,default-trigger = "none";
+		};
+
+		u4-green@6 {
+			label = "u4-green";
+			gpios = <&gpio3 10 0>;
+			linux,default-trigger = "none";
+		};
+
+		u4-red@7 {
+			label = "u4-red";
+			gpios = <&gpio3 11 0>;
+			linux,default-trigger = "none";
+		};
+
+		dia-green@8 {
+			label = "dia-green";
+			gpios = <&gpio3 6 0>;
+			linux,default-trigger = "none";
+		};
+
+		dia-red@9 {
+			label = "dia-red";
+			gpios = <&gpio3 7 0>;
+			linux,default-trigger = "none";
+		};
+
+		bf-green@10 {
+			label = "bf-green";
+			gpios = <&gpio3 2 0>;
+			linux,default-trigger = "none";
+		};
+
+		bf-red@11 {
+			label = "bf-red";
+			gpios = <&gpio3 3 0>;
+			linux,default-trigger = "none";
+		};
+
+		sys-green@12 {
+			label = "sys-green";
+			gpios = <&gpio3 4 0>;
+			linux,default-trigger = "none";
+		};
+
+		sys-red@13 {
+			label = "sys-red";
+			gpios = <&gpio3 5 0>;
+			linux,default-trigger = "none";
+		};
+
+
+		run-green@14 {
+			label = "run-green";
+			gpios = <&gpio3 8 0>;
+			linux,default-trigger = "none";
+		};
+
+		run-red@15 {
+			label = "run-red";
+			gpios = <&gpio3 9 0>;
+			linux,default-trigger = "none";
+		};
+
+		io-green@16 {
+			label = "io-green";
+			gpios = <&gpio3 12 0>;
+			linux,default-trigger = "none";
+		};
+
+		io-red@17 {
+			label = "io-red";
+			gpios = <&gpio3 13 0>;
+			linux,default-trigger = "none";
+		};
+
+		ms-green@18 {
+			label = "ms-green";
+			gpios = <&gpio3 16 0>;
+			linux,default-trigger = "none";
+		};
+
+		ms-red@19 {
+			label = "ms-red";
+			gpios = <&gpio3 17 0>;
+			linux,default-trigger = "none";
+		};
+
+		ns-green@20 {
+			label = "ns-green";
+			gpios = <&gpio3 20 0>;
+			linux,default-trigger = "none";
+		};
+
+		ns-red@21 {
+			label = "ns-red";
+			gpios = <&gpio3 21 0>;
+			linux,default-trigger = "none";
+		};
+
+
+		can-green@22 {
+			label = "can-green";
+			gpios = <&gpio3 24 0>;
+			linux,default-trigger = "none";
+		};
+
+		can-red@23 {
+			label = "can-red";
+			gpios = <&gpio3 25 0>;
+			linux,default-trigger = "none";
+		};
+	};
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3_pins>;
+        status = "okay";
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins>;
+	clock-frequency = <400000>;
+        status = "okay";
+
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+		wp-gpios = <&gpio6 10 GPIO_ACTIVE_LOW>;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#size-cells = <1>;
+			#address-cells = <1>;
+
+			backend_state_eeprom: state@8000 {
+				reg = <0x8000 0x120>;
+				label = "state-eeprom";
+			};
+
+			boot_mode_id: boot-mode-id@0 {
+				reg = <0x0 0x1>;
+				label = "boot_mode_id";
+			};
+
+			devconf: devconf@1FE {
+				reg = <0x1FE 0x2>;
+				label = "devconf";
+			};
+
+			ethaddr1: ethaddr1@200 {
+				reg = <0x200 0x6>;
+				label = "ethaddr1";
+			};
+
+			ethaddr2: ethaddr2@206 {
+				label = "ethaddr2";
+				reg = <0x206 0x6>;
+			};
+		};
+	};
+};
+
+&mmc1 {
+        status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&vmmc_fixed>;
+	bus-width = <4>;
+	cd-gpios = <&gpio4 20 GPIO_ACTIVE_LOW>; /* GPIO 116 */
+	cd-inverted;
+};
+
+&omap3_pmx_core {
+	pinctrl-names = "default";
+	pinctrl-0 = <&emac_pins
+		     &switch_reset>;
+
+	uart3_pins: pinmux_uart3_pins {
+		pinctrl-single,pins = <
+			0x16e (PIN_INPUT | PIN_OFF_WAKEUPENABLE | MUX_MODE0) /* uart3_rx_irrx.uart3_rx_irrx */
+			0x170 (PIN_OUTPUT | MUX_MODE0) /* uart3_tx_irtx.uart3_tx_irtx */
+		>;
+	};
+
+	i2c2_pins: pinmux_i2c2_pins {
+		pinctrl-single,pins = <
+			0x18e (PIN_INPUT_PULLUP | MUX_MODE0)   /* i2c2_scl.i2c2_scl */
+			0x190 (PIN_INPUT_PULLUP | MUX_MODE0)   /* i2c2_sda.i2c2_sda */
+		        0x196 (PIN_OUTPUT | MUX_MODE4)  /* hdq_sio.gpio_170: wd_nwp */
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x114 (PIN_INPUT_PULLUP | MUX_MODE0)	/* sdmmc1_clk.sdmmc1_clk */
+			0x116 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_cmd.sdmmc1_cmd */
+			0x118 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat0.sdmmc1_dat0 */
+			0x11a (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat1.sdmmc1_dat1 */
+			0x11c (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat2.sdmmc1_dat2 */
+			0x11e (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat3.sdmmc1_dat3 */
+		>;
+	};
+
+	emac_pins: pinmux_emac_pins {
+		pinctrl-single,pins = <
+		        0x1ce (PIN_INPUT | MUX_MODE0)           /* rmii_mdio_data.rmii_mdio_data */
+		        0x1d0 (PIN_OUTPUT_PULLUP | MUX_MODE0)   /* rmii_mdio_clk.rmii_mdio_clk   */
+		        0x1d2 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd0.rmii_rxd0           */
+		        0x1d4 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd1.rmii_rxd1           */
+		        0x1d6 (PIN_INPUT | MUX_MODE0)           /* rmii_crs_dv.rmii_crs_dv       */
+		        0x1d8 (PIN_INPUT | MUX_MODE0)           /* rmii_rxer.rmii_rxer           */
+		        0x1da (PIN_OUTPUT_PULLUP | MUX_MODE0)   /* rmii_txd0.rmii_txd0           */
+		        0x1dc (PIN_INPUT | MUX_MODE0)           /* rmii_txd1.rmii_txd1           */
+		        0x1de (PIN_INPUT | MUX_MODE0)           /* rmii_txen.rmii_txen           */
+		        0x1e0 (PIN_INPUT | MUX_MODE0)           /* rmii_50mhz_clk.rmii_50mhz_clk */
+		        0x134 (PIN_OUTPUT | MUX_MODE4)          /* mmc2_dat4.gpio_136: nrst_switch */
+		>;
+	};
+
+	led_pins: pinmux_led_pins {
+		pinctrl-single,pins = <
+		        0x0a4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_pclk.gpio_66: led_1_1_green */
+		        0x0a6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_hsync.gpio_67: led_1_1_red */
+		        0x0a8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_vsync.gpio_68: led_1_2_green */
+		        0x0aa (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_acbias.gpio_69: led_1_2_red */
+
+		        0x0ac (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data0.gpio_70: led_2_1_green */
+		        0x0ae (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data1.gpio_71: led_2_1_red */
+		        0x0b0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data2.gpio_72: led_2_2_green */
+		        0x0b2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data3.gpio_73: led_2_2_red */
+
+		        0x0b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data4.gpio_74: led_3_1_green */
+		        0x0b6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data5.gpio_75: led_3_1_red */
+		        0x0b8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data6.gpio_76: led_3_2_green */
+		        0x0ba (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data7.gpio_77: led_3_2_red */
+
+		        0x0bc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data8.gpio_78: led_4_1_green */
+		        0x0be (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data9.gpio_79: led_4_1_red */
+		        0x0c0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data10.gpio_80: led_4_2_green */
+		        0x0c2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data11.gpio_81: led_4_2_red */
+
+		        0x0c4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data12.gpio_82: led_5_1_green */
+		        0x0c6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data13.gpio_83: led_5_1_red */
+		        0x0c8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data14.gpio_84: led_5_2_green */
+		        0x0ca (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data15.gpio_85: led_5_2_red */
+
+		        0x0cc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data16.gpio_86: led_6_1_green */
+		        0x0ce (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data17.gpio_87: led_6_1_red */
+		        0x0d0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data18.gpio_88: led_6_2_green */
+		        0x0d2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data19.gpio_89: led_6_2_red */
+		>;
+	};
+
+	bas_pins: pinmux_bas_pins {
+		pinctrl-single,pins = <
+			0x0d4 (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data20.gpio_90: bas_run */
+			0x0d6 (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data21.gpio_91: bas_stop */
+			0x0d8 (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data22.gpio_92: bas_reset */
+			0x0da (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data23.gpio_93: reset_all */
+		>;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x04a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a1.gpmc_a1 */
+			0x04c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a2.gpmc_a2 */
+			0x04e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a3.gpmc_a3 */
+			0x050 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a4.gpmc_a4 */
+			0x052 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a5.gpmc_a5 */
+			0x054 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a6.gpmc_a6 */
+			0x056 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a7.gpmc_a7 */
+			0x058 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a8.gpmc_a8 */
+			0x05a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a9.gpmc_a9 */
+			0x05c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a10.gpmc_a10 */
+
+			0x06c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d8.gpmc_d8 */
+			0x06e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d9.gpmc_d9 */
+			0x070 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d10.gpmc_d10 */
+			0x072 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d11.gpmc_d11 */
+			0x074 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d12.gpmc_d12 */
+			0x076 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d13.gpmc_d13 */
+			0x078 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d14.gpmc_d14 */
+			0x07a (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d15.gpmc_d15 */
+
+			0x07e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs0.gpmc_ncs0 */
+			0x080 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs1.gpmc_ncs1 */
+			0x082 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs2.gpmc_ncs2 */
+			0x08c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_clk.gpmc_clk */
+
+			0x090 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nadv_ale.gpmc_nadv_ale */
+			0x092 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_noe.gpmc_noe */
+			0x094 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nwe */
+
+			0x096 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe0_cle.gpmc_nbe0_cle */
+
+			0x098 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe1.gpmc_nbe1 */
+			0x09a (PIN_INPUT | MUX_MODE0)	/* gpmc_nwp.gpmc_nwp */
+
+			0x09c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */
+			0x09e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait1.gpmc_wait1 */
+			0x0a0 (PIN_INPUT_PULLUP | MUX_MODE4)	/* gpmc_wait2.gpio_64 */
+			0x0a2 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait3.gpmc_wait3 */
+		>;
+	};
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x134 (PIN_OUTPUT | MUX_MODE4) /* mmc2_dat4.gpio5_8 (gpio_136) nrst_switch */
+		>;
+	};
+};
+
+&gpmc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+	num-cs = <2>;
+	num-waitpins = <1>;
+	ranges = <
+		0 0 0x08000000 0x01000000	/* CS0: NAND */
+	>;
+
+	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8-hw-det-sw";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <36>;
+		gpmc,cs-wr-off-ns = <36>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <24>;
+		gpmc,adv-wr-off-ns = <36>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <30>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <48>;
+		gpmc,access-ns = <54>;
+		gpmc,rd-cycle-ns = <72>;
+		gpmc,wr-cycle-ns = <72>;
+
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+
+		gpmc,wr-access-ns = <30>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&gpio5 {
+	switch_reset {
+		gpio-hog;
+		gpios = <8 GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "switch-reset";
+	};
+};
+
+/include/ "am3xxx-pfc-nandparts.dtsi"
+
+/* That's uggly, we have to explicitly disable
+   everything we don't need here */
+
+&uart1 {
+      status = "disabled";
+};
+
+&uart2 {
+      status = "disabled";
+};
+
+&i2c1 {
+      status = "disabled";
+};
+
+&i2c3 {
+      status = "disabled";
+};
+
+&mmc2 {
+      status = "disabled";
+};
+
+&mmc3 {
+      status = "disabled";
+};
+
+&gpio1 {
+      status = "disabled";
+};
+
+&gpio2 {
+      status = "disabled";
+};
diff --git a/arch/arm/dts/am3xxx-pfc-nandparts.dtsi b/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
index 1c9fdc5..a7a51b3 100644
--- a/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
+++ b/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
@@ -10,52 +10,54 @@
  */
 
 &nand {
-	partition@0 {
-		label = "mlo0";
-		reg = <0x0 0x20000>;
-	};
-
-	partition@1 {
-		label = "mlo1";
-		reg = <0x20000 0x20000>;
-	};
-
-	partition@2 {
-		label = "mlo2";
-		reg = <0x40000 0x20000>;
-	};
-
-	partition@3 {
-		label = "mlo3";
-		reg = <0x60000 0x20000>;
-	};
-
-	partition@4 {
-		label = "boot0";
-		reg = <0x80000 0x80000>;
-	};
-
-	partition@5 {
-		label = "boot1";
-		reg = <0x100000 0x80000>;
-	};
-
-	partition@6 {
-		label = "boot2";
-		reg = <0x180000 0x80000>;
-	};
-
-	partition@7 {
-		label = "boot3";
-		reg = <0x200000 0x80000>;
-	};
-
-	partition@8 {
-		label = "ubidata";
-		/*
-		 * Size 0x0 extends partition to
-		 * end of nand flash.
-		 */
-		reg = <0x280000 0x0>;
-	};
+	        /* 4 x 128k MLOs */
+		partition@0 {
+			label = "mlo0";
+			reg = <0x0 0x20000>;
+		};
+
+		partition@1 {
+			label = "mlo1";
+			reg = <0x20000 0x20000>;
+		};
+
+		partition@2 {
+			label = "mlo2";
+			reg = <0x40000 0x20000>;
+		};
+
+		partition@3 {
+			label = "mlo3";
+			reg = <0x60000 0x20000>;
+		};
+
+	        /* 16 x 128k: 4 x stage2 (4x128k) */
+		partition@4 {
+			label = "boot0";
+			reg = <0x80000 0x80000>;
+		};
+
+		partition@5 {
+			label = "boot1";
+			reg = <0x100000 0x80000>;
+		};
+
+		partition@6 {
+			label = "boot2";
+			reg = <0x180000 0x80000>;
+		};
+
+		partition@7 {
+			label = "boot3";
+			reg = <0x200000 0x80000>;
+		};
+
+		partition@8 {
+			label = "ubidata";
+			/*
+			 * Size 0x0 extends partition to
+			 * end of nand flash.
+			 */
+			reg = <0x280000 0x0>;
+		};
 };
diff --git a/arch/arm/mach-omap/Kconfig b/arch/arm/mach-omap/Kconfig
index 9930fc1..312f56f 100644
--- a/arch/arm/mach-omap/Kconfig
+++ b/arch/arm/mach-omap/Kconfig
@@ -210,6 +210,15 @@ config MACH_OMAP3EVM
 	help
 	  Say Y here if you are using OMAP3EVM
 
+config MACH_WAGO_PFC_AM35XX
+        bool "Wago PFC200 Fieldbus Controller"
+        select ARCH_OMAP3
+        select HAVE_DEFAULT_ENVIRONMENT_NEW
+        select HAVE_PBL_MULTI_IMAGES
+        select HAVE_CONFIGURABLE_MEMORY_LAYOUT
+        help
+          Say Y here if you are using a the AM3505 based PFC200 controller
+
 config MACH_PANDA
 	bool "Texas Instrument's Panda Board"
 	select ARCH_OMAP4
diff --git a/arch/arm/mach-omap/include/mach/emif4.h b/arch/arm/mach-omap/include/mach/emif4.h
new file mode 100644
index 0000000..61c33de
--- /dev/null
+++ b/arch/arm/mach-omap/include/mach/emif4.h
@@ -0,0 +1,79 @@
+/*
+ * Auther:
+ *       Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Copyright (C) 2010
+ * Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _EMIF_H_
+#define _EMIF_H_
+
+/*
+ * Configuration values
+ */
+#define EMIF4_TIM1_T_RP		(0x3 << 25)
+#define EMIF4_TIM1_T_RCD	(0x3 << 21)
+#define EMIF4_TIM1_T_WR		(0x3 << 17)
+#define EMIF4_TIM1_T_RAS	(0x7 << 12) /* 8->7 */
+#define EMIF4_TIM1_T_RC		(0xA << 6)
+#define EMIF4_TIM1_T_RRD	(0x2 << 3)
+#define EMIF4_TIM1_T_WTR	(0x2)
+
+#define EMIF4_TIM2_T_XP		(0x2 << 28)
+#define EMIF4_TIM2_T_ODT	(0x0 << 25) /* 2? */
+#define EMIF4_TIM2_T_XSNR	(0x1C << 16)
+#define EMIF4_TIM2_T_XSRD	(0xC8 << 6)
+#define EMIF4_TIM2_T_RTP	(0x1 << 3)
+#define EMIF4_TIM2_T_CKE	(0x2)
+
+#define EMIF4_TIM3_T_RFC	(0x15 << 4) /* 25->15 */
+#define EMIF4_TIM3_T_RAS_MAX	(0xf)	    /* 7->f */
+
+#define EMIF4_PWR_IDLE_MODE	(0x2 << 30)
+#define EMIF4_PWR_DPD_DIS	(0x0 << 10)
+#define EMIF4_PWR_DPD_EN	(0x1 << 10)
+#define EMIF4_PWR_LP_MODE	(0x0 << 8)
+#define EMIF4_PWR_PM_TIM	(0x0)
+
+#define EMIF4_INITREF_DIS	(0x0 << 31)
+#define EMIF4_REFRESH_RATE	(0x257) /* 50f->257 */
+
+#define EMIF4_CFG_SDRAM_TYP	(0x2 << 29)
+#define EMIF4_CFG_IBANK_POS	(0x0 << 27)
+#define EMIF4_CFG_DDR_TERM	(0x3 << 24) /* --> 0x3 */
+#define EMIF4_CFG_DDR2_DDQS	(0x1 << 23)
+#define EMIF4_CFG_DDR_DIS_DLL	(0x0 << 20)
+#define EMIF4_CFG_SDR_DRV	(0x0 << 18)
+#define EMIF4_CFG_NARROW_MD	(0x0 << 14)
+#define EMIF4_CFG_CL		(0x5 << 10)
+#define EMIF4_CFG_ROWSIZE	(0x0 << 7) /* --> 0x4: a0..a12 */
+#define EMIF4_CFG_IBANK		(0x3 << 4)
+#define EMIF4_CFG_EBANK		(0x0 << 3)
+#define EMIF4_CFG_PGSIZE	(0x2)      /* 10 columns */
+
+/*
+ * EMIF4 PHY Control 1 register configuration
+ */
+#define EMIF4_DDR1_EXT_STRB_EN	(0x1 << 7)
+#define EMIF4_DDR1_EXT_STRB_DIS	(0x0 << 7)
+#define EMIF4_DDR1_PWRDN_DIS	(0x0 << 6)
+#define EMIF4_DDR1_PWRDN_EN	(0x1 << 6)
+#define EMIF4_DDR1_READ_LAT	(0x6 << 0)
+
+#endif /* endif _EMIF_H_ */
diff --git a/arch/arm/mach-omap/include/mach/omap3-mux.h b/arch/arm/mach-omap/include/mach/omap3-mux.h
index d6fb9c3..a679e25 100644
--- a/arch/arm/mach-omap/include/mach/omap3-mux.h
+++ b/arch/arm/mach-omap/include/mach/omap3-mux.h
@@ -413,4 +413,51 @@
 #define CONTROL_PADCONF_SDRC_CKE0	0x0262
 #define CONTROL_PADCONF_SDRC_CKE1	0x0264
 
-#endif /* _ASM_ARCH_OMAP3_MUX_H_ */
+/* AM3517 specific mux configuration */
+#define CONTROL_PADCONF_SYS_NRESWARM	0x0A08
+/* CCDC */
+#define CONTROL_PADCONF_CCDC_PCLK	0x01E4
+#define CONTROL_PADCONF_CCDC_FIELD	0x01E6
+#define CONTROL_PADCONF_CCDC_HD		0x01E8
+#define CONTROL_PADCONF_CCDC_VD		0x01EA
+#define CONTROL_PADCONF_CCDC_WEN	0x01EC
+#define CONTROL_PADCONF_CCDC_DATA0	0x01EE
+#define CONTROL_PADCONF_CCDC_DATA1	0x01F0
+#define CONTROL_PADCONF_CCDC_DATA2	0x01F2
+#define CONTROL_PADCONF_CCDC_DATA3	0x01F4
+#define CONTROL_PADCONF_CCDC_DATA4	0x01F6
+#define CONTROL_PADCONF_CCDC_DATA5	0x01F8
+#define CONTROL_PADCONF_CCDC_DATA6	0x01FA
+#define CONTROL_PADCONF_CCDC_DATA7	0x01FC
+/* RMII */
+#define CONTROL_PADCONF_RMII_MDIO_DATA	0x01FE
+#define CONTROL_PADCONF_RMII_MDIO_CLK	0x0200
+#define CONTROL_PADCONF_RMII_RXD0	0x0202
+#define CONTROL_PADCONF_RMII_RXD1	0x0204
+#define CONTROL_PADCONF_RMII_CRS_DV	0x0206
+#define CONTROL_PADCONF_RMII_RXER	0x0208
+#define CONTROL_PADCONF_RMII_TXD0	0x020A
+#define CONTROL_PADCONF_RMII_TXD1	0x020C
+#define CONTROL_PADCONF_RMII_TXEN	0x020E
+#define CONTROL_PADCONF_RMII_50MHZ_CLK	0x0210
+#define CONTROL_PADCONF_USB0_DRVBUS	0x0212
+/* CAN */
+#define CONTROL_PADCONF_HECC1_TXD	0x0214
+#define CONTROL_PADCONF_HECC1_RXD	0x0216
+
+#define CONTROL_PADCONF_SYS_BOOT7	0x0218
+#define CONTROL_PADCONF_SDRC_DQS0N	0x021A
+#define CONTROL_PADCONF_SDRC_DQS1N	0x021C
+#define CONTROL_PADCONF_SDRC_DQS2N	0x021E
+#define CONTROL_PADCONF_SDRC_DQS3N	0x0220
+#define CONTROL_PADCONF_STRBEN_DLY0	0x0222
+#define CONTROL_PADCONF_STRBEN_DLY1	0x0224
+#define CONTROL_PADCONF_SYS_BOOT8	0x0226
+
+/* AM/DM37xx specific */
+#define CONTROL_PADCONF_GPIO127		0x0A54
+#define CONTROL_PADCONF_GPIO126		0x0A56
+#define CONTROL_PADCONF_GPIO128		0x0A58
+#define CONTROL_PADCONF_GPIO129		0x0A5A
+
+#endif
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 7ad2b8d..f5951bf 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -4724,3 +4724,4 @@ webbg3flight		MACH_WEBBG3FLIGHT	WEBBG3FLIGHT		4769
 sbc_phycore_am335x	MACH_SBC_PHYCORE_AM335X	SBC_PHYCORE_AM335X	4770
 tsc			MACH_TSC		TSC			4771
 pfc_am335x		MACH_PFC_AM335X		PFC_AM335X		9002
+pfc_am35xx		MACH_PFC_AM35XX		PFC_AM35XX		9003
diff --git a/images/Makefile b/images/Makefile
index 5c4d99a..f8964ee 100644
--- a/images/Makefile
+++ b/images/Makefile
@@ -103,6 +103,7 @@ board = $(srctree)/arch/$(ARCH)/boards
 objboard = $(objtree)/arch/$(ARCH)/boards
 
 include $(srctree)/images/Makefile.am33xx
+include $(srctree)/images/Makefile.am35xx
 include $(srctree)/images/Makefile.bcm283x
 include $(srctree)/images/Makefile.imx
 include $(srctree)/images/Makefile.mvebu
diff --git a/images/Makefile.am35xx b/images/Makefile.am35xx
new file mode 100644
index 0000000..340005b
--- /dev/null
+++ b/images/Makefile.am35xx
@@ -0,0 +1,28 @@
+
+# %.mlo - convert into mlo image
+# ----------------------------------------------------------------
+ifndef CONFIG_ARCH_AM33XX
+quiet_cmd_mlo_image = MLO     $@
+      cmd_mlo_image = scripts/omap_signGP -o $@ -l 0x40200000 -c $<
+endif
+
+# scripts/omap_signGP -o MLO -l 0x40200000 -c $< #
+
+$(obj)/%.mlo: $(obj)/% FORCE
+	$(call if_changed,mlo_image)
+
+ifdef CONFIG_OMAP_BUILD_IFT
+pblx-$(CONFIG_MACH_WAGO_PFC_AM35XX) += start_am35xx_pfc200_sram
+FILE_barebox-am35xx-pfc200-mlo.img = start_am35xx_pfc200_sram.pblx.mlo
+am35xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM35XX) += barebox-am35xx-pfc200-mlo.img
+endif
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM35XX) += start_am35xx_pfc200_sdram
+FILE_barebox-am35xx-pfc200.img = start_am35xx_pfc200_sdram.pblx
+am35xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM35XX) += barebox-am35xx-pfc200.img
+
+ifdef CONFIG_OMAP_BUILD_IFT
+image-y += $(am35xx-mlo-y)
+else
+image-y += $(am35xx-barebox-y)
+endif
diff --git a/include/net/davinci_emac.h b/include/net/davinci_emac.h
new file mode 100644
index 0000000..caead1f
--- /dev/null
+++ b/include/net/davinci_emac.h
@@ -0,0 +1,10 @@
+#ifndef __NET_DAVINCI_EMAC_H__
+#define __NET_DAVINCI_EMAC_H__
+
+struct davinci_emac_platform_data {
+	int phy_addr;
+	bool force_link;
+	bool interface_rmii;
+};
+
+#endif /* __NET_DAVINCI_EMAC_H__ */
-- 
2.7.4

