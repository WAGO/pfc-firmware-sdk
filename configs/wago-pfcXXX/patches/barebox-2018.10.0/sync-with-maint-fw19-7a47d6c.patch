diff --git a/.gitignore b/.gitignore
index d83d317..dd57494 100644
--- a/.gitignore
+++ b/.gitignore
@@ -79,3 +79,6 @@ GTAGS
 
 # Kconfig presets
 all.config
+
+m-arm
+update-svn-patches.sh
diff --git a/Documentation/user/booting-linux.rst b/Documentation/user/booting-linux.rst
index 437f4e8..e9ad726 100644
--- a/Documentation/user/booting-linux.rst
+++ b/Documentation/user/booting-linux.rst
@@ -225,6 +225,14 @@ compatible NFS URI string must be passed to the boot command:
 
   boot nfs://nfshost[:port]//path/
 
+Barebox can choose certain Bootloader Spec config files directly. That avoids searching
+for the right bootentrie. Pass the path of a certain Bootloader Spec config file with
+``file://`` prefix to the boot command:
+
+.. code-block:: sh
+
+  boot file://path/loader/entries/filename.conf
+
 Additionally to the options defined in the original spec barebox understands the
 ``linux-appendroot`` option. This is a boolean value and if set to ``true`` barebox
 will automatically append a ``root=`` string to the Linux commandline based on the
diff --git a/arch/arm/boards/Makefile b/arch/arm/boards/Makefile
index 0c21002..bc5088b 100644
--- a/arch/arm/boards/Makefile
+++ b/arch/arm/boards/Makefile
@@ -113,6 +113,7 @@ obj-$(CONFIG_MACH_SAMA5D3_XPLAINED)		+= sama5d3_xplained/
 obj-$(CONFIG_MACH_SAMA5D4_XPLAINED)		+= sama5d4_xplained/
 obj-$(CONFIG_MACH_SAMA5D4EK)			+= sama5d4ek/
 obj-$(CONFIG_MACH_SCB9328)			+= scb9328/
+obj-$(CONFIG_MACH_WAGO_PFC_CYCLONE5)		+= wago-pfc-cyclone5/
 obj-$(CONFIG_MACH_SOCFPGA_ALTERA_SOCDK)		+= altera-socdk/
 obj-$(CONFIG_MACH_SOCFPGA_EBV_SOCRATES)		+= ebv-socrates/
 obj-$(CONFIG_MACH_SOCFPGA_REFLEX_ACHILLES)	+= reflex-achilles/
@@ -154,3 +155,6 @@ obj-$(CONFIG_MACH_VF610_TWR)			+= freescale-vf610-twr/
 obj-$(CONFIG_MACH_ZII_RDU1)			+= zii-imx51-rdu1/
 obj-$(CONFIG_MACH_ZII_RDU2)			+= zii-imx6q-rdu2/
 obj-$(CONFIG_MACH_ZII_VF610_DEV)		+= zii-vf610-dev/
+obj-$(CONFIG_MACH_WAGO_PFC_AM335X)		+= wago-pfc-am335x/
+obj-$(CONFIG_MACH_WAGO_PFC_AM35XX)		+= wago-pfc-am35xx/
+obj-$(CONFIG_MACH_WAGO_VTPCTP_MX6)		+= wago-vtpctp-imx6/
diff --git a/arch/arm/boards/wago-pfc-am335x/Makefile b/arch/arm/boards/wago-pfc-am335x/Makefile
new file mode 100644
index 0000000..1355b5f
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/Makefile
@@ -0,0 +1,3 @@
+lwl-y += lowlevel.o
+obj-y += board.o
+bbenv-y += defaultenv-pfc-am335x
diff --git a/arch/arm/boards/wago-pfc-am335x/board.c b/arch/arm/boards/wago-pfc-am335x/board.c
new file mode 100644
index 0000000..30e98a6
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/board.c
@@ -0,0 +1,357 @@
+/*
+ * Copyright (C) 2015 Wadim Egorov, PHYTEC Messtechnik GmbH
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * Device initialization for the following pfc board variants:
+ *   - 750-810x	PFC100
+ *   - 750-8208	PFC200
+ *   - 750-821x	PFC200
+ *   - 768-330x	PFC200ADV
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <bootsource.h>
+#include <common.h>
+#include <nand.h>
+#include <net.h>
+#include <init.h>
+#include <io.h>
+#include <linux/sizes.h>
+#include <envfs.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/am33xx-generic.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/am33xx-devices.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <mach/bbu.h>
+#include <globalvar.h>
+#include <xsection.h>
+#include <linux/bitmap.h>
+#include <gpio.h>
+#include <of_gpio.h>
+#include <mci.h>
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+
+static unsigned int pfc_sw_reset_gpio;
+
+static int pfc_coredevice_init(void)
+{
+	if (!of_machine_is_compatible("wago,am335x-pfc"))
+		return 0;
+
+	am33xx_register_ethaddr(0, 0);
+
+	return 0;
+}
+coredevice_initcall(pfc_coredevice_init);
+
+static char *mlo_nandslots[] = {
+	"/dev/nand0.mlo0.bb",
+	"/dev/nand0.mlo1.bb",
+	"/dev/nand0.mlo2.bb",
+	"/dev/nand0.mlo3.bb"
+};
+
+static char *boot_nandslots[] = {
+	"/dev/nand0.boot0.bb",
+	"/dev/nand0.boot1.bb",
+	"/dev/nand0.boot2.bb",
+	"/dev/nand0.boot3.bb"
+};
+
+static char *boot_emmcslots[] = {
+	"/dev/mmc1.boot0",
+	"/dev/mmc1.boot1",
+	"/dev/mmc1.boot2",
+	"/dev/mmc1.boot3",
+};
+
+static struct omap_barebox_boot_parts pfc_barebox_boot_parts = {
+	.boot_nandslots = boot_nandslots,
+	.boot_emmcslots = boot_emmcslots,
+	.num_boot_nandslots = ARRAY_SIZE(boot_nandslots),
+	.num_boot_emmcslots = ARRAY_SIZE(boot_emmcslots),
+};
+
+#define DISABLE_SD_BOOT_BIT 0
+static int pfc_set_device_state(struct omap_board_info *board)
+{
+	u8 mac[6], boot_mode_id_ext;
+	int ret;
+
+	ret = xsection_get_boot_mode_id_ext(&boot_mode_id_ext);
+	if (ret < 0)
+		goto out;
+
+	if (test_bit(DISABLE_SD_BOOT_BIT, &boot_mode_id_ext)) {
+		board->disable_sd_boot = true;
+		pr_info("%s: booting from sd disabled\n", __func__);
+	}
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		goto out;
+
+	if (mac[0] != 0x00 || mac[1] != 0x30 || mac[2] != 0xde)
+		board->production_mode = true;
+
+	if (test_bit(HAS_USB, board->boot_devices)) {
+		struct device_d *usbgadget;
+
+		usbgadget = get_device_by_name("usbgadget");
+		if (!usbgadget) {
+			ret = -ENODEV;
+			goto out;
+		}
+
+		/* use processors internal ethaddr as unique
+		 * serial number for usb connections
+		 */
+		am33xx_get_internal_mac_id(mac, 0);
+		ret = dev_set_param(usbgadget, "serial_number",
+					basprintf("%02x%02x%02x%02x%02x%02x",
+					mac[0], mac[1], mac[2], mac[3], mac[4],
+					mac[5]));
+		if (ret)
+			goto out;
+
+		ret = dev_set_param(usbgadget, "manufacturer",
+					"WAGO Kontakttechnik GmbH & Co. KG");
+	}
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int pfc_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static int pfc_rewrite_compatible(void)
+{
+	struct device_node *root;
+	int ret;
+	u16 devconf;
+	char const *first_compat_str;
+	char *new_string;
+
+	ret = xsection_get_devconf(&devconf);
+	if (ret < 0)
+		goto out;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string_index(root, "compatible", 0, &first_compat_str);
+	if (ret < 0)
+		goto out;
+
+	new_string = basprintf("%s-%04x", first_compat_str, devconf);
+	if (!new_string) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = of_property_write_string(root, "compatible", new_string);
+	free(new_string);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static void pfc_set_available_dev(struct omap_board_info *board, char *alias,
+						enum omap_board_boot_device dev)
+{
+	struct device_node *node;
+
+	node = of_find_node_by_alias(of_get_root_node(), alias);
+	if (!node)
+		return;
+
+	if (of_device_is_available(node))
+		set_bit(dev, board->boot_devices);
+}
+
+static int pfc_devices_init(void)
+{
+	int ret;
+	const char *s;
+	struct omap_board_info *board;
+	struct mci *mci;
+
+	if (!of_machine_is_compatible("wago,am335x-pfc"))
+		return 0;
+
+	board = xzalloc(sizeof(*board));
+
+	/* Do this also in mlo, because the pfc startup code needs this
+	 * information to get the right barebox image.
+	 */
+	ret = of_property_read_string(of_get_root_node(), "board-variant", &s);
+	if (!ret) {
+		board->board_variant = xstrdup(s);
+		globalvar_add_simple("board.variant", board->board_variant);
+	} else {
+		pr_warn("failed to get board.variant from oftree\n");
+	}
+
+	pfc_sw_reset_gpio = of_get_named_gpio(of_get_root_node(),
+							"switch-reset-gpio", 0);
+	if (!gpio_is_valid(pfc_sw_reset_gpio))
+		pfc_sw_reset_gpio = -1;
+
+	globalvar_add_simple_int("pfc.sw_reset_gpio", &pfc_sw_reset_gpio, "%d");
+
+	pfc_set_available_dev(board, "sd", HAS_SD);
+	pfc_set_available_dev(board, "emmc", HAS_EMMC);
+	pfc_set_available_dev(board, "nand", HAS_NAND);
+	pfc_set_available_dev(board, "usb0", HAS_USB);
+
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
+	}
+
+	if (test_bit(HAS_EMMC, board->boot_devices)) {
+		am33xx_bbu_emmc_mlo_register_handler("mlo.emmc", "/dev/mmc1");
+		am33xx_bbu_emmc_register_handler("boot.emmc", boot_emmcslots,
+						ARRAY_SIZE(boot_emmcslots));
+	}
+
+	if (test_bit(HAS_NAND, board->boot_devices)) {
+		am33xx_bbu_nand_xloadslots_register_handler("mlo.nand",
+						mlo_nandslots,
+						ARRAY_SIZE(mlo_nandslots));
+		am33xx_bbu_nand_slots_register_handler("boot.nand",
+						boot_nandslots,
+						ARRAY_SIZE(boot_nandslots));
+	}
+
+	mci = mci_get_device_by_name("mmc0");
+	if (mci && mci->host->card_present) {
+		if (mci->host->card_present(mci->host))
+			of_device_enable_path("/chosen/environment-sd");
+
+	} else if (test_bit(HAS_EMMC, board->boot_devices)) {
+		of_device_enable_path("/chosen/environment-emmc");
+	}
+
+	omap_set_barebox_boot_parts(&pfc_barebox_boot_parts);
+	defaultenv_append_directory(defaultenv_pfc_am335x);
+
+	armlinux_set_architecture(MACH_TYPE_PFC_AM335X);
+	barebox_set_hostname("pfc");
+
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		/* Set MAC address for ethernet0 from eeprom. If no valid MAC
+		 * address could read, use the randomized one. Dont do this in
+		 * mlo, because this is useless there.
+		 */
+		ret = pfc_set_ethaddr();
+		if (ret < 0) {
+			pr_warn("no valid ethaddr in eeprom found. Using "
+				"randomized MAC address\n");
+		}
+	}
+
+	ret = pfc_set_device_state(board);
+	if (ret)
+		goto out;
+
+	omap_set_board_info(board);
+
+	/* dont free in case of mlo boot. We need the board information in the
+	 * xload-pfc module
+	 */
+	if (IS_ENABLED(CONFIG_SHELL_NONE)) {
+		ret = am33xx_of_register_bootdevice();
+		goto out_ret;
+	}
+
+	/* Rewrite the compatible string in the internal barebox device-tree
+	 * (located in ram), and add the eeprom devconf as suffix. This string
+	 * is used by the bootloader-spec module to search for correct bootloader-spec
+	 * entry to load the corrosponding kernel device-tree.
+	 */
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		ret = pfc_rewrite_compatible();
+		if (ret < 0)
+			pr_err("failed to rewrite the internal compatible string "
+				"with devconf from eeprom \n");
+	}
+
+out:
+	free(board->board_variant);
+	free(board);
+out_ret:
+	return ret;
+}
+late_initcall(pfc_devices_init);
+
+#define I2C_EEPROM_BOOT_MODE_ID_DEV_BIT (1 << 0)
+static int pfc_check_and_set_debug_uart(void)
+{
+	struct device_node *boot_mode_node;
+	struct cdev *cdev;
+	u8 boot_mode_id;
+	int ret = 0;
+
+	if (IS_ENABLED(CONFIG_SHELL_NONE)) {
+		boot_mode_node = of_find_node_by_name(NULL, "boot-mode-id@0");
+		if (!boot_mode_node) {
+			pr_err("%s: could not find boot-mode-id@0 node\n",
+								__func__);
+			ret = -ENODEV;
+			goto out;
+		}
+
+		cdev = cdev_by_device_node(boot_mode_node);
+		if (!cdev) {
+			ret = -ENODEV;
+			goto out;
+		}
+
+		ret = cdev_read(cdev, &boot_mode_id, cdev->size, 0, 0);
+		if (ret < 0)
+			goto out;
+
+		if (boot_mode_id & I2C_EEPROM_BOOT_MODE_ID_DEV_BIT) {
+			pr_info("%s: debug mode active\n", __func__);
+			am33xx_add_uart0();
+		}
+	}
+
+out:
+	return ret < 0 ? ret : 0;
+}
+late_initcall(pfc_check_and_set_debug_uart);
diff --git a/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/bin/pfc-config-production-boot b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/bin/pfc-config-production-boot
new file mode 100644
index 0000000..7641a93
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/bin/pfc-config-production-boot
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+global.linux.bootargs.watchdog=""
+global.boot.watchdog_timeout=0
+global.autoboot=1
+
+uart_console -e ${global.pfc.barebox_uart}
+led_mode -m -c green
+usbgadget ${global.pfc.usbgadget_options}
+
+echo -e ${info} "waiting for commands over fastboot"
+
+exit 0
diff --git a/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/init/d-pfc-setup-board-env b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/init/d-pfc-setup-board-env
new file mode 100644
index 0000000..c61c083
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/init/d-pfc-setup-board-env
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+# setup pmic to enable LS2/LS3
+i2c_write -b 0x0 -a 0x24 -r 0x10 0x6F
+i2c_write -b 0x0 -a 0x24 -r 0x12 0x1f
+i2c_write -b 0x0 -a 0x24 -r 0x10 0x69
+i2c_write -b 0x0 -a 0x24 -r 0x14 0xcd
\ No newline at end of file
diff --git a/arch/arm/boards/wago-pfc-am335x/lowlevel.c b/arch/arm/boards/wago-pfc-am335x/lowlevel.c
new file mode 100644
index 0000000..c171c8d
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/lowlevel.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2015 Wadim Egorov, PHYTEC Messtechnik GmbH
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <linux/sizes.h>
+#include <io.h>
+#include <init.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/am33xx-clock.h>
+#include <mach/generic.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/am33xx-mux.h>
+#include <mach/am33xx-generic.h>
+#include <mach/wdt.h>
+#include <debug_ll.h>
+
+#include "ram-timings.h"
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+static noinline void am33xx_pfc_sram_init(void *fdt, int sdram)
+{
+	/*
+	 * WDT1 is already running when the bootloader gets control
+	 * Disable it to avoid "random" resets
+	 */
+	writel(WDT_DISABLE_CODE1, AM33XX_WDT_REG(WSPR));
+	while (readl(AM33XX_WDT_REG(WWPS)) != 0x0);
+
+	writel(WDT_DISABLE_CODE2, AM33XX_WDT_REG(WSPR));
+	while (readl(AM33XX_WDT_REG(WWPS)) != 0x0);
+
+	am33xx_pll_init(MPUPLL_M_600, DDRPLL_M_400);
+
+	am335x_sdram_init(DDR_IOCTRL, &pfc_timings[sdram].cmd_ctrl,
+			&pfc_timings[sdram].regs,
+			&pfc_timings[sdram].data);
+
+	am33xx_uart_soft_reset((void *)AM33XX_UART0_BASE);
+	am33xx_enable_uart0_pin_mux();
+	omap_uart_lowlevel_init((void *)AM33XX_UART0_BASE);
+	putc_ll('>');
+
+	am335x_barebox_entry(fdt);
+}
+
+static noinline void am33xx_pfc_board_entry(unsigned long bootinfo, int sdram,
+					void *fdt)
+{
+	am33xx_save_bootinfo((void *)bootinfo);
+
+	arm_cpu_lowlevel_init();
+
+	/*
+	 * Setup C environment, the board init code uses global variables.
+	 * Stackpointer has already been initialized by the ROM code.
+	 */
+	relocate_to_current_adr();
+	setup_c();
+	am33xx_pfc_sram_init(fdt, sdram);
+}
+
+#define PFC_ENTRY_MLO(name, fdt_name, sdram)				\
+	ENTRY_FUNCTION(name, bootinfo, r1, r2)				\
+	{								\
+		extern char __dtb_z_##fdt_name##_start[];		\
+		void *fdt = __dtb_z_##fdt_name##_start +		\
+			get_runtime_offset();				\
+		am33xx_pfc_board_entry(bootinfo, sdram, fdt);		\
+	}
+
+#define PFC_ENTRY(name, fdt_name, mem_size)				\
+	ENTRY_FUNCTION(name, r0, r1, r2)				\
+	{								\
+		extern char __dtb_z_##fdt_name##_start[];		\
+		void *fdt = __dtb_z_##fdt_name##_start +		\
+			get_runtime_offset();				\
+		barebox_arm_entry(0x80000000, mem_size, fdt);		\
+	}
+
+PFC_ENTRY_MLO(start_am33xx_pfc_750_810x_sram_256mb, am335x_pfc_750_810x_mlo,
+								PFC_DDR3_256MB);
+PFC_ENTRY_MLO(start_am33xx_pfc_750_8208_sram_256mb, am335x_pfc_750_8208_mlo,
+								PFC_DDR3_256MB);
+PFC_ENTRY_MLO(start_am33xx_pfc_750_821x_sram_512mb, am335x_pfc_750_821x_mlo,
+								PFC_DDR3_512MB);
+PFC_ENTRY_MLO(start_am33xx_src_2850_311x_sram_256mb, am335x_src_2850_311x_mlo,
+								PFC_DDR3_256MB);
+PFC_ENTRY_MLO(start_am33xx_pfc_768_330x_sram_512mb, am335x_pfc_768_330x_mlo,
+								PFC_DDR3_512MB);
+PFC_ENTRY_MLO(start_am33xx_rmcb_sram_128mb, am335x_rmcb_mlo, PFC_DDR3_128MB);
+
+PFC_ENTRY(start_am33xx_pfc_750_810x_sdram, am335x_pfc_750_810x, SZ_256M);
+PFC_ENTRY(start_am33xx_pfc_750_8208_sdram, am335x_pfc_750_8208, SZ_256M);
+PFC_ENTRY(start_am33xx_pfc_750_821x_sdram, am335x_pfc_750_821x, SZ_512M);
+PFC_ENTRY(start_am33xx_src_2850_311x_sdram, am335x_src_2850_311x, SZ_256M);
+PFC_ENTRY(start_am33xx_pfc_768_330x_sdram, am335x_pfc_768_330x, SZ_512M);
+PFC_ENTRY(start_am33xx_rmcb_sdram, am335x_rmcb, SZ_128M);
diff --git a/arch/arm/boards/wago-pfc-am335x/ram-timings.h b/arch/arm/boards/wago-pfc-am335x/ram-timings.h
new file mode 100644
index 0000000..56442da
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am335x/ram-timings.h
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2015 Wadim Egorov, PHYTEC Messtechnik GmbH
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __RAM_TIMINGS_H
+#define __RAM_TIMINGS_H
+
+#define DDR_IOCTRL	0x18B
+
+struct am335x_sdram_timings {
+	struct am33xx_emif_regs regs;
+	struct am33xx_ddr_data data;
+	struct am33xx_cmd_control cmd_ctrl;
+};
+
+enum {
+	PFC_DDR3_128MB,
+	PFC_DDR3_256MB,
+	PFC_DDR3_512MB,
+};
+
+struct am335x_sdram_timings pfc_timings[] = {
+	[PFC_DDR3_128MB] = {
+		.regs = {
+			.emif_read_latency	= 0x100007,
+			.emif_tim1		= 0x0AAAD4DB,
+			.emif_tim2		= 0x202F7FDA,
+			.emif_tim3		= 0x501F82BF,
+			.sdram_config		= 0x61C049B2,
+			.sdram_ref_ctrl		= 0x93B,
+			.ocp_config		= 0x00141414,
+			.zq_config		= 0x50074BE4,
+			.sdram_config2		= 0x0,
+		},
+		.data = {
+			.rd_slave_ratio0        = 0x38,
+			.wr_dqs_slave_ratio0    = 0x44,
+			.fifo_we_slave_ratio0	= 0x94,
+			.wr_slave_ratio0        = 0x7D,
+			.use_rank0_delay	= 0x01,
+			.dll_lock_diff0		= 0x0,
+		},
+		.cmd_ctrl = {
+			.slave_ratio0	= 0x80,
+			.dll_lock_diff0	= 0x1,
+			.invert_clkout0	= 0x0,
+			.slave_ratio1	= 0x80,
+			.dll_lock_diff1	= 0x1,
+			.invert_clkout1	= 0x0,
+			.slave_ratio2	= 0x80,
+			.dll_lock_diff2	= 0x1,
+			.invert_clkout2	= 0x0,
+		},
+
+	},
+
+	[PFC_DDR3_256MB] = {
+		.regs = {
+			.emif_read_latency	= 0x100007,
+			.emif_tim1		= 0x0AAAD4DB,
+			.emif_tim2		= 0x24437FDA,
+			.emif_tim3		= 0x50FFE3FF,
+			.sdram_config		= 0x61C052B2,
+			.sdram_ref_ctrl		= 0x20000064,
+			.ocp_config		= 0x00141414,
+			.zq_config		= 0x50074BE4,
+			.sdram_config2		= 0x0,
+		},
+		.data = {
+			.rd_slave_ratio0        = 0x38,
+			.wr_dqs_slave_ratio0    = 0x44,
+			.fifo_we_slave_ratio0	= 0x94,
+			.wr_slave_ratio0        = 0x7D,
+			.use_rank0_delay	= 0x01,
+			.dll_lock_diff0		= 0x0,
+		},
+		.cmd_ctrl = {
+			.slave_ratio0	= 0x80,
+			.dll_lock_diff0	= 0x1,
+			.invert_clkout0	= 0x0,
+			.slave_ratio1	= 0x80,
+			.dll_lock_diff1	= 0x1,
+			.invert_clkout1	= 0x0,
+			.slave_ratio2	= 0x80,
+			.dll_lock_diff2	= 0x1,
+			.invert_clkout2	= 0x0,
+		},
+	},
+
+	[PFC_DDR3_512MB] = {
+		.regs = {
+			.emif_read_latency	= 0x100007,
+			.emif_tim1		= 0x0AAAD4DB,
+			.emif_tim2		= 0x206B7FDA,
+			.emif_tim3		= 0x501F867F,
+			.sdram_config		= 0x61C05332,
+			.sdram_ref_ctrl		= 0x20000064,
+			.ocp_config		= 0x00141414,
+			.zq_config		= 0x50074BE4,
+			.sdram_config2		= 0x0,
+		},
+		.data = {
+			.rd_slave_ratio0        = 0x38,
+			.wr_dqs_slave_ratio0    = 0x44,
+			.fifo_we_slave_ratio0	= 0x94,
+			.wr_slave_ratio0        = 0x7D,
+			.use_rank0_delay	= 0x01,
+			.dll_lock_diff0		= 0x0,
+		},
+		.cmd_ctrl = {
+			.slave_ratio0	= 0x80,
+			.dll_lock_diff0	= 0x1,
+			.invert_clkout0	= 0x0,
+			.slave_ratio1	= 0x80,
+			.dll_lock_diff1	= 0x1,
+			.invert_clkout1	= 0x0,
+			.slave_ratio2	= 0x80,
+			.dll_lock_diff2	= 0x1,
+			.invert_clkout2	= 0x0,
+		},
+
+	},
+};
+
+#endif
diff --git a/arch/arm/boards/wago-pfc-am35xx/Makefile b/arch/arm/boards/wago-pfc-am35xx/Makefile
new file mode 100644
index 0000000..180ca5a
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/Makefile
@@ -0,0 +1,13 @@
+# ifdef CONFIG_OMAP_BUILD_IFT
+# lwl-y += lowlevel-mlo.o
+# obj-y += board-mlo.o
+# else
+lwl-y += lowlevel-mlo.o lowlevel.o
+ifdef CONFIG_OMAP_BUILD_IFT
+obj-y += board-mlo.o
+else
+obj-y += board.o
+endif
+obj-$(CONFIG_NAND_USE_CUSTOM_IDS) += nand_ids.o
+# endif
+bbenv-y += defaultenv-pfc-am35xx
diff --git a/arch/arm/boards/wago-pfc-am35xx/board-mlo.c b/arch/arm/boards/wago-pfc-am35xx/board-mlo.c
new file mode 100644
index 0000000..e329841
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/board-mlo.c
@@ -0,0 +1,209 @@
+/**
+ * @file
+ * @brief Board Initialization routines for PFC200.
+ *
+ * This board is based on OMAP3530.
+ * More on OMAP3530 (including documentation can be found here):
+ * http://focus.ti.com/docs/prod/folders/print/omap3530.html
+ *
+ * This file provides initialization in two stages:
+ * @li Boot time initialization - just get SDRAM working.
+ * This is run from SRAM - so no case constructs and global vars can be used.
+ * @li Run time initialization - this is for the rest of the initializations
+ * such as flash, uart etc.
+ *
+ * Boot time initialization includes:
+ * @li SDRAM initialization.
+ * @li Pin Muxing relevant for the EVM.
+ *
+ * Run time initialization includes
+ * @li serial @ref serial_ns16550.c driver device definition
+ *
+ * Originally from arch/arm/boards/omap/board-beagle.c
+ */
+
+/*
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ * Sanjeev Premi <premi@ti.com>
+ *
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+
+#include <common.h>
+#include <bootsource.h>
+#include <init.h>
+#include <asm/armlinux.h>
+#include <mach/gpmc.h>
+#include <mach/gpmc_nand.h>
+#include <generated/mach-types.h>
+#include <mach/omap3-devices.h>
+#include <mach/generic.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <nand.h>
+#include <i2c/i2c.h>
+#include <linux/bitmap.h>
+
+static char *boot_nandslots[] = {
+	"/dev/nand0.boot0.bb",
+	"/dev/nand0.boot1.bb",
+	"/dev/nand0.boot2.bb",
+	"/dev/nand0.boot3.bb"
+};
+
+static struct omap_barebox_boot_parts pfc_barebox_boot_parts = {
+	.boot_nandslots = boot_nandslots,
+	.num_boot_nandslots = ARRAY_SIZE(boot_nandslots),
+};
+
+static struct omap_board_info board = {
+	.board_variant = "pfc200",
+};
+
+/**
+ * @brief Initialize the serial port to be used as console.
+ *
+ * @return result of device registration
+ */
+static int pfc200_init_console(void)
+{
+	barebox_set_model("PFC-750-820x MLO");
+	barebox_set_hostname("PFC-750-820x-MLO");
+
+	return 0;
+}
+console_initcall(pfc200_init_console);
+
+static int pfc200_mem_init(void)
+{
+	omap_add_ram0(SZ_256M);
+
+	return 0;
+}
+mem_initcall(pfc200_mem_init);
+
+static struct gpmc_nand_platform_data nand_plat = {
+	.cs = 0,
+	.device_width = 8,
+	.ecc_mode = OMAP_ECC_BCH8_CODE_HW_DETECTION_SW,
+	.nand_cfg = &omap3_nand_cfg,
+};
+
+static struct omap_hsmmc_platform_data mmc_pdata = {
+	.devname = "mmc0",
+	.cd_gpio = 116,
+	.cd_inverted = true,
+};
+
+static struct i2c_platform_data i2c_pdata = {
+	.bitrate = 400000,
+};
+
+#define I2C_EEPROM_BUS	 		1
+#define I2C_EEPROM_ADDR			0x54
+#define I2C_EEPROM_BOOT_MODE_ID 	0x0
+#define I2C_EEPROM_BOOT_MODE_ID_EXT 	0x0102
+#define I2C_EEPROM_BOOT_MODE_ID_DEV_BIT (1 << 0)
+#define I2C_EEPROM_BOOT_MODE_ID_DISABLE_SD_BIT (1 << 0)
+static int pfc200_set_device_state_and_enable_debug_uart(void)
+{
+	struct i2c_adapter *adapter;
+	struct i2c_client client;
+	u8 boot_mode_id, boot_mode_id_ext;
+
+	adapter = i2c_get_adapter(I2C_EEPROM_BUS);
+	if (!adapter) {
+		pr_err("%s: i2c2 not found\n", __func__);
+		return -ENODEV;
+	}
+
+	client.adapter = adapter;
+	client.addr = I2C_EEPROM_ADDR;
+
+	i2c_read_reg(&client, I2C_EEPROM_BOOT_MODE_ID | I2C_ADDR_16_BIT,
+							&boot_mode_id, 1);
+
+	if (boot_mode_id & I2C_EEPROM_BOOT_MODE_ID_DEV_BIT) {
+		pr_info("%s: debug mode active\n", __func__);
+		omap3_add_uart3();
+	}
+
+	i2c_read_reg(&client, I2C_EEPROM_BOOT_MODE_ID_EXT | I2C_ADDR_16_BIT,
+							&boot_mode_id_ext, 1);
+
+	if (boot_mode_id_ext & I2C_EEPROM_BOOT_MODE_ID_DISABLE_SD_BIT) {
+		printf("pfc: booting from sd disabled\n");
+		board.disable_sd_boot = true;
+	}
+
+	return 0;
+}
+late_initcall(pfc200_set_device_state_and_enable_debug_uart);
+
+static int pfc200_init_devices(void)
+{
+	/*
+	 * WP is made high and WAIT1 active Low
+	 */
+	gpmc_generic_init(0x10);
+	omap_add_gpmc_nand_device(&nand_plat);
+
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
+	}
+
+	omap3_add_mmc1(&mmc_pdata);
+
+        armlinux_set_architecture(MACH_TYPE_PFC_AM35XX);
+
+	if (IS_ENABLED(CONFIG_I2C_OMAP))
+		omap3_add_i2c2(&i2c_pdata);
+
+	bitmap_zero(board.boot_devices, NUM_BOOT_DEVICES);
+	set_bit(HAS_SD, board.boot_devices);
+	set_bit(HAS_NAND, board.boot_devices);
+	omap_set_board_info(&board);
+
+	return 0;
+}
+device_initcall(pfc200_init_devices);
+
+#define BOOT_START_OFFSET 	0x80000
+#define BOOT_SIZE		0x80000
+static int pfc200_create_boot_partitions(void)
+{
+	int i = 0;
+	loff_t offset = BOOT_START_OFFSET;
+	char part_name[12];
+
+	do {
+		sprintf(part_name, "nand0.boot%d", i);
+		devfs_add_partition("nand0", offset, BOOT_SIZE,
+					DEVFS_PARTITION_FIXED, part_name);
+
+		dev_add_bb_dev(part_name, "bb");
+
+		offset += BOOT_SIZE;
+		i++;
+
+	} while (i < pfc_barebox_boot_parts.num_boot_nandslots);
+
+	omap_set_barebox_boot_parts(&pfc_barebox_boot_parts);
+
+	return 0;
+}
+late_initcall(pfc200_create_boot_partitions);
diff --git a/arch/arm/boards/wago-pfc-am35xx/board.c b/arch/arm/boards/wago-pfc-am35xx/board.c
new file mode 100644
index 0000000..922d970
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/board.c
@@ -0,0 +1,226 @@
+/*
+ * (C) Copyright 2008
+ * Texas Instruments, <www.ti.com>
+ * Raghavendra KH <r-khandenahally@ti.com>
+ *
+ * Copyright (C) 2012 Jan Luebbe <j.luebbe@pengutronix.de>
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/**
+ * @file
+ * @brief PFCxxx Specific Board Initialization routines
+ */
+
+#include <bootsource.h>
+#include <common.h>
+#include <init.h>
+#include <driver.h>
+#include <envfs.h>
+#include <environment.h>
+#include <globalvar.h>
+#include <linux/sizes.h>
+#include <net.h>
+#include <envfs.h>
+#include <bootsource.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <mach/am33xx-generic.h>
+#include <mach/am33xx-silicon.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/gpmc.h>
+#include <linux/err.h>
+#include <gpio.h>
+
+#include <mach/omap3-devices.h>
+
+#include <mach/am33xx-clock.h>
+#include <mach/omap3-devices.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <mach/bbu.h>
+#include <globalvar.h>
+#include <xsection.h>
+
+static char *mlo_nandslots[] = {
+	"/dev/nand0.mlo0.bb",
+	"/dev/nand0.mlo1.bb",
+	"/dev/nand0.mlo2.bb",
+	"/dev/nand0.mlo3.bb"
+};
+
+static char *boot_nandslots[] = {
+	"/dev/nand0.boot0.bb",
+	"/dev/nand0.boot1.bb",
+	"/dev/nand0.boot2.bb",
+	"/dev/nand0.boot3.bb"
+};
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+
+static int pfc200_coredevice_init(void)
+{
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
+		return 0;
+
+	return 0;
+}
+coredevice_initcall(pfc200_coredevice_init);
+
+static int pfc200_mem_init(void)
+{
+	uint32_t sdram_size;
+
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
+		return 0;
+
+	sdram_size = SZ_256M;
+
+	arm_add_mem_device("ram0", 0x80000000, sdram_size);
+	return 0;
+}
+mem_initcall(pfc200_mem_init);
+
+static int pfc_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static int pfc_export_board_variant(void)
+{
+	struct device_node *root;
+	int ret;
+	char const *variant;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string(root, "board-variant", &variant);
+	if (ret < 0)
+		goto out;
+
+	ret = globalvar_add_simple("board.variant", variant);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int pfc_rewrite_compatible(void)
+{
+	struct device_node *root;
+	int ret;
+	u16 devconf;
+	char const *first_compat_str;
+	char *new_string;
+
+	ret = xsection_get_devconf(&devconf);
+	if (ret < 0)
+		goto out;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string_index(root, "compatible", 0, &first_compat_str);
+	if (ret < 0)
+		goto out;
+
+	new_string = basprintf("%s-%04x", first_compat_str, devconf);
+	if (!new_string) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = of_property_write_string(root, "compatible", new_string);
+	free(new_string);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int pfc200_devices_init(void)
+{
+	int ret;
+
+	if (!of_machine_is_compatible("wago,am35xx-pfc"))
+		return 0;
+
+	/* Do this also in mlo, because the pfc startup code needs this
+	 * information to get the right barebox image.
+	 */
+	ret = pfc_export_board_variant();
+	if (ret < 0)
+		pr_warn("failed to export board.variant\n");
+
+	if (bootsource_get() == BOOTSOURCE_MMC) {
+		if (bootsource_get_instance() == 0)
+			omap_set_bootmmc_devname("mmc0");
+		else
+			omap_set_bootmmc_devname("mmc1");
+	}
+
+	am33xx_bbu_nand_xloadslots_register_handler("mlo.nand",
+					mlo_nandslots, ARRAY_SIZE(mlo_nandslots));
+	am33xx_bbu_nand_slots_register_handler("boot.nand", boot_nandslots,
+							ARRAY_SIZE(boot_nandslots));
+
+	defaultenv_append_directory(defaultenv_pfc_am35xx);
+
+	armlinux_set_architecture(MACH_TYPE_PFC_AM35XX);
+	barebox_set_hostname("pfc");
+
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		/* Set MAC address for ethernet0 from eeprom. If no valid MAC
+		 * address could read, use the randomized one. Dont do this in
+		 * mlo, because this is useless there.
+		 */
+		ret = pfc_set_ethaddr();
+		if (ret < 0) {
+			pr_warn("no valid ethaddr in eeprom found. Using "
+				"randomized MAC address\n");
+		}
+	}
+
+	/* Rewrite the compatible string in the internal barebox device-tree
+	 * (located in ram), and add the eeprom devconf as suffix. This string
+	 * is used by the bootloader-spec module to search for correct bootloader-spec
+	 * entry to load the corrosponding kernel device-tree.
+	 */
+	if (!IS_ENABLED(CONFIG_SHELL_NONE)) {
+		ret = pfc_rewrite_compatible();
+		if (ret < 0)
+			pr_err("failed to rewrite the internal compatible string "
+				"with devconf from eeprom \n");
+	}
+
+	return 0;
+}
+device_initcall(pfc200_devices_init);
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/boot/net-setupfw b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/boot/net-setupfw
new file mode 100644
index 0000000..848bf51
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/boot/net-setupfw
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+global.dhcp.retries=1000
+global.dhcp.vendor_id="750-8206"
+global.dhcp.option224="barebox running"
+
+ifup ${global.pfc.eth}
+
+if [ ${eth0.ipaddr} != "0.0.0.0" ] && [ ${eth0.serverip} != "0.0.0.0" ] && [ ! -z "${global.dhcp.bootfile}"  ]; then
+
+	echo -e ${info} "get ${global.dhcp.bootfile} from tftp server ${eth0.serverip}."
+
+	tftp ${global.dhcp.bootfile}
+	if [ "$?" = 0 ]; then
+		global.linux.bootargs.dyn.ip="ip=$eth0.ipaddr:$eth0.serverip:$eth0.gateway:$eth0.netmask::eth0:"
+
+		echo -e ${info} "boot ${global.dhcp.bootfile} to ${global.pfc.nand_ubidata}"
+
+		# we need to be sure, that the mac-address is invalid when the
+		# firmware loader (in case of am35xx based devices is this
+		# barebox v2014.11.0) is booted. Otherwise the firmware-loader
+		# tries to boot in default mode
+		xsection.ethaddr1=00:00:00:00:00:00
+		xsection.ethaddr2=00:00:00:00:00:00
+
+		bootm ${global.dhcp.bootfile}
+		if [ $? -ne 0 ]; then
+			echo -e ${error} "$0: could not boot ${global.dhcp.bootfile}"
+			pfc-config-broken-boot
+			exit 1
+		fi
+	else
+		echo -e ${error} "$0: tftp download failed."
+		pfc-config-broken-boot
+		exit 1
+	fi
+else
+	echo -e ${error} "$0: dhcp configuration not set correctly."
+	pfc-config-broken-boot
+	exit 1
+fi
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8 b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8
new file mode 100644
index 0000000..210da14
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8
@@ -0,0 +1,6 @@
+#!/bin/sh 
+
+# on am35xx based targets we need to set 
+# the ecc-mode bch8 when flashing barebox
+
+gpmc_nand0.eccmode="bch8_hw_detsw"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8-legacy b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8-legacy
new file mode 100644
index 0000000..1813bcb
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-bch8-legacy
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+# on am35xx based targets we need to set
+# the ecc-mode bch8_legacy when flashing
+# images < 2014
+
+gpmc_nand0.eccmode="bch8_hw_detsw_legacy"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-hamming b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-hamming
new file mode 100644
index 0000000..be3e96a
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/data/nand-ecc-hamming
@@ -0,0 +1,6 @@
+#!/bin/sh 
+
+# on am35xx based targets we need to set 
+# the ecc-mode hamming when flashing mlo
+
+gpmc_nand0.eccmode="hamming_hw_romcode"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env
new file mode 100644
index 0000000..637a9ea
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/d-pfc-setup-board-env
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+# put here board specific variables or overwrite global variables
+
+global.pfc.linux_uart="0"
+global.pfc.barebox_uart="3"
+global.pfc.barebox_linux_uart="2"
diff --git a/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/pfc-ksz8863-pwr-down b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/pfc-ksz8863-pwr-down
new file mode 100644
index 0000000..d038b38
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/init/pfc-ksz8863-pwr-down
@@ -0,0 +1,26 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+phy_x1_addr=1
+phy_x2_addr=2
+
+# registers
+control_reg=0
+
+powerdown_enable=6176    	# 0x1820 - set the power down flag
+
+# We assume that we are running on a pfc200 G1 device
+#
+# Power down the phys. This is essetial especially for separated mode
+# operation.
+
+echo -e ${info} "switch: power down the phys"
+miitool -w "${mii_bus}:${phy_x1_addr}:${control_reg}" -p powerdown_enable
+miitool -w "${mii_bus}:${phy_x2_addr}:${control_reg}" -p powerdown_enable
+
+exit 0
diff --git a/arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c b/arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c
new file mode 100644
index 0000000..361b22c
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/lowlevel-mlo.c
@@ -0,0 +1,456 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <io.h>
+#include <init.h>
+#include <linux/sizes.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/generic.h>
+#include <mach/omap3-mux.h>
+#include <mach/sdrc.h>
+#include <mach/control.h>
+#include <mach/syslib.h>
+#include <mach/omap3-silicon.h>
+#include <mach/omap3-generic.h>
+#include <mach/sys_info.h>
+#include <asm/common.h>
+#include <asm-generic/memory_layout.h>
+#include <mach/omap3-devices.h>
+#include <debug_ll.h>
+#include <mach/omap3-clock.h>
+
+#define OMAP_GPIO_OE           0x0034
+#define OMAP_GPIO_DATAIN       0x0038
+#define OMAP_GPIO_DATAOUT      0x003c
+#define OMAP_GPIO_CLEARDATAOUT 0x0090
+#define OMAP_GPIO_SETDATAOUT   0x0094
+
+/*
+ * Boot-time initialization(s)
+ */
+
+#include <mach/emif4.h>
+
+/* Code from U-Boot 2012.07 */
+/* EMIF4 */
+typedef struct emif4 {
+	unsigned int emif_mod_id_rev;
+	unsigned int sdram_sts;
+	unsigned int sdram_config;
+	unsigned int res1;
+	unsigned int sdram_refresh_ctrl;
+	unsigned int sdram_refresh_ctrl_shdw;
+	unsigned int sdram_time1;
+	unsigned int sdram_time1_shdw;
+	unsigned int sdram_time2;
+	unsigned int sdram_time2_shdw;
+	unsigned int sdram_time3;
+	unsigned int sdram_time3_shdw;
+	unsigned char res2[8];
+	unsigned int sdram_pwr_mgmt;
+	unsigned int sdram_pwr_mgmt_shdw;
+	unsigned char res3[32];
+	unsigned int sdram_iodft_tlgc;
+	unsigned char res4[128];
+	unsigned int ddr_phyctrl1;
+	unsigned int ddr_phyctrl1_shdw;
+	unsigned int ddr_phyctrl2;
+} emif4_t;
+
+static emif4_t *emif4_base = (emif4_t *)OMAP3_SDRC_BASE;
+
+/*
+ * do_pac200_emif4_init -
+ *  - Init the emif4 module for DDR access
+ *  - Early init routines, called from flash or SRAM.
+ */
+void emif4_init(void)
+{
+	unsigned int regval;
+	/* Set the DDR PHY parameters in PHY ctrl registers */
+	regval = (EMIF4_DDR1_READ_LAT | EMIF4_DDR1_PWRDN_DIS |
+		EMIF4_DDR1_EXT_STRB_DIS);
+	writel(regval, &emif4_base->ddr_phyctrl1);
+	writel(regval, &emif4_base->ddr_phyctrl1_shdw);
+	writel(0, &emif4_base->ddr_phyctrl2);
+
+	/* Reset the DDR PHY and wait till completed */
+	regval = readl(&emif4_base->sdram_iodft_tlgc);
+	regval |= (1<<10);
+	writel(regval, &emif4_base->sdram_iodft_tlgc);
+	/*Wait till that bit clears*/
+	while ((readl(&emif4_base->sdram_iodft_tlgc) & (1<<10)) == 0x1);
+	/*Re-verify the DDR PHY status*/
+	while ((readl(&emif4_base->sdram_sts) & (1<<2)) == 0x0);
+
+	regval |= (1<<0);
+	writel(regval, &emif4_base->sdram_iodft_tlgc);
+	/* Set SDR timing registers */
+	regval = (EMIF4_TIM1_T_WTR | EMIF4_TIM1_T_RRD |
+		EMIF4_TIM1_T_RC | EMIF4_TIM1_T_RAS |
+		EMIF4_TIM1_T_WR | EMIF4_TIM1_T_RCD |
+		EMIF4_TIM1_T_RP);
+	writel(regval, &emif4_base->sdram_time1);
+	writel(regval, &emif4_base->sdram_time1_shdw);
+
+	regval = (EMIF4_TIM2_T_CKE | EMIF4_TIM2_T_RTP |
+		EMIF4_TIM2_T_XSRD | EMIF4_TIM2_T_XSNR |
+		EMIF4_TIM2_T_ODT | EMIF4_TIM2_T_XP);
+	writel(regval, &emif4_base->sdram_time2);
+	writel(regval, &emif4_base->sdram_time2_shdw);
+
+	regval = (EMIF4_TIM3_T_RAS_MAX | EMIF4_TIM3_T_RFC);
+	writel(regval, &emif4_base->sdram_time3);
+	writel(regval, &emif4_base->sdram_time3_shdw);
+
+	/* Set the PWR control register */
+	regval = (EMIF4_PWR_PM_TIM | EMIF4_PWR_LP_MODE |
+		EMIF4_PWR_DPD_DIS | EMIF4_PWR_IDLE_MODE);
+	writel(regval, &emif4_base->sdram_pwr_mgmt);
+	writel(regval, &emif4_base->sdram_pwr_mgmt_shdw);
+
+	/* Set the DDR refresh rate control register */
+	regval = (EMIF4_REFRESH_RATE | EMIF4_INITREF_DIS);
+	writel(regval, &emif4_base->sdram_refresh_ctrl);
+	writel(regval, &emif4_base->sdram_refresh_ctrl_shdw);
+
+	/* set the SDRAM configuration register */
+	regval = (EMIF4_CFG_PGSIZE | EMIF4_CFG_EBANK |
+		EMIF4_CFG_IBANK | EMIF4_CFG_ROWSIZE |
+		EMIF4_CFG_CL | EMIF4_CFG_NARROW_MD |
+		EMIF4_CFG_SDR_DRV | EMIF4_CFG_DDR_DIS_DLL |
+		EMIF4_CFG_DDR2_DDQS | EMIF4_CFG_DDR_TERM |
+		EMIF4_CFG_IBANK_POS | EMIF4_CFG_SDRAM_TYP);
+	writel(regval, &emif4_base->sdram_config);
+
+
+}
+
+#define PFC200_MUX_DDR2
+#define PFC200_MUX_GPMC
+#undef PFC200_MUX_EMAC
+
+/**
+ * @brief Do the pin muxing required for Board operation.
+ * We enable ONLY the pins we require to set. OMAP provides pins which do not
+ * have alternate modes. Such pins done need to be set.
+ *
+ * See @ref MUX_VAL for description of the muxing mode.
+ *
+ * @return void
+ */
+void mux_config(void)
+{
+       /*
+	* IEN  - Input Enable
+	* IDIS - Input Disable
+	* PTD  - Pull type Down
+	* PTU  - Pull type Up
+	* DIS  - Pull type selection is inactive
+	* EN   - Pull type selection is active
+	* M0   - Mode 0
+	* The commented string gives the final mux configuration for that pin
+	*/
+
+#ifdef PFC200_MUX_EMAC
+	/* Ethernet Switch: Core */
+	MUX_VAL(CP(D2D_MCAD13),		(IEN  | PTD | DIS | M0));   //    RMII_MDIO_DATA-> RMII_MD_DATA
+	MUX_VAL(CP(D2D_MCAD14),		(IDIS | PTU | EN  | M0));   //    RMII_MDIO_CLK -> RMII_MD_CLK
+	MUX_VAL(CP(D2D_MCAD15),		(IEN  | PTD | DIS | M0));   //    RMII_RXD0     -> RMII_RxD0
+	MUX_VAL(CP(D2D_MCAD16),		(IEN  | PTD | DIS | M0));   //    RMII_RXD1     -> RMII_RxD1
+	MUX_VAL(CP(D2D_MCAD17),		(IEN  | PTD | DIS | M0));   //    RMII_CRS_DV   -> RMII_CRS_DV
+	MUX_VAL(CP(D2D_MCAD18),		(IEN  | PTD | DIS | M0));   //    RMII_RXER     -> RMII_RXER
+	MUX_VAL(CP(D2D_MCAD19), 	(IDIS | PTU | EN  | M0));   //    RMII_TXD0     -> RMII_TxD0
+	MUX_VAL(CP(D2D_MCAD20),		(IEN  | PTD | DIS | M0));   //    RMII_TXD1     -> RMII_TxD1
+	MUX_VAL(CP(D2D_MCAD21),		(IEN  | PTD | DIS | M0));   //    RMII_TXEN     -> RMII_TXEN
+	MUX_VAL(CP(D2D_MCAD22),		(IEN  | PTD | DIS | M0));   //    MII_50MHZ_CLK -> RMII_50MHz_CLK
+	/* ETHERNET SWITCH */
+	MUX_VAL(CP(MMC2_DAT4),		(IDIS | PTU | DIS | M4)); /* nRSTSwitch (GPIO_136) */
+	MUX_VAL(CP(MMC2_DAT6),	        (IEN  | PTD | DIS | M4)); /* nINTSwitch (GPIO_138) */
+#endif
+#ifdef PFC200_MUX_DDR2
+	/* SDRC */
+	MUX_VAL(CP(SDRC_D0),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D1),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D2),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D3),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D4),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D5),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D6),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D7),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D8),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D9),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D10),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D11),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D12),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D13),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D14),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D15),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D16),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D17),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D18),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D19),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D20),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D21),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D22),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D23),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D24),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D25),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D26),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D27),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D28),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D29),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D30),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_D31),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_CLK),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS0),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS1),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS2),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS3),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(SDRC_DQS0N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_DQS1N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_DQS2N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_DQS3N),		(IEN  | PTD | EN  | M0));
+	MUX_VAL(CP(SDRC_CKE0),		(M0));
+	MUX_VAL(CP(SDRC_CKE1),		(M0));
+	/* sdrc_strben_dly0 */
+	MUX_VAL(CP(STRBEN_DLY0),	(IEN  | PTD | EN  | M0));
+	 /*sdrc_strben_dly1*/
+	MUX_VAL(CP(STRBEN_DLY1),	(IEN  | PTD | EN  | M0));
+#endif /* PFC200_MUX_DDR2 */
+#ifdef PFC200_MUX_GPMC
+	/* GPMC */
+	MUX_VAL(CP(GPMC_A1),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A2),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A3),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A4),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A5),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A6),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A7),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A8),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A9),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_A10),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D0),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D1),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D2),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D3),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D4),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D5),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D6),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D7),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D8),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D9),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D10),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D11),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D12),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D13),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D14),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_D15),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS0),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS1),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS2),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS3),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS4),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS5),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NCS6),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NCS7),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_CLK),		(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NADV_ALE),	(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NOE),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NWE),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_NBE0_CLE),	(IDIS | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NBE1),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_NWP),		(IEN  | PTD | DIS | M0));
+	MUX_VAL(CP(GPMC_WAIT0),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_WAIT1),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(GPMC_WAIT2),		(IEN  | PTU | EN  | M4)); /*GPIO_64*/
+							 /* - ETH_nRESET*/
+	MUX_VAL(CP(GPMC_WAIT3),		(IEN  | PTU | EN  | M0));
+#endif /* PFC200_MUX_GPMC */
+	/* MMC */
+	MUX_VAL(CP(MMC1_CLK),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(MMC1_CMD),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT0),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT1),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT2),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(MMC1_DAT3),		(IEN  | PTU | DIS | M0));
+	/* MMC GPIOs */
+	MUX_VAL(CP(MCBSP2_FSX),		(IEN  | PTD | DIS | M4)); /* McBSP2_FSX    -> SD-MMC1-CD (GPIO_116) */
+	MUX_VAL(CP(MCBSP2_CLKX),	(IDIS | PTU | DIS | M4)); /* McBSP2_CLKX   -> SD-MMC1-EN (GPIO_117) */
+	MUX_VAL(CP(MCBSP2_DR),		(IEN  | PTD | DIS | M4)); /* McBSP2_DR     -> SD-MMC1-WP (GPIO_118) */
+	MUX_VAL(CP(MMC2_DAT7),		(IDIS | PTU | DIS | M4)); /* MMC2_DAT7     -> SD-MMC1-RW (GPIO_139) */
+	/* UART1 */
+#ifndef PFC200_UART1_SAFEMODE
+	MUX_VAL(CP(UART1_TX),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART1_RTS),		(IDIS | PTD | DIS | M0)); /* M4, GPIO_149 */
+	MUX_VAL(CP(UART1_CTS),		(IEN  | PTU | DIS | M0));
+	MUX_VAL(CP(UART1_RX),		(IEN  | PTD | DIS | M0));
+#endif
+	MUX_VAL(CP(MCSPI1_CS2),		(IDIS | PTU | DIS | M4)); /* MCSPI1_CS2    -> SEL_RS232/485_GPIO176 (GPIO_176) */
+	/* UART2 */
+	MUX_VAL(CP(UART2_TX),		(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART2_RX),		(IEN  | PTD | DIS | M0));
+	/* UART3 */
+	MUX_VAL(CP(UART3_TX_IRTX),	(IDIS | PTD | DIS | M0));
+	MUX_VAL(CP(UART3_RX_IRRX),	(IEN  | PTD | DIS | M0));
+	/* WATCHDOG */
+	MUX_VAL(CP(UART3_RTS_SD),	(IDIS | PTD | DIS | M4)); /* Trigger Event <1,6s */
+	MUX_VAL(CP(UART3_CTS_RCTX),	(IDIS | PTD | DIS | M4)); /* Enable */
+	/* I2C1: PMIC */
+	MUX_VAL(CP(I2C1_SCL),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(I2C1_SDA),		(IEN  | PTU | EN  | M0));
+	MUX_VAL(CP(SYS_NIRQ),		(IEN  | PTU | EN  | M4)); /* SYS_nIRQ      -> PMIC_nINT1      (GPIO_0) */
+	/* I2C2: RTC, EEPROM */
+	MUX_VAL(CP(I2C2_SCL),		(IEN  | PTU | EN  | M0)); /* RTC_EEPROM_SCL2 */
+	MUX_VAL(CP(I2C2_SDA),		(IEN  | PTU | EN  | M0)); /* RTC_EEPROM_SDA2 */
+	MUX_VAL(CP(HDQ_SIO),		(IDIS | PTD | DIS  | M4)); /* HDQ_SIO       -> WD_nWP   GPIO_170 */
+	MUX_VAL(CP(SYS_CLKREQ),		(IEN  | PTD | DIS | M4));  /* SYS_CLKREQ    -> RTC_nINT (GPIO_1) */
+	/* I2C3 */
+	MUX_VAL(CP(I2C3_SCL),		(IEN  | PTU | EN  | M0)); //    I2C3_SCL      -> FB_SCL3 (not used)
+	MUX_VAL(CP(I2C3_SDA),		(IEN  | PTU | EN  | M0)); //    I2C3_SDA      -> FB_SDA3 (not used)
+
+	/* GPIO_BANK3: Betriebsartenschalter und Reset All Taster */
+	MUX_VAL(CP(DSS_DATA20),  (IEN  | PTU | EN  | M4));  //    DSS_DATA20    -> BAS_RUN      /* GPIO 90 */ (sync, changed)
+	MUX_VAL(CP(DSS_DATA21),  (IEN  | PTU | EN  | M4));  //    DSS_DATA21    -> BAS_STOP     /* GPIO 91 */ (sync, changed)
+	MUX_VAL(CP(DSS_DATA22),  (IEN  | PTU | EN  | M4));  //    DSS_DATA22    -> BAS_RESET    /* GPIO 92 */ (sync, changed)
+	MUX_VAL(CP(DSS_DATA23),  (IEN  | PTU | EN  | M4));  //    DSS_DATA23    -> RESET_ALL    /* GPIO 93 */ (sync, changed)
+	MUX_VAL(CP(CCDC_PCLK) , (IEN  | PTU | EN  | M4));   //    CCDC_PCLK     -> System Reset /* GPIO 94 */ (sync, changed) Reserved for later use!
+
+	/* *********** ADDED FOR JTAG DEBUGGING ************* */
+	MUX_VAL(CP(SYS_NRESWARM),     	(IDIS | PTU | DIS | M4));
+}
+
+void mux_config_leds(void)
+{
+	/* GPIO_BANK3: LEDS */
+	MUX_VAL(CP(DSS_PCLK)  ,	(IDIS | PTD | EN | M4));  //    DSS_PCLK      -> LED_1_1_GREEN   (GPIO_66)
+	MUX_VAL(CP(DSS_HSYNC) ,	(IDIS | PTD | EN | M4));  //    DSS_HSYNC     -> LED_1_1_RED     (GPIO_67)
+	MUX_VAL(CP(DSS_VSYNC) ,	(IDIS | PTD | EN | M4));  //    DSS_VSYNC     -> LED_1_2_GREEN   (GPIO_68)
+	MUX_VAL(CP(DSS_ACBIAS), (IDIS | PTD | EN | M4));  //    DSS_ACBIAS    -> LED_1_2_RED     (GPIO_69)
+	MUX_VAL(CP(DSS_DATA0) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA0     -> LED_2_1_GREEN   (GPIO_70)
+	MUX_VAL(CP(DSS_DATA1) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA1     -> LED_2_1_RED     (GPIO_71)
+	MUX_VAL(CP(DSS_DATA2) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA2     -> LED_2_2_GREEN   (GPIO_72)
+	MUX_VAL(CP(DSS_DATA3) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA3     -> LED_2_2_RED     (GPIO_73)
+	MUX_VAL(CP(DSS_DATA4) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA4     -> LED_3_1_GREEN   (GPIO_74)
+	MUX_VAL(CP(DSS_DATA5) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA5     -> LED_3_1_RED     (GPIO_75)
+	MUX_VAL(CP(DSS_DATA6) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA6     -> LED_3_2_GREEN   (GPIO_76)
+	MUX_VAL(CP(DSS_DATA7) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA7     -> LED_3_2_RED     (GPIO_77)
+	MUX_VAL(CP(DSS_DATA8) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA8     -> LED_4_1_GREEN   (GPIO_78)
+	MUX_VAL(CP(DSS_DATA9) ,  (IDIS | PTD | EN | M4));  //    DSS_DATA9     -> LED_4_1_RED     (GPIO_79)
+	MUX_VAL(CP(DSS_DATA10), (IDIS | PTD | EN | M4));  //    DSS_DATA10    -> LED_4_2_GREEN   (GPIO_80)
+	MUX_VAL(CP(DSS_DATA11), (IDIS | PTD | EN | M4));  //    DSS_DATA11    -> LED_4_2_RED     (GPIO_81)
+	MUX_VAL(CP(DSS_DATA12), (IDIS | PTD | EN | M4));  //    DSS_DATA12    -> LED_5_1_GREEN   (GPIO_82)
+	MUX_VAL(CP(DSS_DATA13), (IDIS | PTD | EN | M4));  //    DSS_DATA13    -> LED_5_1_RED     (GPIO_83)
+	MUX_VAL(CP(DSS_DATA14), (IDIS | PTD | EN | M4));  //    DSS_DATA14    -> LED_5_2_GREEN   (GPIO_84)
+	MUX_VAL(CP(DSS_DATA15), (IDIS | PTD | EN | M4));  //    DSS_DATA15    -> LED_5_2_RED     (GPIO_85)
+	MUX_VAL(CP(DSS_DATA16), (IDIS | PTD | EN | M4));  //    DSS_DATA16    -> LED_6_1_GREEN   (GPIO_86)
+	MUX_VAL(CP(DSS_DATA17), (IDIS | PTD | EN | M4));  //    DSS_DATA17    -> LED_6_1_RED     (GPIO_87)
+	MUX_VAL(CP(DSS_DATA18), (IDIS | PTD | EN | M4));  //    DSS_DATA18    -> LED_6_2_GREEN   (GPIO_88)
+	MUX_VAL(CP(DSS_DATA19), (IDIS | PTD | EN | M4));  //    DSS_DATA19    -> LED_6_2_RED     (GPIO_89)
+}
+
+#ifdef CONFIG_DEBUG_LL
+/* UART Defines */
+#define UART_SYSCFG_OFFSET	0x54
+#define UART_SYSSTS_OFFSET	0x58
+
+#define UART_CLK_RUNNING_MASK	0x1
+#define UART_RESET		(0x1 << 1)
+#define UART_SMART_IDLE_EN	(0x1 << 0x3)
+
+void am35xx_uart_soft_reset(void __iomem *uart_base)
+{
+	int reg;
+
+	reg = readl(uart_base + UART_SYSCFG_OFFSET);
+	reg |= UART_RESET;
+	writel(reg, (uart_base + UART_SYSCFG_OFFSET));
+
+	while ((readl(uart_base + UART_SYSSTS_OFFSET) &
+		UART_CLK_RUNNING_MASK) != UART_CLK_RUNNING_MASK)
+		;
+
+	/* Disable smart idle */
+	reg = readl((uart_base + UART_SYSCFG_OFFSET));
+	reg |= UART_SMART_IDLE_EN;
+	writel(reg, (uart_base + UART_SYSCFG_OFFSET));
+}
+
+void early_gpio3_init(void)
+{
+	/* static inline void sr32(u32 addr, u32 start_bit, u32 num_bits, u32 value) */
+	sr32(OMAP3_CM_REG(FCLKEN_PER), 14, 1, 1);
+	sr32(OMAP3_CM_REG(ICLKEN_PER), 14, 1, 1);
+	sr32(OMAP3_CM_REG(AUTOIDLE_PER), 14, 1, 1);
+	wait_on_value((0x1 << 14), 0x4000, OMAP3_CM_REG(IDLEST_PER), 14);
+
+	/* clear gpios */
+	writel(0xffffffff, OMAP3_GPIO3_BASE + OMAP_GPIO_CLEARDATAOUT);
+
+	/* Set Output Enable for GPIO_66..89 */
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_OE, 2, 24, 0);
+}
+#endif
+
+/**
+ * @brief The basic entry point for board initialization.
+ *
+ * This is called as part of machine init (after arch init).
+ * This is again called with stack in SRAM, so not too many
+ * constructs possible here.
+ *
+ * @return void
+ */
+int pfc200_board_init(void)
+{
+	int in_sdram = omap3_running_in_sdram();
+	u32 r0;
+
+#ifdef CONFIG_DEBUG_LL
+#if 0
+	sr32(OMAP3_CM_REG(FCLKEN_PER), 11, 1, 1);
+	sr32(OMAP3_CM_REG(ICLKEN_PER), 11, 1, 1);
+	sr32(OMAP3_CM_REG(AUTOIDLE_PER), 11, 1, 1);
+	wait_on_value((0x1 << 11), 0x800, OMAP3_CM_REG(IDLEST_PER), 11);
+#endif
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_DATAOUT, 3, 1, 1); // turn on LED_1_1_RED
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_DATAOUT, 5, 1, 1); // turn on LED_1_2_RED
+#endif
+
+	omap3_core_init();
+
+	mux_config();
+
+#define CONTROL_DEVCONF3   0x48002584
+	/* DDR2 CPU Terminierung aktivieren */
+	r0 = readl(CONTROL_DEVCONF3);
+	writel(r0 | 0x2, CONTROL_DEVCONF3);
+
+	/* Dont reconfigure SDRAM while running in SDRAM! */
+	if (!in_sdram) {
+		emif4_init();	/* AM35xx has EMIF4 Interface */
+	}
+
+#ifdef CONFIG_DEBUG_LL
+	am35xx_uart_soft_reset((void *)OMAP3_UART3_BASE);	/* 49020000 */
+	omap_uart_lowlevel_init((void *)OMAP3_UART3_BASE);
+	putc_ll('>');
+	putc_ll('*');
+	putc_ll('*');
+#endif
+
+	return 0;
+}
diff --git a/arch/arm/boards/wago-pfc-am35xx/lowlevel.c b/arch/arm/boards/wago-pfc-am35xx/lowlevel.c
new file mode 100644
index 0000000..b07225e
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/lowlevel.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <init.h>
+#include <linux/sizes.h>
+#include <io.h>
+#include <linux/string.h>
+#include <debug_ll.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/generic.h>
+#include <mach/sdrc.h>
+#include <mach/sys_info.h>
+#include <mach/syslib.h>
+#include <mach/wdt.h>
+#include <mach/omap3-mux.h>
+#include <mach/omap3-silicon.h>
+#include <mach/omap3-generic.h>
+#include <mach/control.h>
+#include <asm/common.h>
+#include <asm-generic/memory_layout.h>
+
+#define OMAP_GPIO_OE           0x0034
+#define OMAP_GPIO_DATAIN       0x0038
+#define OMAP_GPIO_DATAOUT      0x003c
+#define OMAP_GPIO_CLEARDATAOUT 0x0090
+#define OMAP_GPIO_SETDATAOUT   0x0094
+
+extern int pfc200_board_init(void);
+extern void early_gpio3_init(void);
+extern void mux_config_leds(void);
+
+ENTRY_FUNCTION(start_am35xx_pfc_750_820x_sram, bootinfo, r1, r2)
+{
+#if 0
+	arm_cpu_lowlevel_init();
+	arm_setup_stack(0x4020FBF0);
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+	mux_config_leds();
+
+	early_gpio3_init();
+
+	sr32(OMAP3_GPIO3_BASE + OMAP_GPIO_DATAOUT, 3, 1, 1); // turn on LED_1_1_RED
+#endif
+
+	omap3_save_bootinfo((void *)bootinfo);
+
+	/*
+	 * Setup C environment, the board init code uses global variables.
+	 * Stackpointer has already been initialized by the ROM code.
+	 */
+	relocate_to_current_adr();
+	setup_c();
+
+	pfc200_board_init();
+
+	barebox_arm_entry(0x80000000, SZ_256M, NULL);
+}
+
+#ifndef CONFIG_OMAP_BUILD_IFT
+extern char __dtb_am35xx_pfc_750_820x_start[];
+ENTRY_FUNCTION(start_am35xx_pfc_750_820x_sdram, r0, r1, r2)
+{
+	uint32_t sdram_size;
+	void *fdt;
+
+	sdram_size = SZ_256M;
+	fdt = __dtb_am35xx_pfc_750_820x_start;
+
+	arm_setup_stack(0x4020FBF0);
+
+	/*
+	 * Setup C environment, the board init code uses global variables.
+	 * Stackpointer has already been initialized by the ROM code.
+	 */
+	relocate_to_current_adr();
+	setup_c();
+	arm_cpu_lowlevel_init();
+
+	fdt -= get_runtime_offset();
+
+	barebox_arm_entry(0x80000000, sdram_size, fdt);
+}
+#endif
diff --git a/arch/arm/boards/wago-pfc-am35xx/nand_ids.c b/arch/arm/boards/wago-pfc-am35xx/nand_ids.c
new file mode 100644
index 0000000..67ce09e
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-am35xx/nand_ids.c
@@ -0,0 +1,45 @@
+/*
+ *  drivers/mtd/nandids.c
+ *
+ *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <common.h>
+#include <sizes.h>
+#include <linux/mtd/nand.h>
+
+#ifdef CONFIG_NAND_INFO
+#define __STR(str) str
+#else
+#define __STR(str) ""
+#endif
+
+#define LP_OPTIONS NAND_SAMSUNG_LP_OPTIONS
+#define LP_OPTIONS16 (LP_OPTIONS | NAND_BUSWIDTH_16)
+
+#define SP_OPTIONS NAND_NEED_READRDY
+#define SP_OPTIONS16 (SP_OPTIONS | NAND_BUSWIDTH_16)
+
+/*
+ * The chip ID list:
+ *    name, device ID, page size, chip size in MiB, eraseblock size, options
+ *
+ * If page size and eraseblock size are 0, the sizes are taken from the
+ * extended chip ID.
+ */
+struct nand_flash_dev custom_nand_ids[] = {
+	/* 2 Gigabit */
+	EXTENDED_ID_NAND(__STR("NAND 256MiB 3,3V 8-bit"),  0xDA, 256, LP_OPTIONS),
+
+	{NULL}
+};
+
+EXPORT_SYMBOL(custom_nand_ids);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Heinrich Toews <heinrich.toews@wago.com>");
+MODULE_DESCRIPTION("Nand device & manufacturer IDs");
diff --git a/arch/arm/boards/wago-pfc-cyclone5/Makefile b/arch/arm/boards/wago-pfc-cyclone5/Makefile
new file mode 100644
index 0000000..a0a9a2b
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/Makefile
@@ -0,0 +1,3 @@
+obj-y += lowlevel.o
+pbl-y += lowlevel.o
+obj-$(CONFIG_MACH_WAGO_PFC_AMP) += startup_amp.o
diff --git a/arch/arm/boards/wago-pfc-cyclone5/defaultenv-pfc-cyclone5/init_post_autoboot/pfc-dp83867-setup b/arch/arm/boards/wago-pfc-cyclone5/defaultenv-pfc-cyclone5/init_post_autoboot/pfc-dp83867-setup
new file mode 100644
index 0000000..db1633b
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/defaultenv-pfc-cyclone5/init_post_autoboot/pfc-dp83867-setup
@@ -0,0 +1,63 @@
+#!/bin/sh
+
+# To determine if we are on a TI DP83867 read the
+# the interal phy_id registers of the DP83867 ethernet phy.
+
+source env/data/print-msg-formats
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+phy_x_addr=0xa
+
+# registers
+phy_id_high_reg=2
+phy_id_low_reg=3
+# extendet registers
+# RGMII Control Register (RGMIICTL), Address 0x0032
+control_reg_rgmii=0x32
+# RGMII Delay Control Register (RGMIIDCTL), Address 0x0086
+# set rx delay (1,5ns) tx delay (0,5ns)
+control_reg_rgmii_delay=0x86
+
+# register values
+#
+# Init values according to Data Sheet:
+#
+phy_id_low_val=41521		# 0xA231
+phy_id_high_val=8192		# 0x2000
+# extended registers
+rgmii_rx_tx_clk_delay_enable=0xd3
+rgmii_rx_tx_clk_delay=0xaa
+
+if [ "${global.autoboot}" = 0 -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+# read phy id regs to check if we are on a TI DP83867 based device.
+
+miitool -x "${mii_bus}:${phy_x_addr}:${phy_id_high_reg}" -p read_phy_id_high_val
+miitool -x "${mii_bus}:${phy_x_addr}:${phy_id_low_reg}" -p read_phy_id_low_val
+
+if [ "${read_phy_id_high_val}" != "${phy_id_high_val}" ] && [ "${read_phy_id_low_val}" != "${phy_id_low_reg}" ]; then
+	exit 0
+fi
+
+echo -e ${info} "TI DP83867 detected"
+
+#
+miitool -e -w "${mii_bus}:${phy_x_addr}:${control_reg_rgmii}" -p rgmii_rx_tx_clk_delay_enable
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable RGMII clk delay for rx/tx"
+	exit 1
+fi
+
+#
+miitool -e -w "${mii_bus}:${phy_x_addr}:${control_reg_rgmii_delay}" -p rgmii_rx_tx_clk_delay
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable set rx/tx delays"
+	exit 1
+fi
+
+exit 0
diff --git a/arch/arm/boards/wago-pfc-cyclone5/iocsr_config_cyclone5.c b/arch/arm/boards/wago-pfc-cyclone5/iocsr_config_cyclone5.c
new file mode 100644
index 0000000..7d61662
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/iocsr_config_cyclone5.c
@@ -0,0 +1,678 @@
+/* GENERATED FILE - DO NOT EDIT */
+/*
+ * Copyright Altera Corporation (C) 2012-2014. All rights reserved
+ *
+ * SPDX-License-Identifier:    BSD-3-Clause
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Altera Corporation nor the
+ *      names of its contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <mach/cyclone5-scan-manager.h>
+
+static const unsigned long iocsr_scan_chain0_table[((CONFIG_HPS_IOCSR_SCANCHAIN0_LENGTH / 32) + 1)]
+    = {
+	0x20000000,
+	0x00000000,
+	0x0FF00080,
+	0xC0000000,
+	0x0000003F,
+	0x80008000,
+	0x1000B23C,
+	0x00601C00,
+	0x23C80040,
+	0x0001800B,
+	0x04000000,
+	0x40004000,
+	0x0800591E,
+	0x01647900,
+	0x91E40020,
+	0x90008005,
+	0x02001647,
+	0xC0002000,
+	0x04000601,
+	0x00B23C80,
+	0xC8F20010,
+	0xC8004002,
+	0x01000B23,
+	0x00001000,
+};
+
+static const unsigned long iocsr_scan_chain1_table[((CONFIG_HPS_IOCSR_SCANCHAIN1_LENGTH / 32) + 1)]
+    = {
+	0x2000300E,
+	0x0591E400,
+	0x479000C0,
+	0x40020016,
+	0x0800591E,
+	0x80008000,
+	0x1000B23C,
+	0x02C8F200,
+	0x23C80040,
+	0x2001000B,
+	0x04002C8F,
+	0x40004000,
+	0x0800591E,
+	0x00300E00,
+	0x91E40020,
+	0x90008005,
+	0x02001647,
+	0x20002000,
+	0x06002C8F,
+	0x08000000,
+	0x01FE0000,
+	0xF8000000,
+	0x00000007,
+	0x90001000,
+	0x02001647,
+	0x00591E40,
+	0x64790008,
+	0xE4003001,
+	0x00800591,
+	0x00000800,
+	0x01000000,
+	0x00000000,
+	0xB23C8004,
+	0x1C001000,
+	0x00400060,
+	0x00000400,
+	0x00800000,
+	0x00164790,
+	0x00000003,
+	0x00000800,
+	0x00200000,
+	0xF2000200,
+	0x006002C8,
+	0x00000000,
+	0x2C8F2001,
+	0x3C800600,
+	0x001000B2,
+	0x79000100,
+	0x00300164,
+	0xC00591E4,
+	0x16479000,
+	0x1E400300,
+	0x000C0059,
+	0x00000080,
+};
+
+static const unsigned long iocsr_scan_chain2_table[((CONFIG_HPS_IOCSR_SCANCHAIN2_LENGTH / 32) + 1)]
+    = {
+	0xA0016479,
+	0x00C03800,
+	0x0FF00080,
+	0x80000000,
+	0x08000C03,
+	0x00008000,
+	0x10001807,
+	0x00000000,
+	0x23C80040,
+	0x2005000B,
+	0x06002C8F,
+	0x80004000,
+	0x0C000C03,
+	0x00300E00,
+	0xC0380020,
+	0xE0008000,
+	0x02000300,
+	0xC0002000,
+	0x06000601,
+	0x00180700,
+	0x601C0018,
+	0x70006000,
+	0x01800180,
+	0xE0001000,
+	0x03000300,
+	0x000C0380,
+	0x300E000C,
+	0x38003000,
+	0x00C000C0,
+	0x00000800,
+};
+
+static const unsigned long iocsr_scan_chain3_table[((CONFIG_HPS_IOCSR_SCANCHAIN3_LENGTH / 32) + 1)]
+    = {
+	0x0C420D80,
+	0x082000FF,
+	0x0A804001,
+	0x07900000,
+	0x08020000,
+	0x00100000,
+	0x0A800000,
+	0x07900000,
+	0x08020000,
+	0x00100000,
+	0xC8800000,
+	0x00003001,
+	0x00C00722,
+	0x00000000,
+	0x00000021,
+	0x82000004,
+	0x05400000,
+	0x03C80000,
+	0x04010000,
+	0x00080000,
+	0x05400000,
+	0x03C80000,
+	0x05400000,
+	0x03C80000,
+	0xE4400000,
+	0x00001800,
+	0x00600391,
+	0x800E4400,
+	0x00000001,
+	0x40000002,
+	0x02A00000,
+	0x01E40000,
+	0x02A00000,
+	0x01E40000,
+	0x02A00000,
+	0x01E40000,
+	0x02A00000,
+	0x01E40000,
+	0x72200000,
+	0x80000C00,
+	0x003001C8,
+	0xC0072200,
+	0x1C880000,
+	0x20000300,
+	0x00040000,
+	0x50670000,
+	0x00000010,
+	0x24590000,
+	0x00001000,
+	0xA0000034,
+	0x0D000001,
+	0x40680C30,
+	0x41034010,
+	0x1C701A00,
+	0x80C300D0,
+	0x34010406,
+	0x01A00410,
+	0x080D0000,
+	0x51406802,
+	0x00410340,
+	0xD000001A,
+	0x06802080,
+	0x10040000,
+	0x00200000,
+	0x10040000,
+	0x00200000,
+	0x15000000,
+	0x0F200000,
+	0x15000000,
+	0x0F200000,
+	0x01FE0000,
+	0x00000000,
+	0x01800E44,
+	0x00391000,
+	0x007F8006,
+	0x00000000,
+	0x0A800001,
+	0x07900000,
+	0x0A800000,
+	0x07900000,
+	0x0A800000,
+	0x07900000,
+	0x08020000,
+	0x00100000,
+	0xC8800000,
+	0x00003001,
+	0x00C00722,
+	0x00000FF0,
+	0x72200000,
+	0x80000C00,
+	0x05400000,
+	0x02480000,
+	0x04000000,
+	0x00080000,
+	0x05400000,
+	0x03C80000,
+	0x05400000,
+	0x03C80000,
+	0x6A1C0000,
+	0x00001800,
+	0x00600391,
+	0x800E4400,
+	0x1A870001,
+	0x40000600,
+	0x02A00040,
+	0x01E40000,
+	0x02A00000,
+	0x01E40000,
+	0x02A00000,
+	0x01E40000,
+	0x02A00000,
+	0x01E40000,
+	0x72200000,
+	0x80000C00,
+	0x003001C8,
+	0xC0072200,
+	0x1C880000,
+	0x20000300,
+	0x00040000,
+	0x50670000,
+	0x00000010,
+	0x24590000,
+	0x00001000,
+	0xA0000034,
+	0x0D000001,
+	0x40680C30,
+	0x8E034010,
+	0x1C701A03,
+	0x802080D0,
+	0x34010406,
+	0x01A00040,
+	0x300D0002,
+	0x1040680C,
+	0x00410340,
+	0xD002081A,
+	0x0680C300,
+	0x10040000,
+	0x00200000,
+	0x10040000,
+	0x00200000,
+	0x15000000,
+	0x0F200000,
+	0x15000000,
+	0x0F200000,
+	0x01FE0000,
+	0x00000000,
+	0x01800E44,
+	0x00391000,
+	0x007F8006,
+	0x00000000,
+	0x99300001,
+	0x34343400,
+	0xAA0D4000,
+	0x01C3A800,
+	0xAA0D4000,
+	0x01C3A890,
+	0xAA0D4000,
+	0x01C3A800,
+	0x00040100,
+	0x00000800,
+	0x00000000,
+	0x00001208,
+	0x00482000,
+	0x01000000,
+	0x00000000,
+	0x00410482,
+	0x0006A000,
+	0x0001B400,
+	0x00020000,
+	0x00000400,
+	0x0002A000,
+	0x0001E400,
+	0x5506A000,
+	0x00E1D400,
+	0x00000000,
+	0xC880090C,
+	0x00003001,
+	0x90400000,
+	0x00000000,
+	0x2020C243,
+	0x2A835000,
+	0x0070EA00,
+	0x2A835000,
+	0x0070EA24,
+	0x2A835000,
+	0x0070EA00,
+	0x00010040,
+	0x00000200,
+	0x00000000,
+	0x00000482,
+	0x00120800,
+	0x00002000,
+	0x80000000,
+	0x00104120,
+	0x00000200,
+	0xAC0D5F80,
+	0xFFFFFFFF,
+	0x14F3690D,
+	0x1A041414,
+	0x00D00000,
+	0x0C864000,
+	0x59647A03,
+	0xDAAAA3DF,
+	0xF519651E,
+	0x034ED348,
+	0x821A0000,
+	0x0000D000,
+	0x06180680,
+	0xDF59647A,
+	0x1EDB2CA3,
+	0xC8F51965,
+	0x00034EB2,
+	0x00080000,
+	0x00001000,
+	0x00080200,
+	0x00001000,
+	0x000A8000,
+	0x00075000,
+	0x541A8000,
+	0x03875001,
+	0x00000000,
+	0x00000010,
+	0x0080C000,
+	0x41000000,
+	0x00003FC2,
+	0x00820000,
+	0xAA0D4000,
+	0x01C3A800,
+	0xAA0D4000,
+	0x01C3A890,
+	0xAA0D4000,
+	0x01C3A800,
+	0x00040000,
+	0x00000800,
+	0x00000000,
+	0x00001208,
+	0x00482000,
+	0x00800000,
+	0x00000000,
+	0x00410482,
+	0x0006A000,
+	0x0001B400,
+	0x00020000,
+	0x00000400,
+	0x00020080,
+	0x00000400,
+	0x5506A000,
+	0x00E1D400,
+	0x00000000,
+	0x0000090C,
+	0x00000010,
+	0x90400000,
+	0x00000000,
+	0x2020C243,
+	0x2A835000,
+	0x0070EA00,
+	0x2A835000,
+	0x0070EA24,
+	0x2A835000,
+	0x0070EA00,
+	0x00015000,
+	0x0000F200,
+	0x00000000,
+	0x00000482,
+	0x00120800,
+	0x00600391,
+	0x80000000,
+	0x00104120,
+	0x00000200,
+	0xAC0D5F80,
+	0xFFFFFFFF,
+	0x14F3690D,
+	0x1A041414,
+	0x00D00000,
+	0x0C864000,
+	0x59647A03,
+	0x9B2CA3DF,
+	0xF611451E,
+	0x035EB2C8,
+	0x821A028A,
+	0x0000D000,
+	0x00000680,
+	0xDF59647A,
+	0x1EDB2CA3,
+	0xC8F61145,
+	0x00034EB2,
+	0x00080000,
+	0x00001000,
+	0x00080000,
+	0x00001000,
+	0x000A8000,
+	0x00075000,
+	0x541A8000,
+	0x03875001,
+	0x00000000,
+	0x00000010,
+	0x0080C000,
+	0x41000000,
+	0x00000002,
+	0x00820004,
+	0xAA0D4000,
+	0x01C3A800,
+	0xAA0D4000,
+	0x01C3A890,
+	0xAA0D4000,
+	0x01C3A800,
+	0x00040000,
+	0x00000800,
+	0x00000000,
+	0x00001208,
+	0x00482000,
+	0x00800000,
+	0x00000000,
+	0x00410482,
+	0x0006A000,
+	0x0001B400,
+	0x00020000,
+	0x00000400,
+	0x0002A000,
+	0x0001E400,
+	0x5506A000,
+	0x00E1D400,
+	0x00000000,
+	0xC880090C,
+	0x00003001,
+	0x90400000,
+	0x00000000,
+	0x2020C243,
+	0x2A835000,
+	0x0070EA00,
+	0x2A835000,
+	0x0070EA24,
+	0x2A835000,
+	0x0070EA00,
+	0x00010000,
+	0x00000200,
+	0x00000000,
+	0x00000482,
+	0x00120800,
+	0x00200000,
+	0x80000000,
+	0x00104120,
+	0x00000200,
+	0xAC0D5F80,
+	0xFFFFFFFF,
+	0x14F3690D,
+	0x1A041414,
+	0x00D00000,
+	0x14864000,
+	0x59647A05,
+	0xDB2CA3D7,
+	0xF611451E,
+	0x035EB2C8,
+	0x821A0000,
+	0x0000D000,
+	0x00000680,
+	0xDF59647A,
+	0x1EDB2CA3,
+	0x48F61965,
+	0x00034ED3,
+	0x00080000,
+	0x00001000,
+	0x00080000,
+	0x00001000,
+	0x000A8000,
+	0x00075000,
+	0x541A8000,
+	0x03875001,
+	0x00000000,
+	0x00000010,
+	0x0080C000,
+	0x41000000,
+	0x00000002,
+	0x00820004,
+	0xAA0D4000,
+	0x01C3A800,
+	0xAA0D4000,
+	0x01C3A890,
+	0xAA0D4000,
+	0x01C3A800,
+	0x00040000,
+	0x00000800,
+	0x00000000,
+	0x00001208,
+	0x00482000,
+	0x00800000,
+	0x00000000,
+	0x00410482,
+	0x0006A000,
+	0x0001B400,
+	0x00020000,
+	0x00000400,
+	0x00020000,
+	0x00000400,
+	0x5506A000,
+	0x00E1D400,
+	0x00000000,
+	0x0000090C,
+	0x00001000,
+	0x90400000,
+	0x00000000,
+	0x2020C243,
+	0x2A835000,
+	0x0070EA00,
+	0x2A835000,
+	0x0070EA24,
+	0x2A835000,
+	0x0070EA00,
+	0x00010040,
+	0x00000200,
+	0x00000000,
+	0x00000482,
+	0x00120800,
+	0x00400000,
+	0x80000000,
+	0x00104120,
+	0x00000200,
+	0xAC0D5F80,
+	0xFFFFFFFF,
+	0x14F1690D,
+	0x1A041414,
+	0x00D00000,
+	0x14864000,
+	0x59647A05,
+	0x9B2CA3D7,
+	0xF611451E,
+	0x0356D348,
+	0x821A0000,
+	0x0000D000,
+	0x00000680,
+	0xD759647A,
+	0x1E9B2CA3,
+	0x48F61145,
+	0x000356D3,
+	0x00080000,
+	0x00001000,
+	0x00080000,
+	0x00001000,
+	0x000A8000,
+	0x00075000,
+	0x541A8000,
+	0x03875001,
+	0x00000000,
+	0x00000010,
+	0x0080C000,
+	0x41000000,
+	0x00000002,
+	0x00820004,
+	0x00489800,
+	0x801A1A1A,
+	0x00000200,
+	0x80000004,
+	0x00000200,
+	0x80000004,
+	0x00000200,
+	0x00000004,
+	0x00000200,
+	0x00000004,
+	0x00040000,
+	0x10000000,
+	0x00000000,
+	0x00004000,
+	0x00010000,
+	0x40002080,
+	0x00000100,
+	0x40000002,
+	0x00000100,
+	0x00000002,
+	0x00000100,
+	0x40000002,
+	0x00000100,
+	0x00000002,
+	0x00020000,
+	0x00000000,
+	0x00000008,
+	0x00000020,
+	0x00008000,
+	0x20001040,
+	0x00000080,
+	0x20000001,
+	0x00000080,
+	0x20000001,
+	0x00000080,
+	0x20000001,
+	0x00000080,
+	0x00000001,
+	0x00010000,
+	0x04000000,
+	0x00FF0000,
+	0x00000000,
+	0x00004000,
+	0x00000800,
+	0xC0000001,
+	0x00041419,
+	0x40000000,
+	0x04000816,
+	0x000D0000,
+	0x00006800,
+	0x00000340,
+	0xD000001A,
+	0x06800000,
+	0x00340000,
+	0x0001A000,
+	0x00000D00,
+	0x40000068,
+	0x1A000003,
+	0x00D00000,
+	0x00068000,
+	0x00003400,
+	0x000001A0,
+	0x00000401,
+	0x00000008,
+	0x00000401,
+	0x00000008,
+	0x00000401,
+	0x00000008,
+	0x00000401,
+	0x80000008,
+	0x0000007F,
+	0x20000000,
+	0x00000000,
+	0xE0000080,
+	0x0000001F,
+	0x00004000,
+};
diff --git a/arch/arm/boards/wago-pfc-cyclone5/lowlevel.c b/arch/arm/boards/wago-pfc-cyclone5/lowlevel.c
new file mode 100644
index 0000000..a4af1ac
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/lowlevel.c
@@ -0,0 +1,93 @@
+/*
+ *
+ * Copyright (C) 2019 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oliver Schildan <oliver.schildan@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <linux/sizes.h>
+#include <io.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/generic.h>
+#include <debug_ll.h>
+#include <asm/cache.h>
+#include "sdram_config.h"
+#include <mach/cyclone5-sdram-config.h>
+#include "pinmux_config.c"
+#include "pll_config.h"
+#include <mach/pll_config.h>
+#include "sequencer_defines.h"
+#include "sequencer_auto.h"
+#include <mach/cyclone5-sequencer.c>
+#include "sequencer_auto_inst_init.c"
+#include "sequencer_auto_ac_init.c"
+#include "iocsr_config_cyclone5.c"
+
+extern char __dtb_cyclone5_pfc_750_8230_start[];
+
+ENTRY_FUNCTION(start_cyclone5_pfc, r0, r1, r2)
+{
+	void *fdt;
+
+	arm_cpu_lowlevel_init();
+
+	fdt = __dtb_cyclone5_pfc_750_8230_start + get_runtime_offset();
+
+	barebox_arm_entry(0x0, SZ_1G, fdt);
+}
+
+static noinline void pfc_entry(void)
+{
+	struct socfpga_io_config io_config;
+	int ret;
+
+	arm_early_mmu_cache_invalidate();
+
+	relocate_to_current_adr();
+	setup_c();
+
+	io_config.pinmux = sys_mgr_init_table;
+	io_config.num_pin = ARRAY_SIZE(sys_mgr_init_table);
+	io_config.iocsr_emac_mixed2 = iocsr_scan_chain0_table;
+	io_config.iocsr_mixed1_flash = iocsr_scan_chain1_table;
+	io_config.iocsr_general = iocsr_scan_chain2_table;
+	io_config.iocsr_ddr = iocsr_scan_chain3_table;
+
+	socfpga_lowlevel_init(&cm_default_cfg, &io_config);
+
+	puts_ll("lowlevel init done\n");
+	puts_ll("SDRAM setup...\n");
+
+	socfpga_sdram_mmr_init();
+
+	puts_ll("SDRAM calibration...\n");
+
+	ret = socfpga_mem_calibration();
+	if (!ret)
+		hang();
+
+	puts_ll("done\n");
+
+	barebox_arm_entry(0x0, SZ_1G, NULL);
+}
+
+ENTRY_FUNCTION(start_cyclone5_pfc_xload, r0, r1, r2)
+{
+	arm_cpu_lowlevel_init();
+
+	arm_setup_stack(0xffff0000 + SZ_64K - SZ_4K - 16);
+
+	pfc_entry();
+}
diff --git a/arch/arm/boards/wago-pfc-cyclone5/pinmux_config.c b/arch/arm/boards/wago-pfc-cyclone5/pinmux_config.c
new file mode 100644
index 0000000..8dd3a89
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/pinmux_config.c
@@ -0,0 +1,241 @@
+/* GENERATED FILE - DO NOT EDIT */
+/*
+ * Copyright Altera Corporation (C) 2012-2014. All rights reserved
+ *
+ * SPDX-License-Identifier:    BSD-3-Clause
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Altera Corporation nor the
+ *      names of its contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <common.h>
+
+/* pin MUX configuration data */
+static unsigned long sys_mgr_init_table[] = {
+	0,			/* EMACIO0 */
+	2,			/* EMACIO1 */
+	2,			/* EMACIO2 */
+	2,			/* EMACIO3 */
+	2,			/* EMACIO4 */
+	2,			/* EMACIO5 */
+	2,			/* EMACIO6 */
+	2,			/* EMACIO7 */
+	2,			/* EMACIO8 */
+	0,			/* EMACIO9 */
+	2,			/* EMACIO10 */
+	2,			/* EMACIO11 */
+	2,			/* EMACIO12 */
+	2,			/* EMACIO13 */
+	0,			/* EMACIO14 */
+	0,			/* EMACIO15 */
+	0,			/* EMACIO16 */
+	0,			/* EMACIO17 */
+	0,			/* EMACIO18 */
+	0,			/* EMACIO19 */
+	3,			/* FLASHIO0 */
+	0,			/* FLASHIO1 */
+	3,			/* FLASHIO2 */
+	3,			/* FLASHIO3 */
+	3,			/* FLASHIO4 */
+	3,			/* FLASHIO5 */
+	3,			/* FLASHIO6 */
+	3,			/* FLASHIO7 */
+	0,			/* FLASHIO8 */
+	3,			/* FLASHIO9 */
+	3,			/* FLASHIO10 */
+	3,			/* FLASHIO11 */
+	3,			/* GENERALIO0 */
+	3,			/* GENERALIO1 */
+	3,			/* GENERALIO2 */
+	3,			/* GENERALIO3 */
+	3,			/* GENERALIO4 */
+	3,			/* GENERALIO5 */
+	3,			/* GENERALIO6 */
+	3,			/* GENERALIO7 */
+	3,			/* GENERALIO8 */
+	0,			/* GENERALIO9 */
+	0,			/* GENERALIO10 */
+	0,			/* GENERALIO11 */
+	0,			/* GENERALIO12 */
+	3,			/* GENERALIO13 */
+	3,			/* GENERALIO14 */
+	3,			/* GENERALIO15 */
+	3,			/* GENERALIO16 */
+	0,			/* GENERALIO17 */
+	0,			/* GENERALIO18 */
+	0,			/* GENERALIO19 */
+	0,			/* GENERALIO20 */
+	0,			/* GENERALIO21 */
+	0,			/* GENERALIO22 */
+	0,			/* GENERALIO23 */
+	0,			/* GENERALIO24 */
+	0,			/* GENERALIO25 */
+	0,			/* GENERALIO26 */
+	0,			/* GENERALIO27 */
+	0,			/* GENERALIO28 */
+	0,			/* GENERALIO29 */
+	0,			/* GENERALIO30 */
+	0,			/* GENERALIO31 */
+	2,			/* MIXED1IO0 */
+	2,			/* MIXED1IO1 */
+	2,			/* MIXED1IO2 */
+	2,			/* MIXED1IO3 */
+	2,			/* MIXED1IO4 */
+	2,			/* MIXED1IO5 */
+	2,			/* MIXED1IO6 */
+	2,			/* MIXED1IO7 */
+	2,			/* MIXED1IO8 */
+	2,			/* MIXED1IO9 */
+	2,			/* MIXED1IO10 */
+	2,			/* MIXED1IO11 */
+	2,			/* MIXED1IO12 */
+	2,			/* MIXED1IO13 */
+	0,			/* MIXED1IO14 */
+	3,			/* MIXED1IO15 */
+	3,			/* MIXED1IO16 */
+	3,			/* MIXED1IO17 */
+	3,			/* MIXED1IO18 */
+	3,			/* MIXED1IO19 */
+	3,			/* MIXED1IO20 */
+	0,			/* MIXED1IO21 */
+	0,			/* MIXED2IO0 */
+	0,			/* MIXED2IO1 */
+	0,			/* MIXED2IO2 */
+	0,			/* MIXED2IO3 */
+	0,			/* MIXED2IO4 */
+	0,			/* MIXED2IO5 */
+	0,			/* MIXED2IO6 */
+	0,			/* MIXED2IO7 */
+	0,			/* GPLINMUX48 */
+	0,			/* GPLINMUX49 */
+	0,			/* GPLINMUX50 */
+	0,			/* GPLINMUX51 */
+	0,			/* GPLINMUX52 */
+	0,			/* GPLINMUX53 */
+	0,			/* GPLINMUX54 */
+	0,			/* GPLINMUX55 */
+	0,			/* GPLINMUX56 */
+	0,			/* GPLINMUX57 */
+	0,			/* GPLINMUX58 */
+	0,			/* GPLINMUX59 */
+	0,			/* GPLINMUX60 */
+	0,			/* GPLINMUX61 */
+	0,			/* GPLINMUX62 */
+	0,			/* GPLINMUX63 */
+	0,			/* GPLINMUX64 */
+	0,			/* GPLINMUX65 */
+	0,			/* GPLINMUX66 */
+	0,			/* GPLINMUX67 */
+	0,			/* GPLINMUX68 */
+	0,			/* GPLINMUX69 */
+	0,			/* GPLINMUX70 */
+	1,			/* GPLMUX0 */
+	1,			/* GPLMUX1 */
+	1,			/* GPLMUX2 */
+	1,			/* GPLMUX3 */
+	1,			/* GPLMUX4 */
+	1,			/* GPLMUX5 */
+	1,			/* GPLMUX6 */
+	1,			/* GPLMUX7 */
+	1,			/* GPLMUX8 */
+	1,			/* GPLMUX9 */
+	1,			/* GPLMUX10 */
+	1,			/* GPLMUX11 */
+	1,			/* GPLMUX12 */
+	1,			/* GPLMUX13 */
+	1,			/* GPLMUX14 */
+	1,			/* GPLMUX15 */
+	1,			/* GPLMUX16 */
+	1,			/* GPLMUX17 */
+	1,			/* GPLMUX18 */
+	1,			/* GPLMUX19 */
+	1,			/* GPLMUX20 */
+	1,			/* GPLMUX21 */
+	1,			/* GPLMUX22 */
+	1,			/* GPLMUX23 */
+	1,			/* GPLMUX24 */
+	1,			/* GPLMUX25 */
+	1,			/* GPLMUX26 */
+	1,			/* GPLMUX27 */
+	1,			/* GPLMUX28 */
+	1,			/* GPLMUX29 */
+	1,			/* GPLMUX30 */
+	1,			/* GPLMUX31 */
+	1,			/* GPLMUX32 */
+	1,			/* GPLMUX33 */
+	1,			/* GPLMUX34 */
+	1,			/* GPLMUX35 */
+	1,			/* GPLMUX36 */
+	1,			/* GPLMUX37 */
+	1,			/* GPLMUX38 */
+	1,			/* GPLMUX39 */
+	1,			/* GPLMUX40 */
+	1,			/* GPLMUX41 */
+	1,			/* GPLMUX42 */
+	1,			/* GPLMUX43 */
+	1,			/* GPLMUX44 */
+	1,			/* GPLMUX45 */
+	1,			/* GPLMUX46 */
+	1,			/* GPLMUX47 */
+	1,			/* GPLMUX48 */
+	1,			/* GPLMUX49 */
+	1,			/* GPLMUX50 */
+	1,			/* GPLMUX51 */
+	1,			/* GPLMUX52 */
+	1,			/* GPLMUX53 */
+	1,			/* GPLMUX54 */
+	1,			/* GPLMUX55 */
+	1,			/* GPLMUX56 */
+	1,			/* GPLMUX57 */
+	1,			/* GPLMUX58 */
+	1,			/* GPLMUX59 */
+	1,			/* GPLMUX60 */
+	1,			/* GPLMUX61 */
+	1,			/* GPLMUX62 */
+	1,			/* GPLMUX63 */
+	1,			/* GPLMUX64 */
+	1,			/* GPLMUX65 */
+	1,			/* GPLMUX66 */
+	1,			/* GPLMUX67 */
+	1,			/* GPLMUX68 */
+	1,			/* GPLMUX69 */
+	1,			/* GPLMUX70 */
+	0,			/* NANDUSEFPGA */
+	0,			/* UART0USEFPGA */
+	0,			/* RGMII1USEFPGA */
+	0,			/* SPIS0USEFPGA */
+	0,			/* CAN0USEFPGA */
+	0,			/* I2C0USEFPGA */
+	0,			/* SDMMCUSEFPGA */
+	0,			/* QSPIUSEFPGA */
+	0,			/* SPIS1USEFPGA */
+	0,			/* RGMII0USEFPGA */
+	1,			/* UART1USEFPGA */
+	0,			/* CAN1USEFPGA */
+	0,			/* USB1USEFPGA */
+	0,			/* I2C3USEFPGA */
+	0,			/* I2C2USEFPGA */
+	0,			/* I2C1USEFPGA */
+	1,			/* SPIM1USEFPGA */
+	0,			/* USB0USEFPGA */
+	0			/* SPIM0USEFPGA */
+};
diff --git a/arch/arm/boards/wago-pfc-cyclone5/pll_config.h b/arch/arm/boards/wago-pfc-cyclone5/pll_config.h
new file mode 100644
index 0000000..a1e6bcf
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/pll_config.h
@@ -0,0 +1,107 @@
+/* GENERATED FILE - DO NOT EDIT */
+/*
+ * Copyright Altera Corporation (C) 2012-2014. All rights reserved
+ *
+ * SPDX-License-Identifier:    BSD-3-Clause
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Altera Corporation nor the
+ *      names of its contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _PRELOADER_PLL_CONFIG_H_
+#define _PRELOADER_PLL_CONFIG_H_
+
+#define CONFIG_HPS_DBCTRL_STAYOSC1 (1)
+
+#define CONFIG_HPS_MAINPLLGRP_VCO_DENOM (0)
+#define CONFIG_HPS_MAINPLLGRP_VCO_NUMER (63)
+#define CONFIG_HPS_MAINPLLGRP_MPUCLK_CNT (0)
+#define CONFIG_HPS_MAINPLLGRP_MAINCLK_CNT (0)
+#define CONFIG_HPS_MAINPLLGRP_DBGATCLK_CNT (0)
+#define CONFIG_HPS_MAINPLLGRP_MAINQSPICLK_CNT (7)
+#define CONFIG_HPS_MAINPLLGRP_MAINNANDSDMMCCLK_CNT (511)
+#define CONFIG_HPS_MAINPLLGRP_CFGS2FUSER0CLK_CNT (15)
+#define CONFIG_HPS_MAINPLLGRP_MAINDIV_L3MPCLK (1)
+#define CONFIG_HPS_MAINPLLGRP_MAINDIV_L3SPCLK (1)
+#define CONFIG_HPS_MAINPLLGRP_MAINDIV_L4MPCLK (1)
+#define CONFIG_HPS_MAINPLLGRP_MAINDIV_L4SPCLK (1)
+#define CONFIG_HPS_MAINPLLGRP_DBGDIV_DBGATCLK (0)
+#define CONFIG_HPS_MAINPLLGRP_DBGDIV_DBGCLK (1)
+#define CONFIG_HPS_MAINPLLGRP_TRACEDIV_TRACECLK (0)
+#define CONFIG_HPS_MAINPLLGRP_L4SRC_L4MP (1)
+#define CONFIG_HPS_MAINPLLGRP_L4SRC_L4SP (1)
+
+#define CONFIG_HPS_PERPLLGRP_VCO_DENOM (0)
+#define CONFIG_HPS_PERPLLGRP_VCO_NUMER (39)
+#define CONFIG_HPS_PERPLLGRP_VCO_PSRC (0)
+#define CONFIG_HPS_PERPLLGRP_EMAC0CLK_CNT (511)
+#define CONFIG_HPS_PERPLLGRP_EMAC1CLK_CNT (3)
+#define CONFIG_HPS_PERPLLGRP_PERQSPICLK_CNT (511)
+#define CONFIG_HPS_PERPLLGRP_PERNANDSDMMCCLK_CNT (4)
+#define CONFIG_HPS_PERPLLGRP_PERBASECLK_CNT (4)
+#define CONFIG_HPS_PERPLLGRP_S2FUSER1CLK_CNT (511)
+#define CONFIG_HPS_PERPLLGRP_DIV_USBCLK (0)
+#define CONFIG_HPS_PERPLLGRP_DIV_SPIMCLK (0)
+#define CONFIG_HPS_PERPLLGRP_DIV_CAN0CLK (4)
+#define CONFIG_HPS_PERPLLGRP_DIV_CAN1CLK (4)
+#define CONFIG_HPS_PERPLLGRP_GPIODIV_GPIODBCLK (6249)
+#define CONFIG_HPS_PERPLLGRP_SRC_SDMMC (2)
+#define CONFIG_HPS_PERPLLGRP_SRC_NAND (2)
+#define CONFIG_HPS_PERPLLGRP_SRC_QSPI (1)
+
+#define CONFIG_HPS_SDRPLLGRP_VCO_DENOM (0)
+#define CONFIG_HPS_SDRPLLGRP_VCO_NUMER (39)
+#define CONFIG_HPS_SDRPLLGRP_VCO_SSRC (0)
+#define CONFIG_HPS_SDRPLLGRP_DDRDQSCLK_CNT (1)
+#define CONFIG_HPS_SDRPLLGRP_DDRDQSCLK_PHASE (0)
+#define CONFIG_HPS_SDRPLLGRP_DDR2XDQSCLK_CNT (0)
+#define CONFIG_HPS_SDRPLLGRP_DDR2XDQSCLK_PHASE (0)
+#define CONFIG_HPS_SDRPLLGRP_DDRDQCLK_CNT (1)
+#define CONFIG_HPS_SDRPLLGRP_DDRDQCLK_PHASE (4)
+#define CONFIG_HPS_SDRPLLGRP_S2FUSER2CLK_CNT (5)
+#define CONFIG_HPS_SDRPLLGRP_S2FUSER2CLK_PHASE (0)
+
+#define CONFIG_HPS_CLK_OSC1_HZ (25000000)
+#define CONFIG_HPS_CLK_OSC2_HZ (25000000)
+#define CONFIG_HPS_CLK_F2S_SDR_REF_HZ (0)
+#define CONFIG_HPS_CLK_F2S_PER_REF_HZ (0)
+#define CONFIG_HPS_CLK_MAINVCO_HZ (1600000000)
+#define CONFIG_HPS_CLK_PERVCO_HZ (1000000000)
+#define CONFIG_HPS_CLK_SDRVCO_HZ (1000000000)
+#define CONFIG_HPS_CLK_EMAC0_HZ (1953125)
+#define CONFIG_HPS_CLK_EMAC1_HZ (250000000)
+#define CONFIG_HPS_CLK_USBCLK_HZ (200000000)
+#define CONFIG_HPS_CLK_NAND_HZ (50000000)
+#define CONFIG_HPS_CLK_SDMMC_HZ (200000000)
+#define CONFIG_HPS_CLK_QSPI_HZ (200000000)
+#define CONFIG_HPS_CLK_SPIM_HZ (200000000)
+#define CONFIG_HPS_CLK_CAN0_HZ (12500000)
+#define CONFIG_HPS_CLK_CAN1_HZ (12500000)
+#define CONFIG_HPS_CLK_GPIODB_HZ (32000)
+#define CONFIG_HPS_CLK_L4_MP_HZ (100000000)
+#define CONFIG_HPS_CLK_L4_SP_HZ (100000000)
+
+#define CONFIG_HPS_ALTERAGRP_MPUCLK (1)
+#define CONFIG_HPS_ALTERAGRP_MAINCLK (3)
+#define CONFIG_HPS_ALTERAGRP_DBGATCLK (3)
+
+#endif /* _PRELOADER_PLL_CONFIG_H_ */
diff --git a/arch/arm/boards/wago-pfc-cyclone5/sdram_config.h b/arch/arm/boards/wago-pfc-cyclone5/sdram_config.h
new file mode 100644
index 0000000..6d738ef
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/sdram_config.h
@@ -0,0 +1,112 @@
+/* GENERATED FILE - DO NOT EDIT */
+/*
+ * Copyright Altera Corporation (C) 2012-2014. All rights reserved
+ *
+ * SPDX-License-Identifier:    BSD-3-Clause
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Altera Corporation nor the
+ *      names of its contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SDRAM_CONFIG_H
+#define __SDRAM_CONFIG_H
+
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_MEMTYPE			(2)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_MEMBL			(8)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_ADDRORDER		(0)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_ECCEN			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_ECCCORREN		(0)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_REORDEREN		(1)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_STARVELIMIT		(10)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_DQSTRKEN			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLCFG_NODMPINS			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING1_TCWL			(6)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING1_AL			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING1_TCL			(7)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING1_TRRD			(4)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING1_TFAW			(20)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING1_TRFC			(130)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING2_IF_TREFI		(1950)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING2_IF_TRCD		(7)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING2_IF_TRP		(7)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING2_IF_TWR		(8)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING2_IF_TWTR		(4)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING3_TRTP			(4)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING3_TRAS			(18)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING3_TRC			(25)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING3_TMRD			(4)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING3_TCCD			(4)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING4_SELFRFSHEXIT		(512)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMTIMING4_PWRDOWNEXIT		(3)
+#define CONFIG_HPS_SDR_CTRLCFG_LOWPWRTIMING_AUTOPDCYCLES	(0)
+#define CONFIG_HPS_SDR_CTRLCFG_LOWPWRTIMING_CLKDISABLECYCLES	(8)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMADDRW_COLBITS		(10)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMADDRW_ROWBITS		(15)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMADDRW_BANKBITS		(3)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMADDRW_CSBITS			(1)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMIFWIDTH_IFWIDTH		(32)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMDEVWIDTH_DEVWIDTH		(8)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMINTR_INTREN			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_LOWPWREQ_SELFRFSHMASK		(3)
+#define CONFIG_HPS_SDR_CTRLCFG_STATICCFG_MEMBL			(2)
+#define CONFIG_HPS_SDR_CTRLCFG_STATICCFG_USEECCASDATA		(0)
+#define CONFIG_HPS_SDR_CTRLCFG_CTRLWIDTH_CTRLWIDTH		(2)
+#define CONFIG_HPS_SDR_CTRLCFG_PORTCFG_AUTOPCHEN		(0)
+#define CONFIG_HPS_SDR_CTRLCFG_FIFOCFG_SYNCMODE			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_FIFOCFG_INCSYNC			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_MPPRIORITY_USERPRIORITY		(0x0)
+#define CONFIG_HPS_SDR_CTRLCFG_MPWIEIGHT_0_STATICWEIGHT_31_0	(0x21084210)
+#define CONFIG_HPS_SDR_CTRLCFG_MPWIEIGHT_1_STATICWEIGHT_49_32	(0x10441)
+#define CONFIG_HPS_SDR_CTRLCFG_MPWIEIGHT_1_SUMOFWEIGHT_13_0	(0x78)
+#define CONFIG_HPS_SDR_CTRLCFG_MPWIEIGHT_2_SUMOFWEIGHT_45_14	(0x0)
+#define CONFIG_HPS_SDR_CTRLCFG_MPWIEIGHT_3_SUMOFWEIGHT_63_46	(0x0)
+#define CONFIG_HPS_SDR_CTRLCFG_PHYCTRL_PHYCTRL_0		(0x200)
+
+#define CONFIG_HPS_SDR_CTRLCFG_CPORTWIDTH_CPORTWIDTH		(0x44555)
+#define CONFIG_HPS_SDR_CTRLCFG_CPORTWMAP_CPORTWMAP		(0x2C011000)
+#define CONFIG_HPS_SDR_CTRLCFG_CPORTRMAP_CPORTRMAP		(0xB00088)
+#define CONFIG_HPS_SDR_CTRLCFG_RFIFOCMAP_RFIFOCMAP		(0x760210)
+#define CONFIG_HPS_SDR_CTRLCFG_WFIFOCMAP_WFIFOCMAP		(0x980543)
+#define CONFIG_HPS_SDR_CTRLCFG_CPORTRDWR_CPORTRDWR		(0x5A56A)
+#define CONFIG_HPS_SDR_CTRLCFG_MPPACING_0_THRESHOLD1_31_0	(0x20820820)
+#define CONFIG_HPS_SDR_CTRLCFG_MPPACING_1_THRESHOLD1_59_32	(0x8208208)
+#define CONFIG_HPS_SDR_CTRLCFG_MPPACING_1_THRESHOLD2_3_0	(0)
+#define CONFIG_HPS_SDR_CTRLCFG_MPPACING_2_THRESHOLD2_35_4	(0x41041041)
+#define CONFIG_HPS_SDR_CTRLCFG_MPPACING_3_THRESHOLD2_59_36	(0x410410)
+#define CONFIG_HPS_SDR_CTRLCFG_MPTHRESHOLDRST_0_THRESHOLDRSTCYCLES_31_0 \
+(0x01010101)
+#define CONFIG_HPS_SDR_CTRLCFG_MPTHRESHOLDRST_1_THRESHOLDRSTCYCLES_63_32 \
+(0x01010101)
+#define CONFIG_HPS_SDR_CTRLCFG_MPTHRESHOLDRST_2_THRESHOLDRSTCYCLES_79_64 \
+(0x0101)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMODT_READ			(0)
+#define CONFIG_HPS_SDR_CTRLCFG_DRAMODT_WRITE			(1)
+#define CONFIG_HPS_SDR_CTRLCFG_FPGAPORTRST_READ_PORT_USED	(0x7)
+#define CONFIG_HPS_SDR_CTRLCFG_FPGAPORTRST_WRITE_PORT_USED	(0x7)
+#define CONFIG_HPS_SDR_CTRLCFG_FPGAPORTRST_COMMAND_PORT_USED	(0x7)
+#define CONFIG_HPS_SDR_CTRLCFG_FPGAPORTRST			(0x777)
+
+#define CONFIG_HPS_SDR_CTRLCFG_EXTRATIME1_CFG_EXTRA_CTL_CLK_RD_TO_WR (2)
+#define CONFIG_HPS_SDR_CTRLCFG_EXTRATIME1_CFG_EXTRA_CTL_CLK_RD_TO_WR_BC (2)
+#define CONFIG_HPS_SDR_CTRLCFG_EXTRATIME1_CFG_EXTRA_CTL_CLK_RD_TO_WR_DIFF_CHIP (2)
+
+#endif /*#ifndef__SDRAM_CONFIG_H */
diff --git a/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto.h b/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto.h
new file mode 100644
index 0000000..93d516e
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto.h
@@ -0,0 +1,225 @@
+/*
+Copyright (C) 2016  Intel Corporation. All rights reserved.
+
+SPDX-License-Identifier:    BSD-3-Clause
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Intel Corporation nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#define __RW_MGR_ac_mrs1 0x04
+#define __RW_MGR_ac_mrs3 0x06
+#define __RW_MGR_ac_write_bank_0_col_0_nodata_wl_1 0x1C
+#define __RW_MGR_ac_act_1 0x11
+#define __RW_MGR_ac_write_postdata 0x1A
+#define __RW_MGR_ac_act_0 0x10
+#define __RW_MGR_ac_des 0x0D
+#define __RW_MGR_ac_init_reset_1_cke_0 0x01
+#define __RW_MGR_ac_write_data 0x19
+#define __RW_MGR_ac_init_reset_0_cke_0 0x00
+#define __RW_MGR_ac_read_bank_0_1_norden 0x22
+#define __RW_MGR_ac_pre_all 0x12
+#define __RW_MGR_ac_mrs0_user 0x02
+#define __RW_MGR_ac_mrs0_dll_reset 0x03
+#define __RW_MGR_ac_read_bank_0_0 0x1D
+#define __RW_MGR_ac_write_bank_0_col_1 0x16
+#define __RW_MGR_ac_read_bank_0_1 0x1F
+#define __RW_MGR_ac_write_bank_1_col_0 0x15
+#define __RW_MGR_ac_write_bank_1_col_1 0x17
+#define __RW_MGR_ac_write_bank_0_col_0 0x14
+#define __RW_MGR_ac_read_bank_1_0 0x1E
+#define __RW_MGR_ac_mrs1_mirr 0x0A
+#define __RW_MGR_ac_read_bank_1_1 0x20
+#define __RW_MGR_ac_des_odt_1 0x0E
+#define __RW_MGR_ac_mrs0_dll_reset_mirr 0x09
+#define __RW_MGR_ac_zqcl 0x07
+#define __RW_MGR_ac_write_predata 0x18
+#define __RW_MGR_ac_mrs0_user_mirr 0x08
+#define __RW_MGR_ac_ref 0x13
+#define __RW_MGR_ac_nop 0x0F
+#define __RW_MGR_ac_rdimm 0x23
+#define __RW_MGR_ac_mrs2_mirr 0x0B
+#define __RW_MGR_ac_write_bank_0_col_0_nodata 0x1B
+#define __RW_MGR_ac_read_en 0x21
+#define __RW_MGR_ac_mrs3_mirr 0x0C
+#define __RW_MGR_ac_mrs2 0x05
+#define __RW_MGR_CONTENT_ac_mrs1 0x10090044
+#define __RW_MGR_CONTENT_ac_mrs3 0x100B0000
+#define __RW_MGR_CONTENT_ac_write_bank_0_col_0_nodata_wl_1 0x18980000
+#define __RW_MGR_CONTENT_ac_act_1 0x106B0000
+#define __RW_MGR_CONTENT_ac_write_postdata 0x38780000
+#define __RW_MGR_CONTENT_ac_act_0 0x10680000
+#define __RW_MGR_CONTENT_ac_des 0x30780000
+#define __RW_MGR_CONTENT_ac_init_reset_1_cke_0 0x20780000
+#define __RW_MGR_CONTENT_ac_write_data 0x3CF80000
+#define __RW_MGR_CONTENT_ac_init_reset_0_cke_0 0x20700000
+#define __RW_MGR_CONTENT_ac_read_bank_0_1_norden 0x10580008
+#define __RW_MGR_CONTENT_ac_pre_all 0x10280400
+#define __RW_MGR_CONTENT_ac_mrs0_user 0x10080831
+#define __RW_MGR_CONTENT_ac_mrs0_dll_reset 0x10080930
+#define __RW_MGR_CONTENT_ac_read_bank_0_0 0x13580000
+#define __RW_MGR_CONTENT_ac_write_bank_0_col_1 0x1C980008
+#define __RW_MGR_CONTENT_ac_read_bank_0_1 0x13580008
+#define __RW_MGR_CONTENT_ac_write_bank_1_col_0 0x1C9B0000
+#define __RW_MGR_CONTENT_ac_write_bank_1_col_1 0x1C9B0008
+#define __RW_MGR_CONTENT_ac_write_bank_0_col_0 0x1C980000
+#define __RW_MGR_CONTENT_ac_read_bank_1_0 0x135B0000
+#define __RW_MGR_CONTENT_ac_mrs1_mirr 0x100A0024
+#define __RW_MGR_CONTENT_ac_read_bank_1_1 0x135B0008
+#define __RW_MGR_CONTENT_ac_des_odt_1 0x38780000
+#define __RW_MGR_CONTENT_ac_mrs0_dll_reset_mirr 0x100808C8
+#define __RW_MGR_CONTENT_ac_zqcl 0x10380400
+#define __RW_MGR_CONTENT_ac_write_predata 0x38F80000
+#define __RW_MGR_CONTENT_ac_mrs0_user_mirr 0x10080849
+#define __RW_MGR_CONTENT_ac_ref 0x10480000
+#define __RW_MGR_CONTENT_ac_nop 0x30780000
+#define __RW_MGR_CONTENT_ac_rdimm 0x10780000
+#define __RW_MGR_CONTENT_ac_mrs2_mirr 0x10090010
+#define __RW_MGR_CONTENT_ac_write_bank_0_col_0_nodata 0x18180000
+#define __RW_MGR_CONTENT_ac_read_en 0x33780000
+#define __RW_MGR_CONTENT_ac_mrs3_mirr 0x100B0000
+#define __RW_MGR_CONTENT_ac_mrs2 0x100A0008
+
+/*
+Copyright (C) 2016  Intel Corporation. All rights reserved.
+
+SPDX-License-Identifier:    BSD-3-Clause
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Intel Corporation nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#define __RW_MGR_READ_B2B_WAIT2 0x6B
+#define __RW_MGR_LFSR_WR_RD_BANK_0_WAIT 0x32
+#define __RW_MGR_REFRESH_ALL 0x14
+#define __RW_MGR_ZQCL 0x06
+#define __RW_MGR_LFSR_WR_RD_BANK_0_NOP 0x23
+#define __RW_MGR_LFSR_WR_RD_BANK_0_DQS 0x24
+#define __RW_MGR_ACTIVATE_0_AND_1 0x0D
+#define __RW_MGR_MRS2_MIRR 0x0A
+#define __RW_MGR_INIT_RESET_0_CKE_0 0x6F
+#define __RW_MGR_LFSR_WR_RD_DM_BANK_0_WAIT 0x46
+#define __RW_MGR_ACTIVATE_1 0x0F
+#define __RW_MGR_MRS2 0x04
+#define __RW_MGR_LFSR_WR_RD_DM_BANK_0_WL_1 0x35
+#define __RW_MGR_MRS1 0x03
+#define __RW_MGR_IDLE_LOOP1 0x7B
+#define __RW_MGR_GUARANTEED_WRITE_WAIT2 0x19
+#define __RW_MGR_MRS3 0x05
+#define __RW_MGR_IDLE_LOOP2 0x7A
+#define __RW_MGR_GUARANTEED_WRITE_WAIT1 0x1F
+#define __RW_MGR_LFSR_WR_RD_BANK_0_DATA 0x25
+#define __RW_MGR_GUARANTEED_WRITE_WAIT3 0x1D
+#define __RW_MGR_RDIMM_CMD 0x79
+#define __RW_MGR_LFSR_WR_RD_DM_BANK_0_NOP 0x37
+#define __RW_MGR_GUARANTEED_WRITE_WAIT0 0x1B
+#define __RW_MGR_LFSR_WR_RD_DM_BANK_0_DATA 0x39
+#define __RW_MGR_GUARANTEED_READ_CONT 0x54
+#define __RW_MGR_REFRESH_DELAY 0x15
+#define __RW_MGR_MRS3_MIRR 0x0B
+#define __RW_MGR_IDLE 0x00
+#define __RW_MGR_READ_B2B 0x59
+#define __RW_MGR_LFSR_WR_RD_DM_BANK_0_DQS 0x38
+#define __RW_MGR_GUARANTEED_WRITE 0x18
+#define __RW_MGR_PRECHARGE_ALL 0x12
+#define __RW_MGR_SGLE_READ 0x7D
+#define __RW_MGR_MRS0_USER_MIRR 0x0C
+#define __RW_MGR_RETURN 0x01
+#define __RW_MGR_LFSR_WR_RD_DM_BANK_0 0x36
+#define __RW_MGR_MRS0_USER 0x07
+#define __RW_MGR_GUARANTEED_READ 0x4C
+#define __RW_MGR_MRS0_DLL_RESET_MIRR 0x08
+#define __RW_MGR_INIT_RESET_1_CKE_0 0x74
+#define __RW_MGR_ACTIVATE_0_AND_1_WAIT2 0x10
+#define __RW_MGR_LFSR_WR_RD_BANK_0_WL_1 0x21
+#define __RW_MGR_MRS0_DLL_RESET 0x02
+#define __RW_MGR_ACTIVATE_0_AND_1_WAIT1 0x0E
+#define __RW_MGR_LFSR_WR_RD_BANK_0 0x22
+#define __RW_MGR_CLEAR_DQS_ENABLE 0x49
+#define __RW_MGR_MRS1_MIRR 0x09
+#define __RW_MGR_READ_B2B_WAIT1 0x61
+#define __RW_MGR_CONTENT_READ_B2B_WAIT2 0x00C680
+#define __RW_MGR_CONTENT_LFSR_WR_RD_BANK_0_WAIT 0x00A680
+#define __RW_MGR_CONTENT_REFRESH_ALL 0x000980
+#define __RW_MGR_CONTENT_ZQCL 0x008380
+#define __RW_MGR_CONTENT_LFSR_WR_RD_BANK_0_NOP 0x00E700
+#define __RW_MGR_CONTENT_LFSR_WR_RD_BANK_0_DQS 0x000C00
+#define __RW_MGR_CONTENT_ACTIVATE_0_AND_1 0x000800
+#define __RW_MGR_CONTENT_MRS2_MIRR 0x008580
+#define __RW_MGR_CONTENT_INIT_RESET_0_CKE_0 0x000000
+#define __RW_MGR_CONTENT_LFSR_WR_RD_DM_BANK_0_WAIT 0x00A680
+#define __RW_MGR_CONTENT_ACTIVATE_1 0x000880
+#define __RW_MGR_CONTENT_MRS2 0x008280
+#define __RW_MGR_CONTENT_LFSR_WR_RD_DM_BANK_0_WL_1 0x00CE00
+#define __RW_MGR_CONTENT_MRS1 0x008200
+#define __RW_MGR_CONTENT_IDLE_LOOP1 0x00A680
+#define __RW_MGR_CONTENT_GUARANTEED_WRITE_WAIT2 0x00CCE8
+#define __RW_MGR_CONTENT_MRS3 0x008300
+#define __RW_MGR_CONTENT_IDLE_LOOP2 0x008680
+#define __RW_MGR_CONTENT_GUARANTEED_WRITE_WAIT1 0x00AC88
+#define __RW_MGR_CONTENT_LFSR_WR_RD_BANK_0_DATA 0x020CE0
+#define __RW_MGR_CONTENT_GUARANTEED_WRITE_WAIT3 0x00EC88
+#define __RW_MGR_CONTENT_RDIMM_CMD 0x009180
+#define __RW_MGR_CONTENT_LFSR_WR_RD_DM_BANK_0_NOP 0x00E700
+#define __RW_MGR_CONTENT_GUARANTEED_WRITE_WAIT0 0x008CE8
+#define __RW_MGR_CONTENT_LFSR_WR_RD_DM_BANK_0_DATA 0x030CE0
+#define __RW_MGR_CONTENT_GUARANTEED_READ_CONT 0x001168
+#define __RW_MGR_CONTENT_REFRESH_DELAY 0x00A680
+#define __RW_MGR_CONTENT_MRS3_MIRR 0x008600
+#define __RW_MGR_CONTENT_IDLE 0x080000
+#define __RW_MGR_CONTENT_READ_B2B 0x040E88
+#define __RW_MGR_CONTENT_LFSR_WR_RD_DM_BANK_0_DQS 0x000C00
+#define __RW_MGR_CONTENT_GUARANTEED_WRITE 0x000B68
+#define __RW_MGR_CONTENT_PRECHARGE_ALL 0x000900
+#define __RW_MGR_CONTENT_SGLE_READ 0x040F08
+#define __RW_MGR_CONTENT_MRS0_USER_MIRR 0x008400
+#define __RW_MGR_CONTENT_RETURN 0x080680
+#define __RW_MGR_CONTENT_LFSR_WR_RD_DM_BANK_0 0x00CD80
+#define __RW_MGR_CONTENT_MRS0_USER 0x008100
+#define __RW_MGR_CONTENT_GUARANTEED_READ 0x001168
+#define __RW_MGR_CONTENT_MRS0_DLL_RESET_MIRR 0x008480
+#define __RW_MGR_CONTENT_INIT_RESET_1_CKE_0 0x000080
+#define __RW_MGR_CONTENT_ACTIVATE_0_AND_1_WAIT2 0x00A680
+#define __RW_MGR_CONTENT_LFSR_WR_RD_BANK_0_WL_1 0x00CE00
+#define __RW_MGR_CONTENT_MRS0_DLL_RESET 0x008180
+#define __RW_MGR_CONTENT_ACTIVATE_0_AND_1_WAIT1 0x008680
+#define __RW_MGR_CONTENT_LFSR_WR_RD_BANK_0 0x00CD80
+#define __RW_MGR_CONTENT_CLEAR_DQS_ENABLE 0x001158
+#define __RW_MGR_CONTENT_MRS1_MIRR 0x008500
+#define __RW_MGR_CONTENT_READ_B2B_WAIT1 0x00A680
diff --git a/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto_ac_init.c b/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto_ac_init.c
new file mode 100644
index 0000000..e7b56c5
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto_ac_init.c
@@ -0,0 +1,67 @@
+/*
+Copyright (C) 2016  Intel Corporation. All rights reserved.
+
+SPDX-License-Identifier:    BSD-3-Clause
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Intel Corporation nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+static const uint32_t ac_rom_init_size = 36;
+static const uint32_t ac_rom_init[36] = {
+	0x20700000,
+	0x20780000,
+	0x10080831,
+	0x10080930,
+	0x10090044,
+	0x100a0008,
+	0x100b0000,
+	0x10380400,
+	0x10080849,
+	0x100808c8,
+	0x100a0024,
+	0x10090010,
+	0x100b0000,
+	0x30780000,
+	0x38780000,
+	0x30780000,
+	0x10680000,
+	0x106b0000,
+	0x10280400,
+	0x10480000,
+	0x1c980000,
+	0x1c9b0000,
+	0x1c980008,
+	0x1c9b0008,
+	0x38f80000,
+	0x3cf80000,
+	0x38780000,
+	0x18180000,
+	0x18980000,
+	0x13580000,
+	0x135b0000,
+	0x13580008,
+	0x135b0008,
+	0x33780000,
+	0x10580008,
+	0x10780000
+};
diff --git a/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto_inst_init.c b/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto_inst_init.c
new file mode 100644
index 0000000..cfeed3f
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/sequencer_auto_inst_init.c
@@ -0,0 +1,158 @@
+/*
+Copyright (C) 2016  Intel Corporation. All rights reserved.
+
+SPDX-License-Identifier:    BSD-3-Clause
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Intel Corporation nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+static const uint32_t inst_rom_init_size = 127;
+static const uint32_t inst_rom_init[127] = {
+	0x80000,
+	0x80680,
+	0x8180,
+	0x8200,
+	0x8280,
+	0x8300,
+	0x8380,
+	0x8100,
+	0x8480,
+	0x8500,
+	0x8580,
+	0x8600,
+	0x8400,
+	0x800,
+	0x8680,
+	0x880,
+	0xa680,
+	0x80680,
+	0x900,
+	0x80680,
+	0x980,
+	0xa680,
+	0x8680,
+	0x80680,
+	0xb68,
+	0xcce8,
+	0xae8,
+	0x8ce8,
+	0xb88,
+	0xec88,
+	0xa08,
+	0xac88,
+	0x80680,
+	0xce00,
+	0xcd80,
+	0xe700,
+	0xc00,
+	0x20ce0,
+	0x20ce0,
+	0x20ce0,
+	0x20ce0,
+	0xd00,
+	0x680,
+	0x680,
+	0x680,
+	0x680,
+	0x60e80,
+	0x61080,
+	0x61080,
+	0x61080,
+	0xa680,
+	0x8680,
+	0x80680,
+	0xce00,
+	0xcd80,
+	0xe700,
+	0xc00,
+	0x30ce0,
+	0x30ce0,
+	0x30ce0,
+	0x30ce0,
+	0xd00,
+	0x680,
+	0x680,
+	0x680,
+	0x680,
+	0x70e80,
+	0x71080,
+	0x71080,
+	0x71080,
+	0xa680,
+	0x8680,
+	0x80680,
+	0x1158,
+	0x6d8,
+	0x80680,
+	0x1168,
+	0x7e8,
+	0x7e8,
+	0x87e8,
+	0x40fe8,
+	0x410e8,
+	0x410e8,
+	0x410e8,
+	0x1168,
+	0x7e8,
+	0x7e8,
+	0xa7e8,
+	0x80680,
+	0x40e88,
+	0x41088,
+	0x41088,
+	0x41088,
+	0x40f68,
+	0x410e8,
+	0x410e8,
+	0x410e8,
+	0xa680,
+	0x40fe8,
+	0x410e8,
+	0x410e8,
+	0x410e8,
+	0x41008,
+	0x41088,
+	0x41088,
+	0x41088,
+	0x1100,
+	0xc680,
+	0x8680,
+	0xe680,
+	0x80680,
+	0x0,
+	0x8000,
+	0xa000,
+	0xc000,
+	0x80000,
+	0x80,
+	0x8080,
+	0xa080,
+	0xc080,
+	0x80080,
+	0x9180,
+	0x8680,
+	0xa680,
+	0x80680,
+	0x40f08,
+	0x80680
+};
diff --git a/arch/arm/boards/wago-pfc-cyclone5/sequencer_defines.h b/arch/arm/boards/wago-pfc-cyclone5/sequencer_defines.h
new file mode 100644
index 0000000..701a00b
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/sequencer_defines.h
@@ -0,0 +1,165 @@
+/*
+Copyright (C) 2016 Intel Corporation
+All rights reserved.
+
+SPDX-License-Identifier:    BSD-3-Clause
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of Altera Corporation nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ALTERA CORPORATION BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef _SEQUENCER_DEFINES_H_
+#define _SEQUENCER_DEFINES_H_
+
+#define AC_ROM_MR1_MIRR 0000000100100
+#define AC_ROM_MR1_OCD_ENABLE
+#define AC_ROM_MR2_MIRR 0000000010000
+#define AC_ROM_MR3_MIRR 0000000000000
+#define AC_ROM_MR0_CALIB
+#define AC_ROM_MR0_DLL_RESET_MIRR 0100011001000
+#define AC_ROM_MR0_DLL_RESET 0100100110000
+#define AC_ROM_MR0_MIRR 0100001001001
+#define AC_ROM_MR0 0100000110001
+#define AC_ROM_MR1 0000001000100
+#define AC_ROM_MR2 0000000001000
+#define AC_ROM_MR3 0000000000000
+#define AC_ROM_USER_ADD_0 0_0000_0000_0000
+#define AC_ROM_USER_ADD_1 0_0000_0000_1000
+#define AFI_CLK_FREQ 501
+#define AFI_RATE_RATIO 1
+#define AP_MODE 0
+#define ARRIAVGZ 0
+#define ARRIAV 0
+#define AVL_CLK_FREQ 63
+#define BFM_MODE 0
+#define BURST2 0
+#define CALIBRATE_BIT_SLIPS 0
+#define CALIB_LFIFO_OFFSET 8
+#define CALIB_VFIFO_OFFSET 6
+#define CYCLONEV 1
+#define DDR2 0
+#define DDR3 1
+#define DDRX 1
+#define DM_PINS_ENABLED 1
+#define ENABLE_ASSERT 0
+#define ENABLE_BRINGUP_DEBUGGING 0
+#define ENABLE_DELAY_CHAIN_WRITE 0
+#define ENABLE_DQS_IN_CENTERING 1
+#define ENABLE_DQS_OUT_CENTERING 0
+#define ENABLE_EXPORT_SEQ_DEBUG_BRIDGE 0
+#define ENABLE_INST_ROM_WRITE 1
+#define ENABLE_MARGIN_REPORT_GEN 0
+#define ENABLE_NON_DESTRUCTIVE_CALIB 0
+#define ENABLE_NON_DES_CAL_TEST 0
+#define ENABLE_NON_DES_CAL 0
+#define ENABLE_SUPER_QUICK_CALIBRATION 0
+#define ENABLE_TCL_DEBUG 0
+#define FAKE_CAL_FAIL 0
+#define FIX_READ_LATENCY 8
+#define FULL_RATE 1
+#define GUARANTEED_READ_BRINGUP_TEST 0
+#define HALF_RATE 0
+#define HARD_PHY 1
+#define HARD_VFIFO 1
+#define HCX_COMPAT_MODE 0
+#define HHP_HPS_SIMULATION 0
+#define HHP_HPS_VERIFICATION 0
+#define HHP_HPS 1
+#define HPS_HW 1
+#define HR_DDIO_OUT_HAS_THREE_REGS 0
+#define IO_DELAY_PER_DCHAIN_TAP 25
+#define IO_DELAY_PER_DQS_EN_DCHAIN_TAP 25
+#define IO_DELAY_PER_OPA_TAP 250
+#define IO_DLL_CHAIN_LENGTH 8
+#define IO_DM_OUT_RESERVE 0
+#define IO_DQDQS_OUT_PHASE_MAX 0
+#define IO_DQS_EN_DELAY_MAX 15
+#define IO_DQS_EN_DELAY_OFFSET 16
+#define IO_DQS_EN_PHASE_MAX 7
+#define IO_DQS_IN_DELAY_MAX 31
+#define IO_DQS_IN_RESERVE 4
+#define IO_DQS_OUT_RESERVE 4
+#define IO_DQ_OUT_RESERVE 0
+#define IO_IO_IN_DELAY_MAX 31
+#define IO_IO_OUT1_DELAY_MAX 31
+#define IO_IO_OUT2_DELAY_MAX 0
+#define IO_SHIFT_DQS_EN_WHEN_SHIFT_DQS 0
+#define LPDDR1 0
+#define LPDDR2 0
+#define LRDIMM 0
+#define MARGIN_VARIATION_TEST 0
+#define MAX_LATENCY_COUNT_WIDTH 5
+#define MEM_ADDR_WIDTH 13
+#define MRS_MIRROR_PING_PONG_ATSO 0
+#define MULTIPLE_AFI_WLAT 0
+#define NON_DES_CAL 0
+#define NUM_SHADOW_REGS 1
+#define QDRII 0
+#define QUARTER_RATE 0
+#define RDIMM 0
+#define READ_AFTER_WRITE_CALIBRATION 1
+#define READ_VALID_FIFO_SIZE 16
+#define REG_FILE_INIT_SEQ_SIGNATURE 0x555504a1
+#define RLDRAM3 0
+#define RLDRAMII 0
+#define RLDRAMX 0
+#define RUNTIME_CAL_REPORT 0
+#define RW_MGR_MEM_ADDRESS_MIRRORING 0
+#define RW_MGR_MEM_ADDRESS_WIDTH 15
+#define RW_MGR_MEM_BANK_WIDTH 3
+#define RW_MGR_MEM_CHIP_SELECT_WIDTH 1
+#define RW_MGR_MEM_CLK_EN_WIDTH 1
+#define RW_MGR_MEM_CONTROL_WIDTH 1
+#define RW_MGR_MEM_DATA_MASK_WIDTH 4
+#define RW_MGR_MEM_DATA_WIDTH 32
+#define RW_MGR_MEM_DQ_PER_READ_DQS 8
+#define RW_MGR_MEM_DQ_PER_WRITE_DQS 8
+#define RW_MGR_MEM_IF_READ_DQS_WIDTH 4
+#define RW_MGR_MEM_IF_WRITE_DQS_WIDTH 4
+#define RW_MGR_MEM_NUMBER_OF_CS_PER_DIMM 1
+#define RW_MGR_MEM_NUMBER_OF_RANKS 1
+#define RW_MGR_MEM_ODT_WIDTH 1
+#define RW_MGR_MEM_VIRTUAL_GROUPS_PER_READ_DQS 1
+#define RW_MGR_MEM_VIRTUAL_GROUPS_PER_WRITE_DQS 1
+#define RW_MGR_MR0_BL 1
+#define RW_MGR_MR0_CAS_LATENCY 3
+#define RW_MGR_TRUE_MEM_DATA_MASK_WIDTH 4
+#define RW_MGR_WRITE_TO_DEBUG_READ 1.0
+#define SET_FIX_READ_LATENCY_ENABLE 0
+#define SKEW_CALIBRATION 0
+#define SKIP_PTAP_0_DQS_EN_CAL 1
+#define STATIC_FULL_CALIBRATION 1
+#define STATIC_SIM_FILESET 0
+#define STATIC_SKIP_MEM_INIT 0
+#define STRATIXV 0
+#define TINIT_CNTR1_VAL 32
+#define TINIT_CNTR2_VAL 32
+#define TINIT_CNTR0_VAL 124
+#define TRACKING_ERROR_TEST 0
+#define TRACKING_WATCH_TEST 0
+#define TRESET_CNTR1_VAL 99
+#define TRESET_CNTR2_VAL 10
+#define TRESET_CNTR0_VAL 124
+#define USE_DQS_TRACKING 1
+#define USE_SHADOW_REGS 0
+#define USE_USER_RDIMM_VALUE 0
+
+#endif /* _SEQUENCER_DEFINES_H_ */
diff --git a/arch/arm/boards/wago-pfc-cyclone5/startup_amp.c b/arch/arm/boards/wago-pfc-cyclone5/startup_amp.c
new file mode 100644
index 0000000..954f089
--- /dev/null
+++ b/arch/arm/boards/wago-pfc-cyclone5/startup_amp.c
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <bootm.h>
+#include <fs.h>
+#include <malloc.h>
+#include <memory.h>
+#include <libfile.h>
+#include <image-fit.h>
+#include <globalvar.h>
+#include <init.h>
+#include <environment.h>
+#include <linux/stat.h>
+#include <magicvar.h>
+
+
+static int amp_xload(void)
+{
+	char *buf;
+	uint32_t len;
+
+	/* TODO: implement and get dts infos */
+
+	buf = read_file("/boot/cpu1.bin", &len);
+	if (buf) {
+		/* address filtering enhancement */
+		__asm__ volatile ("ldr     r7, =0xFFFEFC00\n");
+		__asm__ volatile ("ldr     r8, =0x00100001\n");
+		__asm__ volatile ("str     r8, [r7]\n");
+		/* set CPU1 programm start semaphore */
+		__asm__ volatile ("ldr     r7, =0xFFFFC000\n");
+		__asm__ volatile ("ldr     r8, =0x0\n");
+		__asm__ volatile ("str     r8, [r7]\n");
+		/* copy to memory area untouched by linux */
+		memcpy((void *)0x4000000, buf, len);
+		free(buf); /* free old buffer from open */
+		/* set the programm memory address of CPU1 */
+		__asm__ volatile ("ldr     r7, =0xffd080c4\n");
+		__asm__ volatile ("ldr     r8, =0x04000000\n");
+		__asm__ volatile ("str     r8, [r7]\n");
+		/* release the reset of CPU1 */
+		__asm__ volatile ("ldr     r7, =0xffd05010\n");
+		__asm__ volatile ("ldr     r8, [r7]\n");
+		__asm__ volatile ("bic     r8, r8, #0x2\n");
+		__asm__ volatile ("str     r8, [r7]\n");
+		__asm__ volatile ("dsb\n");
+		__asm__ volatile ("dmb\n");
+		__asm__ volatile ("isb\n");
+	}
+
+	return 0;
+}
+postenvironment_initcall(amp_xload);
+
diff --git a/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x128mx16.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x128mx16.imxcfg
new file mode 100644
index 0000000..fd0d0e2
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x128mx16.imxcfg
@@ -0,0 +1,42 @@
+wm 32 MX6_MMDC_P0_MDPDC			0x00020036
+wm 32 MX6_MMDC_P0_MDSCR			0x00008000
+wm 32 MX6_MMDC_P0_MDCFG0		0x54597955
+wm 32 MX6_MMDC_P0_MDCFG1		0xFF328F64
+wm 32 MX6_MMDC_P0_MDCFG2		0x01FF00DB
+wm 32 MX6_MMDC_P0_MDRWD			0x000026D2
+wm 32 MX6_MMDC_P0_MDOR			0x00591023
+wm 32 MX6_MMDC_P0_MDOTC			0x09444040
+wm 32 MX6_MMDC_P0_MDPDC			0x00025576
+wm 32 MX6_MMDC_P0_MDASP			0x00000027
+wm 32 MX6_MMDC_P0_MDCTL			0x831A0000
+wm 32 MX6_MMDC_P0_MDSCR			0x02088032
+wm 32 MX6_MMDC_P0_MDSCR			0x00008033
+wm 32 MX6_MMDC_P0_MDSCR			0x00048031
+wm 32 MX6_MMDC_P0_MDSCR			0x19408030
+wm 32 MX6_MMDC_P0_MDSCR			0x04008040
+wm 32 MX6_MMDC_P0_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P1_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P0_MDREF			0x00007800
+wm 32 MX6_MMDC_P0_MPODTCTRL		0x00022227
+wm 32 MX6_MMDC_P1_MPODTCTRL		0x00022227
+
+wm 32 MX6_MMDC_P0_MPDGCTRL0		0x0338034C
+wm 32 MX6_MMDC_P0_MPDGCTRL1		0x03340334
+wm 32 MX6_MMDC_P1_MPDGCTRL0		0x03400350
+wm 32 MX6_MMDC_P1_MPDGCTRL1		0x03340304
+
+wm 32 MX6_MMDC_P0_MPRDDLCTL		0x4A383C42
+wm 32 MX6_MMDC_P1_MPRDDLCTL		0x3C3E3A46
+
+wm 32 MX6_MMDC_P0_MPWRDLCTL		0x3A3C4040
+wm 32 MX6_MMDC_P1_MPWRDLCTL		0x48384840
+
+wm 32 MX6_MMDC_P0_MPWLDECTRL0	0x00220022
+wm 32 MX6_MMDC_P0_MPWLDECTRL1	0x002F0024
+wm 32 MX6_MMDC_P1_MPWLDECTRL0	0x001B002B
+wm 32 MX6_MMDC_P1_MPWLDECTRL1	0x00110026
+
+wm 32 MX6_MMDC_P0_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P1_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P0_MDSCR			0x00000000
+wm 32 MX6_MMDC_P0_MAPSR			0x00011006
diff --git a/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x256mx16.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x256mx16.imxcfg
new file mode 100644
index 0000000..e095b796
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/1066mhz_4x256mx16.imxcfg
@@ -0,0 +1,45 @@
+wm 32 MX6_MMDC_P0_MDPDC			0x00020036
+wm 32 MX6_MMDC_P0_MDOTC			0x09444040
+wm 32 MX6_MMDC_P0_MDCFG0		0x898E7955
+wm 32 MX6_MMDC_P0_MDCFG1		0xFF328F64
+wm 32 MX6_MMDC_P0_MDCFG2		0x01FF00DB
+wm 32 MX6_MMDC_P0_MDMISC		0x00011740
+wm 32 MX6_MMDC_P0_MDSCR			0x00008000
+wm 32 MX6_MMDC_P0_MDRWD			0x000026D2
+wm 32 MX6_MMDC_P0_MDOR			0x008E1023
+wm 32 MX6_MMDC_P0_MDASP			0x00000047
+wm 32 MX6_MMDC_P0_MDCTL			0x841A0000 // row/column address width
+
+//Mode register writes we use only CS0
+wm 32 MX6_MMDC_P0_MDSCR			0x02088032
+wm 32 MX6_MMDC_P0_MDSCR			0x00008033
+wm 32 MX6_MMDC_P0_MDSCR			0x00048031
+wm 32 MX6_MMDC_P0_MDSCR			0x19408030
+wm 32 MX6_MMDC_P0_MDSCR			0x04008040
+
+wm 32 MX6_MMDC_P0_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P1_MPZQHWCTRL	0xA1390003
+wm 32 MX6_MMDC_P0_MDREF			0x00007800
+wm 32 MX6_MMDC_P0_MPODTCTRL		0x00022227
+wm 32 MX6_MMDC_P1_MPODTCTRL		0x00022227
+
+wm 32 MX6_MMDC_P0_MPDGCTRL0		0x03100324
+wm 32 MX6_MMDC_P0_MPDGCTRL1		0x030C0304
+wm 32 MX6_MMDC_P1_MPDGCTRL0		0x03180328
+wm 32 MX6_MMDC_P1_MPDGCTRL1		0x0310025C
+
+wm 32 MX6_MMDC_P0_MPRDDLCTL		0x4230363A
+wm 32 MX6_MMDC_P1_MPRDDLCTL		0x3A363442
+
+wm 32 MX6_MMDC_P0_MPWRDLCTL		0x34363E38
+wm 32 MX6_MMDC_P1_MPWRDLCTL		0x442C483C
+
+wm 32 MX6_MMDC_P0_MPWLDECTRL0	0x001F001F
+wm 32 MX6_MMDC_P0_MPWLDECTRL1	0x00280023
+wm 32 MX6_MMDC_P1_MPWLDECTRL0	0x00190030
+wm 32 MX6_MMDC_P1_MPWLDECTRL1	0x00190028
+
+wm 32 MX6_MMDC_P0_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P1_MPMUR0		0x00000800
+wm 32 MX6_MMDC_P0_MDSCR			0x00000000
+wm 32 MX6_MMDC_P0_MAPSR			0x00011006
diff --git a/arch/arm/boards/wago-vtpctp-imx6/Makefile b/arch/arm/boards/wago-vtpctp-imx6/Makefile
new file mode 100644
index 0000000..c7a078b
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/Makefile
@@ -0,0 +1,3 @@
+obj-y += board.o
+lwl-y += lowlevel.o
+bbenv-y += defaultenv-vtpctp-imx6
diff --git a/arch/arm/boards/wago-vtpctp-imx6/board.c b/arch/arm/boards/wago-vtpctp-imx6/board.c
new file mode 100644
index 0000000..74b1ce6
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/board.c
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2012 Steffen Trumtrar, Pengutronix
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Ralf Gliese <ralf.gliese@wago.com>
+ *
+ * Device initialization for the following touch panel variants:
+ *   - 762-4x0x Touch Panel 600 Standard Line
+ *   - 762-5x0x Touch Panel 600 Advanced Line
+ *   - 762-620x Touch Panel 600 Marine Line
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <init.h>
+#include <gpio.h>
+#include <mach/bbu.h>
+#include <mach/generic.h>
+#include <mach/iomux-mx6.h>
+#include <asm/armlinux.h>
+#include <generated/mach-types.h>
+#include <linux/micrel_phy.h>
+#include <net.h>
+#include <envfs.h>
+#include <globalvar.h>
+#include <xsection.h>
+
+#define LCD_CTRL_VLCD_ON	IMX_GPIO_NR(6, 11)
+#define LCD_CTRL_LIGHT_ON	IMX_GPIO_NR(2, 8)
+#define LCD_CTRL_VLED_ON	IMX_GPIO_NR(2, 11)
+#define LCD_CTRL_PWM		IMX_GPIO_NR(2, 9)
+#define CAPTAST_NRESET		IMX_GPIO_NR(2, 3)
+
+#define ETH_DEVICE_0 0
+#define ETH_DEVICE_1 1
+
+#define KSZ8863_GLOBAL_CONTROL_4		0x06
+#define KSZ8863_PORT1_Q0_INGRESS_DATA_RATE	0x16
+#define KSZ8863_PORT1_GLOBAL_CONTRL12		0x1c
+#define KSZ8863_PORT1_GLOBAL_CONTRL13		0x1d
+#define KSZ8863_PORT1_STATUS1			0x1f
+
+static iomux_v3_cfg_t vtpctp_enet_gpio_pads[] = {
+	/* Ethernet */
+	MX6Q_PAD_EIM_D23__GPIO_3_23,		/* RGMII_nRST */
+	MX6Q_PAD_RGMII_RXC__GPIO_6_30,		/* PHYAD */
+	MX6Q_PAD_RGMII_RD0__GPIO_6_25,		/* MODE0 */
+	MX6Q_PAD_RGMII_RD1__GPIO_6_27,		/* MODE1 */
+	MX6Q_PAD_RGMII_RD2__GPIO_6_28,		/* MODE2 */
+	MX6Q_PAD_RGMII_RD3__GPIO_6_29,		/* MODE3 */
+	MX6Q_PAD_RGMII_RX_CTL__GPIO_6_24,
+};
+
+static struct gpio fec_gpios[] = {
+	{
+		.gpio = 105,
+		.flags = GPIOF_OUT_INIT_LOW,
+		.label = "phy-rst",
+	}, {
+		.gpio = 190,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-addr2",
+	}, {
+		.gpio = 23,
+		.flags = GPIOF_OUT_INIT_LOW,
+		.label = "phy-led-mode",
+	}, {
+		/* MODE strap-in pins: advertise all capabilities */
+		.gpio = 185,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		.gpio = 187,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		.gpio = 188,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		.gpio = 189,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-adv1",
+	}, {
+		/* Enable 125 MHz clock output */
+		.gpio = 184,
+		.flags = GPIOF_OUT_INIT_HIGH,
+		.label = "phy-125MHz",
+	},
+};
+
+static int pfc_set_ethaddr(void)
+{
+	u8 mac[6];
+	int ret;
+
+	ret = xsection_get_ethaddr1(mac);
+	if (ret < 0)
+		return ret;
+
+	eth_register_ethaddr(ETH_DEVICE_0, mac);
+	eth_register_ethaddr(ETH_DEVICE_1, mac);
+
+	return 0;
+}
+
+static int pfc_rewrite_compatible(void)
+{
+	struct device_node *root;
+	int ret;
+	u16 devconf;
+	char const *first_compat_str;
+	char *new_string;
+
+	ret = xsection_get_devconf(&devconf);
+	if (ret < 0)
+		goto out;
+
+	root = of_get_root_node();
+	if (!root) {
+		ret = -ENOENT;
+		goto out;
+	}
+
+	ret = of_property_read_string_index(root, "compatible", 0,
+							&first_compat_str);
+	if (ret < 0)
+		goto out;
+
+	new_string = basprintf("%s-%04x", first_compat_str, devconf);
+	if (!new_string) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = of_property_write_string(root, "compatible", new_string);
+	free(new_string);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int ksz8863_phy_fixup(struct phy_device *phydev)
+{
+	phy_write(phydev, KSZ8863_PORT1_STATUS1, 0x8190);
+	phy_write(phydev, KSZ8863_PORT1_Q0_INGRESS_DATA_RATE, 0x202);
+	phy_write(phydev, KSZ8863_GLOBAL_CONTROL_4, 0x30);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL12, 0x9f);
+	phy_write(phydev, KSZ8863_PORT1_GLOBAL_CONTRL13, 0x00);
+
+	return 0;
+}
+
+static int vtpctp_ksz8863_setup(void)
+{
+	int ret;
+
+	if (!of_machine_is_compatible("wago,imx6q-vtpctp"))
+		return 0;
+
+	mxc_iomux_v3_setup_multiple_pads(vtpctp_enet_gpio_pads,
+			ARRAY_SIZE(vtpctp_enet_gpio_pads));
+
+	ret = gpio_request_array(fec_gpios, ARRAY_SIZE(fec_gpios));
+	if (ret) {
+		pr_err("Failed to request fec gpios: %s\n", strerror(-ret));
+		return ret;
+	}
+
+	mdelay(10);
+
+	/* FEC driver picks up the reset gpio later and
+	 * releases the phy reset
+	 */
+	gpio_free_array(fec_gpios, ARRAY_SIZE(fec_gpios));
+
+	phy_register_fixup_for_uid(PHY_ID_KSZ8863, MICREL_PHY_ID_MASK,
+							ksz8863_phy_fixup);
+
+	return 0;
+}
+/*
+ * Do this before the fec initializes but after our
+ * gpios are available.
+ */
+fs_initcall(vtpctp_ksz8863_setup);
+
+static int vtpctp_devices_init(void)
+{
+	int ret;
+	const char *s = NULL;
+
+	if (!of_machine_is_compatible("wago,imx6q-vtpctp"))
+		return 0;
+
+	ret = of_property_read_string(of_get_root_node(), "board-variant", &s);
+	if (!ret)
+		globalvar_add_simple("board.variant", s);
+	else
+		pr_warn("failed to get board.variant from oftree\n");
+
+	imx6_bbu_internal_mmc_register_handler("boot.emmc", "/dev/mmc2",
+						BBU_HANDLER_FLAG_DEFAULT);
+
+	of_device_enable_path("/chosen/environment-sd");
+	defaultenv_append_directory(defaultenv_vtpctp_imx6);
+
+	armlinux_set_architecture(MACH_TYPE_VTPCTP_MX6);
+
+	ret = pfc_set_ethaddr();
+	if (ret < 0)
+		pr_info("no valid ethaddr in eeprom found. Using randomized MAC address\n");
+
+	barebox_set_hostname("tp600");
+
+	/* Rewrite the compatible string in the internal barebox device-tree
+	 * (located in ram), and add the eeprom devconf as suffix.
+	 * This string is used by the bootloader-spec module to search for
+	 * correct bootloader-spec entry
+	 * to load the corrosponding kernel device-tree.
+	 */
+	ret = pfc_rewrite_compatible();
+	if (ret < 0)
+		pr_err("failed to rewrite the internal compatible string with devconf from eeprom\n");
+
+	return 0;
+}
+device_initcall(vtpctp_devices_init);
+
+static int vtpctp_coredevices_init(void)
+{
+	if (!of_machine_is_compatible("wago,imx6q-vtpctp"))
+		return 0;
+
+	gpio_request(LCD_CTRL_VLCD_ON, "LCD_CTRL_VLCD_ON");
+	gpio_request(LCD_CTRL_LIGHT_ON, "LCD_CTRL_LIGHT_ON");
+	gpio_request(LCD_CTRL_VLED_ON, "LCD_CTRL_VLED_ON");
+	gpio_request(LCD_CTRL_PWM, "LCD_CTRL_PWM");
+	gpio_request(CAPTAST_NRESET, "CAPTAST_NRESET");
+	gpio_direction_output(LCD_CTRL_VLCD_ON, 1);
+	gpio_set_value(LCD_CTRL_VLCD_ON, 1);
+	mdelay(30);
+	gpio_direction_output(LCD_CTRL_LIGHT_ON, 1);
+	gpio_set_value(LCD_CTRL_LIGHT_ON, 1);
+	gpio_direction_output(LCD_CTRL_VLED_ON, 1);
+	gpio_set_value(LCD_CTRL_VLED_ON, 1);
+	gpio_direction_output(LCD_CTRL_PWM, 0);
+	gpio_set_value(LCD_CTRL_PWM, 0);
+	gpio_set_value(CAPTAST_NRESET, 1);
+
+	return 0;
+}
+coredevice_initcall(vtpctp_coredevices_init);
diff --git a/arch/arm/boards/wago-vtpctp-imx6/clocks.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/clocks.imxcfg
new file mode 100644
index 0000000..582ec0b
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/clocks.imxcfg
@@ -0,0 +1,10 @@
+wm 32 0x020c4068 0x00c03f3f
+wm 32 0x020c406c 0x0030fc03
+wm 32 0x020c4070 0x0fffc000
+wm 32 0x020c4074 0x3ff00000
+wm 32 0x020c4078 0x00fff300
+wm 32 0x020c407c 0x0f0000c3
+wm 32 0x020c4080 0x000003ff
+wm 32 0x020e0010 0xf00000cf
+wm 32 0x020e0018 0x007f007f
+wm 32 0x020e001c 0x007f007f
diff --git a/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/bin/pfc-config-production-boot b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/bin/pfc-config-production-boot
new file mode 100644
index 0000000..6b00d83
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/bin/pfc-config-production-boot
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+
+global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+global.linux.bootargs.base="root=/dev/mmcblk0p2 rw rootwait cma=64M consoleblank=0"
+global.boot.watchdog_timeout=0
+
+if [ -e "${global.pfc.sd}" ] && [ -e "${global.pfc.sd_boot}/production_mode.sh" ]; then
+	global.boot.default="${global.pfc.sd_boot}/production_mode.sh"
+else
+	echo -e ${error} "vtpctp no script found for production-mode"
+	pfc-config-broken-boot
+	exit 1
+fi
diff --git a/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/init/aa-vtpctp-setup-board-env b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/init/aa-vtpctp-setup-board-env
new file mode 100644
index 0000000..4a13031
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/init/aa-vtpctp-setup-board-env
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+# set variables for vtpctp
+
+# emmc settings
+global.pfc.emmc_name="mmc2"
+global.pfc.emmc="/dev/mmc2"
+global.pfc.emmc_boot="/mnt/mmc2.0"
+global.pfc.emmc_dev_rootfs0="/dev/mmc2.4"
+global.pfc.emmc_dev_rootfs1="/dev/mmc2.7"
+
+global.pfc.linux_uart_device="ttymxc"
+global.pfc.linux_uart="1"
+global.pfc.barebox_uart="0"
+
+global.linux.bootargs.watchdog="imx2-wdt.timeout=${global.pfc.watchdog_timeout_linux_boot}"
diff --git a/arch/arm/boards/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg
new file mode 100644
index 0000000..8ebda4a
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg
@@ -0,0 +1,10 @@
+soc imx6
+loadaddr 0x20000000
+dcdofs 0x400
+
+#include <mach/imx6-ddr-regs.h>
+#include <mach/imx6q-ddr-regs.h>
+
+#include "ram-base.imxcfg"
+#include "1066mhz_4x256mx16.imxcfg"
+#include "clocks.imxcfg"
diff --git a/arch/arm/boards/wago-vtpctp-imx6/lowlevel.c b/arch/arm/boards/wago-vtpctp-imx6/lowlevel.c
new file mode 100644
index 0000000..05a4dc0
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/lowlevel.c
@@ -0,0 +1,41 @@
+#include <common.h>
+#include <linux/sizes.h>
+#include <mach/generic.h>
+#include <asm/barebox-arm-head.h>
+#include <asm/barebox-arm.h>
+#include <mach/imx6-regs.h>
+#include <io.h>
+#include <mach/debug_ll.h>
+#include <mach/esdctl.h>
+#include <asm/cache.h>
+
+extern char __dtb_imx6q_vtpctp_762_4xxx_start[];
+
+static noinline void imx6q_vtpctp_start(void)
+{
+	void __iomem *iomuxbase = IOMEM(MX6_IOMUXC_BASE_ADDR);
+	void __iomem *uart = IOMEM(MX6_UART1_BASE_ADDR);
+
+	writel(0x4, iomuxbase + 0x0bc);
+
+	imx6_ungate_all_peripherals();
+	imx6_uart_setup(uart);
+	pbl_set_putc(imx_uart_putc, uart);
+
+	pr_debug("Freescale i.MX6q VTPCTP\n");
+
+	imx6q_barebox_entry(__dtb_imx6q_vtpctp_762_4xxx_start);
+}
+
+ENTRY_FUNCTION(start_imx6q_vtpctp, r0, r1, r2)
+{
+	imx6_cpu_lowlevel_init();
+
+	arm_early_mmu_cache_invalidate();
+
+	relocate_to_current_adr();
+	setup_c();
+	barrier();
+
+	imx6q_vtpctp_start();
+}
diff --git a/arch/arm/boards/wago-vtpctp-imx6/ram-base.imxcfg b/arch/arm/boards/wago-vtpctp-imx6/ram-base.imxcfg
new file mode 100644
index 0000000..cf303ed
--- /dev/null
+++ b/arch/arm/boards/wago-vtpctp-imx6/ram-base.imxcfg
@@ -0,0 +1,67 @@
+wm 32 MX6_IOM_DRAM_SDQS0		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS1		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS2		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS3		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS4		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS5		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS6		0x00000028
+wm 32 MX6_IOM_DRAM_SDQS7		0x00000028
+
+wm 32 MX6_IOM_GRP_B0DS			0x00000028
+wm 32 MX6_IOM_GRP_B1DS			0x00000028
+wm 32 MX6_IOM_GRP_B2DS			0x00000028
+wm 32 MX6_IOM_GRP_B3DS			0x00000028
+wm 32 MX6_IOM_GRP_B4DS			0x00000028
+wm 32 MX6_IOM_GRP_B5DS			0x00000028
+wm 32 MX6_IOM_GRP_B6DS			0x00000028
+wm 32 MX6_IOM_GRP_B7DS			0x00000028
+wm 32 MX6_IOM_GRP_ADDDS			0x00000028
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+wm 32 MX6_IOM_GRP_CTLDS			0x00000028
+
+wm 32 MX6_IOM_DRAM_DQM0			0x00000028
+wm 32 MX6_IOM_DRAM_DQM1			0x00000028
+wm 32 MX6_IOM_DRAM_DQM2			0x00000028
+wm 32 MX6_IOM_DRAM_DQM3			0x00000028
+wm 32 MX6_IOM_DRAM_DQM4			0x00000028
+wm 32 MX6_IOM_DRAM_DQM5			0x00000028
+wm 32 MX6_IOM_DRAM_DQM6			0x00000028
+wm 32 MX6_IOM_DRAM_DQM7			0x00000028
+
+wm 32 MX6_IOM_DRAM_CAS			0x00000028
+wm 32 MX6_IOM_DRAM_RAS			0x00000028
+wm 32 MX6_IOM_DRAM_SDCLK_0		0x00000028
+wm 32 MX6_IOM_DRAM_SDCLK_1		0x00000028
+
+wm 32 MX6_IOM_DRAM_RESET		0x00000028
+wm 32 MX6_IOM_DRAM_SDCKE0		0x00003000
+wm 32 MX6_IOM_DRAM_SDCKE1		0x00003000
+
+wm 32 MX6_IOM_DRAM_SDODT0		0x00000028
+wm 32 MX6_IOM_DRAM_SDODT1		0x00000028
+
+/* (differential input) */
+wm 32 MX6_IOM_DDRMODE_CTL		0x00020000
+/* (differential input) */
+wm 32 MX6_IOM_GRP_DDRMODE		0x00020000
+/* disable ddr pullups */
+wm 32 MX6_IOM_GRP_DDRPKE		0x00000000
+wm 32 MX6_IOM_DRAM_SDBA2		0x00000000
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+wm 32 MX6_IOM_GRP_DDR_TYPE		0x000C0000
+
+/* Read data DQ Byte0-3 delay */
+wm 32 MX6_MMDC_P0_MPRDDQBY0DL	0x33333333
+wm 32 MX6_MMDC_P0_MPRDDQBY1DL	0x33333333
+wm 32 MX6_MMDC_P0_MPRDDQBY2DL	0x33333333
+wm 32 MX6_MMDC_P0_MPRDDQBY3DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY0DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY1DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY2DL	0x33333333
+wm 32 MX6_MMDC_P1_MPRDDQBY3DL	0x33333333
+
+/* MDMISC	mirroring	interleaved (row/bank/col) */
+wm 32 MX6_MMDC_P0_MDMISC		0x00011740
+
+/* MDSCR	con_req */
+wm 32 MX6_MMDC_P0_MDSCR			0x00008000
diff --git a/arch/arm/configs/am335x_mlo_defconfig b/arch/arm/configs/am335x_mlo_defconfig
index 58034b6..65d9260 100644
--- a/arch/arm/configs/am335x_mlo_defconfig
+++ b/arch/arm/configs/am335x_mlo_defconfig
@@ -34,6 +34,7 @@ CONFIG_NAND=y
 # CONFIG_NAND_BBT is not set
 CONFIG_NAND_OMAP_GPMC=y
 CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
 # CONFIG_MCI_WRITE is not set
 CONFIG_MCI_OMAP_HSMMC=y
 CONFIG_PINCTRL_SINGLE=y
diff --git a/arch/arm/configs/am335x_pfc_adv_defconfig b/arch/arm/configs/am335x_pfc_adv_defconfig
new file mode 100644
index 0000000..3e5d913
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_adv_defconfig
@@ -0,0 +1,146 @@
+CONFIG_ARCH_OMAP=y
+# CONFIG_OMAP_GPMC is not set
+CONFIG_BAREBOX_UPDATE_AM33XX_EMMC=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_768_330x=y
+CONFIG_MACH_WAGO_AM335X_RMCB=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_CONSOLE_RATP=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-adv-am335x/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_SFDISK=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_USBGADGET=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OF_DISPLAY_TIMINGS=y
+CONFIG_CMD_OF_FIXUP_STATUS=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_RESOLV=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_NET_CPSW=y
+CONFIG_MICREL_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_NET_USB=y
+CONFIG_NET_USB_ASIX=y
+CONFIG_NET_USB_SMSC95XX=y
+# CONFIG_SPI is not set
+CONFIG_MTD=y
+CONFIG_USB_HOST=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_USB_GADGET_FASTBOOT_SPARSE=y
+CONFIG_USB_MUSB=y
+CONFIG_USB_MUSB_AM335X=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_LED_PCA955X=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_OMAP=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_ZLIB=y
diff --git a/arch/arm/configs/am335x_pfc_adv_mlo_defconfig b/arch/arm/configs/am335x_pfc_adv_mlo_defconfig
new file mode 100644
index 0000000..064311b
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_adv_mlo_defconfig
@@ -0,0 +1,37 @@
+CONFIG_ARCH_OMAP=y
+# CONFIG_OMAP_GPMC is not set
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_768_330x=y
+CONFIG_MACH_WAGO_AM335X_RMCB=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_MMU=y
+CONFIG_BAREBOX_MAX_PBLX_SIZE=0x1b400
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="MLO>"
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM=y
+CONFIG_BOOTM_AIMAGE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_AUTOSTART is not set
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_USB_MUSB=y
+CONFIG_USB_MUSB_AM335X=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_XSECTION=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am335x_pfc_defconfig b/arch/arm/configs/am335x_pfc_defconfig
new file mode 100644
index 0000000..02a216f
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_defconfig
@@ -0,0 +1,157 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_BAREBOX_UPDATE_AM33XX_SPI_NOR_MLO=y
+CONFIG_BAREBOX_UPDATE_AM33XX_NAND=y
+CONFIG_BAREBOX_UPDATE_AM33XX_EMMC=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_810x=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_8208=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_821x=y
+CONFIG_MACH_WAGO_PFC_AM335X_2850_311x=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_CONSOLE_RATP=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-pfc-am335x/defaultenv-pfc-am335x/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_UBIFORMAT=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_NANDTEST=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_USBGADGET=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OF_DISPLAY_TIMINGS=y
+CONFIG_CMD_OF_FIXUP_STATUS=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_RESOLV=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_NET_CPSW=y
+CONFIG_MICREL_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_NET_USB=y
+CONFIG_NET_USB_ASIX=y
+CONFIG_NET_USB_SMSC95XX=y
+CONFIG_DRIVER_SPI_OMAP3=y
+CONFIG_MTD=y
+CONFIG_MTD_M25P80=y
+CONFIG_NAND=y
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_USB_HOST=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DFU=y
+CONFIG_USB_GADGET_SERIAL=y
+CONFIG_USB_GADGET_FASTBOOT=y
+CONFIG_USB_MUSB=y
+CONFIG_USB_MUSB_AM335X=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_GADGET=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_LED_PCA955X=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_OMAP=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_BUS_OMAP_GPMC=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_UBIFS=y
+CONFIG_FS_UBIFS_COMPRESSION_LZO=y
+CONFIG_FS_UBIFS_COMPRESSION_ZLIB=y
diff --git a/arch/arm/configs/am335x_pfc_mlo_defconfig b/arch/arm/configs/am335x_pfc_mlo_defconfig
new file mode 100644
index 0000000..45ef00e
--- /dev/null
+++ b/arch/arm/configs/am335x_pfc_mlo_defconfig
@@ -0,0 +1,44 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_OMAP_SERIALBOOT=y
+CONFIG_OMAP_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_PFC_AM335X=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_810x=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_8208=y
+CONFIG_MACH_WAGO_PFC_AM335X_750_821x=y
+CONFIG_MACH_WAGO_PFC_AM335X_2850_311x=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_MMU=y
+CONFIG_BAREBOX_MAX_PBLX_SIZE=0x1b400
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="MLO>"
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_DEBUG_INFO=y
+CONFIG_OFDEVICE=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_SPI_OMAP3=y
+CONFIG_MTD=y
+# CONFIG_MTD_WRITE is not set
+# CONFIG_MTD_OOB_DEVICE is not set
+CONFIG_MTD_M25P80=y
+CONFIG_NAND=y
+# CONFIG_NAND_ECC_SOFT is not set
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
+# CONFIG_NAND_INFO is not set
+# CONFIG_NAND_BBT is not set
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_XSECTION=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_BUS_OMAP_GPMC=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/am35xx_pfc_defconfig b/arch/arm/configs/am35xx_pfc_defconfig
new file mode 100644
index 0000000..60138ee
--- /dev/null
+++ b/arch/arm/configs/am35xx_pfc_defconfig
@@ -0,0 +1,130 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_BAREBOX_UPDATE_AM33XX_NAND=y
+CONFIG_MACH_WAGO_PFC_AM35XX=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BLSPEC=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-pfc-am35xx/defaultenv-pfc-am35xx/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_UBIFORMAT=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_NANDTEST=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_RESOLV=y
+CONFIG_OFDEVICE=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+CONFIG_DRIVER_NET_DAVINCI_EMAC=y
+CONFIG_MTD=y
+CONFIG_MTD_M25P80=y
+CONFIG_NAND=y
+CONFIG_NAND_ECC_HW_SW_ERR_DETECTION=y
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_OMAP=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_BUS_OMAP_GPMC=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_FS_UBIFS=y
+CONFIG_FS_UBIFS_COMPRESSION_LZO=y
diff --git a/arch/arm/configs/am35xx_pfc_mlo_defconfig b/arch/arm/configs/am35xx_pfc_mlo_defconfig
new file mode 100644
index 0000000..31a0636
--- /dev/null
+++ b/arch/arm/configs/am35xx_pfc_mlo_defconfig
@@ -0,0 +1,41 @@
+CONFIG_ARCH_OMAP=y
+CONFIG_OMAP_BUILD_IFT=y
+CONFIG_MACH_WAGO_PFC_AM35XX=y
+CONFIG_THUMB2_BAREBOX=y
+# CONFIG_ARM_EXCEPTIONS is not set
+# CONFIG_MEMINFO is not set
+CONFIG_MMU=y
+# CONFIG_MMU_EARLY is not set
+CONFIG_STACK_SIZE=0xc00
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_DUMMY=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="X-load pfc200>"
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_COMPILE_LOGLEVEL=3
+CONFIG_DEBUG_INFO=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_SERIAL_NS16550_OMAP_EXTENSIONS=y
+# CONFIG_SPI is not set
+CONFIG_I2C=y
+CONFIG_I2C_OMAP=y
+CONFIG_MTD=y
+# CONFIG_MTD_WRITE is not set
+# CONFIG_MTD_OOB_DEVICE is not set
+CONFIG_NAND=y
+# CONFIG_NAND_ECC_SOFT is not set
+CONFIG_NAND_ECC_HW_SW_ERR_DETECTION=y
+# CONFIG_NAND_ECC_HW_SYNDROME is not set
+# CONFIG_NAND_ECC_HW_NONE is not set
+# CONFIG_NAND_INFO is not set
+# CONFIG_NAND_BBT is not set
+CONFIG_NAND_OMAP_GPMC=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_OMAP_HSMMC=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/cyclone5_pfc_defconfig b/arch/arm/configs/cyclone5_pfc_defconfig
new file mode 100644
index 0000000..b61a315
--- /dev/null
+++ b/arch/arm/configs/cyclone5_pfc_defconfig
@@ -0,0 +1,104 @@
+CONFIG_TEXT_BASE=0x08000000
+CONFIG_ARCH_SOCFPGA=y
+CONFIG_BAREBOX_MAX_IMAGE_SIZE=0x08000000
+CONFIG_MACH_PFCXXX=y
+CONFIG_MACH_WAGO_PFC_CYCLONE5=y
+CONFIG_MACH_WAGO_PFC_AMP=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_BAREBOX_MAX_PBL_SIZE=0x08000000
+CONFIG_BAREBOX_MAX_BARE_INIT_SIZE=0x08000000
+CONFIG_BAREBOX_MAX_PBLX_SIZE=0x08000000
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+#CONFIG_RELOCATABLE=y
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_CMDLINE_EDITING=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-pfc-cyclone5/defaultenv-pfc-cyclone5/"
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_LL=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENU_MANAGEMENT=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_FIRMWARELOAD=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_NET=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_RESOLV=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_DRIVER_NET_DESIGNWARE=y
+CONFIG_DRIVER_NET_DESIGNWARE_SOCFPGA=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_DW=y
+CONFIG_MFD_MC13XXX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_EEPROM_AT25=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_GPIO_DESIGNWARE=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_FIRMWARE_ALTERA_SOCFPGA=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
diff --git a/arch/arm/configs/cyclone5_pfc_mlo_defconfig b/arch/arm/configs/cyclone5_pfc_mlo_defconfig
new file mode 100644
index 0000000..3b8ac4e
--- /dev/null
+++ b/arch/arm/configs/cyclone5_pfc_mlo_defconfig
@@ -0,0 +1,31 @@
+CONFIG_ARCH_SOCFPGA=y
+CONFIG_ARCH_SOCFPGA_XLOAD=y
+CONFIG_MACH_PFCXXX=y
+CONFIG_MACH_WAGO_PFC_CYCLONE5=y
+CONFIG_THUMB2_BAREBOX=y
+# CONFIG_ARM_EXCEPTIONS is not set
+# CONFIG_MEMINFO is not set
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_DUMMY=y
+CONFIG_RELOCATABLE=y
+CONFIG_SHELL_NONE=y
+# CONFIG_ERRNO_MESSAGES is not set
+# CONFIG_TIMESTAMP is not set
+CONFIG_COMPILE_LOGLEVEL=4
+CONFIG_DEFAULT_LOGLEVEL=4
+CONFIG_DEBUG_INFO=y
+CONFIG_MTD=y
+CONFIG_DEBUG_LL=y
+CONFIG_DRIVER_SERIAL_NS16550=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+# CONFIG_MCI_WRITE is not set
+CONFIG_MCI_DW=y
+CONFIG_MFD_MC13XXX=y
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_FS_RAMFS is not set
+# CONFIG_FS_DEVFS is not set
+CONFIG_FS_FAT=y
+CONFIG_BOOTSTRAP=y
+CONFIG_BOOTSTRAP_DEVFS=y
+CONFIG_BOOTSTRAP_DISK=y
diff --git a/arch/arm/configs/imx6_vtpctp_defconfig b/arch/arm/configs/imx6_vtpctp_defconfig
new file mode 100644
index 0000000..699a79b
--- /dev/null
+++ b/arch/arm/configs/imx6_vtpctp_defconfig
@@ -0,0 +1,155 @@
+CONFIG_ARCH_IMX=y
+CONFIG_IMX_MULTI_BOARDS=y
+CONFIG_MACH_WAGO_VTPCTP_MX6=y
+CONFIG_IMX_IIM=y
+CONFIG_IMX_IIM_FUSE_BLOW=y
+CONFIG_THUMB2_BAREBOX=y
+CONFIG_ARM_BOARD_APPEND_ATAG=y
+CONFIG_ARM_OPTIMZED_STRING_FUNCTIONS=y
+CONFIG_ARM_UNWIND=y
+CONFIG_ARM_PSCI=y
+CONFIG_MMU=y
+CONFIG_MALLOC_SIZE=0x0
+CONFIG_MALLOC_TLSF=y
+CONFIG_KALLSYMS=y
+CONFIG_RELOCATABLE=y
+CONFIG_PROMPT="barebox> "
+CONFIG_HUSH_FANCY_PROMPT=y
+CONFIG_AUTO_COMPLETE=y
+CONFIG_MENU=y
+# CONFIG_TIMESTAMP is not set
+CONFIG_BOOTM_SHOW_TYPE=y
+CONFIG_BOOTM_VERBOSE=y
+CONFIG_BOOTM_INITRD=y
+CONFIG_BOOTM_OFTREE=y
+CONFIG_BLSPEC=y
+CONFIG_IMD=y
+CONFIG_CONSOLE_ACTIVATE_NONE=y
+CONFIG_CONSOLE_ALLOW_COLOR=y
+CONFIG_CONSOLE_RATP=y
+CONFIG_DEFAULT_ENVIRONMENT_GENERIC_NEW=y
+CONFIG_DEFAULT_ENVIRONMENT_PATH="defaultenv/defaultenv-pfc-base/ arch/arm/boards/wago-vtpctp-imx6/defaultenv-vtpctp-imx6/"
+CONFIG_STATE=y
+CONFIG_BOOTCHOOSER=y
+CONFIG_RESET_SOURCE=y
+CONFIG_DEBUG_INFO=y
+CONFIG_LONGHELP=y
+CONFIG_CMD_IOMEM=y
+CONFIG_CMD_MEMINFO=y
+CONFIG_CMD_ARM_MMUINFO=y
+CONFIG_CMD_MMC_EXTCSD=y
+# CONFIG_CMD_BOOTU is not set
+CONFIG_CMD_BOOTZ=y
+CONFIG_CMD_GO=y
+CONFIG_CMD_LOADB=y
+CONFIG_CMD_RESET=y
+CONFIG_CMD_UIMAGE=y
+CONFIG_CMD_PARTITION=y
+CONFIG_CMD_EXPORT=y
+CONFIG_CMD_LOADENV=y
+CONFIG_CMD_PRINTENV=y
+CONFIG_CMD_MAGICVAR=y
+CONFIG_CMD_MAGICVAR_HELP=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_FILETYPE=y
+CONFIG_CMD_LN=y
+CONFIG_CMD_MD5SUM=y
+CONFIG_CMD_UNCOMPRESS=y
+CONFIG_CMD_LET=y
+CONFIG_CMD_MSLEEP=y
+CONFIG_CMD_READF=y
+CONFIG_CMD_SLEEP=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MIITOOL=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_TFTP=y
+CONFIG_CMD_ECHO_E=y
+CONFIG_CMD_EDIT=y
+CONFIG_CMD_MENU=y
+CONFIG_CMD_MENUTREE=y
+CONFIG_CMD_READLINE=y
+CONFIG_CMD_TIMEOUT=y
+CONFIG_CMD_CRC=y
+CONFIG_CMD_CRC_CMP=y
+CONFIG_CMD_MM=y
+CONFIG_CMD_DETECT=y
+CONFIG_CMD_FLASH=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_LED=y
+CONFIG_CMD_LED_MODE=y
+CONFIG_CMD_SPI=y
+CONFIG_CMD_LED_TRIGGER=y
+CONFIG_CMD_WD=y
+CONFIG_CMD_BAREBOX_UPDATE=y
+CONFIG_CMD_OF_NODE=y
+CONFIG_CMD_OF_PROPERTY=y
+CONFIG_CMD_OFTREE=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_STATE=y
+CONFIG_CMD_BOOTCHOOSER=y
+CONFIG_CMD_UART_CONSOLE=y
+CONFIG_CMD_ETHADDR_MATCH=y
+CONFIG_NET=y
+CONFIG_NET_NFS=y
+CONFIG_NET_NETCONSOLE=y
+CONFIG_NET_RESOLV=y
+CONFIG_OFDEVICE=y
+CONFIG_OF_BAREBOX_DRIVERS=y
+CONFIG_OF_BAREBOX_ENV_IN_FS=y
+CONFIG_DRIVER_NET_FEC_IMX=y
+CONFIG_DRIVER_NET_MICREL=y
+CONFIG_MICREL_PHY=y
+CONFIG_DRIVER_SPI_GPIO=y
+CONFIG_DRIVER_SPI_IMX=y
+CONFIG_DISK_AHCI=y
+CONFIG_DISK_AHCI_IMX=y
+CONFIG_DISK_INTF_PLATFORM_IDE=y
+CONFIG_DISK_PATA_IMX=y
+CONFIG_USB_HOST=y
+CONFIG_USB_IMX_CHIPIDEA=y
+CONFIG_USB_EHCI=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_STORAGE=y
+CONFIG_MCI=y
+CONFIG_MCI_STARTUP=y
+CONFIG_MCI_MMC_BOOT_PARTITIONS=y
+CONFIG_MCI_IMX_ESDHC=y
+CONFIG_MFD_DA9063=y
+CONFIG_MFD_MC13XXX=y
+CONFIG_MFD_MC34704=y
+CONFIG_MFD_MC9SDZ60=y
+CONFIG_MFD_STMPE=y
+CONFIG_STATE_DRV=y
+CONFIG_XSECTION=y
+CONFIG_BOOTMATRIX=y
+CONFIG_LED=y
+CONFIG_LED_GPIO=y
+CONFIG_LED_GPIO_OF=y
+CONFIG_LED_TRIGGERS=y
+CONFIG_LED_PCA955X=y
+CONFIG_EEPROM_AT25=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_IMX=y
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_MXS_APBH_DMA=y
+CONFIG_GPIO_74164=y
+CONFIG_GPIO_STMPE=y
+CONFIG_NVMEM=y
+CONFIG_IMX_OCOTP=y
+CONFIG_IMX_OCOTP_WRITE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED=y
+CONFIG_GENERIC_PHY=y
+CONFIG_USB_NOP_XCEIV=y
+CONFIG_FS_EXT4=y
+CONFIG_FS_TFTP=y
+CONFIG_FS_NFS=y
+CONFIG_FS_FAT=y
+CONFIG_FS_FAT_WRITE=y
+CONFIG_FS_FAT_LFN=y
+CONFIG_ZLIB=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_ARCH_IMX_USBLOADER=y is not set
diff --git a/arch/arm/cpu/common.c b/arch/arm/cpu/common.c
index 51fe7ed..dadffe9 100644
--- a/arch/arm/cpu/common.c
+++ b/arch/arm/cpu/common.c
@@ -103,7 +103,9 @@ void relocate_to_current_adr(void)
 #error "Architecture not specified"
 #endif
 
+#if defined(CONFIG_MMU) && !defined(CONFIG_MACH_WAGO_PFC_AM35XX)
 	arm_early_mmu_cache_flush();
+#endif
 	icache_invalidate();
 }
 
diff --git a/arch/arm/cpu/setupc.S b/arch/arm/cpu/setupc.S
index 717500c..b4876b3 100644
--- a/arch/arm/cpu/setupc.S
+++ b/arch/arm/cpu/setupc.S
@@ -27,7 +27,7 @@ ENTRY(setup_c)
 	ldr	r2, =__bss_stop
 	sub	r2, r2, r0
 	bl	memset			/* clear bss */
-#ifdef CONFIG_MMU
+#if defined(CONFIG_MMU) && !defined(CONFIG_MACH_WAGO_PFC_AM35XX)
 	bl	arm_early_mmu_cache_flush
 #endif
 	mov	r0, #0
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 7ec10bf..e2149fb 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -113,5 +113,26 @@ pbl-dtb-$(CONFIG_MACH_ZII_VF610_DEV) += \
 	vf610-zii-scu4-aib-rev-c.dtb.o
 pbl-dtb-$(CONFIG_MACH_AT91SAM9263EK_DT) += at91sam9263ek.dtb.o
 pbl-dtb-$(CONFIG_MACH_AT91SAM9X5EK) += at91sam9x5ek.dtb.o
-
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += \
+	am335x-pfc-750_810x.dtb.o \
+	am335x-pfc-750_810x-mlo.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += \
+	am335x-pfc-750_8208.dtb.o \
+	am335x-pfc-750_8208-mlo.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += \
+	am335x-pfc-750_821x.dtb.o \
+	am335x-pfc-750_821x-mlo.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM335X_2850_311x) += \
+	am335x-src-2850_311x.dtb.o \
+	am335x-src-2850_311x-mlo.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM35XX) += am35xx-pfc-750_820x.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_VTPCTP_MX6) += imx6q-vtpctp-762-4xxx.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += \
+	am335x-pfc-768_330x.dtb.o \
+	am335x-pfc-768_330x-mlo.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_PFC_CYCLONE5) += \
+	cyclone5-pfc-750_8230.dtb.o
+pbl-dtb-$(CONFIG_MACH_WAGO_AM335X_RMCB) += \
+	am335x-rmcb.dtb.o \
+	am335x-rmcb-mlo.dtb.o
 clean-files := *.dtb *.dtb.S .*.dtc .*.pre .*.dts *.dtb.lzo
diff --git a/arch/arm/dts/am335x-pfc-750_810x-mlo.dts b/arch/arm/dts/am335x-pfc-750_810x-mlo.dts
new file mode 100644
index 0000000..3297145
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_810x-mlo.dts
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-750-810x MLO";
+	compatible = "wago,am335x-pfc-750_810x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc100";
+};
+
+&gpmc {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_810x.dts b/arch/arm/dts/am335x-pfc-750_810x.dts
new file mode 100644
index 0000000..35798b8d
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_810x.dts
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii2.dtsi"
+
+/ {
+	model = "PFC-750-810x";
+	compatible = "wago,am335x-pfc-750_810x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc100";
+	switch-reset-gpio = <&gpio2 21 GPIO_ACTIVE_LOW>;
+};
+
+&am33xx_pinmux {
+	pinctrl-0 = <&switch_reset>;
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x140 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)   /* mii1_rxd0.gpio2_21 */
+		>;
+	};
+};
+
+&rst {
+	gpios = <&gpio3 15 GPIO_ACTIVE_LOW>;
+};
+
+&gpmc {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&mac {
+	status = "okay";
+};
+
+/delete-node/ &pca9552_61;
diff --git a/arch/arm/dts/am335x-pfc-750_8208-mlo.dts b/arch/arm/dts/am335x-pfc-750_8208-mlo.dts
new file mode 100644
index 0000000..1738daf
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_8208-mlo.dts
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-750-820x MLO";
+	compatible = "wago,am335x-pfc-750_8208", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v2";
+};
+
+&gpmc {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_8208.dts b/arch/arm/dts/am335x-pfc-750_8208.dts
new file mode 100644
index 0000000..35a5c0b
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_8208.dts
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-nand.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii2.dtsi"
+
+/ {
+	model = "PFC-750-820x";
+	compatible = "wago,am335x-pfc-750_8208", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v2";
+	switch-reset-gpio = <&gpio3 10 GPIO_ACTIVE_LOW>;
+};
+
+
+&am33xx_pinmux {
+	pinctrl-0 = <&switch_reset>;
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x130 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)	/* mii1_rx_clk.gpio3_10 */
+		>;
+	};
+};
+
+&gpmc {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&pca9552_61 {
+	status = "okay";
+};
+
+&mac {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_821x-mlo.dts b/arch/arm/dts/am335x-pfc-750_821x-mlo.dts
new file mode 100644
index 0000000..ff9d912
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_821x-mlo.dts
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-750-821x MLO";
+	compatible = "wago,am335x-pfc-750_821x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v3";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+};
+
+&mmc2 {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-750_821x.dts b/arch/arm/dts/am335x-pfc-750_821x.dts
new file mode 100644
index 0000000..e91c774
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-750_821x.dts
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii12.dtsi"
+
+/ {
+	model = "PFC-750-821x";
+	compatible = "wago,am335x-pfc-750_821x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200v3";
+	switch-reset-gpio = <&pca953x 4 GPIO_ACTIVE_LOW>;
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+};
+
+&i2c0 {
+	pca953x: pca953x@70 {
+		compatible = "nxp,pca9538";
+		reg = <0x70>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&mmc1 {
+	cd-gpios = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&pca9552_61 {
+	status = "okay";
+};
+
+&mac {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-768_330x-mlo.dts b/arch/arm/dts/am335x-pfc-768_330x-mlo.dts
new file mode 100644
index 0000000..012f64f
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-768_330x-mlo.dts
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "PFC-768-330x MLO";
+	compatible = "wago,am335x-pfc-768_330x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200adv";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+};
+
+&mmc1_cd_pins {
+	pinctrl-single,pins = <
+		0x04C (PIN_INPUT_PULLDOWN | MUX_MODE7)  /* gpmc_a3.gpio1_19 */
+	>;
+};
+
+&mmc1 {
+	cd-gpios = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-pfc-768_330x.dts b/arch/arm/dts/am335x-pfc-768_330x.dts
new file mode 100644
index 0000000..1dd1bc9
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-768_330x.dts
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-emmc.dtsi"
+#include "am335x-pfc-leds.dtsi"
+#include "am335x-pfc-rmii12.dtsi"
+
+/ {
+	model = "PFC-768-330x";
+	compatible = "wago,am335x-pfc-768_330x", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "pfc200adv";
+	switch-reset-gpio = <&pca953x 4 GPIO_ACTIVE_LOW>;
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x20000000>; /* 512 MB */
+	};
+};
+
+&i2c0 {
+	pca953x: pca953x@70 {
+		compatible = "nxp,pca9538";
+		reg = <0x70>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+
+&mmc1_cd_pins {
+	pinctrl-single,pins = <
+		0x04C (PIN_INPUT_PULLDOWN | MUX_MODE7)  /* gpmc_a3.gpio1_19 */
+	>;
+};
+
+&mmc1 {
+	cd-gpios = <&gpio1 19 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+	status = "okay";
+};
+
+&pca9552_60 {
+	status = "okay";
+};
+
+&led_0 {
+	label = "ds-red";
+};
+
+&led_1 {
+	label = "ds-green";
+};
+
+&led_2 {
+	label = "ec-red";
+};
+
+&led_3 {
+	label = "ec-blue";
+};
+
+&led_4 {
+	label = "ms-red";
+};
+
+&led_5 {
+	label = "ms-green";
+};
+
+&led_6 {
+	label = "ns-red";
+};
+
+&led_7 {
+	label = "ns-green";
+};
+
+&led_8 {
+	label = "run-red";
+};
+
+&led_9 {
+	label = "run-green";
+};
+
+&led_10 {
+	label = "app-red";
+};
+
+&led_11 {
+	label = "app-green";
+};
+
+&mac {
+	status = "okay";
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0 {
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&rst {
+	gpios = <&gpio3 15 GPIO_ACTIVE_LOW>;
+};
+
+&partitions {
+	blp_uii: ethaddr2@1CF {
+		label = "blp_uii";
+		reg = <0x1CF 0x28>;
+	};
+};
+
+&xsection {
+	blp_uii = <&blp_uii>;
+};
diff --git a/arch/arm/dts/am335x-pfc-emmc.dtsi b/arch/arm/dts/am335x-pfc-emmc.dtsi
new file mode 100644
index 0000000..a60ad69
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-emmc.dtsi
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&am33xx_pinmux {
+	emmc_pins: pinmux_emmc_pins {
+		pinctrl-single,pins = <
+			0x080 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE2) /* gpmc_csn1.mmc1_clk */
+			0x084 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE2) /* gpmc_csn2.mmc1_cmd */
+			0x000 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE1) /* gpmc_ad0.gpmc_ad0  */
+			0x004 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE1) /* gpmc_ad0.gpmc_ad1  */
+			0x008 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE1) /* gpmc_ad0.gpmc_ad2  */
+			0x00c (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE1) /* gpmc_ad0.gpmc_ad3  */
+		>;
+	};
+};
+
+&mmc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&emmc_pins>;
+	vmmc-supply = <&vmmcsd_fixed>;
+	bus-width = <4>;
+	non-removable;
+	status = "disabled";
+};
+
+#include "am3xxx-pfc-emmcparts.dtsi"
diff --git a/arch/arm/dts/am335x-pfc-gpmc.dtsi b/arch/arm/dts/am335x-pfc-gpmc.dtsi
new file mode 100644
index 0000000..7d6c302
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-gpmc.dtsi
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&gpmc {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+	num-cs = <3>;
+	num-waitpins = <1>;
+	ranges = <
+		0 0 0x08000000 0x01000000 /* CS0: NAND */
+	>;
+
+ 	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		elm_id = <&elm>;
+	};
+};
+
+/include/ "am3xxx-pfc-nandparts.dtsi"
diff --git a/arch/arm/dts/am335x-pfc-leds.dtsi b/arch/arm/dts/am335x-pfc-leds.dtsi
new file mode 100644
index 0000000..fe90719
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-leds.dtsi
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&i2c0 {
+	/*
+	 * Note:
+	 * The predefined order here determines
+	 * the order how leds are enabled.
+	 *
+	 * Note: BUG in barebox-led trigger code.
+	 * triggers are assuming, that leds-max
+	 * value is 1. this is correct for gpio-leds but
+	 * not for brightness driven leds like the
+	 * pca 9552 chip.
+	 *
+	 * for pca-chips use custom brightness values for
+	 * triggering:
+	 *
+	 * 		1 Blink  1 HZ
+	 * 		2 Blink  4 HZ
+	 * 		3 Blink 10 HZ
+	 */
+
+	pca9552_61: pca9552@61 {
+		compatible = "pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x61>;
+		status = "disabled";
+
+		u1-green@11 {
+		      label = "u1-green";
+		      reg = <11>;
+		      linux,default-trigger = "none";
+		};
+
+		u1-red@10 {
+		      label = "u1-red";
+		      reg = <10>;
+		      linux,default-trigger = "none";
+		};
+
+		u2-green@9 {
+		      label = "u2-green";
+		      reg = <9>;
+		      linux,default-trigger = "none";
+		};
+
+		u2-red@8 {
+		      label = "u2-red";
+		      reg = <8>;
+		      linux,default-trigger = "none";
+		};
+
+		u3-green@7 {
+		      label = "u3-green";
+		      reg = <7>;
+		      linux,default-trigger = "none";
+		};
+
+		u3-red@6 {
+		      label = "u3-red";
+		      reg = <6>;
+		      linux,default-trigger = "none";
+		};
+
+		u4-green@5 {
+		      label = "u4-green";
+		      reg = <5>;
+		      linux,default-trigger = "none";
+		};
+
+		u4-red@4 {
+		      label = "u4-red";
+		      reg = <4>;
+		      linux,default-trigger = "none";
+		};
+
+		u5-green@3 {
+		      label = "u5-green";
+		      reg = <3>;
+		      linux,default-trigger = "none";
+		};
+
+		u5-red@2 {
+		      label = "u5-red";
+		      reg = <2>;
+		      linux,default-trigger = "none";
+		};
+
+		u6-green@1 {
+		      label = "u6-green";
+		      reg = <1>;
+		      linux,default-trigger = "none";
+		};
+
+		u6-red@0 {
+		      label = "u6-red";
+		      reg = <0>;
+		      linux,default-trigger = "none";
+		};
+        };
+
+	pca9552_60: pca9552@60 {
+		compatible = "pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x60>;
+		status = "disabled";
+
+		overwrite: overwrite@15 {
+			label = "overwrite";
+			reg = <15>;
+			linux,default-trigger = "default-on";
+		};
+
+		led_0: sys-red@0 {
+			label = "sys-red";
+			reg = <0>;
+			linux,default-trigger = "none";
+		};
+
+		led_1: sys-green@1 {
+			label = "sys-green";
+			reg = <1>;
+			linux,default-trigger = "none";
+		};
+
+		led_2: run-red@2 {
+			label = "run-red";
+			reg = <2>;
+			linux,default-trigger = "none";
+		};
+
+		led_3: run-green@3 {
+			label = "run-green";
+			reg = <3>;
+			linux,default-trigger = "none";
+		};
+
+		led_4: io-red@4 {
+			label = "io-red";
+			reg = <4>;
+			linux,default-trigger = "none";
+		};
+
+		led_5: io-green@5 {
+			label = "io-green";
+			reg = <5>;
+			linux,default-trigger = "none";
+		};
+
+		led_6: ms-red@6 {
+			label = "ms-red";
+			reg = <6>;
+			linux,default-trigger = "none";
+		};
+
+		led_7: ms-green@7 {
+			label = "ms-green";
+			reg = <7>;
+			linux,default-trigger = "none";
+		};
+
+		led_8: ns-red@8 {
+			label = "ns-red";
+			reg = <8>;
+			linux,default-trigger = "none";
+		};
+
+		led_9: ns-green@9 {
+			label = "ns-green";
+			reg = <9>;
+			linux,default-trigger = "none";
+		};
+
+		led_10: u7-red@10 {
+			label = "u7-red";
+			reg = <10>;
+			linux,default-trigger = "none";
+		};
+
+		led_11: u7-green@11 {
+			label = "u7-green";
+			reg = <11>;
+			linux,default-trigger = "none";
+		};
+	};
+};
diff --git a/arch/arm/dts/am335x-pfc-nand.dtsi b/arch/arm/dts/am335x-pfc-nand.dtsi
new file mode 100644
index 0000000..ae7ed50
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-nand.dtsi
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&am33xx_pinmux {
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x000 0x20	/* gpmc_ad0, INPUT_PULLDOWN | MODE0 */
+			0x004 0x20	/* gpmc_ad1, INPUT_PULLDOWN | MODE0 */
+			0x008 0x20	/* gpmc_ad2, INPUT_PULLDOWN | MODE0 */
+			0x00c 0x20	/* gpmc_ad3, INPUT_PULLDOWN | MODE0 */
+			0x010 0x20	/* gpmc_ad4, INPUT_PULLDOWN | MODE0 */
+			0x014 0x20	/* gpmc_ad5, INPUT_PULLDOWN | MODE0 */
+			0x018 0x20	/* gpmc_ad6, INPUT_PULLDOWN | MODE0 */
+			0x01c 0x20	/* gpmc_ad7, INPUT_PULLDOWN | MODE0 */
+			0x020 0x20	/* gpmc_ad8, INPUT_PULLDOWN | MODE0 */
+			0x024 0x20	/* gpmc_ad9, INPUT_PULLDOWN | MODE0 */
+			0x028 0x20	/* gpmc_ad10, INPUT_PULLDOWN | MODE0 */
+			0x02c 0x20	/* gpmc_ad11, INPUT_PULLDOWN | MODE0 */
+			0x030 0x20	/* gpmc_ad12, INPUT_PULLDOWN | MODE0 */
+			0x034 0x20	/* gpmc_ad13, INPUT_PULLDOWN | MODE0 */
+			0x038 0x20	/* gpmc_ad14, INPUT_PULLDOWN | MODE0 */
+			0x03c 0x20	/* gpmc_ad15, INPUT_PULLDOWN | MODE0 */
+			0x070 0x30	/* gpmc_wait0, INPUT_PULLUP | MODE0 */
+			0x07c 0x10	/* gpmc_csn0, OUTPUT_PULLUP | MODE0 */
+			0x080 0x10	/* gpmc_csn1, OUTPUT_PULLUP | MODE0 */
+			0x084 0x11	/* gpmc_csn2, OUTPUT_PULLUP | MODE1 (gpmc_be1n_mux1) */
+			0x090 0x08	/* gpmc_advn_ale, MODE0 */
+			0x094 0x08	/* gpmc_oen_ren,  MODE0 */
+			0x098 0x08	/* gpmc_wen, OUTPUT_PULLUP | MODE0 */
+			0x09c 0x08	/* gpmc_ben0_cle.gpmc_be0n_cle, OUTPUT_PULLUP | MODE0 */
+		>;
+	};
+};
+
+/include/ "am335x-pfc-gpmc.dtsi"
diff --git a/arch/arm/dts/am335x-pfc-rmii12.dtsi b/arch/arm/dts/am335x-pfc-rmii12.dtsi
new file mode 100644
index 0000000..d54f11c
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-rmii12.dtsi
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&am33xx_pinmux {
+	cpsw_rmmi12_default: cpsw_rmmi12_default {
+		pinctrl-single,pins = <
+			/* RMMI2 */
+			0x040 (PIN_OUTPUT | SLEWCTRL_FAST | MUX_MODE3) /* gpmc_a0.rmii2_txen     */
+			0x050 (PIN_OUTPUT | SLEWCTRL_FAST | MUX_MODE3) /* gpmc_a4.rmii2_txd1     */
+			0x054 (PIN_OUTPUT | SLEWCTRL_FAST | MUX_MODE3) /* gpmc_a5.rmii2_txd0     */
+			0x068 (PIN_INPUT                  | MUX_MODE3) /* gpmc_a10.rmii2_rxd1    */
+			0x06C (PIN_INPUT                  | MUX_MODE3) /* gpmc_a11.rmii2_rxd0    */
+			0x108 (PIN_INPUT                  | MUX_MODE1) /* mii1_col.rmii2_refclk  */
+			0x088 (PIN_INPUT                  | MUX_MODE2) /* gpmc_csn3.rmii2_crs_dv */
+			0x074 (PIN_INPUT 		  | MUX_MODE7) /* gpmc_wpn.gpio0_31      */
+
+			/* RMMI1 only used on Marvell based devices; default off */
+			0x144 (PIN_INPUT                  | MUX_MODE7) /* rmii1_ref_clk.rmii1_refclk */
+			0x114 (PIN_INPUT                  | MUX_MODE7) /* mii1_txen.rmii1_txen       */
+			0x128 (PIN_INPUT                  | MUX_MODE7) /* mii1_txd0.rmii1_txd0       */
+			0x124 (PIN_INPUT                  | MUX_MODE7) /* mii1_txd1.rmii1_txd1       */
+			0x140 (PIN_INPUT                  | MUX_MODE7) /* mii1_rxd0.rmii1_rxd0       */
+			0x13c (PIN_INPUT                  | MUX_MODE7) /* mii1_rxd1.rmii1_rxd1       */
+			0x10c (PIN_INPUT                  | MUX_MODE7) /* mii1_crs.rmii1_crs_dv      */
+		>;
+	};
+
+	cpsw_rmmi12_sleep: cpsw_rmmi12_sleep {
+		pinctrl-single,pins = <
+			/* RMMI2 */
+			0x040 (PIN_INPUT | MUX_MODE7) /* gpmc_a0.rmii2_txen     */
+			0x050 (PIN_INPUT | MUX_MODE7) /* gpmc_a4.rmii2_txd1     */
+			0x054 (PIN_INPUT | MUX_MODE7) /* gpmc_a5.rmii2_txd0     */
+			0x068 (PIN_INPUT | MUX_MODE7) /* gpmc_a10.rmii2_rxd1    */
+			0x06C (PIN_INPUT | MUX_MODE7) /* gpmc_a11.rmii2_rxd0    */
+			0x108 (PIN_INPUT | MUX_MODE7) /* mii1_col.rmii2_refclk  */
+			0x088 (PIN_INPUT | MUX_MODE7) /* gpmc_csn3.rmii2_crs_dv */
+			0x074 (PIN_INPUT | MUX_MODE7) /* gpmc_wpn.gpio0_31      */
+
+			/* RMMI1 only used on Marvell based devices; default off to not brick
+			 * the bootstrap option of marvell based devices
+			 */
+			0x144 (PIN_INPUT | MUX_MODE7) /* rmii1_ref_clk.rmii1_refclk      */
+			0x114 (PIN_INPUT | MUX_MODE7) /* mii1_txen.rmii1_txen (gpio3_3)  */
+			0x128 (PIN_INPUT | MUX_MODE7) /* mii1_txd0.rmii1_txd0 (gpio0_28) */
+			0x124 (PIN_INPUT | MUX_MODE7) /* mii1_txd1.rmii1_txd1 (gpio0_21) */
+			0x140 (PIN_INPUT | MUX_MODE7) /* mii1_rxd0.rmii1_rxd0 (gpio2_21) */
+			0x13c (PIN_INPUT | MUX_MODE7) /* mii1_rxd1.rmii1_rxd1 (gpio2_20) */
+			0x10c (PIN_INPUT | MUX_MODE7) /* mii1_crs.rmii1_crs_dv (gpio3_1) */
+	       >;
+	};
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_rmmi12_default>;
+	pinctrl-1 = <&cpsw_rmmi12_sleep>;
+	status = "disabled";
+};
diff --git a/arch/arm/dts/am335x-pfc-rmii2.dtsi b/arch/arm/dts/am335x-pfc-rmii2.dtsi
new file mode 100644
index 0000000..be7332d
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-rmii2.dtsi
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&am33xx_pinmux {
+	cpsw_rmmi2_default: cpsw_rmmi2_default {
+		pinctrl-single,pins = <
+                        0x040 (PIN_OUTPUT_PULLDOWN | MUX_MODE3) /* gpmc_a0.rmii2_txen */
+                        0x050 (PIN_OUTPUT_PULLDOWN | MUX_MODE3) /* gpmc_a4.rmii2_txd1 */
+                        0x054 (PIN_OUTPUT_PULLDOWN | MUX_MODE3) /* gpmc_a5.rmii2_txd0 */
+                        0x068 (PIN_INPUT_PULLDOWN | MUX_MODE3)  /* gpmc_a10.rmii2_rxd1 */
+                        0x06C (PIN_INPUT_PULLDOWN | MUX_MODE3)  /* gpmc_a11.rmii2_rxd0 */
+                        0x074 (PIN_INPUT_PULLDOWN | MUX_MODE3)  /* gpmc_wpn.rmii2_rxer */
+                        0x108 (PIN_INPUT_PULLDOWN | MUX_MODE1)  /* mii1_col.rmii2_refclk */
+                        0x088 (PIN_INPUT          | MUX_MODE2)  /* gpmc_csn3.rmii2_crs_dv */
+		>;
+	};
+
+	cpsw_rmmi2_sleep: cpsw_rmmi2_sleep {
+		pinctrl-single,pins = <
+                        0x040 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+                        0x050 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+                        0x054 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+                        0x068 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+                        0x06C (PIN_INPUT_PULLDOWN | MUX_MODE7)
+                        0x074 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+                        0x108 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+                        0x088 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+		>;
+	};
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_rmmi2_default>;
+	pinctrl-1 = <&cpsw_rmmi2_sleep>;
+	status = "disabled";
+};
diff --git a/arch/arm/dts/am335x-pfc-strip.dtsi b/arch/arm/dts/am335x-pfc-strip.dtsi
new file mode 100644
index 0000000..cac253a
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc-strip.dtsi
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	aliases {
+		/delete-property/ serial1;
+		/delete-property/ serial2;
+		/delete-property/ serial3;
+		/delete-property/ serial4;
+		/delete-property/ serial5;
+		/delete-property/ usb1;
+		/delete-property/ phy1;
+		/delete-property/ bootmatrix;
+		/delete-property/ ethernet0;
+		/delete-property/ ethernet1;
+		/delete-property/ spi0;
+		/delete-property/ bootstate;
+	};
+};
+
+/delete-node/ &environment_sd;
+/delete-node/ &uart1;
+/delete-node/ &uart2;
+/delete-node/ &uart3;
+/delete-node/ &uart4;
+/delete-node/ &uart5;
+/delete-node/ &davinci_mdio_default;
+/delete-node/ &davinci_mdio_sleep;
+/delete-node/ &bas_pins;
+/delete-node/ &bootmatrix;
+/delete-node/ &davinci_mdio;
+/delete-node/ &cpsw_emac0;
+/delete-node/ &cpsw_emac1;
+/delete-node/ &phy_sel;
+/delete-node/ &mac;
+/delete-node/ &spi0;
+/delete-node/ &bootstate;
diff --git a/arch/arm/dts/am335x-pfc.dtsi b/arch/arm/dts/am335x-pfc.dtsi
new file mode 100644
index 0000000..7c5b73f
--- /dev/null
+++ b/arch/arm/dts/am335x-pfc.dtsi
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "am33xx.dtsi"
+#include "bootchooser.dtsi"
+
+/ {
+	aliases {
+		ethernet0 = &cpsw_emac1;
+		ethernet1 = &cpsw_emac0;
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+		nand = &gpmc;
+		emmc = &mmc2;
+		sd = &mmc1;
+	};
+
+	chosen {
+		stdout-path = &uart0;
+
+		environment_sd: environment-sd {
+			compatible = "barebox,environment";
+			device-path = &mmc1, "partname:0";
+			file-path = "barebox.env";
+			status = "disabled";
+		};
+
+		environment_emmc: environment-emmc {
+			compatible = "barebox,environment";
+			device-path = &mmc2, "partname:0";
+			file-path = "barebox.env";
+			status = "disabled";
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bas_pins>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpio3 18 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpio3 17 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpio3 16 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpio3 15 GPIO_ACTIVE_HIGH>;};
+	};
+
+	vmmcsd_fixed: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vmmcsd_fixed";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&am33xx_pinmux {
+
+	pinctrl-0 = <&uart0_pins
+		     &uart1_pins>;
+
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart0_rxd.uart0_rxd */
+			0x174 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart0_txd.uart0_txd */
+		>;
+	};
+
+	uart1_pins: pinmux_uart1_pins {
+		pinctrl-single,pins = <
+			0x178 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart1_cts.uart1_cts */
+			0x17C (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart1_rts.uart1_rts */
+			0x180 (PIN_INPUT_PULLUP | MUX_MODE0)	/* uart1_rxd.uart1_rxd */
+			0x184 (PIN_OUTPUT_PULLDOWN | MUX_MODE0)	/* uart1_txd.uart1_txd */
+			0x1A4 (PIN_OUTPUT_PULLDOWN | MUX_MODE7) /* mcasp0_fsr.gpio3_19 */
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_sda.i2c0_sda */
+			0x18c (PIN_INPUT_PULLUP | MUX_MODE0)	/* i2c0_scl.i2c0_scl */
+		>;
+	};
+
+	davinci_mdio_default: davinci_mdio_default {
+		pinctrl-single,pins = <
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE0) /* mdio_data.mdio_data */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE0)		     /* mdio_clk.mdio_clk */
+		>;
+	};
+
+	davinci_mdio_sleep: davinci_mdio_sleep {
+		pinctrl-single,pins = <
+			0x148 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x14c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x0F0 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat3.mmc0_dat3 */
+			0x0F4 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat2.mmc0_dat2 */
+			0x0F8 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat1.mmc0_dat1 */
+			0x0FC (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat0.mmc0_dat0 */
+			0x100 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_clk.mmc0_clk   */
+			0x104 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_cmd.mmc0_cmd   */
+		>;
+	};
+
+	mmc1_cd_pins: pinmux_mmc1_cd_pins {
+		pinctrl-single,pins = <
+			0x190 (PIN_INPUT_PULLDOWN | MUX_MODE7)  /* mcasp0_aclkx.gpio3_14 */
+		>;
+	};
+
+	bas_pins: pinmux_bas_pins {
+		pinctrl-single,pins = <
+			0x194 (PIN_INPUT | MUX_MODE7)    /* mcasp0_fsx.gpio3_15    */    //b13   RESET-ALL-BUT
+			0x198 (PIN_INPUT | MUX_MODE7)    /* mcasp0_axr0.gpio3_16   */    //d12   nRST-BAS
+			0x19c (PIN_INPUT | MUX_MODE7)    /* mcasp0_ahclkr.gpio3_17 */    //c12   nSTOP-BAS
+			0x1A0 (PIN_INPUT | MUX_MODE7)    /* mcasp0_aclkr.gpio3_18  */    //b12   nRUN-BAS
+		>;
+	};
+};
+
+&cppi41dma  {
+	status = "okay";
+};
+
+&mmc1 {
+	status = "okay";
+	vmmc-supply = <&vmmcsd_fixed>;
+	bus-width = <0x4>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>, <&mmc1_cd_pins>;
+	cd-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+	cd-inverted;
+};
+
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "disabled";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins>;
+	status = "disabled";
+};
+
+&cpsw_emac0 {
+	phy-mode = "rmii";
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&cpsw_emac1 {
+	phy-mode = "rmii";
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&phy_sel {
+	rmii-clock-ext;
+	status = "okay";
+};
+
+&davinci_mdio {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&davinci_mdio_default>;
+	pinctrl-1 = <&davinci_mdio_sleep>;
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	clock-frequency = <400000>;
+	status = "okay";
+
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+	};
+};
+
+#include "eepromparts.dtsi"
diff --git a/arch/arm/dts/am335x-rmcb-mlo.dts b/arch/arm/dts/am335x-rmcb-mlo.dts
new file mode 100644
index 0000000..f81dc5c
--- /dev/null
+++ b/arch/arm/dts/am335x-rmcb-mlo.dts
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2020 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "RMCB MLO";
+	compatible = "wago,am335x-rmcb", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "rmcb";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x8000000>; /* 128 MB */
+	};
+};
+
+&mmc1 {
+	cd-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/am335x-rmcb.dts b/arch/arm/dts/am335x-rmcb.dts
new file mode 100644
index 0000000..c534fbb
--- /dev/null
+++ b/arch/arm/dts/am335x-rmcb.dts
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2017 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+
+/delete-node/ &environment_emmc;
+
+/ {
+	model = "RMCB";
+	compatible = "wago,am335x-rmcb", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "rmcb";
+	switch-reset-gpio = <&pca9535_21 7 GPIO_ACTIVE_LOW>;
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x8000000>; /* 128 MB */
+	};
+
+	aliases {
+		ethernet0 = &cpsw_emac0;
+		ethernet1 = &cpsw_emac1;
+	};
+
+	gpio-sysled {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&sys_led_pin>;
+
+		sysled-green@0 {
+			label = "sysled-green";
+			gpios = <&gpio3 0 1>;
+			linux,default-trigger = "none";
+		};
+	};
+
+	gpio-pca9535_22-leds {
+		compatible = "gpio-leds";
+
+		led1-red@0 {
+			label = "led1-red";
+			gpios = <&pca9535_22 0 1>;
+			linux,default-trigger = "none";
+		};
+
+		led1-green@1 {
+			label = "led1-green";
+			gpios = <&pca9535_22 1 1>;
+			linux,default-trigger = "none";
+		};
+
+		led2-red@2 {
+			label = "led2-red";
+			gpios = <&pca9535_22 2 1>;
+			linux,default-trigger = "none";
+		};
+
+		led2-green@3 {
+			label = "led2-green";
+			gpios = <&pca9535_22 3 1>;
+			linux,default-trigger = "none";
+		};
+
+		led3-red@4 {
+			label = "led3-red";
+			gpios = <&pca9535_22 4 1>;
+			linux,default-trigger = "none";
+		};
+
+		led3-green@5 {
+			label = "led3-green";
+			gpios = <&pca9535_22 5 1>;
+			linux,default-trigger = "none";
+		};
+
+		led4-red@6 {
+			label = "led4-red";
+			gpios = <&pca9535_22 6 1>;
+			linux,default-trigger = "none";
+		};
+
+		led4-green@7 {
+			label = "led4-green";
+			gpios = <&pca9535_22 7 1>;
+			linux,default-trigger = "none";
+		};
+
+		led5-red@8 {
+			label = "led5-red";
+			gpios = <&pca9535_22 8 1>;
+			linux,default-trigger = "none";
+		};
+
+		led5-green@9 {
+			label = "led5-green";
+			gpios = <&pca9535_22 9 1>;
+			linux,default-trigger = "none";
+		};
+
+		led6-red@10 {
+			label = "led6-red";
+			gpios = <&pca9535_22 10 1>;
+			linux,default-trigger = "none";
+		};
+
+		led6-green@11 {
+			label = "led6-green";
+			gpios = <&pca9535_22 11 1>;
+			linux,default-trigger = "none";
+		};
+
+		led7-red@12 {
+			label = "led7-red";
+			gpios = <&pca9535_22 12 1>;
+			linux,default-trigger = "none";
+		};
+
+		led7-green@13 {
+			label = "led7-green";
+			gpios = <&pca9535_22 13 1>;
+			linux,default-trigger = "none";
+		};
+
+		led8-red@14 {
+			label = "led8-red";
+			gpios = <&pca9535_22 14 1>;
+			linux,default-trigger = "none";
+		};
+
+		led8-green@15 {
+			label = "led8-green";
+			gpios = <&pca9535_22 15 1>;
+			linux,default-trigger = "none";
+		};
+	};
+};
+
+&am33xx_pinmux {
+
+	cpsw_default: cpsw_default {
+		pinctrl-single,pins = <
+			/* RMII1 */
+			AM33XX_IOPAD(0x90c, PIN_INPUT | MUX_MODE1)  /* (H17) gmii1_crs.rmii1_crs_dv */
+			AM33XX_IOPAD(0x910, PIN_INPUT | MUX_MODE1)  /* (J15) gmii1_rxer.rmii1_rxer */
+			AM33XX_IOPAD(0x914, PIN_OUTPUT | MUX_MODE1) /* (J16) gmii1_txen.rmii1_txen */
+			AM33XX_IOPAD(0x928, PIN_OUTPUT | MUX_MODE1) /* (K17) gmii1_txd0.rmii1_txd0 */
+			AM33XX_IOPAD(0x924, PIN_OUTPUT | MUX_MODE1) /* (K16) gmii1_txd1.rmii1_txd1 */
+			AM33XX_IOPAD(0x940, PIN_INPUT | MUX_MODE1)  /* (M16) gmii1_rxd0.rmii1_rxd0 */
+			AM33XX_IOPAD(0x93c, PIN_INPUT | MUX_MODE1)  /* (L15) gmii1_rxd1.rmii1_rxd1 */
+			AM33XX_IOPAD(0x944, PIN_INPUT | MUX_MODE0)  /* (H18) rmii1_refclk.rmii1_refclk */
+		>;
+	};
+
+	cpsw_sleep: cpsw_sleep {
+		pinctrl-single,pins = <
+			/* RMII1 */
+			AM33XX_IOPAD(0x90c, PIN_INPUT | MUX_MODE7) /* (H17) gmii1_crs.rmii1_crs_dv */
+			AM33XX_IOPAD(0x910, PIN_INPUT | MUX_MODE7) /* (J15) gmii1_rxer.rmii1_rxer */
+			AM33XX_IOPAD(0x914, PIN_INPUT | MUX_MODE7) /* (J16) gmii1_txen.rmii1_txen */
+			AM33XX_IOPAD(0x928, PIN_INPUT | MUX_MODE7) /* (K17) gmii1_txd0.rmii1_txd0 */
+			AM33XX_IOPAD(0x924, PIN_INPUT | MUX_MODE7) /* (K16) gmii1_txd1.rmii1_txd1 */
+			AM33XX_IOPAD(0x940, PIN_INPUT | MUX_MODE7) /* (M16) gmii1_rxd0.rmii1_rxd0 */
+			AM33XX_IOPAD(0x93c, PIN_INPUT | MUX_MODE7) /* (L15) gmii1_rxd1.rmii1_rxd1 */
+			AM33XX_IOPAD(0x944, PIN_INPUT | MUX_MODE7) /* (H18) rmii1_refclk.rmii1_refclk */
+		>;
+	};
+
+	sys_led_pin: pinmux_sys_led_pin {
+		pinctrl-single,pins = <
+			AM33XX_IOPAD(0x908, PIN_OUTPUT | MUX_MODE7) /* (H16) gmii1_col.gpio3_0 */
+		>;
+	};
+
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_default>;
+	pinctrl-1 = <&cpsw_sleep>;
+	status = "okay";
+};
+
+&mmc1 {
+	cd-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>;
+};
+
+&rst {
+	gpios = <&gpio3 15 GPIO_ACTIVE_LOW>;
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	clock-frequency = <400000>;
+	status = "okay";
+
+	pca9535_21: pca9535@21 {
+		status = "okay";
+		compatible = "nxp,pca9535";
+		reg = <0x21>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+
+	pca9535_22: pca9535@22 {
+		status = "okay";
+		compatible = "nxp,pca9535";
+		reg = <0x22>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+		wp-gpios = <&pca9535_21 6 GPIO_ACTIVE_LOW>;
+	};
+};
diff --git a/arch/arm/dts/am335x-src-2850_311x-mlo.dts b/arch/arm/dts/am335x-src-2850_311x-mlo.dts
new file mode 100644
index 0000000..a169aec
--- /dev/null
+++ b/arch/arm/dts/am335x-src-2850_311x-mlo.dts
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-src-nand.dtsi"
+#include "am335x-pfc-strip.dtsi"
+#include "am33xx-strip.dtsi"
+#include "am33xx-clocks-strip.dtsi"
+
+/ {
+	model = "SRC-2850-311x MLO";
+	compatible = "wago,am335x-src-2850_311x", "wago,am335x-src", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "src";
+};
+
+&am33xx_pinmux {
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x0F0 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat3.mmc0_dat3 */
+			0x0F4 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat2.mmc0_dat2 */
+			0x0F8 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat1.mmc0_dat1 */
+			0x0FC (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat0.mmc0_dat0 */
+			0x100 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_clk.mmc0_clk   */
+			0x104 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_cmd.mmc0_cmd   */
+			0x1A0 (PIN_INPUT_PULLDOWN | MUX_MODE7)  /* mcasp0_aclkr.gpio3_18 */
+		>;
+	};
+};
+
+&mmc1 {
+	cd-gpios = <&gpio3 18 GPIO_ACTIVE_HIGH>;
+};
+
+&gpmc {
+	status = "okay";
+};
diff --git a/arch/arm/dts/am335x-src-2850_311x.dts b/arch/arm/dts/am335x-src-2850_311x.dts
new file mode 100644
index 0000000..96a9a16
--- /dev/null
+++ b/arch/arm/dts/am335x-src-2850_311x.dts
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include "am335x-pfc.dtsi"
+#include "am335x-src-nand.dtsi"
+#include "am335x-src-leds.dtsi"
+#include "am335x-pfc-rmii2.dtsi"
+
+/ {
+	model = "SRC-2850-311x";
+	compatible = "wago,am335x-src-2850_311x", "wago,am335x-src", "wago,am335x-pfc", "ti,am33xx";
+	board-variant = "src";
+	switch-reset-gpio = <&gpio3 10 GPIO_ACTIVE_LOW>;
+};
+
+&am33xx_pinmux {
+	pinctrl-0 = <&switch_reset>, <&low_voltage_buffer>;
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x130 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)   /* mii1_rx_clk.gpio3_10 */
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x0F0 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat3.mmc0_dat3 */
+			0x0F4 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat2.mmc0_dat2 */
+			0x0F8 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat1.mmc0_dat1 */
+			0x0FC (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat0.mmc0_dat0 */
+			0x100 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_clk.mmc0_clk   */
+			0x104 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_cmd.mmc0_cmd   */
+			0x1A0 (PIN_INPUT_PULLDOWN | MUX_MODE7)  /* mcasp0_aclkr.gpio3_18 */
+		>;
+	};
+
+	bas_pins: pinmux_bas_pins {
+		pinctrl-single,pins = <
+			0x1A4 (PIN_INPUT | MUX_MODE7)    /* mcasp0_fsr.gpio3_19 */    //b13   RESET-ALL-BUT
+		>;
+	};
+
+	low_voltage_buffer: low_voltage_buffer {
+		pinctrl-single,pins = <
+			0x080 (PIN_OUTPUT_PULLDOWN | MUX_MODE7)   /* gpmc_csn1.gpio1_30 */
+		>;
+	};
+};
+
+&gpio1 {
+	low_voltage_buffer {
+		gpio-hog;
+		gpios = <30 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "low-voltage-buffer";
+	};
+};
+
+/* bootmatrix */
+/delete-node/ &run;
+/delete-node/ &stop;
+/delete-node/ &reset;
+
+&rst {
+	gpios = <&gpio3 19 GPIO_ACTIVE_HIGH>;
+};
+
+&gpmc {
+	status = "okay";
+};
+
+&mac {
+	status = "okay";
+};
+
+&mmc1 {
+	cd-gpios = <&gpio3 18 GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm/dts/am335x-src-leds.dtsi b/arch/arm/dts/am335x-src-leds.dtsi
new file mode 100644
index 0000000..197ca5f
--- /dev/null
+++ b/arch/arm/dts/am335x-src-leds.dtsi
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+	/* LEDs DS and APP. Red color leds are driven by pwm to be able to
+	 * compensate temperature dependent yellow color.
+	 */
+	leds {
+		compatible = "gpio-leds";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_pins>;
+
+		app-green {
+			label = "app-green";
+			gpios=<&gpio2 24 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		ds-green {
+			label = "ds-green";
+			gpios=<&gpio2 23 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		app-red {
+			label = "app-red";
+			gpios=<&gpio0 22 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		ds-red {
+			label = "ds-red";
+			gpios=<&gpio0 23 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+	};
+};
+
+&am33xx_pinmux {
+
+	led_pins: pinmux_led_pins {
+		pinctrl-single,pins = <
+			0x0e4 (PIN_OUTPUT | MUX_MODE7) /* lcd_hsync.gpio2_23	ds-green  */
+			0x0e8 (PIN_OUTPUT | MUX_MODE7) /* lcd_pclk.gpio2_24	app-green */
+			0x020 (PIN_OUTPUT | MUX_MODE7) /* gpmc_ad8.gpio0_22	app-red	  */
+			0x024 (PIN_OUTPUT | MUX_MODE7) /* gpmc_ad9.gpio0_23	ds-red	  */
+		>;
+	};
+};
diff --git a/arch/arm/dts/am335x-src-nand.dtsi b/arch/arm/dts/am335x-src-nand.dtsi
new file mode 100644
index 0000000..89aa96c
--- /dev/null
+++ b/arch/arm/dts/am335x-src-nand.dtsi
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&am33xx_pinmux {
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x000 0x20    /* gpmc_ad0, INPUT_PULLDOWN | MODE0 */
+			0x004 0x20    /* gpmc_ad1, INPUT_PULLDOWN | MODE0 */
+			0x008 0x20    /* gpmc_ad2, INPUT_PULLDOWN | MODE0 */
+			0x00c 0x20    /* gpmc_ad3, INPUT_PULLDOWN | MODE0 */
+			0x010 0x20    /* gpmc_ad4, INPUT_PULLDOWN | MODE0 */
+			0x014 0x20    /* gpmc_ad5, INPUT_PULLDOWN | MODE0 */
+			0x018 0x20    /* gpmc_ad6, INPUT_PULLDOWN | MODE0 */
+			0x01c 0x20    /* gpmc_ad7, INPUT_PULLDOWN | MODE0 */
+			0x070 0x30    /* gpmc_wait0, INPUT_PULLUP | MODE0 */
+			0x07c 0x10    /* gpmc_csn0, OUTPUT_PULLUP | MODE0 */
+			0x090 0x10    /* gpmc_advn_ale, OUTPUT_PULLUP | MODE0 */
+			0x094 0x10    /* gpmc_oen_ren, OUTPUT_PULLUP | MODE0 */
+			0x098 0x10    /* gpmc_wen, OUTPUT_PULLUP | MODE0 */
+			0x09c 0x10    /* gpmc_ben0_cle.gpmc_be0n_cle, OUTPUT_PULLUP | MODE0 */
+		>;
+	};
+};
+
+/include/ "am335x-pfc-gpmc.dtsi"
diff --git a/arch/arm/dts/am35xx-pfc-750_820x.dts b/arch/arm/dts/am35xx-pfc-750_820x.dts
new file mode 100644
index 0000000..55f843e
--- /dev/null
+++ b/arch/arm/dts/am35xx-pfc-750_820x.dts
@@ -0,0 +1,525 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2014 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Heinrich Toews <heinrich.toews@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include <arm/am3517.dtsi>
+#include "bootchooser.dtsi"
+
+/ {
+	model = "PFC-750-820x";
+	compatible =  "wago,am3505-pfc-750_820x", "wago,am35xx-pfc", "ti,am3517", "ti,omap3";
+	board-variant = "pfc200";
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+        vmmc_fixed: vmmc {
+                compatible = "regulator-fixed";
+                regulator-name = "vmmc_fixed";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+        };
+
+	aliases {
+		serial1 = &uart1;
+		serial2 = &uart2;
+		serial3 = &uart3;
+                gpio0 = &gpio1;
+                gpio1 = &gpio2;
+                gpio2 = &gpio3;
+                gpio3 = &gpio4;
+                gpio4 = &gpio5;
+                gpio5 = &gpio6;
+		mmc0 = &mmc1;
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+	};
+
+	chosen {
+		stdout-path = &uart3;
+
+		environment_sd: environment-sd {
+			compatible = "barebox,environment";
+			device-path = &mmc1, "partname:0";
+			file-path = "barebox.env";
+			status = "okay";
+		};
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&bas_pins>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpio3 26 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpio3 27 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpio3 28 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpio3 29 GPIO_ACTIVE_HIGH>; };
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_pins>;
+
+		u1-green@0 {
+			label = "u1-green";
+			gpios = <&gpio3 22 0>;
+			linux,default-trigger = "none";
+		};
+
+		u1-red@1 {
+			label = "u1-red";
+			gpios = <&gpio3 23 0>;
+			linux,default-trigger = "none";
+		};
+
+		u2-green@2 {
+			label = "u2-green";
+			gpios = <&gpio3 18 0>;
+			linux,default-trigger = "none";
+		};
+
+		u2-red@3 {
+			label = "u2-red";
+			gpios = <&gpio3 19 0>;
+			linux,default-trigger = "none";
+		};
+
+		u3-green@4 {
+			label = "u3-green";
+			gpios = <&gpio3 14 0>;
+			linux,default-trigger = "none";
+		};
+
+		u3-red@5 {
+			label = "u3-red";
+			gpios = <&gpio3 15 0>;
+			linux,default-trigger = "none";
+		};
+
+		u4-green@6 {
+			label = "u4-green";
+			gpios = <&gpio3 10 0>;
+			linux,default-trigger = "none";
+		};
+
+		u4-red@7 {
+			label = "u4-red";
+			gpios = <&gpio3 11 0>;
+			linux,default-trigger = "none";
+		};
+
+		dia-green@8 {
+			label = "dia-green";
+			gpios = <&gpio3 6 0>;
+			linux,default-trigger = "none";
+		};
+
+		dia-red@9 {
+			label = "dia-red";
+			gpios = <&gpio3 7 0>;
+			linux,default-trigger = "none";
+		};
+
+		bf-green@10 {
+			label = "bf-green";
+			gpios = <&gpio3 2 0>;
+			linux,default-trigger = "none";
+		};
+
+		bf-red@11 {
+			label = "bf-red";
+			gpios = <&gpio3 3 0>;
+			linux,default-trigger = "none";
+		};
+
+		sys-green@12 {
+			label = "sys-green";
+			gpios = <&gpio3 4 0>;
+			linux,default-trigger = "none";
+		};
+
+		sys-red@13 {
+			label = "sys-red";
+			gpios = <&gpio3 5 0>;
+			linux,default-trigger = "none";
+		};
+
+
+		run-green@14 {
+			label = "run-green";
+			gpios = <&gpio3 8 0>;
+			linux,default-trigger = "none";
+		};
+
+		run-red@15 {
+			label = "run-red";
+			gpios = <&gpio3 9 0>;
+			linux,default-trigger = "none";
+		};
+
+		io-green@16 {
+			label = "io-green";
+			gpios = <&gpio3 12 0>;
+			linux,default-trigger = "none";
+		};
+
+		io-red@17 {
+			label = "io-red";
+			gpios = <&gpio3 13 0>;
+			linux,default-trigger = "none";
+		};
+
+		ms-green@18 {
+			label = "ms-green";
+			gpios = <&gpio3 16 0>;
+			linux,default-trigger = "none";
+		};
+
+		ms-red@19 {
+			label = "ms-red";
+			gpios = <&gpio3 17 0>;
+			linux,default-trigger = "none";
+		};
+
+		ns-green@20 {
+			label = "ns-green";
+			gpios = <&gpio3 20 0>;
+			linux,default-trigger = "none";
+		};
+
+		ns-red@21 {
+			label = "ns-red";
+			gpios = <&gpio3 21 0>;
+			linux,default-trigger = "none";
+		};
+
+
+		can-green@22 {
+			label = "can-green";
+			gpios = <&gpio3 24 0>;
+			linux,default-trigger = "none";
+		};
+
+		can-red@23 {
+			label = "can-red";
+			gpios = <&gpio3 25 0>;
+			linux,default-trigger = "none";
+		};
+	};
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3_pins>;
+        status = "disabled";
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins>;
+	clock-frequency = <400000>;
+        status = "okay";
+
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+		wp-gpios = <&gpio6 10 GPIO_ACTIVE_LOW>;
+	};
+};
+
+#include "eepromparts.dtsi"
+
+&mmc1 {
+        status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&vmmc_fixed>;
+	bus-width = <4>;
+	cd-gpios = <&gpio4 20 GPIO_ACTIVE_LOW>; /* GPIO 116 */
+	cd-inverted;
+};
+
+&omap3_pmx_core {
+	pinctrl-names = "default";
+	pinctrl-0 = <&emac_pins
+		     &switch_reset
+		     &uart3_pins>;
+
+	uart3_pins: pinmux_uart3_pins {
+		pinctrl-single,pins = <
+			0x16e (PIN_INPUT | PIN_OFF_WAKEUPENABLE | MUX_MODE0) /* uart3_rx_irrx.uart3_rx_irrx */
+			0x170 (PIN_OUTPUT | MUX_MODE0) /* uart3_tx_irtx.uart3_tx_irtx */
+		>;
+	};
+
+	i2c2_pins: pinmux_i2c2_pins {
+		pinctrl-single,pins = <
+			0x18e (PIN_INPUT_PULLUP | MUX_MODE0)   /* i2c2_scl.i2c2_scl */
+			0x190 (PIN_INPUT_PULLUP | MUX_MODE0)   /* i2c2_sda.i2c2_sda */
+		        0x196 (PIN_OUTPUT | MUX_MODE4)  /* hdq_sio.gpio_170: wd_nwp */
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x114 (PIN_INPUT_PULLUP | MUX_MODE0)	/* sdmmc1_clk.sdmmc1_clk */
+			0x116 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_cmd.sdmmc1_cmd */
+			0x118 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat0.sdmmc1_dat0 */
+			0x11a (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat1.sdmmc1_dat1 */
+			0x11c (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat2.sdmmc1_dat2 */
+			0x11e (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat3.sdmmc1_dat3 */
+		>;
+	};
+
+	emac_pins: pinmux_emac_pins {
+		pinctrl-single,pins = <
+		        0x1ce (PIN_INPUT | MUX_MODE0)           /* rmii_mdio_data.rmii_mdio_data */
+		        0x1d0 (PIN_OUTPUT_PULLUP | MUX_MODE0)   /* rmii_mdio_clk.rmii_mdio_clk   */
+		        0x1d2 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd0.rmii_rxd0           */
+		        0x1d4 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd1.rmii_rxd1           */
+		        0x1d6 (PIN_INPUT | MUX_MODE0)           /* rmii_crs_dv.rmii_crs_dv       */
+		        0x1d8 (PIN_INPUT | MUX_MODE0)           /* rmii_rxer.rmii_rxer           */
+		        0x1da (PIN_OUTPUT_PULLUP | MUX_MODE0)   /* rmii_txd0.rmii_txd0           */
+		        0x1dc (PIN_INPUT | MUX_MODE0)           /* rmii_txd1.rmii_txd1           */
+		        0x1de (PIN_INPUT | MUX_MODE0)           /* rmii_txen.rmii_txen           */
+		        0x1e0 (PIN_INPUT | MUX_MODE0)           /* rmii_50mhz_clk.rmii_50mhz_clk */
+		        0x134 (PIN_OUTPUT | MUX_MODE4)          /* mmc2_dat4.gpio_136: nrst_switch */
+		>;
+	};
+
+	led_pins: pinmux_led_pins {
+		pinctrl-single,pins = <
+		        0x0a4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_pclk.gpio_66: led_1_1_green */
+		        0x0a6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_hsync.gpio_67: led_1_1_red */
+		        0x0a8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_vsync.gpio_68: led_1_2_green */
+		        0x0aa (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_acbias.gpio_69: led_1_2_red */
+
+		        0x0ac (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data0.gpio_70: led_2_1_green */
+		        0x0ae (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data1.gpio_71: led_2_1_red */
+		        0x0b0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data2.gpio_72: led_2_2_green */
+		        0x0b2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data3.gpio_73: led_2_2_red */
+
+		        0x0b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data4.gpio_74: led_3_1_green */
+		        0x0b6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data5.gpio_75: led_3_1_red */
+		        0x0b8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data6.gpio_76: led_3_2_green */
+		        0x0ba (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data7.gpio_77: led_3_2_red */
+
+		        0x0bc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data8.gpio_78: led_4_1_green */
+		        0x0be (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data9.gpio_79: led_4_1_red */
+		        0x0c0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data10.gpio_80: led_4_2_green */
+		        0x0c2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data11.gpio_81: led_4_2_red */
+
+		        0x0c4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data12.gpio_82: led_5_1_green */
+		        0x0c6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data13.gpio_83: led_5_1_red */
+		        0x0c8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data14.gpio_84: led_5_2_green */
+		        0x0ca (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data15.gpio_85: led_5_2_red */
+
+		        0x0cc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data16.gpio_86: led_6_1_green */
+		        0x0ce (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data17.gpio_87: led_6_1_red */
+		        0x0d0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data18.gpio_88: led_6_2_green */
+		        0x0d2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data19.gpio_89: led_6_2_red */
+		>;
+	};
+
+	bas_pins: pinmux_bas_pins {
+		pinctrl-single,pins = <
+			0x0d4 (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data20.gpio_90: bas_run */
+			0x0d6 (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data21.gpio_91: bas_stop */
+			0x0d8 (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data22.gpio_92: bas_reset */
+			0x0da (PIN_INPUT_PULLUP | MUX_MODE4)	/* dss_data23.gpio_93: reset_all */
+		>;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x04a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a1.gpmc_a1 */
+			0x04c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a2.gpmc_a2 */
+			0x04e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a3.gpmc_a3 */
+			0x050 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a4.gpmc_a4 */
+			0x052 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a5.gpmc_a5 */
+			0x054 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a6.gpmc_a6 */
+			0x056 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a7.gpmc_a7 */
+			0x058 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a8.gpmc_a8 */
+			0x05a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a9.gpmc_a9 */
+			0x05c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a10.gpmc_a10 */
+
+			0x06c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d8.gpmc_d8 */
+			0x06e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d9.gpmc_d9 */
+			0x070 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d10.gpmc_d10 */
+			0x072 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d11.gpmc_d11 */
+			0x074 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d12.gpmc_d12 */
+			0x076 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d13.gpmc_d13 */
+			0x078 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d14.gpmc_d14 */
+			0x07a (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d15.gpmc_d15 */
+
+			0x07e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs0.gpmc_ncs0 */
+			0x080 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs1.gpmc_ncs1 */
+			0x082 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs2.gpmc_ncs2 */
+			0x08c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_clk.gpmc_clk */
+
+			0x090 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nadv_ale.gpmc_nadv_ale */
+			0x092 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_noe.gpmc_noe */
+			0x094 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nwe */
+
+			0x096 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe0_cle.gpmc_nbe0_cle */
+
+			0x098 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe1.gpmc_nbe1 */
+			0x09a (PIN_INPUT | MUX_MODE0)	/* gpmc_nwp.gpmc_nwp */
+
+			0x09c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */
+			0x09e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait1.gpmc_wait1 */
+			0x0a0 (PIN_INPUT_PULLUP | MUX_MODE4)	/* gpmc_wait2.gpio_64 */
+			0x0a2 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait3.gpmc_wait3 */
+		>;
+	};
+
+	switch_reset: switch_reset {
+		pinctrl-single,pins = <
+			0x134 (PIN_OUTPUT | MUX_MODE4) /* mmc2_dat4.gpio5_8 (gpio_136) nrst_switch */
+		>;
+	};
+};
+
+&gpmc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+	num-cs = <2>;
+	num-waitpins = <1>;
+	ranges = <
+		0 0 0x08000000 0x01000000	/* CS0: NAND */
+	>;
+
+	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8-hw-det-sw";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <36>;
+		gpmc,cs-wr-off-ns = <36>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <24>;
+		gpmc,adv-wr-off-ns = <36>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <30>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <48>;
+		gpmc,access-ns = <54>;
+		gpmc,rd-cycle-ns = <72>;
+		gpmc,wr-cycle-ns = <72>;
+
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+
+		gpmc,wr-access-ns = <30>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+#include "am3xxx-pfc-nandparts.dtsi"
+
+&gpio5 {
+	switch_reset {
+		gpio-hog;
+		gpios = <8 GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "switch-reset";
+	};
+};
+
+/* That's uggly, we have to explicitly disable
+   everything we don't need here */
+
+&uart1 {
+      status = "disabled";
+};
+
+&uart2 {
+      status = "disabled";
+};
+
+&i2c1 {
+      status = "disabled";
+};
+
+&i2c3 {
+      status = "disabled";
+};
+
+&mmc2 {
+      status = "disabled";
+};
+
+&mmc3 {
+      status = "disabled";
+};
+
+&gpio1 {
+      status = "disabled";
+};
+
+&gpio2 {
+      status = "disabled";
+};
+
+&davinci_emac {
+	status = "okay";
+	/* In order to use the driver as it is,
+	 * we need to update ressource entries in order
+	 * to meet the expected arrangement */
+	reg = <0x5c010000 0x800 /* EMAC_BASE_ADDR */
+	       0x5c000000 0xff  /* EMAC_WRAPPER_BASE_ADDR */
+	       0x5c030000 0xff  /* EMAC_MDIO_BASE_ADDR */
+	       0x5c020000 0x2000>; /* EMAC_WRAPPER_RAM_ADDR */
+
+	/* set 'force-link' here
+	 * if problems occur */
+	interface-rmii;
+
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
diff --git a/arch/arm/dts/am3xxx-pfc-emmcparts.dtsi b/arch/arm/dts/am3xxx-pfc-emmcparts.dtsi
new file mode 100644
index 0000000..f8aa4c3
--- /dev/null
+++ b/arch/arm/dts/am3xxx-pfc-emmcparts.dtsi
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oliver Schildan <oliver.schildan@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&mmc2{
+        #size-cells = <1>;
+        #address-cells = <1>;
+
+	partition@0 {
+		label = "mlo0";
+		reg = <0x0 0x20000>;
+	};
+
+	partition@20000 {
+		label = "mlo1";
+		reg = <0x20000 0x20000>;
+	};
+
+	partition@40000 {
+		label = "mlo2";
+		reg = <0x40000 0x20000>;
+	};
+
+	partition@60000 {
+		label = "mlo3";
+		reg = <0x60000 0x20000>;
+	};
+
+	partition@80000 {
+		label = "boot0";
+		reg = <0x80000 0x80000>;
+	};
+
+	partition@100000 {
+		label = "boot1";
+		reg = <0x100000 0x80000>;
+	};
+
+	partition@180000 {
+		label = "boot2";
+		reg = <0x180000 0x80000>;
+	};
+
+	partition@200000 {
+		label = "boot3";
+		reg = <0x200000 0x80000>;
+	};
+};
diff --git a/arch/arm/dts/am3xxx-pfc-nandparts.dtsi b/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
new file mode 100644
index 0000000..00a2ade
--- /dev/null
+++ b/arch/arm/dts/am3xxx-pfc-nandparts.dtsi
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * Copyright (C) 2015 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&nand {
+        /* 4 x 128k MLOs */
+	partition@0 {
+		label = "mlo0";
+		reg = <0x0 0x20000>;
+	};
+
+	partition@1 {
+		label = "mlo1";
+		reg = <0x20000 0x20000>;
+	};
+
+	partition@2 {
+		label = "mlo2";
+		reg = <0x40000 0x20000>;
+	};
+
+	partition@3 {
+		label = "mlo3";
+		reg = <0x60000 0x20000>;
+	};
+
+        /* 16 x 128k: 4 x stage2 (4x128k) */
+	partition@4 {
+		label = "boot0";
+		reg = <0x80000 0x80000>;
+	};
+
+	partition@5 {
+		label = "boot1";
+		reg = <0x100000 0x80000>;
+	};
+
+	partition@6 {
+		label = "boot2";
+		reg = <0x180000 0x80000>;
+	};
+
+	partition@7 {
+		label = "boot3";
+		reg = <0x200000 0x80000>;
+	};
+
+	partition@8 {
+		label = "ubidata";
+		/*
+		 * Size 0x0 extends partition to
+		 * end of nand flash.
+		 */
+		reg = <0x280000 0x0>;
+	};
+};
diff --git a/arch/arm/dts/bootchooser.dtsi b/arch/arm/dts/bootchooser.dtsi
new file mode 100644
index 0000000..1456648
--- /dev/null
+++ b/arch/arm/dts/bootchooser.dtsi
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	bootstate: bootstate {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		magic = <0x3f45620e>;
+		compatible = "barebox,state";
+		backend-type = "raw";
+		backend = <&backend_state_eeprom>;
+		backend-storage-type = "direct";
+		backend-stridesize = <0x40>;
+
+		rootfs.1 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@0 {
+				reg = <0x0 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@4 {
+				reg = <0x4 0x4>;
+				type = "uint32";
+				default = <20>;
+			};
+		};
+
+		rootfs.2 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			remaining_attempts@8 {
+				reg = <0x8 0x4>;
+				type = "uint32";
+				default = <3>;
+			};
+
+			priority@10 {
+				reg = <0xC 0x4>;
+				type = "uint32";
+				default = <10>;
+			};
+		};
+
+		last_chosen@10 {
+			reg = <0x10 0x4>;
+			type = "uint32";
+		};
+
+		device_setup@14 {
+			reg = <0x14 0x4>;
+			type = "uint32";
+		};
+	};
+};
diff --git a/arch/arm/dts/cyclone5-pfc-750_8230.dts b/arch/arm/dts/cyclone5-pfc-750_8230.dts
new file mode 100644
index 0000000..c7abc96
--- /dev/null
+++ b/arch/arm/dts/cyclone5-pfc-750_8230.dts
@@ -0,0 +1,88 @@
+/*
+ *  Copyright (C) 2012 Altera Corporation <www.altera.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <arm/socfpga_cyclone5.dtsi>
+#include "socfpga.dtsi"
+
+/ {
+	model = "PFC200-8230";
+	compatible = "altr,socdk", "altr,socfpga-cyclone5", "altr,socfpga";
+	board-variant = "pfc200-8230";
+
+	chosen {
+		compatible = "barebox,environment";
+		device-path = &mmc, "partname:1";
+		file-path = "barebox.env";
+		bootargs = "earlyprintk";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@0 {
+		name = "memory";
+		device_type = "memory";
+		reg = <0x0 0x40000000>; /* 1GB */
+	};
+
+	aliases {
+		/* this allow the ethaddr barebox environmnet variable contents
+		 * to be added to the gmac1 device tree blob.
+		 */
+		ethernet0 = &gmac1;
+	};
+
+	regulator_3_3v: 3-3-v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+
+	rxd0-skew-ps = <0>;
+	rxd1-skew-ps = <0>;
+	rxd2-skew-ps = <0>;
+	rxd3-skew-ps = <0>;
+	txen-skew-ps = <0>;
+	txc-skew-ps = <2600>;
+	rxdv-skew-ps = <0>;
+	rxc-skew-ps = <2000>;
+};
+
+&gpio0 {
+	status = "okay";
+};
+
+&gpio1 {
+	status = "okay";
+};
+
+&gpio2 {
+	status = "okay";
+};
+
+&mmc0 {
+	cd-gpios = <&portb 18 0>;
+	vmmc-supply = <&regulator_3_3v>;
+	vqmmc-supply = <&regulator_3_3v>;
+	status = "okay";
+};
+
+
diff --git a/arch/arm/dts/eepromparts.dtsi b/arch/arm/dts/eepromparts.dtsi
new file mode 100644
index 0000000..c7718e1
--- /dev/null
+++ b/arch/arm/dts/eepromparts.dtsi
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&eeprom {
+	partitions: partitions {
+		compatible = "fixed-partitions";
+		#size-cells = <1>;
+		#address-cells = <1>;
+
+		backend_state_eeprom: state@2100 {
+			reg = <0x2100 0x120>;
+			label = "state-eeprom";
+		};
+
+		boot_mode_id: boot-mode-id@0 {
+			reg = <0x0 0x1>;
+			label = "boot_mode_id";
+		};
+
+		boot_mode_id_ext: boot-mode-id_ext@0102 {
+			reg = <0x0102 0x1>;
+			label = "boot_mode_id_ext";
+		};
+
+		blidx: blidx@1F7 {
+			reg = <0x1F7 0x1>;
+			label = "blidx";
+		};
+
+		devconf: devconf@1FE {
+			reg = <0x1FE 0x2>;
+			label = "devconf";
+		};
+
+		ethaddr1: ethaddr1@200 {
+			reg = <0x200 0x6>;
+			label = "ethaddr1";
+		};
+
+		ethaddr2: ethaddr2@206 {
+			label = "ethaddr2";
+			reg = <0x206 0x6>;
+		};
+	};
+};
diff --git a/arch/arm/dts/imx6q-vtpctp-762-4xxx.dts b/arch/arm/dts/imx6q-vtpctp-762-4xxx.dts
new file mode 100644
index 0000000..593f55e
--- /dev/null
+++ b/arch/arm/dts/imx6q-vtpctp-762-4xxx.dts
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Ralf Gliese <ralf.gliese@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+#include <arm/imx6q.dtsi>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include "bootchooser.dtsi"
+
+/ {
+	model = "VTPCTP-762-4xxx";
+	compatible = "wago,imx6q-vtpctp-762_4xxx", "wago,imx6q-vtpctp", "fsl,imx6q";
+	board-variant = "vtpctp";
+	switch-reset-gpio = <&gpio4 9 GPIO_ACTIVE_LOW>;
+
+	aliases {
+		bootstate = &bootstate;
+		xsection = &xsection;
+		bootmatrix = &bootmatrix;
+		ethernet1 = &fec;
+	};
+
+	chosen {
+		stdout-path = &uart1;
+
+		environment-sd {
+			compatible = "barebox,environment";
+			device-path = &usdhc1, "partname:0";
+			file-path = "barebox.env";
+			status = "disabled";
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x10000000 0x80000000>; /* 2GB */
+	};
+
+	xsection: xsection {
+		compatible = "xsection";
+		status = "okay";
+
+		boot_mode_id = <&boot_mode_id>;
+		boot_mode_id_ext = <&boot_mode_id_ext>;
+		devconf = <&devconf>;
+		ethaddr1 = <&ethaddr1>;
+		ethaddr2 = <&ethaddr2>;
+		blidx = <&blidx>;
+	};
+
+	bootmatrix: bootmatrix {
+		compatible = "bootmatrix";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_bas>;
+
+		/* seconds for factory reset or setup-fw startup */
+		rst-timeout-secs = <7>;
+
+		run:   run   { gpios = <&gpio2 12 GPIO_ACTIVE_LOW>; };
+		stop:  stop  { gpios = <&gpio2 13 GPIO_ACTIVE_LOW>; };
+		reset: reset { gpios = <&gpio2 15 GPIO_ACTIVE_LOW>; };
+		rst:   rst   { gpios = <&gpio4 7  GPIO_ACTIVE_LOW>; };
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_2p5v: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "2P5V";
+			regulator-min-microvolt = <2500000>;
+			regulator-max-microvolt = <2500000>;
+			regulator-always-on;
+		};
+
+		reg_3p3v: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "3P3V";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			gpio = <&gpio4 15 GPIO_ACTIVE_LOW>;
+			enable-active-high;
+		};
+
+		reg_lvds_backlight_3v3: regulator@3 {
+			compatible = "regulator-fixed";
+			regulator-name = "lvds-3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+		};
+	};
+
+	front_rgb_leds {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rgb_led>;
+		compatible = "gpio-leds";
+
+		sys-red {
+			label = "sys-red";
+			gpios = <&gpio2 4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		sys-green {
+			label = "sys-green";
+			gpios = <&gpio2 5 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+
+		sys-blue {
+			label = "sys-blue";
+			gpios = <&gpio2 6 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "none";
+		};
+	};
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio3 19 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "okay";
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	phy-reset-gpios = <&gpio4 9 GPIO_ACTIVE_LOW>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@0 {
+			compatible = "micrel,ksz8863";
+			device_type = "ethernet-phy";
+			reg = <0>;
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	eeprom: eeprom@54 {
+		status = "okay";
+		compatible = "atmel,24c512";
+		pagesize = <128>;
+		reg = <0x54>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	imx6q-nitrogen6x {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				/* SGTL5000 sys_mclk */
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x030b0
+			>;
+		};
+
+		pinctrl_ecspi1: ecspi1grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO	0x100b1
+				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI	0x100b1
+				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK	0x100b1
+				MX6QDL_PAD_EIM_D19__GPIO3_IO19  0x000b1	/* CS */
+			>;
+		};
+
+		pinctrl_enet: enetgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO	    0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC	    0x1b0b0
+				MX6QDL_PAD_ENET_RXD0__ENET_RX_DATA0 0x1b0b0
+				MX6QDL_PAD_ENET_RXD1__ENET_RX_DATA1 0x1b0b0
+				MX6QDL_PAD_ENET_CRS_DV__ENET_RX_EN  0x1b0b0
+				MX6QDL_PAD_ENET_TXD0__ENET_TX_DATA0 0x1b0b0
+				MX6QDL_PAD_ENET_TXD1__ENET_TX_DATA1 0x1b0b0
+				MX6QDL_PAD_ENET_TX_EN__ENET_TX_EN   0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK    0x1b0b0
+				/* Phy reset */
+				MX6QDL_PAD_KEY_ROW1__GPIO4_IO09	    0x1B0B0
+				//MX6QDL_PAD_KEY_ROW1__GPIO4_IO09   0x80000000
+				/* phy irq */
+				MX6QDL_PAD_GPIO_6__ENET_IRQ         0x000b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL	  0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA 	  0x4001b8b1
+				/* EEPROM WP GPIO169 */
+				MX6QDL_PAD_NANDF_WP_B__GPIO6_IO09 0x1b0b0
+			>;
+		};
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA 0x1b0b1
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA 0x1b0b1
+			>;
+		};
+
+		pinctrl_uart2: uart2grp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
+				MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				/* OTG_ID */
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID  0x1b0b1
+				/* OTG_OC */
+				MX6QDL_PAD_KEY_COL4__USB_OTG_OC	   0x1b0b1
+				/* OTG_PWR */
+				//MX6QDL_PAD_KEY_ROW4__USB_OTG_PWR 0x130b0
+				/* OTG_PWR */
+				MX6QDL_PAD_KEY_ROW4__GPIO4_IO15	   0x130b0
+			>;
+		};
+
+		pinctrl_usdhc1: usdhc1grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_CMD__SD1_CMD	0x17059
+				MX6QDL_PAD_SD1_CLK__SD1_CLK	0x10059
+				MX6QDL_PAD_SD1_DAT0__SD1_DATA0	0x17059
+				MX6QDL_PAD_SD1_DAT1__SD1_DATA1	0x17059
+				MX6QDL_PAD_SD1_DAT2__SD1_DATA2	0x17059
+				MX6QDL_PAD_SD1_DAT3__SD1_DATA3	0x17059
+				/* CD */
+				MX6QDL_PAD_GPIO_1__SD1_CD_B	0x1b0b0
+				/* SD-CARD.EN */
+				MX6QDL_PAD_SD4_CMD__GPIO7_IO09	0x1b0b0
+			>;
+		};
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD	0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK	0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0	0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1	0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2	0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3	0x17059
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4	0x17059
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5	0x17059
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6	0x17059
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7	0x17059
+			>;
+		};
+
+		pinctrl_rgb_led: rgb_led {
+			fsl,pins = <
+				/* LED-RD-ON */
+				MX6QDL_PAD_NANDF_D4__GPIO2_IO04	0x1b0b0
+				/* LED-GN-ON */
+				MX6QDL_PAD_NANDF_D5__GPIO2_IO05	0x1b0b0
+				/* LED-BL-ON */
+				MX6QDL_PAD_NANDF_D6__GPIO2_IO06	0x1b0b0
+			>;
+		};
+
+		pinctrl_bas: basgrp {
+			fsl,pins = <
+				/* BAS-NRUN */
+				MX6QDL_PAD_SD4_DAT4__GPIO2_IO12	0x1b0b0
+				/* BAS-NSTOP */
+				MX6QDL_PAD_SD4_DAT5__GPIO2_IO13	0x1b0b0
+				/* BAS-NRESET */
+				MX6QDL_PAD_SD4_DAT7__GPIO2_IO15	0x1b0b0
+				/* RESET-ALL */
+				MX6QDL_PAD_KEY_ROW0__GPIO4_IO07	0x1b0b0
+			>;
+		};
+
+	};
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	status = "disabled";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "disabled";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	phy_type = "utmi";
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	cd-gpios = <&gpio7 9 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	non-removable;
+	bus-width = <8>;
+	status = "okay";
+};
+
+#include "eepromparts.dtsi"
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index 1d6b4e1..975d2a2 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -401,6 +401,12 @@ config MACH_ADVANTECH_ROM_742X
 	select ARCH_IMX6
 	select ARM_USE_COMPRESSED_DTB
 
+config MACH_WAGO_VTPCTP_MX6
+	bool "Wago VTPCTP Panels"
+	select ARCH_IMX6
+	help
+	  Support for Wago i.MX6 Quad-Core Touch-Panels
+
 config MACH_WARP7
 	bool "NXP i.MX7: element 14 WaRP7 Board"
 	select ARCH_IMX7
diff --git a/arch/arm/mach-omap/Kconfig b/arch/arm/mach-omap/Kconfig
index c451cf0..5cc3eed 100644
--- a/arch/arm/mach-omap/Kconfig
+++ b/arch/arm/mach-omap/Kconfig
@@ -184,6 +184,60 @@ config MACH_VSCOM_BALTOS
 	help
 	  Say Y here if you are using a am335x based VScom Baltos devices
 
+config MACH_WAGO_PFC_AM335X
+	bool "Wago AM335X PFCs"
+	select ARCH_AM33XX
+	select WAGO_PFC_XLOAD
+	help
+	  Say Y here if you are using a am335x based Wago PFC
+
+if MACH_WAGO_PFC_AM335X
+
+config MACH_WAGO_PFC_AM335X_750_810x
+	bool "PFC-750-810x"
+	help
+	  Say Y here if you are using a am335x based Wago PFC-750-810x
+
+config MACH_WAGO_PFC_AM335X_750_8208
+	bool "PFC-750-8208"
+	help
+	  Say Y here if you are using a am335x based Wago PFC-750-8208
+
+config MACH_WAGO_PFC_AM335X_750_821x
+	bool "PFC-750-821x"
+	help
+	  Say Y here if you are using a am335x based Wago PFC-750-821x
+
+config MACH_WAGO_PFC_AM335X_2850_311x
+	bool "SRC-2850-311x"
+	help
+	  Say Y here if you are using a am335x based Wago SRC-2850-311x
+
+config MACH_WAGO_PFC_AM335X_768_330x
+	bool "PAC-768-330x"
+	help
+	  Say Y here if you are using a am335x based Wago PAC-768-330x
+
+config MACH_WAGO_AM335X_RMCB
+	bool "RMCB"
+	help
+	  Say Y here if you are using a am335x based rocket master evaluation
+	  board.
+
+endif
+
+endif
+
+if MACH_WAGO_PFC_AM335X || MACH_WAGO_PFC_AM35XX
+
+config WAGO_PFC_XLOAD
+	bool
+	select PARAMETER if !MACH_WAGO_PFC_AM35XX
+	prompt "Activate Wago PFC specific xload startup"
+	help
+	  Say Y to enable pfc specific xload startup code. This simultaneously
+	  disables the upstream xload startup code.
+
 endif
 
 source arch/arm/boards/phytec-som-am335x/Kconfig
@@ -204,6 +258,16 @@ config MACH_OMAP3EVM
 	help
 	  Say Y here if you are using OMAP3EVM
 
+config MACH_WAGO_PFC_AM35XX
+        bool "Wago PFC200 Fieldbus Controller"
+        select ARCH_OMAP3
+        select HAVE_DEFAULT_ENVIRONMENT_NEW
+        select HAVE_PBL_MULTI_IMAGES
+        select HAVE_CONFIGURABLE_MEMORY_LAYOUT
+	select WAGO_PFC_XLOAD
+        help
+          Say Y here if you are using a the AM3505 based PFC200 controller
+
 config MACH_PANDA
 	bool "Texas Instrument's Panda Board"
 	select ARCH_OMAP4
diff --git a/arch/arm/mach-omap/Makefile b/arch/arm/mach-omap/Makefile
index a84e94e..d06fb43 100644
--- a/arch/arm/mach-omap/Makefile
+++ b/arch/arm/mach-omap/Makefile
@@ -28,7 +28,11 @@ obj-$(CONFIG_ARCH_AM33XX) += am33xx_scrm.o
 obj-$(CONFIG_ARCH_OMAP3) += omap3_clock.o
 pbl-$(CONFIG_ARCH_OMAP3) += omap3_clock.o
 obj-$(CONFIG_OMAP_GPMC) += gpmc.o devices-gpmc-nand.o
+ifdef CONFIG_WAGO_PFC_XLOAD
+obj-$(CONFIG_SHELL_NONE) += xload-pfc.o
+else
 obj-$(CONFIG_SHELL_NONE) += xload.o
+endif
 obj-$(CONFIG_MFD_TWL6030) += omap4_twl6030_mmc.o
 obj-$(CONFIG_OMAP4_USBBOOT) += omap4_rom_usb.o
 obj-$(CONFIG_OMAP3_USBBOOT) += omap3_xload_usb.o
diff --git a/arch/arm/mach-omap/am33xx_bbu_emmc.c b/arch/arm/mach-omap/am33xx_bbu_emmc.c
index 1fd7222..ff66ba5 100644
--- a/arch/arm/mach-omap/am33xx_bbu_emmc.c
+++ b/arch/arm/mach-omap/am33xx_bbu_emmc.c
@@ -22,6 +22,12 @@
 #define PART_TABLE_SIZE		66
 #define PART_TABLE_OFFSET	0x1BE
 
+struct emmc_bbu_handler {
+	struct bbu_handler bbu_handler;
+	char **devicefile;
+	int num_devicefiles;
+};
+
 static int emmc_mlo_handler(struct bbu_handler *handler, struct bbu_data *data)
 {
 	int ret = 0;
@@ -76,6 +82,66 @@ error:
 	return (ret > 0) ? 0 : ret;
 }
 
+static int emmc_write_to_device(const char *devicefile, const void *image,
+								size_t size)
+{
+	int ret, fd;
+
+	fd = open(devicefile, O_RDWR);
+	if (fd < 0) {
+		pr_err("could not open %s: %s\n", devicefile,
+							errno_str());
+		return fd;
+	}
+
+	ret = write(fd, image, size);
+	if (ret < 0)
+		pr_err("could not write to fd %s: %s\n", devicefile,
+								errno_str());
+
+	close(fd);
+
+	return ret;
+
+}
+
+static int emmc_update_handler(struct bbu_handler *handler,
+							struct bbu_data *data)
+{
+	int ret = 0;
+	int i = 0;
+	const void *image = data->image;
+	size_t size = data->len;
+	struct emmc_bbu_handler *nh;
+
+	nh = container_of(handler, struct emmc_bbu_handler, bbu_handler);
+
+	if (file_detect_type(image, size) != filetype_arm_barebox) {
+		pr_err("%s is not a valid ch-image\n", data->imagefile);
+		return -EINVAL;
+	}
+
+	ret = bbu_confirm(data);
+	if (ret != 0)
+		goto out;
+
+	/* check if the devicefile has been overwritten */
+	if (strcmp(data->devicefile, nh->devicefile[0]) != 0) {
+		ret = emmc_write_to_device(data->devicefile, image, size);
+		if (!ret)
+			goto out;
+	} else {
+		for (i = 0; i < nh->num_devicefiles; i++) {
+			ret = emmc_write_to_device(nh->devicefile[i], image, size);
+			if (!ret)
+				goto out;
+		}
+	}
+
+out:
+	return ret;
+}
+
 int am33xx_bbu_emmc_mlo_register_handler(const char *name, char *devicefile)
 {
 	struct bbu_handler *handler;
@@ -93,3 +159,23 @@ int am33xx_bbu_emmc_mlo_register_handler(const char *name, char *devicefile)
 
 	return ret;
 }
+
+int am33xx_bbu_emmc_register_handler(const char *name, char **devicefile,
+							int num_devicefiles)
+{
+	struct emmc_bbu_handler *handler;
+	int ret;
+
+	handler = xzalloc(sizeof(*handler));
+	handler->devicefile = devicefile;
+	handler->num_devicefiles = num_devicefiles;
+	handler->bbu_handler.devicefile = devicefile[0];
+	handler->bbu_handler.handler = emmc_update_handler;
+	handler->bbu_handler.name = name;
+
+	ret = bbu_register_handler(&handler->bbu_handler);
+	if (ret)
+		free(handler);
+
+	return ret;
+}
diff --git a/arch/arm/mach-omap/am33xx_generic.c b/arch/arm/mach-omap/am33xx_generic.c
index 5137462..0580621 100644
--- a/arch/arm/mach-omap/am33xx_generic.c
+++ b/arch/arm/mach-omap/am33xx_generic.c
@@ -28,6 +28,7 @@
 #include <mach/am33xx-generic.h>
 #include <mach/gpmc.h>
 #include <reset_source.h>
+#include <mach/syslib.h>
 
 static void __noreturn am33xx_restart_soc(struct restart_handler *rst)
 {
@@ -189,11 +190,10 @@ static void am33xx_detect_reset_reason(void)
 	}
 }
 
-int am33xx_register_ethaddr(int eth_id, int mac_id)
+int am33xx_get_internal_mac_id(uint8_t *mac_addr, int mac_id)
 {
 	void __iomem *mac_id_low = (void *)AM33XX_MAC_ID0_LO + mac_id * 8;
 	void __iomem *mac_id_high = (void *)AM33XX_MAC_ID0_HI + mac_id * 8;
-	uint8_t mac_addr[6];
 	uint32_t mac_hi, mac_lo;
 
 	mac_lo = readl(mac_id_low);
@@ -205,6 +205,15 @@ int am33xx_register_ethaddr(int eth_id, int mac_id)
 	mac_addr[4] = mac_lo & 0xff;
 	mac_addr[5] = (mac_lo & 0xff00) >> 8;
 
+	return 0;
+}
+
+int am33xx_register_ethaddr(int eth_id, int mac_id)
+{
+	uint8_t mac_addr[6];
+
+	am33xx_get_internal_mac_id(mac_addr, mac_id);
+
 	if (is_valid_ether_addr(mac_addr)) {
 		eth_register_ethaddr(eth_id, mac_addr);
 		return 0;
@@ -456,6 +465,7 @@ void am335x_sdram_init(int ioctrl, const struct am33xx_cmd_control *cmd_ctrl,
 	am33xx_enable_ddr_clocks();
 
 	am33xx_config_vtp();
+	sdelay(50000);
 
 	am33xx_ddr_phydata_cmd_macro(cmd_ctrl);
 	am33xx_config_ddr_data(ddr_data, 0);
diff --git a/arch/arm/mach-omap/include/mach/am33xx-generic.h b/arch/arm/mach-omap/include/mach/am33xx-generic.h
index 7e64e74..0d2afb8 100644
--- a/arch/arm/mach-omap/include/mach/am33xx-generic.h
+++ b/arch/arm/mach-omap/include/mach/am33xx-generic.h
@@ -6,6 +6,7 @@
 #include <mach/am33xx-silicon.h>
 
 int am33xx_register_ethaddr(int eth_id, int mac_id);
+int am33xx_get_internal_mac_id(uint8_t *mac_addr, int mac_id);
 
 u32 am33xx_get_cpu_rev(void);
 
diff --git a/arch/arm/mach-omap/include/mach/am3xxx-pfc-generic.h b/arch/arm/mach-omap/include/mach/am3xxx-pfc-generic.h
new file mode 100644
index 0000000..3d671d5
--- /dev/null
+++ b/arch/arm/mach-omap/include/mach/am3xxx-pfc-generic.h
@@ -0,0 +1,42 @@
+#ifndef __MACH_AM3XXX_PFC_GENERIC_H
+#define __MACH_AM3XXX_PFC_GENERIC_H
+
+struct omap_barebox_boot_parts {
+	char **boot_nandslots;
+	char **boot_emmcslots;
+	int num_boot_nandslots;
+	int num_boot_emmcslots;
+};
+
+enum omap_board_boot_device {
+	HAS_SD = 0,
+	HAS_NAND,
+	HAS_EMMC,
+	HAS_USB,
+	NUM_BOOT_DEVICES,
+};
+
+struct omap_board_info {
+	char *board_variant;
+	bool production_mode;
+	bool disable_sd_boot;
+	DECLARE_BITMAP(boot_devices, NUM_BOOT_DEVICES);
+};
+
+#ifdef CONFIG_SHELL_NONE
+int omap_set_barebox_boot_parts(struct omap_barebox_boot_parts *parts);
+int omap_set_board_info(struct omap_board_info *board_info);
+#else
+static inline int
+omap_set_barebox_boot_parts(struct omap_barebox_boot_parts *parts)
+{
+	return 0;
+}
+
+static inline int omap_set_board_info(struct omap_board_info *board_info)
+{
+	return 0;
+}
+#endif
+
+#endif /* __MACH_AM3XXX_PFC_GENERIC_H */
diff --git a/arch/arm/mach-omap/include/mach/bbu.h b/arch/arm/mach-omap/include/mach/bbu.h
index c8b0a55..4255e87 100644
--- a/arch/arm/mach-omap/include/mach/bbu.h
+++ b/arch/arm/mach-omap/include/mach/bbu.h
@@ -41,7 +41,8 @@ static inline int am33xx_bbu_nand_slots_register_handler(const char *name,
 
 #ifdef CONFIG_BAREBOX_UPDATE_AM33XX_EMMC
 int am33xx_bbu_emmc_mlo_register_handler(const char *name, char *devicefile);
-int am33xx_bbu_emmc_register_handler(const char *name, char *devicefile);
+int am33xx_bbu_emmc_register_handler(const char *name, char **devicefile,
+							int num_devicefiles);
 #else
 static inline int am33xx_bbu_emmc_mlo_register_handler(const char *name,
 							char *devicefile)
@@ -50,7 +51,8 @@ static inline int am33xx_bbu_emmc_mlo_register_handler(const char *name,
 }
 
 static inline int am33xx_bbu_emmc_register_handler(const char *name,
-							char *devicefile)
+							char **devicefile,
+							int num_devicefiles)
 {
 	return 0;
 }
diff --git a/arch/arm/mach-omap/include/mach/emif4.h b/arch/arm/mach-omap/include/mach/emif4.h
new file mode 100644
index 0000000..61c33de
--- /dev/null
+++ b/arch/arm/mach-omap/include/mach/emif4.h
@@ -0,0 +1,79 @@
+/*
+ * Auther:
+ *       Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Copyright (C) 2010
+ * Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _EMIF_H_
+#define _EMIF_H_
+
+/*
+ * Configuration values
+ */
+#define EMIF4_TIM1_T_RP		(0x3 << 25)
+#define EMIF4_TIM1_T_RCD	(0x3 << 21)
+#define EMIF4_TIM1_T_WR		(0x3 << 17)
+#define EMIF4_TIM1_T_RAS	(0x7 << 12) /* 8->7 */
+#define EMIF4_TIM1_T_RC		(0xA << 6)
+#define EMIF4_TIM1_T_RRD	(0x2 << 3)
+#define EMIF4_TIM1_T_WTR	(0x2)
+
+#define EMIF4_TIM2_T_XP		(0x2 << 28)
+#define EMIF4_TIM2_T_ODT	(0x0 << 25) /* 2? */
+#define EMIF4_TIM2_T_XSNR	(0x1C << 16)
+#define EMIF4_TIM2_T_XSRD	(0xC8 << 6)
+#define EMIF4_TIM2_T_RTP	(0x1 << 3)
+#define EMIF4_TIM2_T_CKE	(0x2)
+
+#define EMIF4_TIM3_T_RFC	(0x15 << 4) /* 25->15 */
+#define EMIF4_TIM3_T_RAS_MAX	(0xf)	    /* 7->f */
+
+#define EMIF4_PWR_IDLE_MODE	(0x2 << 30)
+#define EMIF4_PWR_DPD_DIS	(0x0 << 10)
+#define EMIF4_PWR_DPD_EN	(0x1 << 10)
+#define EMIF4_PWR_LP_MODE	(0x0 << 8)
+#define EMIF4_PWR_PM_TIM	(0x0)
+
+#define EMIF4_INITREF_DIS	(0x0 << 31)
+#define EMIF4_REFRESH_RATE	(0x257) /* 50f->257 */
+
+#define EMIF4_CFG_SDRAM_TYP	(0x2 << 29)
+#define EMIF4_CFG_IBANK_POS	(0x0 << 27)
+#define EMIF4_CFG_DDR_TERM	(0x3 << 24) /* --> 0x3 */
+#define EMIF4_CFG_DDR2_DDQS	(0x1 << 23)
+#define EMIF4_CFG_DDR_DIS_DLL	(0x0 << 20)
+#define EMIF4_CFG_SDR_DRV	(0x0 << 18)
+#define EMIF4_CFG_NARROW_MD	(0x0 << 14)
+#define EMIF4_CFG_CL		(0x5 << 10)
+#define EMIF4_CFG_ROWSIZE	(0x0 << 7) /* --> 0x4: a0..a12 */
+#define EMIF4_CFG_IBANK		(0x3 << 4)
+#define EMIF4_CFG_EBANK		(0x0 << 3)
+#define EMIF4_CFG_PGSIZE	(0x2)      /* 10 columns */
+
+/*
+ * EMIF4 PHY Control 1 register configuration
+ */
+#define EMIF4_DDR1_EXT_STRB_EN	(0x1 << 7)
+#define EMIF4_DDR1_EXT_STRB_DIS	(0x0 << 7)
+#define EMIF4_DDR1_PWRDN_DIS	(0x0 << 6)
+#define EMIF4_DDR1_PWRDN_EN	(0x1 << 6)
+#define EMIF4_DDR1_READ_LAT	(0x6 << 0)
+
+#endif /* endif _EMIF_H_ */
diff --git a/arch/arm/mach-omap/include/mach/gpmc_nand.h b/arch/arm/mach-omap/include/mach/gpmc_nand.h
index c9730a9..0c0b893 100644
--- a/arch/arm/mach-omap/include/mach/gpmc_nand.h
+++ b/arch/arm/mach-omap/include/mach/gpmc_nand.h
@@ -34,6 +34,8 @@ enum gpmc_ecc_mode {
 	OMAP_ECC_HAMMING_CODE_HW_ROMCODE,
 	OMAP_ECC_BCH8_CODE_HW,
 	OMAP_ECC_BCH8_CODE_HW_ROMCODE,
+	OMAP_ECC_BCH8_CODE_HW_DETECTION_SW,
+	OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY,
 };
 
 /** omap nand platform data structure */
diff --git a/arch/arm/mach-omap/include/mach/omap3-clock.h b/arch/arm/mach-omap/include/mach/omap3-clock.h
index 7c52da7..849964a 100644
--- a/arch/arm/mach-omap/include/mach/omap3-clock.h
+++ b/arch/arm/mach-omap/include/mach/omap3-clock.h
@@ -64,6 +64,8 @@
 #define CM_CLKSEL_CAM		0X0f40
 #define CM_FCLKEN_PER		0X1000
 #define CM_ICLKEN_PER		0X1010
+#define CM_IDLEST_PER		0X1020
+#define CM_AUTOIDLE_PER		0X1030
 #define CM_CLKSEL_PER		0X1040
 #define CM_CLKSEL1_EMU		0X1140
 #define CM_FCLKEN_USBH		0x1400
diff --git a/arch/arm/mach-omap/include/mach/omap3-mux.h b/arch/arm/mach-omap/include/mach/omap3-mux.h
index d6fb9c3..a679e25 100644
--- a/arch/arm/mach-omap/include/mach/omap3-mux.h
+++ b/arch/arm/mach-omap/include/mach/omap3-mux.h
@@ -413,4 +413,51 @@
 #define CONTROL_PADCONF_SDRC_CKE0	0x0262
 #define CONTROL_PADCONF_SDRC_CKE1	0x0264
 
-#endif /* _ASM_ARCH_OMAP3_MUX_H_ */
+/* AM3517 specific mux configuration */
+#define CONTROL_PADCONF_SYS_NRESWARM	0x0A08
+/* CCDC */
+#define CONTROL_PADCONF_CCDC_PCLK	0x01E4
+#define CONTROL_PADCONF_CCDC_FIELD	0x01E6
+#define CONTROL_PADCONF_CCDC_HD		0x01E8
+#define CONTROL_PADCONF_CCDC_VD		0x01EA
+#define CONTROL_PADCONF_CCDC_WEN	0x01EC
+#define CONTROL_PADCONF_CCDC_DATA0	0x01EE
+#define CONTROL_PADCONF_CCDC_DATA1	0x01F0
+#define CONTROL_PADCONF_CCDC_DATA2	0x01F2
+#define CONTROL_PADCONF_CCDC_DATA3	0x01F4
+#define CONTROL_PADCONF_CCDC_DATA4	0x01F6
+#define CONTROL_PADCONF_CCDC_DATA5	0x01F8
+#define CONTROL_PADCONF_CCDC_DATA6	0x01FA
+#define CONTROL_PADCONF_CCDC_DATA7	0x01FC
+/* RMII */
+#define CONTROL_PADCONF_RMII_MDIO_DATA	0x01FE
+#define CONTROL_PADCONF_RMII_MDIO_CLK	0x0200
+#define CONTROL_PADCONF_RMII_RXD0	0x0202
+#define CONTROL_PADCONF_RMII_RXD1	0x0204
+#define CONTROL_PADCONF_RMII_CRS_DV	0x0206
+#define CONTROL_PADCONF_RMII_RXER	0x0208
+#define CONTROL_PADCONF_RMII_TXD0	0x020A
+#define CONTROL_PADCONF_RMII_TXD1	0x020C
+#define CONTROL_PADCONF_RMII_TXEN	0x020E
+#define CONTROL_PADCONF_RMII_50MHZ_CLK	0x0210
+#define CONTROL_PADCONF_USB0_DRVBUS	0x0212
+/* CAN */
+#define CONTROL_PADCONF_HECC1_TXD	0x0214
+#define CONTROL_PADCONF_HECC1_RXD	0x0216
+
+#define CONTROL_PADCONF_SYS_BOOT7	0x0218
+#define CONTROL_PADCONF_SDRC_DQS0N	0x021A
+#define CONTROL_PADCONF_SDRC_DQS1N	0x021C
+#define CONTROL_PADCONF_SDRC_DQS2N	0x021E
+#define CONTROL_PADCONF_SDRC_DQS3N	0x0220
+#define CONTROL_PADCONF_STRBEN_DLY0	0x0222
+#define CONTROL_PADCONF_STRBEN_DLY1	0x0224
+#define CONTROL_PADCONF_SYS_BOOT8	0x0226
+
+/* AM/DM37xx specific */
+#define CONTROL_PADCONF_GPIO127		0x0A54
+#define CONTROL_PADCONF_GPIO126		0x0A56
+#define CONTROL_PADCONF_GPIO128		0x0A58
+#define CONTROL_PADCONF_GPIO129		0x0A5A
+
+#endif
diff --git a/arch/arm/mach-omap/include/mach/omap_hsmmc.h b/arch/arm/mach-omap/include/mach/omap_hsmmc.h
index 19942df..308d181 100644
--- a/arch/arm/mach-omap/include/mach/omap_hsmmc.h
+++ b/arch/arm/mach-omap/include/mach/omap_hsmmc.h
@@ -22,5 +22,7 @@
 struct omap_hsmmc_platform_data {
 	unsigned f_max;         /* host interface upper limit */
 	char *devname;		/* The mci device name, optional */
+	int cd_gpio;
+	bool cd_inverted;
 };
 #endif /* __ASM_OMAP_HSMMC_H */
diff --git a/arch/arm/mach-omap/omap3_clock.c b/arch/arm/mach-omap/omap3_clock.c
index 6700f56..cb007bc 100644
--- a/arch/arm/mach-omap/omap3_clock.c
+++ b/arch/arm/mach-omap/omap3_clock.c
@@ -3,7 +3,7 @@
  * @brief OMAP DPLL and various clock configuration
  *
  * @ref prcm_init This is the second level clock init for PRCM as defined in
- * clocks.h -- called from SRAM, or Flash (using temp SRAM stack).
+ * clocks.h -- -                       init_iva_dpll_34x(cpu_rev, clk_index); called from SRAM, or Flash (using temp SRAM stack).
  *
  * During reconfiguring the clocks while in SDRAM/Flash, we can have invalid
  * clock configuration to which ARM instruction/data fetch ops can fail.
@@ -39,6 +39,7 @@
 #include <mach/timers.h>
 #include <mach/sys_info.h>
 #include <mach/syslib.h>
+#include <generated/mach-types.h>
 
 #define S32K_CR			(OMAP3_32KTIMER_BASE + 0x10)
 
@@ -198,7 +199,9 @@ static void init_core_dpll_34x(u32 cpu_rev, u32 clk_sel)
 		sr32(OMAP3_CM_REG(CLKSEL1_PLL), 6, 1, 0);
 
 		sr32(OMAP3_CM_REG(CLKSEL_CORE), 8, 4, CORE_SSI_DIV);
+#ifdef CONFIG_USB /* Solve L3 App IRQ In-Band-Error Issue */
 		sr32(OMAP3_CM_REG(CLKSEL_CORE), 4, 2, CORE_FUSB_DIV);
+#endif
 		sr32(OMAP3_CM_REG(CLKSEL_CORE), 2, 2, CORE_L4_DIV);
 		sr32(OMAP3_CM_REG(CLKSEL_CORE), 0, 2, CORE_L3_DIV);
 		sr32(OMAP3_CM_REG(CLKSEL_GFX), 0, 3, GFX_DIV_34X);
@@ -290,7 +293,7 @@ static struct dpll_param mpu_dpll_param_34x_es1[] = {
 
 static struct dpll_param mpu_dpll_param_34x_es2[] = {
 	{.m = 0x0FA, .n = 0x05, .fsel = 0x07, .m2 = 0x01, }, /* 12   MHz */
-	{.m = 0x1F4, .n = 0x0C, .fsel = 0x03, .m2 = 0x01, }, /* 13   MHz */
+	{.m = 0x258, .n = 0x0C, .fsel = 0x03, .m2 = 0x01, }, /* 13   MHz */
 	{.m = 0x271, .n = 0x17, .fsel = 0x03, .m2 = 0x01, }, /* 19.2 MHz */
 	{.m = 0x0FA, .n = 0x0C, .fsel = 0x07, .m2 = 0x01, }, /* 26   MHz */
 	{.m = 0x271, .n = 0x2F, .fsel = 0x03, .m2 = 0x01, }, /* 38.4 MHz */
@@ -329,6 +332,7 @@ static void init_mpu_dpll_34x(u32 cpu_rev, u32 clk_sel)
 	sr32(OMAP3_CM_REG(CLKEN_PLL_MPU), 4, 4, dp->fsel);
 }
 
+#ifndef CONFIG_MACH_WAGO_PFC_AM35XX
 static struct dpll_param iva_dpll_param_34x_es1[] = {
 	{ .m = 	0x07D, .n = 0x05, .fsel = 0x07,	.m2 = 0x01, }, /* 12   MHz */
 	{ .m = 	0x0FA, .n = 0x0C, .fsel = 0x03,	.m2 = 0x01, }, /* 13   MHz */
@@ -382,6 +386,7 @@ static void init_iva_dpll_34x(u32 cpu_rev, u32 clk_sel)
 	sr32(OMAP3_CM_REG(CLKEN_PLL_IVA2), 0, 3, PLL_LOCK);
 	wait_on_value((0x1 << 0), 1, OMAP3_CM_REG(IDLEST_PLL_IVA2), LDELAY);
 }
+#endif
 
 /* FIXME: All values correspond to 26MHz only */
 static struct dpll_param core_dpll_param_36x[] = {
@@ -621,7 +626,9 @@ void prcm_init(void)
 		init_core_dpll_34x(cpu_rev, clk_index);
 		init_per_dpll_34x(cpu_rev, clk_index);
 		init_mpu_dpll_34x(cpu_rev, clk_index);
+#ifndef CONFIG_MACH_WAGO_PFC_AM35XX
 		init_iva_dpll_34x(cpu_rev, clk_index);
+#endif
 	}
 	else if (cpu_type == CPU_3630) {
 		init_core_dpll_36x(cpu_rev, clk_index);
@@ -676,7 +683,11 @@ static void per_clocks_enable(void)
 #define ICK_CAM_ON	0x00000001
 #define FCK_PER_ON	0x0003ffff
 #define ICK_PER_ON	0x0003ffff
+#ifndef CONFIG_MACH_WAGO_PFC_AM35XX
 	sr32(OMAP3_CM_REG(FCLKEN_IVA2), 0, 32, FCK_IVA2_ON);
+	sr32(OMAP3_CM_REG(FCLKEN_CAM), 0, 32, FCK_CAM_ON);
+	sr32(OMAP3_CM_REG(ICLKEN_CAM), 0, 32, ICK_CAM_ON);
+#endif
 	sr32(OMAP3_CM_REG(FCLKEN1_CORE), 0, 32, FCK_CORE1_ON);
 	sr32(OMAP3_CM_REG(ICLKEN1_CORE), 0, 32, ICK_CORE1_ON);
 	sr32(OMAP3_CM_REG(ICLKEN2_CORE), 0, 32, ICK_CORE2_ON);
@@ -684,8 +695,6 @@ static void per_clocks_enable(void)
 	sr32(OMAP3_CM_REG(ICLKEN_WKUP), 0, 32, ICK_WKUP_ON);
 	sr32(OMAP3_CM_REG(FCLKEN_DSS), 0, 32, FCK_DSS_ON);
 	sr32(OMAP3_CM_REG(ICLKEN_DSS), 0, 32, ICK_DSS_ON);
-	sr32(OMAP3_CM_REG(FCLKEN_CAM), 0, 32, FCK_CAM_ON);
-	sr32(OMAP3_CM_REG(ICLKEN_CAM), 0, 32, ICK_CAM_ON);
 	sr32(OMAP3_CM_REG(FCLKEN_PER), 0, 32, FCK_PER_ON);
 	sr32(OMAP3_CM_REG(ICLKEN_PER), 0, 32, ICK_PER_ON);
 
diff --git a/arch/arm/mach-omap/omap3_generic.c b/arch/arm/mach-omap/omap3_generic.c
index 5327bad..8e45f18 100644
--- a/arch/arm/mach-omap/omap3_generic.c
+++ b/arch/arm/mach-omap/omap3_generic.c
@@ -43,6 +43,7 @@
 #include <mach/wdt.h>
 #include <mach/sys_info.h>
 #include <mach/syslib.h>
+#include <reset_source.h>
 
 /**
  * @brief Reset the CPU
@@ -486,12 +487,60 @@ static int omap3_bootsource(void)
 	return 0;
 }
 
+#define OMAP3_PRM_RSTST_OFF 0x8
+#define OMAP3_REG_PRM_RSTST (OMAP3_PRM_REG(RSTCTRL) + OMAP3_PRM_RSTST_OFF)
+
+#define OMAP3_ICECRUSHER_RST	(1<<10)
+#define OMAP3_ICEPICK_RST	(1<<9)
+#define OMAP3_EXTERNAL_WARM_RST	(1<<6)
+#define OMAP3_SECURE_WD_RST	(1<<5)
+#define OMAP3_MPU_WD_RST	(1<<4)
+#define OMAP3_SECURITY_VIOL_RST	(1<<3)
+#define OMAP3_GLOBAL_SW_RST	(1<<1)
+#define OMAP3_GLOBAL_COLD_RST	(1<<0)
+
+static void omap3_detect_reset_reason(void)
+{
+	uint32_t val = 0;
+
+	val = readl(OMAP3_REG_PRM_RSTST);
+	/* clear OMAP3_PRM_RSTST - must be cleared by software */
+	writel(val, OMAP3_REG_PRM_RSTST);
+
+	switch (val) {
+	case (OMAP3_ICECRUSHER_RST):
+	case (OMAP3_ICEPICK_RST):
+		reset_source_set(RESET_JTAG);
+		break;
+	case (OMAP3_EXTERNAL_WARM_RST):
+		reset_source_set(RESET_EXT);
+		break;
+	case (OMAP3_SECURE_WD_RST):
+	case (OMAP3_MPU_WD_RST):
+	case (OMAP3_SECURITY_VIOL_RST):
+		reset_source_set(RESET_WDG);
+		break;
+	case (OMAP3_GLOBAL_SW_RST):
+		reset_source_set(RESET_RST);
+		break;
+	case (OMAP3_GLOBAL_COLD_RST):
+		reset_source_set(RESET_POR);
+		break;
+	default:
+		reset_source_set(RESET_UKWN);
+		break;
+	}
+}
+
 int omap3_init(void)
 {
 	omap_gpmc_base = (void *)OMAP3_GPMC_BASE;
 
 	restart_handler_register_fn(omap3_restart_soc);
 
+	if (IS_ENABLED(CONFIG_RESET_SOURCE))
+		omap3_detect_reset_reason();
+
 	return omap3_bootsource();
 }
 
diff --git a/arch/arm/mach-omap/xload-pfc.c b/arch/arm/mach-omap/xload-pfc.c
new file mode 100644
index 0000000..c5e698b
--- /dev/null
+++ b/arch/arm/mach-omap/xload-pfc.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Peter Galka <peter.galka@wago.com>
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * Xload handler tries to boot from mmc first, if card inserted and barebox
+ * image available. Otherwise it boots from internal memory (nand or emmc).
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <init.h>
+#include <mci.h>
+#include <bootsource.h>
+#include <mach/generic.h>
+#include <mach/am3xxx-pfc-generic.h>
+#include <filetype.h>
+#include <fcntl.h>
+#include <sys/mount.h>
+#include <libfile.h>
+#include <fs.h>
+#include <usb/gadget-multi.h>
+
+#define UIMAGE_HEADER_SIZE 64
+
+struct omap_barebox_boot_parts *barebox_boot_parts;
+struct omap_board_info *board;
+
+static int pfc_mmc_inserted(void)
+{
+	struct mci *mci;
+
+	mci = mci_get_device_by_name("mmc0");
+	if (!mci)
+		return 0;
+
+	if (mci->host->card_present)
+		return (mci->host->card_present(mci->host) <= 0) ? 0 : 1;
+
+	return 0;
+}
+
+static unsigned int pfc_xload_get_image_size(void *head)
+{
+	unsigned int ret = 0;
+	unsigned int *psize = head + ARM_HEAD_SIZE_OFFSET;
+
+	if (is_barebox_arm_head(head))
+		ret = *psize;
+	pr_info("Detected barebox image size %u\n", ret);
+
+	return ret;
+}
+
+static void *pfc_xload_read_image_head(const char *name)
+{
+	void *header = xmalloc(ARM_HEAD_SIZE);
+	struct cdev *cdev;
+	int ret;
+
+	cdev = cdev_open(name, O_RDONLY);
+	if (!cdev) {
+		pr_info("%s: failed to open %s\n", name, __func__);
+		return NULL;
+	}
+
+	ret = cdev_read(cdev, header, ARM_HEAD_SIZE, 0, 0);
+	cdev_close(cdev);
+
+	if (ret != ARM_HEAD_SIZE) {
+		pr_info("%s: failed to read from %s\n", __func__, name);
+		return NULL;
+	}
+
+	return header;
+}
+
+static void *pfc_xload_read_cdev_barebox(const char *partition)
+{
+	int ret;
+	int size;
+	void *to, *header;
+	struct cdev *cdev;
+
+	header = pfc_xload_read_image_head(partition);
+	if (header == NULL)
+		return NULL;
+
+	size = pfc_xload_get_image_size(header);
+	if (!size) {
+		pr_info("%s: failed to get image size\n", __func__);
+		return NULL;
+	}
+
+	to = xmalloc(size);
+
+	cdev = cdev_open(partition, O_RDONLY);
+	if (!cdev) {
+		pr_info("%s: failed to open partition\n", __func__);
+		return NULL;
+	}
+
+	ret = cdev_read(cdev, to, size, 0, 0);
+	if (ret != size) {
+		pr_info("%s: failed to read from partition\n", __func__);
+		return NULL;
+	}
+
+	return to;
+}
+
+static void *pfc_xload_boot_parts(char **parts, int num_parts)
+{
+	int i = 0;
+	void *to;
+
+	for (i=0; i < num_parts; i++) {
+		to = pfc_xload_read_cdev_barebox(parts[i]);
+		if (to) {
+			pr_info("%s: found image on raw partition %s\n",
+							 __func__, parts[i]);
+			break;
+		}
+	}
+
+	return to;
+}
+
+static void *pfc_xload_boot_mmc(char *bootfile)
+{
+	int ret;
+	int len;
+	const char *rootpath;
+	const char *diskdev;
+	char *partname;
+	char *bootfile_path;
+	struct cdev *cdev;
+	void *buf = NULL;
+
+	diskdev = omap_get_bootmmc_devname();
+	if (!diskdev)
+		goto out;
+
+	ret = device_detect_by_name(diskdev);
+	if (ret)
+		goto out;
+
+	partname = basprintf("%s.0", diskdev);
+	cdev = cdev_by_name(partname);
+	if (!cdev) {
+		pr_err("failed to get device %s\n", partname);
+		goto free;
+	}
+
+	rootpath = cdev_mount_default(cdev, NULL);
+	if (IS_ERR(rootpath)) {
+		pr_err("failed to mount %s: (%ld)\n", cdev->name,
+							PTR_ERR(rootpath));
+		goto free;
+	}
+
+	bootfile_path = basprintf("%s/%s", rootpath, bootfile);
+	buf = read_file(bootfile_path, &len);
+	free(bootfile_path);
+
+free:
+	free(partname);
+out:
+	return buf;
+}
+
+static int pfc_xload_activate_fastboot(void)
+{
+	struct f_multi_opts *opts;
+	struct file_list *files;
+	int ret;
+
+	opts = xzalloc(sizeof(*opts));
+	opts->release = usb_multi_opts_release;
+
+	files = file_list_parse("/barebox(barebox)c");
+	if (IS_ERR(files)) {
+		ret = PTR_ERR(files);
+		goto err;
+	}
+
+	opts->fastboot_opts.files = files;
+
+	ret = usb_multi_register(opts);
+	if (ret)
+		goto err;
+
+	return ret;
+err:
+	usb_multi_opts_release(opts);
+	return ret;
+}
+
+static __noreturn int pfc_xload(void)
+{
+	char *bootfile = NULL;
+	char *bootfile_legacy = "barebox.img";
+	void *barebox = NULL;
+	enum bootsource bootsource;
+	int ret;
+
+	if (!board) {
+		pr_err("%s: no board information set\n", __func__);
+		goto out;
+	}
+
+	printf("%s: rom-code boots us from: ", __func__);
+
+	bootsource = bootsource_get();
+	switch (bootsource) {
+		case BOOTSOURCE_MMC:
+			printf("mmc%d\n", bootsource_get_instance());
+			break;
+		case BOOTSOURCE_NAND:
+			printf("nand%d\n", bootsource_get_instance());
+			break;
+		default:
+			printf("unknown\n");
+	}
+
+	if (!board->board_variant)
+		bootfile = basprintf("barebox.bin");
+	else
+		bootfile = basprintf("barebox.bin.%s", board->board_variant);
+
+	printf("%s: board-variant: %s\n", __func__, board->board_variant ?
+							board->board_variant :
+							"none");
+
+	if (test_bit(HAS_SD, board->boot_devices) && pfc_mmc_inserted() &&
+						!board->disable_sd_boot) {
+		omap_set_bootmmc_devname("mmc0");
+		printf("%s: boot %s vfat from %s\n", __func__, bootfile,
+						omap_get_bootmmc_devname());
+
+		barebox = pfc_xload_boot_mmc(bootfile);
+		if (!barebox) {
+			printf("%s: file %s not found on %s\n", __func__,
+					bootfile, omap_get_bootmmc_devname());
+
+			/* legacy support for FW < 05 */
+			printf("%s: boot %s vfat from %s\n", __func__,
+						bootfile_legacy,
+						omap_get_bootmmc_devname());
+			barebox = pfc_xload_boot_mmc(bootfile_legacy);
+			if (barebox) {
+				/* skip uimage header */
+				barebox += UIMAGE_HEADER_SIZE;
+			} else {
+				printf("%s: file %s not found on %s\n",
+						__func__, bootfile_legacy,
+						omap_get_bootmmc_devname());
+			}
+		}
+	}
+
+	if (test_bit(HAS_EMMC, board->boot_devices) && !barebox) {
+		omap_set_bootmmc_devname("mmc1");
+
+		if (barebox_boot_parts) {
+			printf("%s: boot raw from %s\n", __func__,
+						omap_get_bootmmc_devname());
+
+			barebox = pfc_xload_boot_parts(
+					barebox_boot_parts->boot_emmcslots,
+					barebox_boot_parts->num_boot_emmcslots);
+		}
+
+		if (!barebox) {
+			printf("%s: no raw image file found on %s\n", __func__,
+						omap_get_bootmmc_devname());
+
+			printf("%s: boot %s vfat from %s\n", __func__,
+						bootfile,
+						omap_get_bootmmc_devname());
+			barebox = pfc_xload_boot_mmc(bootfile);
+		}
+	}
+
+	if (test_bit(HAS_NAND, board->boot_devices) && !barebox) {
+		if (barebox_boot_parts) {
+			printf("%s: boot raw from nand\n", __func__);
+			barebox = pfc_xload_boot_parts(
+					barebox_boot_parts->boot_nandslots,
+					barebox_boot_parts->num_boot_nandslots);
+		}
+	}
+
+	if (IS_ENABLED(CONFIG_USB_GADGET_FASTBOOT) &&
+				!barebox && board->production_mode &&
+				test_bit(HAS_USB, board->boot_devices)) {
+		ret = pfc_xload_activate_fastboot();
+		if (ret)
+			printf("%s: could not activate fastboot\n", __func__);
+		else
+			printf("%s: waiting for fastboot commands...\n",
+								__func__);
+		goto out_poll;
+	}
+
+	if (barebox)
+		omap_start_barebox(barebox);
+out:
+	pr_err("%s: could not boot from any boot device\n", __func__);
+out_poll:
+	free(bootfile);
+	while (1) { poller_call(); }
+}
+
+int omap_set_barebox_boot_parts(struct omap_barebox_boot_parts *parts)
+{
+	barebox_boot_parts = parts;
+
+	return 0;
+}
+
+int omap_set_board_info(struct omap_board_info *board_info)
+{
+	board = board_info;
+
+	return 0;
+}
+
+static int pfc_set_xload(void)
+{
+	barebox_main = pfc_xload;
+
+	return 0;
+}
+late_initcall(pfc_set_xload);
diff --git a/arch/arm/mach-socfpga/Kconfig b/arch/arm/mach-socfpga/Kconfig
index 65097b6..ed628ae 100644
--- a/arch/arm/mach-socfpga/Kconfig
+++ b/arch/arm/mach-socfpga/Kconfig
@@ -15,6 +15,18 @@ config ARCH_TEXT_BASE
 
 comment "Altera SoCFPGA System-on-Chip"
 
+config	MACH_WAGO_PFC_CYCLONE5
+	bool "Wago PFCXXX (Cyclone-based)"
+	select ARCH_SOCFPGA_CYCLONE5
+	help
+	  Say Y here if you are using a PFC8230 controller
+
+config MACH_WAGO_PFC_AMP
+	bool "AMP: Asymmetric Multiprocessing on"
+	depends on MACH_WAGO_PFC_CYCLONE5
+	help
+	  Say y if you want to use the dual core in AMP style
+
 config ARCH_SOCFPGA_CYCLONE5
 	bool
 	select CPU_V7
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 01bc7aa..e86b91c 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -4723,3 +4723,6 @@ ecv4			MACH_ECV4		ECV4			4768
 webbg3flight		MACH_WEBBG3FLIGHT	WEBBG3FLIGHT		4769
 sbc_phycore_am335x	MACH_SBC_PHYCORE_AM335X	SBC_PHYCORE_AM335X	4770
 tsc			MACH_TSC		TSC			4771
+pfc_am35xx		MACH_PFC_AM35XX		PFC_AM35XX		9000
+pfc_am335x		MACH_PFC_AM335X		PFC_AM335X		9002
+vtpctp_imx6		MACH_VTPCTP_MX6		VTPCTP_MX6		9003
diff --git a/commands/Kconfig b/commands/Kconfig
index 675bd1c..3ed319a 100644
--- a/commands/Kconfig
+++ b/commands/Kconfig
@@ -607,6 +607,14 @@ config CMD_UMOUNT
 
 	  Unmount a filesystem mounted on a specific MOINTPOINT
 
+config CMD_SFDISK
+	bool
+	prompt "sfdisk"
+	help
+	  Usage: sfdisk <script> <device>
+
+	  Format <device> as defined in <script>
+
 # end Partition commands
 endmenu
 
@@ -1802,6 +1810,13 @@ config CMD_LED
 
 	  Without arguments the available LEDs are listed.
 
+config CMD_LED_MODE
+	bool
+	depends on LED
+	prompt "led-mode command"
+	help
+	  Set LED's to mode "static" or "moving"
+
 config CMD_NAND
 	tristate
 	default y
@@ -2138,6 +2153,30 @@ config CMD_SEED
 	help
 	  Seed the pseudo random number generator (PRNG)
 
+config CMD_UART_CONSOLE
+	tristate
+	prompt "uart_console"
+	help
+	  uart_console - activate uart as console
+
+	  Usage: uart_console [-e] [NUM]
+
+	  Options:
+		  -e		enable uart<NUM> as console
+
+config CMD_ETHADDR_MATCH
+	bool
+	prompt "ethaddr_match"
+	help
+	  ethaddr_match - Match a given pattern to configured ethaddr of an
+	  ethernet interface
+
+	  Usage: ethaddr_match [-i intf] [-p pattern]
+
+	  Options:
+		  -i		network interface e.g. eth0
+		  -p		pattern to match against ethaddr
+
 # end Miscellaneous commands
 endmenu
 
diff --git a/commands/Makefile b/commands/Makefile
index eb47963..8053526 100644
--- a/commands/Makefile
+++ b/commands/Makefile
@@ -123,3 +123,7 @@ obj-$(CONFIG_CMD_MMC_EXTCSD)	+= mmc_extcsd.o
 obj-$(CONFIG_CMD_NAND_BITFLIP)	+= nand-bitflip.o
 obj-$(CONFIG_CMD_SEED)		+= seed.o
 obj-$(CONFIG_CMD_IP_ROUTE_GET)  += ip-route-get.o
+obj-$(CONFIG_CMD_UART_CONSOLE)	+= uart_console.o
+obj-$(CONFIG_CMD_ETHADDR_MATCH) += ethaddr_match.o
+obj-$(CONFIG_CMD_LED_MODE) 	+= led_mode.o
+obj-$(CONFIG_CMD_SFDISK)	+= sfdisk.o
diff --git a/commands/ethaddr_match.c b/commands/ethaddr_match.c
new file mode 100644
index 0000000..5afbe5c
--- /dev/null
+++ b/commands/ethaddr_match.c
@@ -0,0 +1,69 @@
+/*
+ * ethaddr_match.c - match a given ethaddr pattern command support
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <command.h>
+#include <getopt.h>
+#include <net.h>
+
+static int do_ethaddr_match(int argc, char *argv[])
+{
+	int opt;
+	struct eth_device *edev;
+	char *ethname = NULL, *pattern = NULL;
+	char ethaddr_str[sizeof("xx:xx:xx:xx:xx:xx")];
+
+	while ((opt = getopt(argc, argv, "i:p:")) > 0) {
+		switch (opt) {
+		case 'i':
+			ethname = optarg;
+			break;
+		case 'p':
+			pattern = optarg;
+			break;
+		}
+	}
+
+	if (!ethname || !pattern)
+		return COMMAND_ERROR_USAGE;
+
+	edev = eth_get_byname(ethname);
+	if (!edev)
+		return -ENODEV;
+
+	ethaddr_to_string(edev->ethaddr, ethaddr_str);
+	if (strstr(ethaddr_str, pattern))
+		return COMMAND_SUCCESS;
+
+	return COMMAND_ERROR;
+}
+
+BAREBOX_CMD_HELP_START(ethaddr_match)
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT("-i <intf>",           "network interface e.g. eth0\n")
+BAREBOX_CMD_HELP_OPT("-p <match_pattern>",  "pattern to match to ethaddr of"
+								" <intf>\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(ethaddr_match)
+	.cmd		= do_ethaddr_match,
+	BAREBOX_CMD_DESC("Match a given pattern to configured ethaddr of an"
+							"ethernet interface")
+	BAREBOX_CMD_OPTS("[-ip]")
+	BAREBOX_CMD_GROUP(CMD_GRP_MISC)
+	BAREBOX_CMD_HELP(cmd_ethaddr_match_help)
+BAREBOX_CMD_END
diff --git a/commands/led_mode.c b/commands/led_mode.c
new file mode 100644
index 0000000..2b94509
--- /dev/null
+++ b/commands/led_mode.c
@@ -0,0 +1,177 @@
+/*
+ * led_mode.c - command to set all registered leds to a specific mode
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <led.h>
+#include <led_mode.h>
+#include <command.h>
+#include <getopt.h>
+#include <errno.h>
+
+#define OVERWRITE_LED "overwrite"
+
+enum led_mode {
+	STATIC = 0,
+	MOVING,
+	INVALID_MODE,
+};
+
+int led_mode_static(char *color, bool state)
+{
+	struct led *led;
+	int i;
+
+	if (strcmp(color, "green") && strcmp(color, "red") &&
+							strcmp(color, "yellow"))
+		return -EINVAL;
+
+	led = led_by_number(0);
+	if (!led)
+		return -ENODEV;
+
+	i = 0;
+	while ((led = led_by_number(i))) {
+		if (strcmp(led->name, OVERWRITE_LED)) {
+			if (strstr(led->name, color))
+				state ? led_set(led, led->max_value) :
+								led_set(led, 0);
+			else if (!strcmp(color, "yellow"))
+				state ? led_set(led, led->max_value) :
+								led_set(led, 0);
+		}
+		i++;
+	}
+
+	return 0;
+}
+
+int led_mode_moving(char *color, unsigned int duration_ms, bool turn_off_anc)
+{
+	struct led *led, *last_led;
+	int i;
+
+	if (strcmp(color, "green") && strcmp(color, "red"))
+		return -EINVAL;
+
+	led = led_by_number(0);
+	if (!led)
+		return -ENODEV;
+
+	/* switch all leds off */
+	led_mode_static("yellow", false);
+
+	i = 0;
+	last_led = NULL;
+	while ((led = led_by_number(i++))) {
+		if (strcmp(led->name, OVERWRITE_LED)) {
+			if (strstr(led->name, color)) {
+				if (last_led && turn_off_anc)
+					led_set(last_led, 0);
+
+				led_set(led, led->max_value);
+				last_led = led;
+				mdelay(duration_ms);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int do_led_mode(int argc, char *argv[])
+{
+	char *color = "none";
+	enum led_mode mode = INVALID_MODE;
+	bool state = false, turn_off_anc = true;
+	unsigned int duration_ms = 30;
+	int opt, ret = 0;
+
+	while ((opt = getopt(argc, argv, "smc:v::d::t")) > 0) {
+		switch (opt) {
+		case 's':
+			mode = STATIC;
+			break;
+		case 'm':
+			mode = MOVING;
+			break;
+		case 'c':
+			color = optarg;
+			break;
+		case 'v':
+			if (!strcmp(optarg, "on"))
+				state = true;
+			else
+				state = false;
+			break;
+		case 'd':
+			duration_ms = simple_strtoul(optarg, NULL, 0);
+			break;
+		case 't':
+			turn_off_anc = false;
+			break;
+
+		default:
+			ret = COMMAND_ERROR_USAGE;
+			goto out;
+		}
+	}
+
+	if (argc == 1) {
+		ret = COMMAND_ERROR_USAGE;
+		goto out;
+	}
+
+	switch (mode) {
+	case STATIC:
+		ret = led_mode_static(color, state);
+		break;
+	case MOVING:
+		ret = led_mode_moving(color, duration_ms, turn_off_anc);
+		break;
+	default:
+		ret = COMMAND_ERROR_USAGE;
+	}
+
+out:
+	return ret;
+}
+
+BAREBOX_CMD_HELP_START(led_mode)
+BAREBOX_CMD_HELP_TEXT("Set all registered leds to a specific mode. Supported ")
+BAREBOX_CMD_HELP_TEXT("modes are: static and moving. In static mode all leds ")
+BAREBOX_CMD_HELP_TEXT("are turned on/off at once.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("In moving mode all leds are flashing with a defined ")
+BAREBOX_CMD_HELP_TEXT("duration.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("LEDs are set by the order they where registered. ")
+BAREBOX_CMD_HELP_TEXT("To see the currently configured order call ")
+BAREBOX_CMD_HELP_TEXT("cmd: <led> without args.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT ("-s -c <green|red|yellow> -v <on|off>", "set all leds to static state")
+BAREBOX_CMD_HELP_OPT ("-m -c <green|red> [ -d <duration_ms> ] [ -t ]", "move the leds with optional duration time. Default 30ms. The optional option -t is used to not tur off the ancestor led")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(led_mode)
+	.cmd		= do_led_mode,
+	BAREBOX_CMD_DESC("set leds to specific mode")
+	BAREBOX_CMD_OPTS("MODE COLOR STATE|DURATION")
+	BAREBOX_CMD_GROUP(CMD_GRP_HWMANIP)
+	BAREBOX_CMD_HELP(cmd_led_mode_help)
+BAREBOX_CMD_END
diff --git a/commands/miitool.c b/commands/miitool.c
index dea4f85..46941ec 100644
--- a/commands/miitool.c
+++ b/commands/miitool.c
@@ -34,6 +34,7 @@
 #include <fs.h>
 #include <fcntl.h>
 #include <getopt.h>
+#include <environment.h>
 #include <linux/stat.h>
 #include <xfuncs.h>
 #include <net.h>
@@ -265,13 +266,139 @@ enum miitool_operations {
 	MIITOOL_NOOP,
 	MIITOOL_SHOW,
 	MIITOOL_REGISTER,
+	MIITOOL_MDIO_READ,
+	MIITOOL_MDIO_WRITE,
 };
 
+static int miitool_parse(const char *str, int *bus, struct mii_bus **mii,
+			 int *addr, int *reg)
+{
+	char *endp;
+
+	if (!str || !*str)
+		return COMMAND_ERROR_USAGE;
+
+	if (!bus || !mii)
+		return COMMAND_ERROR;
+
+	*bus = simple_strtoul(str, &endp, 0);
+
+	*mii = mdiobus_get_bus(*bus);
+	if (!*mii) {
+		printf("Can't find MDIO bus #%d\n", *bus);
+		return COMMAND_ERROR;
+	}
+
+	if (!addr)
+		return COMMAND_SUCCESS;
+
+	if (*endp != ':') {
+		printf("No colon between bus and address\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	endp++;
+	*addr = simple_strtoul(endp, &endp, 0);
+
+	if (*addr >= PHY_MAX_ADDR) {
+		printf("Address out of range (max %d)\n", PHY_MAX_ADDR - 1);
+		return COMMAND_ERROR_USAGE;
+	}
+
+	if (!reg)
+		return COMMAND_SUCCESS;
+
+	if (*endp != ':') {
+		printf("No colon address and register\n");
+		return COMMAND_ERROR_USAGE;
+	}
+
+	endp++;
+	*reg = simple_strtoul(endp, &endp, 0);
+
+	if (*reg > U8_MAX) {
+		printf("Register number out of range (max %d)\n", U8_MAX);
+		return COMMAND_ERROR_USAGE;
+	}
+
+	return 0;
+}
+
+static int miitool_mdio_write(const char *str, const char *variable, int ext)
+{
+	int ret;
+	struct mii_bus *mii;
+	int bus, addr, reg;
+	unsigned long val;
+
+	if (!variable || !*variable)
+		return COMMAND_ERROR_USAGE;
+
+	ret = miitool_parse(str, &bus, &mii, &addr, &reg);
+	if (ret)
+		return ret;
+
+	ret = getenv_ul(variable, &val);
+	if (ret)
+		return COMMAND_ERROR_USAGE;
+
+	if (val > U16_MAX) {
+		printf("Value out auf range (max %d 0x%04X)\n", U16_MAX,
+		       U16_MAX);
+		return COMMAND_ERROR;
+	}
+
+	if (ext) {
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK);
+		mdiobus_write(mii, addr, MII_MMD_DATA, reg);
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK |
+						MII_MMD_CTRL_NOINCR);
+		ret = mdiobus_write(mii, addr, MII_MMD_DATA, val);
+	} else
+		ret = mdiobus_write(mii, addr, reg, val);
+
+	return (!ret) ? ret : COMMAND_ERROR_USAGE;
+}
+
+static int miitool_mdio_read(const char *str, const char *variable, int ext)
+{
+	int ret;
+	struct mii_bus *mii;
+	int bus, addr, reg;
+	char buf[20] = {0};
+
+	if (!variable || !*variable)
+		return COMMAND_ERROR_USAGE;
+
+	ret = miitool_parse(str, &bus, &mii, &addr, &reg);
+	if (ret)
+		return ret;
+
+	if (ext) {
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK);
+		mdiobus_write(mii, addr, MII_MMD_DATA, reg);
+		mdiobus_write(mii, addr, MII_MMD_CTRL, MII_MMD_CTRL_DEVAD_MASK |
+							MII_MMD_CTRL_NOINCR);
+		ret = mdiobus_read(mii, addr, MII_MMD_DATA);
+	} else
+		ret = mdiobus_read(mii, addr, reg);
+
+	if (ret < 0)
+		return ret;
+
+	snprintf(buf, sizeof(buf), "%d", (u16)ret);
+
+	ret = setenv(variable, strim(buf));
+
+	return (!ret) ? ret : COMMAND_ERROR_USAGE;
+}
+
 static int do_miitool(int argc, char *argv[])
 {
 	char *phydevname = NULL;
 	char *regstr = NULL;
-	char *endp;
+	char *variable = NULL;
+	int ext = 0;
 	struct mii_bus *mii;
 	int opt, ret;
 	int verbose = 0;
@@ -279,13 +406,10 @@ static int do_miitool(int argc, char *argv[])
 	enum miitool_operations action = MIITOOL_NOOP;
 	int addr, bus;
 
-	while ((opt = getopt(argc, argv, "vs:r:")) > 0) {
+	while ((opt = getopt(argc, argv, "evs:r:w:x:p:")) > 0) {
 		switch (opt) {
-		case 'a':
-			addr = simple_strtol(optarg, NULL, 0);
-			break;
-		case 'b':
-			bus = simple_strtoul(optarg, NULL, 0);
+		case 'e':
+			ext = 1;
 			break;
 		case 's':
 			action = MIITOOL_SHOW;
@@ -298,42 +422,50 @@ static int do_miitool(int argc, char *argv[])
 		case 'v':
 			verbose++;
 			break;
+		case 'p':
+			variable = optarg;
+			break;
+		case 'w':
+			action = MIITOOL_MDIO_WRITE;
+			regstr = optarg;
+			break;
+		case 'x':
+			action = MIITOOL_MDIO_READ;
+			regstr = optarg;
+			break;
 		default:
 			ret = COMMAND_ERROR_USAGE;
-			goto free_phydevname;
+			goto out;
 		}
 	}
 
 	switch (action) {
 	case MIITOOL_REGISTER:
-		bus = simple_strtoul(regstr, &endp, 0);
-		if (*endp != ':') {
-			printf("No colon between bus and address\n");
-			return COMMAND_ERROR_USAGE;
-		}
-		endp++;
-		addr = simple_strtoul(endp, NULL, 0);
-
-		if (addr >= PHY_MAX_ADDR)
-			printf("Address out of range (max %d)\n", PHY_MAX_ADDR - 1);
-
-		mii = mdiobus_get_bus(bus);
-		if (!mii) {
-			printf("Can't find MDIO bus #%d\n", bus);
-			ret = COMMAND_ERROR;
-			goto free_phydevname;
-		}
+		ret = miitool_parse(regstr, &bus, &mii, &addr, NULL);
+		if (ret)
+			goto out;
 
 		phydev = phy_device_create(mii, addr, -1);
+
 		ret = phy_register_device(phydev);
 		if (ret) {
 			printf("failed to register phy %s: %s\n",
 				dev_name(&phydev->dev), strerror(-ret));
-			goto free_phydevname;
+			goto out;
 		} else {
 			printf("registered phy %s\n", dev_name(&phydev->dev));
 		}
 		break;
+	case MIITOOL_MDIO_WRITE:
+		ret = miitool_mdio_write(regstr, variable, ext);
+		if (ret)
+			goto out;
+		break;
+	case MIITOOL_MDIO_READ:
+		ret = miitool_mdio_read(regstr, variable, ext);
+		if (ret)
+			goto out;
+		break;
 	default:
 	case MIITOOL_SHOW:
 		for_each_mii_bus(mii) {
@@ -347,7 +479,7 @@ static int do_miitool(int argc, char *argv[])
 
 	ret = COMMAND_SUCCESS;
 
-free_phydevname:
+out:
 	free(phydevname);
 	return ret;
 }
@@ -357,17 +489,21 @@ BAREBOX_CMD_HELP_TEXT("This utility checks or sets the status of a network inter
 BAREBOX_CMD_HELP_TEXT("Media Independent Interface (MII) unit as well as allowing to")
 BAREBOX_CMD_HELP_TEXT("register dummy PHY devices for raw MDIO access. Most fast ethernet")
 BAREBOX_CMD_HELP_TEXT("adapters use an MII to autonegotiate link speed and duplex setting.")
+BAREBOX_CMD_HELP_TEXT("Furthermore it allows to acces to MDIO bus directly")
 BAREBOX_CMD_HELP_TEXT("")
 BAREBOX_CMD_HELP_TEXT("Options:")
 BAREBOX_CMD_HELP_OPT("-v", "increase verbosity")
 BAREBOX_CMD_HELP_OPT("-s <devpath/devname>", "show PHY status (not providing PHY prints status of all)")
-BAREBOX_CMD_HELP_OPT("-r <busno>:<adr>", "register a PHY")
+BAREBOX_CMD_HELP_OPT("-r <busno>:<addr>", "register a PHY")
+BAREBOX_CMD_HELP_OPT("-w <busno>:<addr>:<reg> -p variable", "read value from variable and writes it to MDIO bus")
+BAREBOX_CMD_HELP_OPT("-x <busno>:<addr>:<reg> -p variable", "read value from MDIO bus and writes it to variable")
+BAREBOX_CMD_HELP_OPT("-e", "enable (once) extended register read/write")
 BAREBOX_CMD_HELP_END
 
 BAREBOX_CMD_START(miitool)
 	.cmd		= do_miitool,
-	BAREBOX_CMD_DESC("view media-independent interface status")
-	BAREBOX_CMD_OPTS("[-vsr]")
+	BAREBOX_CMD_DESC("media-independent interface access")
+	BAREBOX_CMD_OPTS("[-evsrwxp]")
 	BAREBOX_CMD_GROUP(CMD_GRP_NET)
 	BAREBOX_CMD_HELP(cmd_miitool_help)
 BAREBOX_CMD_END
diff --git a/commands/sfdisk.c b/commands/sfdisk.c
new file mode 100644
index 0000000..55df47f
--- /dev/null
+++ b/commands/sfdisk.c
@@ -0,0 +1,372 @@
+/*
+ * sfdisk minimalistic implementation
+ *
+ * Copyright (C) 2019 WAGO Kontakttechnik GmbH & Co. KG
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+
+#include <common.h>
+#include <command.h>
+#include <stdlib.h>
+#include <libfile.h>
+#include <fs.h>
+
+#define PART_OFFS 446
+#define PART_LEN 16
+#define SECT_SIZE 512
+#define MBR_SIZE SECT_SIZE
+
+#define PRIMARY_PARTITIONS 4
+#define MAX_PARTITIONS 32
+
+/* Align all EBR and partitions on a 2k sector line,
+ * which is 1 MByte aligned.
+ * Except the first partition, which is 8k aligned = 4 MByte
+ */
+#define BOUNDARY 0x800
+#define FIRST_BOUNDARY 0x2000
+#define SECT_ALIGN(x) (((x)+(BOUNDARY-1)) & ~(BOUNDARY-1))
+
+#define TYPE_EXT   0x05
+#define TYPE_LINUX 0x83
+#define TYPE_SWAP  0x82
+
+struct part {
+	unsigned char act;
+	unsigned char type;
+	unsigned long start;
+	unsigned long size;
+};
+
+struct mbr {
+	unsigned long position;
+	int active;
+	struct part part[4];
+};
+
+/* This Cylinder/Heads/Sector stuff is most probably superfluous */
+#define HEADS_PER_CYL 4
+#define SECTORS_PER_TRACK 16
+
+/* https://en.wikipedia.org/wiki/Logical_block_addressing#CHS_conversion */
+static void lba2chs(unsigned int lba, unsigned char *p)
+{
+	int c, h, s;
+
+	c =  lba / (HEADS_PER_CYL * SECTORS_PER_TRACK);
+	h = (lba / SECTORS_PER_TRACK) % HEADS_PER_CYL;
+	s = (lba % SECTORS_PER_TRACK) + 1;
+
+	p[0] = h;
+	p[1] = s | ((c >> 2) & 0xc0);
+	p[2] = c & 0xff;
+}
+
+static void host2le(unsigned int n, unsigned char *p)
+{
+	for (int i = 0; i < 4; i++)
+		p[i] = (n >> (8*i)) & 0xff;
+}
+
+static void serialize_partition(struct mbr *mbr, unsigned char *data, int n)
+{
+	struct part *part_n = mbr->part + n;
+	unsigned char *part = data + PART_OFFS + n * PART_LEN;
+	unsigned long chs_start = part_n->start + mbr->position;
+
+	part[0] = part_n->act;
+	lba2chs(chs_start, part + 1);
+
+	part[4] = part_n->type;
+	lba2chs(chs_start + part_n->size - 1, part + 5);
+
+	host2le(part_n->start, part + 8);
+	host2le(part_n->size, part + 12);
+}
+
+static int write_mbr(struct cdev *cdev, struct mbr *mbr)
+{
+	int i;
+	unsigned char data[MBR_SIZE];
+
+	memset(data, 0, sizeof(data));
+	data[MBR_SIZE-1] = 0xaa;
+	data[MBR_SIZE-2] = 0x55;
+
+	srand(get_time_ns());
+	get_random_bytes(data + (PART_OFFS - 6), 6);
+
+	for (i = 0; i < 4; i++) {
+		if (mbr->part[i].size > 0)
+			serialize_partition(mbr, data, i);
+	}
+	return cdev_write(cdev, data, sizeof(data), mbr->position*SECT_SIZE, 0);
+}
+
+static int write_partitions(const char *device, struct mbr *mbr, int n_mbr)
+{
+	int i, ret = COMMAND_SUCCESS;
+	struct cdev *cdev;
+
+	cdev = cdev_open(device, O_RDWR);
+	if (!cdev) {
+		perror(device);
+		return COMMAND_ERROR;
+	}
+	for (i = 0; i < n_mbr; i++) {
+		if (!mbr[i].active)
+			continue;
+		if (write_mbr(cdev, mbr + i) == -1) {
+			perror("Write MBR");
+			ret = COMMAND_ERROR;
+			break;
+		}
+	}
+	cdev_close(cdev);
+	return ret;
+}
+
+unsigned long no_sectors;
+static void get_device_sectors(const char *device)
+{
+	struct cdev *cdev = cdev_open(device, O_RDWR);
+
+	if (cdev) {
+		no_sectors = cdev->size / SECT_SIZE;
+		cdev_close(cdev);
+	}
+}
+
+static int init_part(struct part *part, int act, int type,
+			unsigned long start, unsigned long size)
+{
+	part->start = SECT_ALIGN(start);
+
+	if (!size)
+		size = no_sectors - part->start;
+
+	part->size  = SECT_ALIGN(size);
+
+	part->act = act ? 0x80 : 0x00;
+	part->type = type;
+
+	return part->start + part->size;
+}
+
+static int add_extended(struct mbr *mbr, struct part *prev, int type,
+			unsigned long start, unsigned long size)
+{
+	unsigned long part_start = BOUNDARY;
+
+	if (!prev)
+		part_start = FIRST_BOUNDARY;
+
+	if (!size)
+		size = no_sectors - start;
+
+	mbr->position = start - part_start;
+	mbr->active = 1;
+	init_part(mbr->part, 0, type, part_start, size);
+
+	if (prev) {
+		prev->type = TYPE_EXT;
+		prev->start = mbr->position;
+		prev->size = mbr->part[0].start + mbr->part[0].size;
+	}
+
+	return mbr->position + mbr->part[0].start + mbr->part[0].size;
+}
+
+static unsigned long char2num(const char *val)
+{
+	char *end;
+	unsigned long v;
+
+	if (!val || !*val)
+		return 0;
+
+	v = simple_strtoul(val, &end, 10);
+	if (!v || !end || !*end)
+		return v;
+
+	switch (*end) {
+	case 'm':
+	case 'M':
+		v *= 1024; /* FALL */
+	case 'k':
+	case 'K':
+		v = v * (1024 / SECT_SIZE);
+	}
+	return v;
+}
+
+/* Parse partition configuration line in sfdisk format */
+#define DELIM ",;\n "
+static unsigned char parse_part_line(char *line, unsigned long *start,
+					unsigned long *size, int *act)
+{
+	char id = TYPE_LINUX, *val;
+
+	*act = 0;
+	*start = char2num(strsep(&line, DELIM));
+	*size = char2num(strsep(&line, DELIM));
+	val = strsep(&line, DELIM);
+
+	if (!val || !*val)
+		return id;
+
+	switch (*val) {
+	case 'X':
+	case 'E':
+		id = TYPE_EXT;
+		break;
+	case 'S':
+		id = TYPE_SWAP;
+		break;
+	case 'L':
+		id = TYPE_LINUX;
+		break;
+	default:
+		id = simple_strtoul(val, NULL, 16);
+	}
+	val = strsep(&line, DELIM);
+	if (!val)
+		return id;
+	*act = *val == '*' || *val == '_' ? 1 : 0;
+	return id;
+}
+
+static int do_sfdisk(int argc, char *argv[])
+{
+	/* Next sector for primary partition */
+	unsigned long pnext = FIRST_BOUNDARY;
+	/* Next relative sector for logic partition */
+	unsigned long lnext = 0;
+	/* Current primary and extended MBR index */
+	int prim = 0, ext = 0;
+	/* Previous EBR of the logic partition chain */
+	struct part *prev = NULL;
+	struct mbr mbr[MAX_PARTITIONS] = { { .active = 1 }, };
+	char *line, *device, *next;
+	void *buf;
+	size_t buflen;
+	int ret;
+
+	if (argc < 3)
+		return COMMAND_ERROR_USAGE;
+
+	ret = read_file_2(argv[1], &buflen, &buf, FILESIZE_MAX);
+	if (!buf || ret)
+		return COMMAND_ERROR_USAGE;
+
+	next = buf;
+	while (buflen > 0 && next[buflen-1] == '\n')
+		next[--buflen] = 0;
+
+	device = argv[2];
+	get_device_sectors(device);
+
+	for (line = buf; line; line = next) {
+		int act;
+		unsigned long start, size;
+		unsigned char type;
+
+		next = strchr(line, '\n');
+		if (next)
+			*next++ = 0;
+
+		type = parse_part_line(line, &start, &size, &act);
+		if (!ext) {
+			if (start)
+				pnext = start;
+			init_part(mbr->part + prim, act, type, pnext, size);
+			pnext = mbr->part[prim].start + mbr->part[prim].size;
+			if (type == TYPE_EXT) {
+				ext = PRIMARY_PARTITIONS;
+				lnext = mbr->part[prim].start + FIRST_BOUNDARY;
+				no_sectors = pnext;
+			}
+			if (prim++ >= PRIMARY_PARTITIONS) {
+				pr_err("Too much primary partitions\n");
+				free(buf);
+				return COMMAND_ERROR;
+			}
+		} else {
+			if (start)
+				lnext = start;
+			lnext = add_extended(mbr + ext, prev, type, lnext,
+						size) + BOUNDARY;
+			prev = mbr[ext].part + 1;
+			if (ext++ >= MAX_PARTITIONS) {
+				pr_err("Too much extended partitions\n");
+				free(buf);
+				return COMMAND_ERROR;
+			}
+		}
+	}
+	if (ext > 4) {
+		for (prim = 0; prim < PRIMARY_PARTITIONS; prim++) {
+			if (mbr->part[prim].type != TYPE_EXT)
+				continue;
+			pnext = mbr->part[prim].start;
+
+			while (ext-- > PRIMARY_PARTITIONS)
+				mbr[ext].part[1].start -= pnext;
+
+			if (!mbr->part[prim].size)
+				mbr->part[prim].size = lnext - pnext - BOUNDARY;
+			break;
+		}
+		if (prim >= PRIMARY_PARTITIONS) {
+			pr_err("No primary partition with type 'Extended'.\n");
+			free(buf);
+			return COMMAND_ERROR;
+		}
+
+	}
+	free(buf);
+
+	return write_partitions(device, mbr, MAX_PARTITIONS);
+}
+
+BAREBOX_CMD_HELP_START(sfdisk)
+BAREBOX_CMD_HELP_TEXT("Creates partitions on <device> described by")
+BAREBOX_CMD_HELP_TEXT("the sfdisk formatted <script file>.")
+BAREBOX_CMD_HELP_TEXT("The default for <device> is '/dev/mmc1'.")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("Example script file entrys:")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("with sector defines:")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("8192,32768,b,*")
+BAREBOX_CMD_HELP_TEXT("40960,7593984,E")
+BAREBOX_CMD_HELP_TEXT("49152,14336")
+BAREBOX_CMD_HELP_TEXT("65536,14336")
+BAREBOX_CMD_HELP_TEXT("81920,620544")
+BAREBOX_CMD_HELP_TEXT("704512,3143680")
+BAREBOX_CMD_HELP_TEXT("3850240,3143680")
+BAREBOX_CMD_HELP_TEXT("6995968,620544,L")
+BAREBOX_CMD_HELP_TEXT("7618560,16384")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT("with dynamic sized values:")
+BAREBOX_CMD_HELP_TEXT("")
+BAREBOX_CMD_HELP_TEXT(",16M,b,*")
+BAREBOX_CMD_HELP_TEXT(",,E")
+BAREBOX_CMD_HELP_TEXT(",7M,L")
+BAREBOX_CMD_HELP_TEXT(",7M,L")
+BAREBOX_CMD_HELP_TEXT(",303M,L")
+BAREBOX_CMD_HELP_TEXT(",1535M,L")
+BAREBOX_CMD_HELP_TEXT(",1535M,L")
+BAREBOX_CMD_HELP_TEXT(",303M,L")
+BAREBOX_CMD_HELP_TEXT(",,L")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(sfdisk)
+	.cmd = do_sfdisk,
+	BAREBOX_CMD_DESC("Create MBR formatted partition table")
+	BAREBOX_CMD_OPTS("<script file> <device>")
+	BAREBOX_CMD_GROUP(CMD_GRP_PART)
+	BAREBOX_CMD_HELP(cmd_sfdisk_help)
+BAREBOX_CMD_END
+
diff --git a/commands/uart_console.c b/commands/uart_console.c
new file mode 100644
index 0000000..ea75286
--- /dev/null
+++ b/commands/uart_console.c
@@ -0,0 +1,63 @@
+/*
+ * uart_console.c - command to activate a dedicated uart
+ *
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <common.h>
+#include <of.h>
+#include <of_address.h>
+#include <command.h>
+#include <getopt.h>
+#include <console.h>
+
+static int do_uart_console(int argc, char *argv[])
+{
+	struct device_node *uart_node;
+	int uart_num = -1, opt;
+	char *alias_name;
+
+	while ((opt = getopt(argc, argv, "e:")) > 0) {
+		switch (opt) {
+		case 'e':
+			uart_num = simple_strtoul(optarg, NULL, 0);
+			break;
+		}
+	}
+
+	alias_name = basprintf("serial%d", uart_num);
+
+	uart_node = of_find_node_by_alias(of_get_root_node(), alias_name);
+	if (!uart_node)
+		return -ENODEV;
+
+	if (!of_device_enable_and_register(uart_node))
+		return -ENODEV;
+
+	return 0;
+}
+
+BAREBOX_CMD_HELP_START(uart_console)
+BAREBOX_CMD_HELP_TEXT("Options:")
+BAREBOX_CMD_HELP_OPT("-e <NUM>", "enable uart<NUM> as console\n")
+BAREBOX_CMD_HELP_END
+
+BAREBOX_CMD_START(uart_console)
+	.cmd		= do_uart_console,
+	BAREBOX_CMD_DESC("activate uart as console")
+	BAREBOX_CMD_OPTS("[-e]")
+	BAREBOX_CMD_GROUP(CMD_GRP_MISC)
+	BAREBOX_CMD_HELP(cmd_uart_console_help)
+BAREBOX_CMD_END
diff --git a/common/block.c b/common/block.c
index 8d0de42..6730ca9 100644
--- a/common/block.c
+++ b/common/block.c
@@ -36,7 +36,7 @@ struct chunk {
 	struct list_head list;
 };
 
-#define BUFSIZE (PAGE_SIZE * 4)
+#define BUFSIZE (PAGE_SIZE * 16)
 
 /*
  * Write all dirty chunks back to the device
@@ -372,7 +372,7 @@ int blockdevice_register(struct block_device *blk)
 	debug("%s: rdbufsize: %d blockbits: %d blkmask: 0x%08x\n", __func__, blk->rdbufsize, blk->blockbits,
 			blk->blkmask);
 
-	for (i = 0; i < 32; i++) {
+	for (i = 0; i < 8; i++) {
 		struct chunk *chunk = xzalloc(sizeof(*chunk));
 		chunk->data = dma_alloc(BUFSIZE);
 		chunk->num = i;
diff --git a/common/blspec.c b/common/blspec.c
index 2c682e1..da8f53a 100644
--- a/common/blspec.c
+++ b/common/blspec.c
@@ -31,6 +31,7 @@
 #include <linux/stat.h>
 #include <linux/err.h>
 #include <mtd/ubi-user.h>
+#include <libgen.h>
 
 /*
  * blspec_entry_var_set - set a variable to a value
@@ -444,15 +445,97 @@ static bool entry_is_match_machine_id(struct blspec_entry *entry)
 }
 
 /*
+ * blspec_check_conf_file - check if config file is valid
+ *
+ * return 0 if config file not valid != 0 otherwise
+ */
+static int blspec_check_conf_file(struct bootentries *bootentries,
+				   char *configname)
+{
+	int ret = 0;
+	char *dot;
+	struct stat s;
+
+	pr_debug("%s: %s\n", __func__, configname);
+
+	dot = strrchr(configname, '.');
+	if (!dot)
+		goto out;
+
+	if (strcmp(dot, ".conf"))
+		goto out;
+
+	if (stat(configname, &s))
+		goto out;
+
+	if (!S_ISREG(s.st_mode))
+		goto out;
+
+	return !blspec_have_entry(bootentries, configname);
+out:
+	return ret;
+}
+
+/*
+ * blspec_get_entry - create and set content of blspec entry
+ *
+ * return NULL if error occur else valid blspech entry
+ */
+static struct blspec_entry *blspec_get_entry(struct bootentries *bootentries,
+					     char *configname, const char* root)
+{
+	struct blspec_entry *entry = NULL;
+	char *devname = NULL, *hwdevname = NULL;
+
+	entry = blspec_entry_open(bootentries, configname);
+	if (IS_ERR(entry))
+		goto out;
+
+	entry->rootpath = xstrdup(root);
+	entry->configpath = xstrdup(configname);
+	entry->cdev = get_cdev_by_mountpath(root);
+
+	if (!entry_is_of_compatible(entry))
+		goto err_out;
+
+	if (!entry_is_match_machine_id(entry))
+		goto err_out;
+
+	if (entry->cdev && entry->cdev->dev) {
+		devname = xstrdup(dev_name(entry->cdev->dev));
+		if (entry->cdev->dev->parent)
+			hwdevname = xstrdup(dev_name(entry->cdev->dev->parent));
+	}
+
+	entry->entry.title = xstrdup(blspec_entry_var_get(entry, "title"));
+	entry->entry.description = basprintf("blspec entry, device: %s "
+						"hwdevice: %s", devname ?
+						devname : "none", hwdevname ?
+						hwdevname : "none");
+	free(devname);
+	free(hwdevname);
+
+	entry->entry.me.type = MENU_ENTRY_NORMAL;
+	entry->entry.release = blspec_entry_free;
+
+	return entry;
+
+err_out:
+	blspec_entry_free(&entry->entry);
+out:
+	return NULL;
+}
+
+/*
  * blspec_scan_directory - scan over a directory
  *
- * Given a root path collects all bootentries entries found under /bootentries/entries/.
+ * Given a root path collects all bootentries entries found under
+ * /loader/entries/.
  *
  * returns the number of entries found or a negative error value otherwise.
  */
 int blspec_scan_directory(struct bootentries *bootentries, const char *root)
 {
-	struct blspec_entry *entry;
 	DIR *dir;
 	struct dirent *d;
 	char *abspath;
@@ -476,92 +559,93 @@ int blspec_scan_directory(struct bootentries *bootentries, const char *root)
 	}
 
 	while ((d = readdir(dir))) {
+		struct blspec_entry *entry;
 		char *configname;
-		struct stat s;
-		char *dot;
-		char *devname = NULL, *hwdevname = NULL;
 
 		if (*d->d_name == '.')
 			continue;
 
 		configname = basprintf("%s/%s", abspath, d->d_name);
 
-		dot = strrchr(configname, '.');
-		if (!dot) {
+		ret = blspec_check_conf_file(bootentries, configname);
+		if (!ret) {
 			free(configname);
 			continue;
 		}
 
-		if (strcmp(dot, ".conf")) {
-			free(configname);
-			continue;
+		entry = blspec_get_entry(bootentries, configname, root);
+		if (entry) {
+			++found;
+			bootentries_add_entry(bootentries, &entry->entry);
 		}
+	}
 
-		ret = stat(configname, &s);
-		if (ret) {
-			free(configname);
-			continue;
-		}
+	ret = found;
 
-		if (!S_ISREG(s.st_mode)) {
-			free(configname);
-			continue;
-		}
+	closedir(dir);
+err_out:
+	if (!IS_ERR(nfspath))
+		free(nfspath);
+	free(abspath);
 
-		if (blspec_have_entry(bootentries, configname)) {
-			free(configname);
-			continue;
-		}
+	return ret;
+}
 
-		entry = blspec_entry_open(bootentries, configname);
-		if (IS_ERR(entry)) {
-			free(configname);
-			continue;
-		}
+/*
+ * blspec_scan_file - scan a certainly blspec config file
+ *
+ * returns the 1 if valid entrie found, 0 or a negative error value otherwise.
+ */
+int blspec_scan_file(struct bootentries *bootentries, const char *file)
+{
+	int ret = 0;
+	struct blspec_entry *entry;
+	char *abspath, *root = NULL;
+	char *sep, *confdir;
+	const char *dirname = "loader/entries";
 
-		entry->rootpath = xstrdup(root);
-		entry->configpath = configname;
-		entry->cdev = get_cdev_by_mountpath(root);
+	if (strncmp(file, "file://", 7)) {
+		ret = -EINVAL;
+		goto out;
+	}
 
-		if (!entry_is_of_compatible(entry)) {
-			blspec_entry_free(&entry->entry);
-			continue;
-		}
+	file += 7;
 
-		if (!entry_is_match_machine_id(entry)) {
-			blspec_entry_free(&entry->entry);
-			continue;
-		}
+	abspath = xstrdup(file);
 
-		found++;
+	ret = blspec_check_conf_file(bootentries, abspath);
+	if (!ret) {
+		ret = -EINVAL;
+		goto out_free;
+	}
 
-		if (entry->cdev && entry->cdev->dev) {
-			devname = xstrdup(dev_name(entry->cdev->dev));
-			if (entry->cdev->dev->parent)
-				hwdevname = xstrdup(dev_name(entry->cdev->dev->parent));
-		}
+	root = xstrdup(abspath);
 
-		entry->entry.title = xstrdup(blspec_entry_var_get(entry, "title"));
-		entry->entry.description = basprintf("blspec entry, device: %s hwdevice: %s",
-						    devname ? devname : "none",
-						    hwdevname ? hwdevname : "none");
-		free(devname);
-		free(hwdevname);
+	sep = strrchr(root, '/');
+	if (!sep) {
+		ret = -EINVAL;
+		goto out_free;
+	}
 
-		entry->entry.me.type = MENU_ENTRY_NORMAL;
-		entry->entry.release = blspec_entry_free;
+	*sep = 0;
+	confdir = sep - strlen(dirname);
 
-		bootentries_add_entry(bootentries, &entry->entry);
+	if (strncmp(confdir, dirname, strlen(dirname))) {
+		ret = -EINVAL;
+		goto out_free;
 	}
 
-	ret = found;
+	entry = blspec_get_entry(bootentries, abspath, root);
+	if (!entry)
+		goto out_free;
 
-	closedir(dir);
-err_out:
-	if (!IS_ERR(nfspath))
-		free(nfspath);
-	free(abspath);
+	bootentries_add_entry(bootentries, &entry->entry);
+	ret = 1;
 
+out_free:
+	free(root);
+	free(abspath);
+out:
 	return ret;
 }
 
@@ -778,6 +862,12 @@ static int blspec_bootentry_provider(struct bootentries *bootentries,
 			found += ret;
 	}
 
+	if (!strncmp(name, "file://", 7)) {
+		ret = blspec_scan_file(bootentries, name);
+		if (ret > 0)
+			found += ret;
+	}
+
 	return found;
 }
 
diff --git a/defaultenv/defaultenv-2-base/bin/init b/defaultenv/defaultenv-2-base/bin/init
index 8d02e3d..0bdb325 100644
--- a/defaultenv/defaultenv-2-base/bin/init
+++ b/defaultenv/defaultenv-2-base/bin/init
@@ -6,6 +6,7 @@ global hostname
 global user
 global autoboot_timeout
 global autoboot_abort_key
+global autoboot
 global boot.default
 global linux.bootargs.base
 global linux.bootargs.console
@@ -23,6 +24,7 @@ magicvar -a global.autoboot_timeout "timeout in seconds before automatic booting
 magicvar -a global.autoboot_abort_key "key to abort automatic booting (valid options: any, ctrl-c)"
 [ -z "${global.boot.default}" ] && global.boot.default=net
 [ -z "${global.editcmd}" ] && global.editcmd=sedit
+[ -z "${global.autoboot}" ] && global.autoboot=0
 
 [ -e /env/config-board ] && /env/config-board
 /env/config
@@ -30,7 +32,7 @@ magicvar -a global.autoboot_abort_key "key to abort automatic booting (valid opt
 # allow to stop the boot before execute the /env/init/*
 # but without waiting
 timeout -s -a -v key 0
-autoboot="$?"
+global.autoboot="$?"
 
 echo -e -n "\e[?25h"
 if [ "${key}" = "q" ]; then
@@ -55,16 +57,16 @@ else
 	echo -e -n "\nHit $abort_string to stop autoboot: "
 fi
 
-if [ "$autoboot" = 0 ]; then
+if [ "$global.autoboot" = 0 ]; then
 	timeout $abort_args $global.autoboot_timeout -v key
-	autoboot="$?"
+	global.autoboot="$?"
 fi
 
 if [ "${key}" = "q" ]; then
 	exit
 fi
 
-if [ "$autoboot" = 0 ]; then
+if [ "$global.autoboot" = 0 ]; then
 	boot
 fi
 
diff --git a/defaultenv/defaultenv-pfc-base/bin/init b/defaultenv/defaultenv-pfc-base/bin/init
new file mode 100644
index 0000000..7af3568
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/init
@@ -0,0 +1,88 @@
+#!/bin/sh
+
+export PATH=/env/bin
+
+global hostname
+global user
+global autoboot_timeout
+global autoboot_abort_key
+global autoboot
+global boot.default
+global linux.bootargs.base
+global linux.bootargs.console
+#linux.bootargs.dyn.* will be cleared at the beginning of boot
+global linux.bootargs.dyn.ip
+global linux.bootargs.dyn.root
+global editcmd
+
+[ -z "${global.hostname}" ] && global.hostname=generic
+[ -z "${global.user}" ] && global.user=none
+magicvar -a global.user "username (used in network filenames)"
+[ -z "${global.autoboot_timeout}" ] && global.autoboot_timeout=3
+magicvar -a global.autoboot_timeout "timeout in seconds before automatic booting"
+[ -z "${global.autoboot_abort_key}" ] && global.autoboot_abort_key=any
+magicvar -a global.autoboot_abort_key "key to abort automatic booting (valid options: any, ctrl-c)"
+[ -z "${global.boot.default}" ] && global.boot.default=net
+[ -z "${global.editcmd}" ] && global.editcmd=sedit
+[ -z "${global.autoboot}" ] && global.autoboot=0
+
+[ -e /env/config-board ] && /env/config-board
+/env/config
+
+# allow to stop the boot before execute the /env/init/*
+# but without waiting
+timeout -s -a -v key 0
+global.autoboot="$?"
+
+echo -e -n "\e[?25h"
+if [ "${key}" = "q" ]; then
+	exit
+fi
+
+for i in /env/init/*; do
+	. $i
+done
+
+if [ "${global.autoboot_abort_key}" = "ctrl-c" ]; then
+	abort_string="ctrl-c"
+	abort_args="-c"
+else
+	abort_string="any key"
+	abort_args="-a -e"
+fi
+
+if [ -e /env/menu ]; then
+	echo -e -n "\nHit m for menu or $abort_string to stop autoboot: "
+else
+	echo -e -n "\nHit $abort_string to stop autoboot: "
+fi
+
+if [ "$global.autoboot" = 0 ]; then
+	timeout $abort_args $global.autoboot_timeout -v key
+	global.autoboot="$?"
+fi
+
+for i in /env/init_post_autoboot/*; do
+	. $i
+done
+
+if [ "${key}" = "q" ]; then
+	exit
+fi
+
+if [ "$global.autoboot" = 0 ]; then
+	boot
+	if [ ! "$?" = "0" ]; then
+		echo -e ${error} "$0: could not boot at least one of this bootsources: ${global.boot.default}"
+		pfc-config-broken-boot
+		exit 1
+	fi
+fi
+
+if [ -e /env/menu ]; then
+	if [ "${key}" != "m" ]; then
+		echo -e "\ntype exit to get to the menu"
+		sh
+	fi
+	/env/menu/mainmenu
+fi
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart b/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart
new file mode 100644
index 0000000..0a8d509
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-check-for-debug-uart
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let debug_mode_mask="(1<<0)"
+let debug_mode_enable="0x${global.pfc.boot_mode_id} & 0x${debug_mode_mask}"
+
+if [ "${debug_mode_enable}" = "${debug_mode_mask}" ]; then
+	echo -e ${warning} "uart debug mode active"
+	global.autoboot_timeout=3
+	global.pfc.debug_mode_active=true
+
+	# one some devices the debug uart interface is only
+	# available through the jtag interface. This is not
+	# always wired to the mainboard (e.g. PAC-Devices).
+	uart_console -e ${global.pfc.barebox_uart}
+
+	# on devices with usb interface enable the usb gadget, too.
+	usbgadget ${global.pfc.usbgadget_options}
+fi
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot
new file mode 100644
index 0000000..1e3b359
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-broken-boot
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# first switch of any previously activated leds
+led_mode -s -c yellow -v off
+led_mode -s -c red -v on
+
+global.pfc.boot_mode="broken"
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=1
+uart_console -e ${global.pfc.barebox_uart}
+
+echo -e ${error} "$0: setting boot_mode to: ${global.pfc.boot_mode}"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot
new file mode 100644
index 0000000..ee142a3
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-default-boot
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+led_mode -s -c yellow -v on
+
+global.autoboot_timeout=0
+global.boot.watchdog_timeout=${global.pfc.watchdog_timeout_linux_load}
+global.linux.bootargs.base="bootversion=${global.version} reset_state=${global.system.reset}"
+global.boot.default="bootchooser"
+
+sd_blspec="${global.pfc.sd_rootfs}/boot/sd/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+sd_legacy_uImage="${global.pfc.sd_boot}/uImage"
+
+emmc_blspec_rootfs0="${global.pfc.emmc_rootfs0}/boot/emmc0/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+emmc_blspec_rootfs1="${global.pfc.emmc_rootfs1}/boot/emmc1/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+
+nand_blspec_rootfs0="${global.pfc.nand_rootfs0}/boot/nand0/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+nand_blspec_rootfs1="${global.pfc.nand_rootfs1}/boot/nand1/loader/entries/${global.model}-${global.pfc.devconf}.conf"
+
+if [ -e "${global.pfc.emmc}" ]; then
+	global.bootchooser.rootfs.1.boot="file://${emmc_blspec_rootfs0}"
+	global.bootchooser.rootfs.2.boot="file://${emmc_blspec_rootfs1}"
+
+elif [ -e "${global.pfc.nand}" ]; then
+	global.bootchooser.rootfs.1.boot="file://${nand_blspec_rootfs0}"
+	global.bootchooser.rootfs.2.boot="file://${nand_blspec_rootfs1}"
+else
+	# remove bootchooser from default boot source
+	global.boot.default=""
+	echo -e ${warning} "$0: no valid boot device found for bootchooser"
+fi
+
+if [ "${global.pfc.disable_sd_boot}" = 0 ]; then
+	if [ -e "${global.pfc.sd}" ] && [ -e "${sd_blspec}" ]; then
+		global.boot.default="file://${sd_blspec} bootchooser"
+
+	elif [ -e "${global.pfc.sd}" ] && [ -e "${sd_legacy_uImage}" ]; then
+		# disable watchdog in case of an legacy boot, because we dont know if the
+		# watchdog is disabled per default in legacy kernel.
+		global.boot.watchdog_timeout=0
+
+		global.bootm.boot_atag=true
+		global.boot.default="sd-legacy bootchooser"
+	fi
+fi
+
+if [ "${global.pfc.dhcpboot}" = 1 ]; then
+	global.boot.default="dhcp-boot $global.boot.default"
+fi
+
+if [ -z "${global.boot.default}" ]; then
+	echo -e ${error} "$0: no valid boot device available"
+	exit 1
+fi
+
+pfc-check-for-debug-uart
+pfc-set-linux-console
+
+echo -e ${info} "default boot order is: $global.boot.default"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot
new file mode 100644
index 0000000..3ebde65
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-production-boot
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+global.linux.bootargs.productionmode="production_mode=1"
+global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+global.linux.bootargs.watchdog=""
+global.boot.watchdog_timeout=0
+
+led_mode -m -c green
+pfc-config-setupfw-generic-boot
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot
new file mode 100644
index 0000000..09d872b
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-boot
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+global.linux.bootargs.productionmode="production_mode=2"
+global.linux.bootargs.console="console="
+
+led_mode -m -c red
+pfc-config-setupfw-generic-boot
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot
new file mode 100644
index 0000000..2be71c6
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-config-setupfw-generic-boot
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+global.autoboot_timeout=3
+global.linux.bootargs.base="root=/dev/ram0 rdinit=/init.sh quiet macaddr=${eth0.ethaddr}"
+
+if [ -e "${global.pfc.sd}" ] &&
+   [ -e "${global.pfc.sd_boot}/setupfw" ] &&
+   [ -e "${global.pfc.sd_boot}/oftree-${global.board.variant}-setupfw.dtb" ] ; then
+	global.boot.default="sd-setupfw net-setupfw"
+
+else
+	global.boot.default="net-setupfw"
+fi
+
+echo -e ${info} "default boot order is: $global.boot.default"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode b/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode
new file mode 100644
index 0000000..bb26941c
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-debug-uart-mode
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+mode="unknown"
+let debug_mask="(1<<0)"
+
+while getopt "edh" opt; do
+	if [ ${opt} = e ]; then
+                mode="enable"
+	elif [ ${opt} = d ]; then
+                mode="disable"
+	elif [ ${opt} = h ]; then
+		mode="unknown"
+	fi
+done
+
+if [ "${mode}" = "unknown" ]; then
+	echo "usage: $0 [-ed]"
+	echo ""
+	echo "control debug uart mode. Mode is set persistent through eeprom bit "develop-mode-enable" in eeprom"
+	echo ""
+	echo "-e enable debug uart mode\n"
+	echo "-d disable debug uart mode\n"
+	echo ""
+	exit 1
+fi
+
+if [ "${mode}" = "enable" ]; then
+	let debug_enable="0x${global.pfc.boot_mode_id} | 0x${debug_mask}"
+else
+	let debug_enable="0x${global.pfc.boot_mode_id} & ~0x${debug_mask}"
+fi
+
+# write persistent to eeprom
+xsection.boot_mode_id=${debug_enable}
+
+# also update global variable
+global.pfc.boot_mode_id=${xsection.boot_mode_id}
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode b/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode
new file mode 100644
index 0000000..ec2a4f5
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-detect-boot-mode
@@ -0,0 +1,50 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let setup_fw_mask="(1 << 5)"
+let setup_fw_enable="0x${global.pfc.boot_mode_id} & ${setup_fw_mask}"
+let setup_fw_disable="0x${global.pfc.boot_mode_id} & ~${setup_fw_mask}"
+
+let disable_sd_boot_mask="(1 << 0)"
+let disable_sd_boot="0x${global.pfc.boot_mode_id_ext} & ${disable_sd_boot_mask}"
+
+let dhcpboot_mask="(1 << 1)"
+let dhcpboot="0x${global.pfc.boot_mode_id_ext} & ${dhcpboot_mask}"
+
+pfc-validate-ethaddr
+
+if [ "${dhcpboot}" = "${dhcpboot_mask}" ]; then
+	global.pfc.dhcpboot=1
+	echo -e ${warning} "dhcpboot enabled."
+fi
+
+if [ "${disable_sd_boot}" = "${disable_sd_boot_mask}" ]; then
+	global.pfc.disable_sd_boot=1
+	echo -e ${warning} "booting from sd disabled"
+fi
+
+if [ "${global.pfc.ethaddr_is_valid}" = false ]; then
+        global.pfc.boot_mode="production"
+
+elif [ -e "${global.pfc.sd}" ] && [ "${global.pfc.disable_sd_boot}" = 0 ]; then
+
+	# if a downgrade.bin.<platform-suffix> file is found on the first
+	# sd/mmc boot partition, we execute it.
+	# if downgrading will be executed successfully,
+	# we never come back here.
+	if [ -e "${global.pfc.downgrade_img}" ]; then
+        	global.pfc.boot_mode="downgrade"
+
+	# if a custom setup script is in located in the
+	# first sd/mmc card partition (fat), execute it.
+	elif [ -e "${global.pfc.custom_sh}" ]; then
+        	global.pfc.boot_mode="custom"
+	fi
+
+elif [ "${setup_fw_enable}" = "${setup_fw_mask}" ]; then
+        global.pfc.boot_mode="setupfw"
+	xsection.boot_mode_id="${setup_fw_disable}"
+fi
+
+echo -e ${info} "detected boot_mode: ${global.pfc.boot_mode}"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata b/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata
new file mode 100644
index 0000000..fcb2c80
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-erase-flash-ubidata
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+source /env/data/print-msg-formats
+
+# on am35xx based targets we need to set the ecc-mode
+nand_bch8="/env/data/nand-ecc-bch8"
+
+ubi_image="$1"
+
+if [ -z ${ubi_image} ] || [ ! -e "${ubi_image}" ]; then
+	echo -e ${error} "$0: no ubi-image to flash given"
+	exit 1
+fi
+
+# detach ubi device if attached
+[ -e "${global.pfc.nand_ubidata}.ubi" ] && ubidetach ${global.pfc.nand_ubidata}
+
+erase ${global.pfc.nand_ubidata}
+
+# here we also need to set the ecc-mode on
+# am335x based targets.
+if [ -e "${nand_bch8}" ]; then
+	${nand_bch8}
+fi
+
+ubiformat -q ${global.pfc.nand_ubidata} -y -e 0 -f ${ubi_image}
+if [ $? -ne 0 ]; then
+        echo -e ${error} "$0: error due flashing ${ubi_image} on ${global.pfc.nand_ubidata}"
+        exit 1
+fi
+
+exit 0
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot
new file mode 100644
index 0000000..4421f28
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-custom-boot
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+led_mode -m -c green
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=1
+uart_console -e ${global.pfc.barebox_uart}
+
+echo -e ${info} "execute custom script: ${global.pfc.custom_sh}"
+
+${global.pfc.custom_sh}
+exit $?
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot
new file mode 100644
index 0000000..0b1bb61
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-exec-downgrade-boot
@@ -0,0 +1,193 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+uart_console -e ${global.pfc.barebox_uart}
+
+# set autoboot variable to 1, to stop auto booting in
+# /env/bin/init and stay in shell.
+global.autoboot=1
+
+downgrade_lzo="downgrade.bin.${global.board.variant}"
+downgrade_script="downgrade"
+
+###############################
+##### legacy parts ############
+###############################
+
+mtd_linux1="mtd0_raw_linux1"
+mtd_linux2="mtd0_raw_linux2"
+mtd_data="mtd2_fs_data"
+mtd_xload="mtd3_raw_xload"
+mtd_barebox="mtd4_raw_barebox"
+mtd_barebox_env="mtd5_raw_barebox-env"
+mtd_product="mtd6_raw_product"
+mtd_recovery="mtd7_raw_recovery"
+mtd_parts="${mtd_linux1} ${mtd_linux2} ${mtd_data} ${mtd_xload} ${mtd_barebox} ${mtd_barebox_env} ${mtd_product} ${mtd_recovery}"
+
+recovery_parts="512k@0k(${mtd_xload}),1024k@512k(${mtd_barebox}),256k@1536k(${mtd_barebox_env}),256k@1792k(${mtd_product}),40192k@2048k(${mtd_recovery}),4096k@42240k(${mtd_linux1}),4096k@46336k(${mtd_linux2}),-@50432k(${mtd_data})"
+
+mlo="downgrade.mlo--nand"
+barebox="downgrade.barebox.img"
+recovery="recovery"
+
+###############################
+
+nand_hamming="/env/data/nand-ecc-hamming"
+nand_bch8_legacy="/env/data/nand-ecc-bch8-legacy"
+
+led_mode -m -c red -t
+
+echo -e ${info} "starting firmware downgrade..."
+echo -e ${info} "checking the environment..."
+
+# check if mount point is at correct location
+if [ ! -e "${global.pfc.sd_boot}" ]; then
+
+	echo -e ${error} "mount point ${global.pfc.sd_boot} not available"
+	exit 1
+
+fi
+
+# check if all recovery files are available
+if [ ! -e "${global.pfc.sd_boot}/${mlo}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${mlo} not available"
+	exit 1
+
+fi
+
+if [ ! -e "${global.pfc.sd_boot}/${barebox}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${barebox} not available"
+	exit 1
+
+fi
+
+if [ ! -e "${global.pfc.sd_boot}/${recovery}" ]; then
+
+	echo -e ${error} "recovery file: ${global.pfc.sd_boot}/${recovery} not available"
+	exit 1
+
+fi
+
+# reset bootloader index in eeprom
+echo -e ${info} "restore bootloader index..."
+xsection.blidx=0
+
+echo -e ${info} "restore recovery partitions..."
+
+# delete current mlo partitions
+for partition in ${global.pfc.nand_mlo_parts}; do
+	nand -d ${partition}.bb
+	delpart ${partition}
+done
+
+# delete current boot partitions
+for partition in ${global.pfc.nand_boot_parts}; do
+	nand -d ${partition}.bb
+	delpart ${partition}
+done
+
+# delete current data partition
+nand -d ${global.pfc.nand_ubidata}.bb
+delpart ${global.pfc.nand_ubidata}
+
+# restore recovery partitions
+mtdparts-add -b -d nand0 -p ${recovery_parts}
+
+# do additional check for created recovery partitions
+for partition in ${mtd_parts}; do
+	if [ ! -e "${global.pfc.nand}.${partition}" ]; then
+		echo -e ${error} "recovery-partition ${global.pfc.nand}.${partition} not available"
+		exit 1
+	fi
+
+	if [ ! -e "${global.pfc.nand}.${partition}.bb" ]; then
+		echo -e ${error} "recovery-partition ${global.pfc.nand}.${partition}.bb not available"
+		exit 1
+	fi
+done
+
+# check if all nand ecc-modes are available
+[ ! -e "${nand_hamming}" ] && echo -e ${error} "ecc-mode ${nand_hamming} not available" && exit 1
+[ ! -e "${nand_bch8_legacy}" ] && echo -e ${error} "ecc-mode ${nand_bch8_legacy} not available" && exit 1
+
+echo ""
+echo -e ${warning} "####################################################################"
+echo -e ${warning} "ATTENTION: DO NOT SWITCH OFF THE DEVICE DURING ERASE AND FLASH STEPS"
+echo -e ${warning} "####################################################################"
+echo ""
+echo -e -n ${warning} "PRESS ANY KEY TO ABORT ERASE AND FLASH STEPS: "
+
+timeout -a 3
+res=$?
+if [ ${res} -eq 1 ]; then
+
+	echo -e ${warning} "ABORTED BY USER...BOOT TO SHELL"
+	exit 1
+
+fi
+
+echo -e ${warning} "erase bootloader partitions..."
+
+# erase all bootloader partitions
+erase ${global.pfc.nand}.${mtd_xload}
+erase ${global.pfc.nand}.${mtd_barebox}.bb
+
+echo -e ${warning} "flash mlo and barebox..."
+
+# flash mlo
+${nand_hamming}
+#    -- first  128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x0
+#    -- second 128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x20000
+#    -- third  128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x40000
+#    -- fourth 128k
+memcpy -s ${global.pfc.sd_boot}/${mlo} -d ${global.pfc.nand}.${mtd_xload} 0x0 0x60000
+
+
+# flash barebox
+${nand_bch8_legacy}
+memcpy -s ${global.pfc.sd_boot}/${barebox} -d ${global.pfc.nand}.${mtd_barebox}.bb 0x0 0x0
+
+echo -e ${warning} "flash recovery image..."
+erase ${global.pfc.nand}.${mtd_recovery}.bb 0x0
+memcpy -s ${global.pfc.sd_boot}/${recovery} -d ${global.pfc.nand}.${mtd_recovery}.bb 0x0 0x0
+
+echo -e ${warning} "done..."
+echo ""
+echo -e ${warning} "############################################################"
+echo -e ${warning} "ATTENTION: DO NOT SWITCH OFF THE DEVICE DURING FACTORY RESET"
+echo -e ${warning} "############################################################"
+echo ""
+
+
+# setup bootargs
+echo -e ${info} "setup bootargs"
+
+global linux.bootargs.dyn.root="root=/dev/ram0 rdinit=/init.sh"
+global linux.bootargs.dyn.ip=""
+global linux.bootargs.dyn.macaddr=""
+global linux.bootargs.bootmode="pac_boot_id=0x1"
+global linux.bootargs.productionmode="production_mode=2"
+global linux.bootargs.devconf="devconf=0x0"
+
+# we need to clear the console kernel parameter. Otherwise the recovery step will
+# fail and damage the internal nand partiton layout.
+global.linux.bootargs.console=""
+
+# load production-firmware from nand partition and start it
+echo -e ${info} "now boot recovery image in factory-reset-mode"
+echo ""
+
+global.bootm.boot_atag=true
+bootm -v -f ${global.pfc.nand}.${mtd_recovery}.bb
+if [ ! $? = "0" ]; then
+	echo -e ${error} "could not start recovery image...booting to shell..."
+	exit 1
+fi
+
+exit $?
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console b/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console
new file mode 100644
index 0000000..e644823
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-set-linux-console
@@ -0,0 +1,23 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+let uart_mask="(1<<1)"
+let uart_enable="0x${global.pfc.boot_mode_id} & 0x${uart_mask}"
+
+if [ "${uart_enable}" = "${uart_mask}" ]; then
+	global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.linux_uart},115200n8"
+
+elif [ "${global.bootm.boot_atag}" = true ]; then
+	# in case of an legacy boot (e.g. kernel 3.6.11, FW < 5) we are not
+	# allowed to set console=null because this will break the init-process
+	# and the boot hangs.
+	global.linux.bootargs.console=""
+
+elif [ "${global.pfc.debug_mode_active}" = true ]; then
+	global.linux.bootargs.console="console=${global.pfc.linux_uart_device}${global.pfc.barebox_linux_uart},115200n8"
+else
+	global.linux.bootargs.console="console=null"
+fi
+
+echo -e ${info} "setting linux console to: $global.linux.bootargs.console"
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console b/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console
new file mode 100644
index 0000000..7a0d30d
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-switch-linux-console
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+mode="unknown"
+let uart_mask="(1<<1)"
+
+while getopt "edh" opt; do
+	if [ ${opt} = e ]; then
+                mode="enable"
+	elif [ ${opt} = d ]; then
+                mode="disable"
+	elif [ ${opt} = h ]; then
+		mode="unknown"
+	fi
+done
+
+if [ "${mode}" = "unknown" ]; then
+	echo "usage: $0 [-ed]"
+	echo ""
+	echo "control serial console bit. Mode is set persistent through eeprom bit "uart-enable" in eeprom"
+	echo ""
+	echo "-e enable linux uart mode\n"
+	echo "-d disable linux uart mode\n"
+	echo ""
+	exit 1
+fi
+
+if [ "${mode}" = "enable" ]; then
+	let uart_enable="0x${global.pfc.boot_mode_id} | 0x${uart_mask}"
+else
+	let uart_enable="0x${global.pfc.boot_mode_id} & ~0x${uart_mask}"
+fi
+
+# write persistent to eeprom
+xsection.boot_mode_id=${uart_enable}
+
+# also update global variable
+global.pfc.boot_mode_id=${xsection.boot_mode_id}
diff --git a/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr b/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr
new file mode 100644
index 0000000..8ac4865
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/bin/pfc-validate-ethaddr
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+ethaddr_match -i eth0 -p "00:30:de"
+if [ "$?" = 0 ]; then
+        global.pfc.ethaddr_is_valid="true"
+else
+        global.pfc.ethaddr_is_valid="false"
+fi
+
+echo -e ${info} "ethaddr is valid: $global.pfc.ethaddr_is_valid"
diff --git a/defaultenv/defaultenv-pfc-base/boot/dhcp-boot b/defaultenv/defaultenv-pfc-base/boot/dhcp-boot
new file mode 100644
index 0000000..a341a26
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/dhcp-boot
@@ -0,0 +1,22 @@
+#!/bin/sh
+
+# disable watchdog, otherwise the device will be resettet when the dhcp-request
+# takes to long.
+wd 0
+
+# send magic string with the dhcp-request to signal the dhcp-boot state
+global.dhcp.option224="cit-recover"
+
+ifup eth0
+
+if [ ! -z "${global.dhcp.bootfile}" ]; then
+	echo -e ${info} "enter DHCPBOOT now"
+
+	tftp ${global.dhcp.bootfile}
+
+	echo -e ${info} "DHCPBOOT: exec <${global.dhcp.bootfile}>"
+	./${global.dhcp.bootfile}
+fi
+
+# enable watchdog again, if the dhcp-server does not provide any bootfile.
+wd $global.pfc.watchdog_timeout_linux_load
diff --git a/defaultenv/defaultenv-pfc-base/boot/net-setupfw b/defaultenv/defaultenv-pfc-base/boot/net-setupfw
new file mode 100644
index 0000000..a28eca3
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/net-setupfw
@@ -0,0 +1,94 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+global.dhcp.retries=1000
+global.dhcp.vendor_id="750-8206"
+global.dhcp.option224="barebox running"
+
+ifup ${global.pfc.eth}
+
+if [ ${eth0.ipaddr} != "0.0.0.0" ] && [ ${eth0.serverip} != "0.0.0.0" ] &&
+  				      [ ! -z "${global.dhcp.bootfile}"  ]; then
+
+	echo -e ${info} "get ${global.dhcp.bootfile} from tftp server ${eth0.serverip}."
+
+	tftp ${global.dhcp.bootfile}
+	if [ "$?" = 0 ]; then
+
+		# Flash PFC200v3 G2 EMMC
+		if [ -e "${global.pfc.emmc}" ]; then
+			echo -e ${info} "flash ${global.pfc.bootfile} to ${global.pfc.emmc}"
+			umount /boot
+			umount ${global.pfc.emmc}.0
+			delpart ${global.pfc.emmc}.0
+
+			cp ${global.dhcp.bootfile} ${global.pfc.emmc}
+			if [ $? -ne 0 ]; then
+				echo -e ${error} "$0: error while flashing ${global.dhcp.bootfile} on ${global.pfc.emmc}"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			# normally there are no available partitions on emmc devices at the commissioner.
+			# With the result that we dont see any partitions under /dev. After we flashed the
+			# emmc image to the device we need to rescan the partiton tables and add the new
+			# flashed partitions under /dev.
+			${global.pfc.emmc_name}.scan=1
+			if [ $? -ne 0 ]; then
+				echo -e ${PRINT_ERROR} "error scanning partitions"
+				all_lights -s 1 -c red
+				exit 1
+			fi
+
+			# set setupfw image and dtb file to newly flashed emmc image files
+			if [ ! -e "${global.pfc.emmc_boot}/setupfw" ] ||
+			   [ ! -e "${global.pfc.emmc_boot}/oftree-${global.board.variant}-setupfw.dtb" ]; then
+				echo -e ${error} "$0: no setupfw on newly flashed emmc found"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			global.bootm.image="${global.pfc.emmc_boot}/setupfw"
+			global.bootm.oftree="${global.pfc.emmc_boot}/oftree-${global.board.variant}-setupfw.dtb"
+
+		# Flash NAND flash devices, like SRC
+		elif [ -e "${global.pfc.nand}" ]; then
+
+			echo -e ${info} "flash ${global.dhcp.bootfile} to ${global.pfc.nand_ubidata}"
+
+			pfc-erase-flash-ubidata ${global.dhcp.bootfile}
+			if [ $? -ne 0 ]; then
+				echo -e ${error} "$0: error while flashing ${global.dhcp.bootfile} on ${global.pfc.nand_ubidata}"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			automount -d ${global.pfc.nand_boot} "ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_boot} ${global.pfc.nand_boot}"
+
+			# set setupfw image and dtb file to newly flashed nand image files
+			if [ ! -e "${global.pfc.nand_boot}/setupfw" ] ||
+			   [ ! -e "${global.pfc.nand_boot}/oftree-${global.board.variant}-setupfw.dtb" ]; then
+				echo -e ${error} "$0: no setupfw on newly flashed nand found"
+				#all_lights -s 1 -c red
+				exit 1
+			fi
+
+			global.bootm.image="${global.pfc.nand_boot}/setupfw"
+			global.bootm.oftree="${global.pfc.nand_boot}/oftree-${global.board.variant}-setupfw.dtb"
+
+		else
+			echo -e ${error} "$0: No EMMC nor FLASH found. Nothing useful to do here, bailing out ..."
+			#all_lights -s 1 -c red
+			exit 1
+		fi
+	else
+		echo -e ${error} "$0: tftp download failed."
+		#all_lights -s 1 -c red
+		exit 1
+	fi
+else
+	echo -e ${error} "$0: dhcp configuration not set correctly."
+	#all_lights -s 1 -c red
+	exit 1
+fi
diff --git a/defaultenv/defaultenv-pfc-base/boot/sd-legacy b/defaultenv/defaultenv-pfc-base/boot/sd-legacy
new file mode 100644
index 0000000..04c4223
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/sd-legacy
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+# We need to define an imaginary mtd-partition
+# to protect our flash if an FW < 5 is booted via sd-card. The customer could
+# break his device when the create-boot-image is executed via e.g. wbm.
+
+global.bootm.image="${global.pfc.sd_boot}/uImage"
+global.linux.bootargs.base="rw root=/dev/mmcblk0p2 rootfstype=ext3 rootwait mtdparts=omap2-nand.0:-(nand_not_valid)ro pxc_boot_id=0x82 bootversion=${global.version} devconf=0x${global.pfc.devconf} macaddr=${eth0.ethaddr}"
diff --git a/defaultenv/defaultenv-pfc-base/boot/sd-setupfw b/defaultenv/defaultenv-pfc-base/boot/sd-setupfw
new file mode 100644
index 0000000..249247a
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/boot/sd-setupfw
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+global.bootm.image="${global.pfc.sd_boot}/setupfw"
+global.bootm.oftree="${global.pfc.sd_boot}/oftree-${global.board.variant}-setupfw.dtb"
diff --git a/defaultenv/defaultenv-pfc-base/config b/defaultenv/defaultenv-pfc-base/config
new file mode 100644
index 0000000..0df3e19
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/config
@@ -0,0 +1,225 @@
+#!/bin/sh
+
+# Here we setup the pfc environment for the start up scripts. Use global
+# variables because they make the sub-scripts more readable and can be
+# evaluated via commandline (e.g. magicvar command) if only booted to shell.
+
+############################
+# global variable definition
+############################
+global pfc.boot_mode
+global pfc.devconf
+global pfc.boot_mode_id
+global pfc.boot_mode_id_ext
+global pfc.ethaddr_is_valid
+global pfc.downgrade_img
+global pfc.custom_sh
+global pfc.sd
+global pfc.sd_boot
+global pfc.sd_rootfs
+global pfc.sd_dev_boot
+global pfc.sd_dev_rootfs
+global pfc.emmc_name
+global pfc.emmc
+global pfc.emmc_dev_boot
+global pfc.emmc_dev_rootfs0
+global pfc.emmc_dev_rootfs1
+global pfc.emmc_dev_home0
+global pfc.emmc_dev_home1
+global pfc.emmc_boot
+global pfc.emmc_rootfs0
+global pfc.emmc_rootfs1
+global pfc.nand
+global pfc.nand_ubidata
+global pfc.nand_ubidata_rootfs0
+global pfc.nand_ubidata_rootfs1
+global pfc.nand_ubidata_boot
+global pfc.nand_rootfs0
+global pfc.nand_rootfs1
+global pfc.nand_boot
+global pfc.nand_mlo_parts
+global pfc.nand_boot_parts
+global pfc.barebox_uart
+global pfc.barebox_linux_uart
+global pfc.linux_uart
+global pfc.eth
+global pfc.debug_mode_active
+global pfc.watchdog_timeout_linux_load
+global pfc.watchdog_timeout_linux_boot
+global pfc.linux_uart_device
+global pfc.eeprom_dev
+global pfc.usbgadget_options
+global pfc.disable_sd_boot
+global pfc.dhcpboot
+
+global bootchooser.rootfs.1.boot
+global bootchooser.rootfs.2.boot
+global linux.bootargs.productionmode
+global linux.bootargs.watchdog
+
+################################
+# global variable description
+################################
+magicvar -a global.pfc.boot_mode	"indicates boot state of this pfc device
+                                         possible values are:
+					 <default, production, setupfw, broken>"
+
+magicvar -a global.pfc.devconf		"copy value from eeprom xsection"
+magicvar -a global.pfc.boot_mode_id	"copy value from eeprom xsection"
+magicvar -a global.pfc.boot_mode_id_ext	"copy value from eeprom xsection"
+
+magicvar -a global.pfc.ethaddr_is_valid	"indicates if the configured ethaddr of
+					 eth0 is valid. Is valid when it matches
+					 the pattern 00:30:de possible values
+					 are: <valid, not_valid>"
+
+magicvar -a global.pfc.downgrade_img	"path to the downgrade image file on the
+					 sd card vfat boot partition"
+
+magicvar -a global.pfc.custom_sh	"path to the custom-setup script file on
+					 the sd card vfat boot partition"
+
+magicvar -a global.pfc.sd		"path to the sd card device"
+magicvar -a global.pfc.sd_boot		"path to the sd cards boot partition"
+magicvar -a global.pfc.sd_rootfs	"path to the sd cards rootfs partition"
+magicvar -a global.pfc.sd_dev_boot	"path to the sd cards boot partition
+					 device"
+
+magicvar -a global.pfc.sd_dev_rootfs	"path to the sd cards rootfs partition
+					 device"
+
+magicvar -a global.pfc.emmc_name	"name of the emmc in /dev"
+magicvar -a global.pfc.emmc		"path to the emmc device"
+magicvar -a global.pfc.emmc_dev_boot	"path to the emmc boot device"
+magicvar -a global.pfc.emmc_dev_rootfs0	"path to the emmc rootfs0 device"
+magicvar -a global.pfc.emmc_dev_rootfs1	"path to the emmc rootfs1 device"
+magicvar -a global.pfc.emmc_dev_home0	"path to the emmc home0 device"
+magicvar -a global.pfc.emmc_dev_home1	"path to the emmc home1 device"
+magicvar -a global.pfc.emmc_boot	"path to emmcs boot partition"
+magicvar -a global.pfc.emmc_rootfs0	"path to emmcs rootfs0 partition"
+magicvar -a global.pfc.emmc_rootfs1	"path to emmcs rootfs1 partition"
+magicvar -a global.pfc.nand		"path to the nand device"
+magicvar -a global.pfc.nand_ubidata	"path to the nand ubidata device"
+magicvar -a global.pfc.nand_ubidata_rootfs0 "path to the nand ubidata rootfs0
+					     device"
+
+magicvar -a global.pfc.nand_ubidata_rootfs1 "path to the nand ubidata rootfs1
+					     device"
+
+magicvar -a global.pfc.nand_ubidata_boot "path to the nand ubidata boot device"
+
+magicvar -a global.pfc.nand_rootfs0	"path to the nand rootfs0 partition"
+magicvar -a global.pfc.nand_rootfs1	"path to the nand rootfs1 partition"
+magicvar -a global.pfc.nand_boot	"path to the nand boot partition"
+magicvar -a global.pfc.nand_mlo_parts	"list of mlo partition paths"
+magicvar -a global.pfc.nand_boot_parts  "list of barebox (2nd stage) partition paths"
+magicvar -a global.pfc.barebox_uart	"uart device that is used in barebox for
+					 console messages"
+
+magicvar -a global.pfc.barebox_linux_uart "uart device that is used in linux for
+					    console messages, when uart bit is
+					    disabled and developer bit is
+					    enabled. E.g. in AM35xx barebox uart
+					    is 3 but corrosponding linux uart is
+					    2."
+
+
+magicvar -a global.pfc.linux_uart	"uart device that that the kernel uses
+					 for console messages"
+
+magicvar -a global.pfc.eth		"ethernet device that is used in all pfc
+					 devices"
+
+magicvar -a global.pfc.debug_mode_active "true if debug mode bit in boot_mode_id
+					  is set; false otherwise"
+
+magicvar -a global.pfc.watchdog_timeout_linux_load "watchdog timeout when trying
+						    to load the linux kernel in
+						    to ram"
+
+magicvar -a global.pfc.watchdog_timeout_linux_boot "watchdog timeout when trying
+						    to boot the linux kernel. Is
+						    resetted when the kernel driver
+						    is probed"
+
+magicvar -a global.pfc.linux_uart_device "uart device string that is used when
+					  configuring the kernel parameter (e.g
+					  ttyO, ttymxc)."
+
+
+magicvar -a global.linux.bootargs.productionmode "parameter for starting setupfw
+						  in production or wsc mode"
+magicvar -a global.linux.bootargs.watchdog "board specific watchdog kernel parameter"
+magicvar -a global.pfc.eeprom_dev "path to eeprom device"
+magicvar -a global.pfc.usbgadget_options "options to activate when usbgadget is
+					  used. By default fastboot-, fastboot
+					  bbu- and CDC ACM-Functions are
+					  activated"
+magicvar -a global.pfc.disable_sd_boot "is set during boot phase and disables sd
+					firmware boot, Mode is derived from
+					boot-mode-id-ext."
+magicvar -a global.pfc.dhcpboot "is set during boot and enables dhcpboot mode
+				based on the flag in boot-mode-id-ext."
+
+
+
+################################
+# global variable initialisation
+################################
+[ -z "${global.pfc.boot_mode}" ] && global.pfc.boot_mode="${bootmatrix.mode}"
+[ -z "${global.pfc.devconf}" ] && global.pfc.devconf="${xsection.devconf}"
+[ -z "${global.pfc.boot_mode_id}" ] && global.pfc.boot_mode_id="${xsection.boot_mode_id}"
+[ -z "${global.pfc.boot_mode_id_ext}" ] && global.pfc.boot_mode_id_ext="${xsection.boot_mode_id_ext}"
+[ -z "${global.pfc.ethaddr_is_valid}" ] && global.pfc.ethaddr_is_valid=false
+[ -z "${global.pfc.sd}" ] && global.pfc.sd="/dev/mmc0"
+[ -z "${global.pfc.sd_boot}" ] && global.pfc.sd_boot="/mnt/sd_boot"
+[ -z "${global.pfc.sd_rootfs}" ] && global.pfc.sd_rootfs="/mnt/sd_rootfs"
+[ -z "${global.pfc.sd_dev_boot}" ] && global.pfc.sd_dev_boot="${global.pfc.sd}.0"
+[ -z "${global.pfc.sd_dev_rootfs}" ] && global.pfc.sd_dev_rootfs="${global.pfc.sd}.1"
+[ -z "${global.pfc.emmc_name}" ] && global.pfc.emmc_name="mmc1"
+[ -z "${global.pfc.emmc}" ] && global.pfc.emmc="/dev/${global.pfc.emmc_name}"
+[ -z "${global.pfc.emmc_dev_boot}" ] && global.pfc.emmc_dev_boot="${global.pfc.emmc}.0"
+[ -z "${global.pfc.emmc_dev_rootfs0}" ] && global.pfc.emmc_dev_rootfs0="${global.pfc.emmc}.4"
+[ -z "${global.pfc.emmc_dev_rootfs1}" ] && global.pfc.emmc_dev_rootfs1="${global.pfc.emmc}.7"
+[ -z "${global.pfc.emmc_dev_home0}" ] && global.pfc.emmc_dev_home0="${global.pfc.emmc}.5"
+[ -z "${global.pfc.emmc_dev_home1}" ] && global.pfc.emmc_dev_home1="${global.pfc.emmc}.6"
+[ -z "${global.pfc.emmc_boot}" ] && global.pfc.emmc_boot="/mnt/mmc1.0"
+[ -z "${global.pfc.emmc_rootfs0}" ] && global.pfc.emmc_rootfs0="/mnt/emmc_rootfs0"
+[ -z "${global.pfc.emmc_rootfs1}" ] && global.pfc.emmc_rootfs1="/mnt/emmc_rootfs1"
+[ -z "${global.pfc.nand}" ] && global.pfc.nand="/dev/nand0"
+[ -z "${global.pfc.nand_ubidata}" ] && global.pfc.nand_ubidata="${global.pfc.nand}.ubidata"
+[ -z "${global.pfc.nand_ubidata_rootfs0}" ] && global.pfc.nand_ubidata_rootfs0="${global.pfc.nand}.ubidata.ubi.rootfs.1"
+[ -z "${global.pfc.nand_ubidata_rootfs1}" ] && global.pfc.nand_ubidata_rootfs1="${global.pfc.nand}.ubidata.ubi.rootfs.2"
+[ -z "${global.pfc.nand_ubidata_boot}" ] && global.pfc.nand_ubidata_boot="${global.pfc.nand}.ubidata.ubi.boot"
+[ -z "${global.pfc.nand_rootfs0}" ] && global.pfc.nand_rootfs0="/mnt/ubi_rootfs0"
+[ -z "${global.pfc.nand_rootfs1}" ] && global.pfc.nand_rootfs1="/mnt/ubi_rootfs1"
+[ -z "${global.pfc.nand_boot}" ] && global.pfc.nand_boot="/mnt/ubi_boot"
+[ -z "${global.pfc.nand_mlo_parts}" ] && global.pfc.nand_mlo_parts="${global.pfc.nand}.mlo0 ${global.pfc.nand}.mlo1 ${global.pfc.nand}.mlo2 ${global.pfc.nand}.mlo3"
+[ -z "${global.pfc.nand_boot_parts}" ] && global.pfc.nand_boot_parts="${global.pfc.nand}.boot0 ${global.pfc.nand}.boot1 ${global.pfc.nand}.boot2 ${global.pfc.nand}.boot3"
+[ -z "${global.pfc.eeprom_dev}" ] && global.pfc.eeprom_dev="/dev/eeprom0"
+
+[ -z "${global.pfc.downgrade_img}" ] && global.pfc.downgrade_img="${global.pfc.sd_boot}/downgrade.bin.$global.board.variant"
+[ -z "${global.pfc.custom_sh}" ] && global.pfc.custom_sh="${global.pfc.sd_boot}/custom_setup.sh"
+[ -z "${global.pfc.barebox_uart}" ] && global.pfc.barebox_uart="0"
+[ -z "${global.pfc.barebox_linux_uart}" ] && global.pfc.barebox_linux_uart="0"
+[ -z "${global.pfc.linux_uart}" ] && global.pfc.linux_uart="1"
+[ -z "${global.pfc.eth}" ] && global.pfc.eth="eth0"
+[ -z "${global.pfc.debug_mode_active}" ] && global.pfc.debug_mode_active=false
+[ -z "${global.pfc.watchdog_timeout_linux_load}" ] && global.pfc.watchdog_timeout_linux_load=20
+[ -z "${global.pfc.watchdog_timeout_linux_boot}" ] && global.pfc.watchdog_timeout_linux_boot=30
+[ -z "${global.pfc.debug_mode_active}" ] && global.pfc.debug_mode_active=false
+[ -z "${global.pfc.linux_uart_device}" ] && global.pfc.linux_uart_device="ttyO"
+[ -z "${global.pfc.usbgadget_options}" ] && global.pfc.usbgadget_options="-A -b -a"
+[ -z "${global.pfc.disable_sd_boot}" ] && global.pfc.disable_sd_boot=0
+[ -z "${global.pfc.dhcpboot}" ] && global.pfc.dhcpboot=0
+
+[ -z "${global.bootchooser.targets}" ] && global.bootchooser.targets="rootfs.1 rootfs.2"
+[ -z "${global.bootchooser.state_prefix}" ] && global.bootchooser.state_prefix="bootstate"
+[ -z "${global.bootchooser.reset_attempts}" ] && global.bootchooser.reset_attempts="all-zero power-on"
+[ -z "${global.bootchooser.reset_priorities}" ] && global.bootchooser.reset_priorities="all-zero"
+[ -z "${global.bootchooser.disable_on_zero_attempts}" ] && global.bootchooser.disable_on_zero_attempts=0
+[ -z "${global.bootchooser.retry}" ] && global.bootchooser.retry=1
+
+[ -z "${global.linux.bootargs.watchdog}" ] && global.linux.bootargs.watchdog="omap_wdt.early_enable omap_wdt.timer_margin=${global.pfc.watchdog_timeout_linux_boot}"
+[ -z "${global.usbgadget.fastboot_bbu}" ] && global.usbgadget.fastboot_bbu=1
+[ -z "${global.usbgadget.fastboot_function}" ] && global.usbgadget.fastboot_function="/kernel(kernel)c,/initrd(initrd)c,/devicetree(devicetree)c,${global.pfc.emmc_dev_boot}(boot)c,${global.pfc.emmc_dev_rootfs0}(rootfs1)c,${global.pfc.emmc_dev_rootfs1}(rootfs2)c,${global.pfc.sd_dev_boot}(boot_sd)c,${global.pfc.sd_dev_rootfs}(rootfs_sd)c,${global.pfc.eeprom_dev}(eeprom)c,${global.pfc.emmc_dev_home0}(home1)c,${global.pfc.emmc_dev_home1}(home2)c,/parttable(parttable)c"
diff --git a/defaultenv/defaultenv-pfc-base/data/print-msg-formats b/defaultenv/defaultenv-pfc-base/data/print-msg-formats
new file mode 100644
index 0000000..3442e99
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/data/print-msg-formats
@@ -0,0 +1,9 @@
+#!/bin/sh
+
+# here we are defining some print messages formats,
+# that are sourced and used in scripts.
+
+info="\e[00;32mINFO: PFC\e[00m: "
+error="\e[00;31mERROR: PFC\e[00m: "
+warning="\e[00;33mWARN: PFC\e[00m: "
+
diff --git a/defaultenv/defaultenv-pfc-base/init/automount b/defaultenv/defaultenv-pfc-base/init/automount
new file mode 100644
index 0000000..527b363d
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/automount
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+[ -e "${global.pfc.nand_ubidata}" ] && automount -d ${global.pfc.nand_rootfs0} "[ ! -e ${global.pfc.nand_ubidata_rootfs0} ] && ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_rootfs0} ${global.pfc.nand_rootfs0}"
+[ -e "${global.pfc.nand_ubidata}" ] && automount -d ${global.pfc.nand_rootfs1} "[ ! -e ${global.pfc.nand_ubidata_rootfs1} ] && ubiattach ${global.pfc.nand_ubidata}; mount -t ubifs ${global.pfc.nand_ubidata_rootfs1} ${global.pfc.nand_rootfs1}"
+[ -e "${global.pfc.emmc_dev_rootfs0}" ] && automount -d ${global.pfc.emmc_rootfs0} "mount ${global.pfc.emmc_dev_rootfs0} ${global.pfc.emmc_rootfs0}"
+[ -e "${global.pfc.emmc_dev_rootfs1}" ] && automount -d ${global.pfc.emmc_rootfs1} "mount ${global.pfc.emmc_dev_rootfs1} ${global.pfc.emmc_rootfs1}"
+[ -e "${global.pfc.sd_dev_rootfs}" ] && automount -d ${global.pfc.sd_rootfs} "mount ${global.pfc.sd_dev_rootfs} ${global.pfc.sd_rootfs}"
+[ -e "${global.pfc.sd_dev_boot}" ] && automount -d ${global.pfc.sd_boot} "mount ${global.pfc.sd_dev_boot} ${global.pfc.sd_boot}"
diff --git a/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize b/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize
new file mode 100644
index 0000000..1045e1a
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/pfc-max-tftp-bsize
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+global.tftp.blocksize=1432
diff --git a/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup b/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup
new file mode 100644
index 0000000..d597e55
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init/z-pfc-config-startup
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+pfc-detect-boot-mode
+
+if [ "${global.pfc.boot_mode}" = "default" ]; then
+	pfc-config-default-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: could not configure default boot"
+		pfc-config-broken-boot
+		exit 1
+	fi
+
+elif [ "${global.pfc.boot_mode}" = "production" ]; then
+	pfc-config-production-boot
+
+elif [ "${global.pfc.boot_mode}" = "setupfw" ]; then
+	pfc-config-setupfw-boot
+
+elif [ "${global.pfc.boot_mode}" = "downgrade" ]; then
+	pfc-exec-downgrade-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: failed to execute downgrade boot"
+		led_mode -s -c yellow -v off
+		led_mode -s -c red -v on
+		exit 1
+	fi
+
+elif [ "${global.pfc.boot_mode}" = "custom" ]; then
+	pfc-exec-custom-boot
+	if [ "$?" = 1 ]; then
+		echo -e ${error} "$0: failed to execute custom script"
+		led_mode -s -c yellow -v off
+		led_mode -s -c red -v on
+		exit 1
+	fi
+
+else
+	pfc-config-broken-boot
+	exit 1
+fi
+
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset b/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset
new file mode 100644
index 0000000..46e08fb
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/a-pfc-switch-reset
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+source env/data/print-msg-formats
+
+# Hint: on am35xx based devices we do not need to get the switch out of reset
+# manually. This is already done by the hardware reset-logic.
+
+if [ "${global.autoboot}" = 0 -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+if [ ${global.pfc.sw_reset_gpio} -eq -1 ]; then
+	echo -e ${warning} "no switch reset pin defined for board \e[00;32m${global.board.variant}\e[00m"
+	exit 0
+else
+	echo -n -e ${info} "reset switch for board \e[00;32m${global.board.variant}\e[00m with gpio pin "
+	echo "${global.pfc.sw_reset_gpio}"
+fi
+
+gpio_direction_output "${global.pfc.sw_reset_gpio}" 0
+msleep 1
+gpio_direction_output "${global.pfc.sw_reset_gpio}" 1
+# give the switch and phys some time to wakeup from reset
+msleep 1000
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg
new file mode 100644
index 0000000..93301e8
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-disable-wdg
@@ -0,0 +1,5 @@
+#!/bin/sh
+
+if [ "${global.autoboot}" != 0 ] || [ "${global.pfc.boot_mode}" != "default" ] && [ "${global.pfc.boot_mode}" != "broken" ]; then
+	global.boot.watchdog_timeout=0
+fi
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup
new file mode 100644
index 0000000..79d7cfc
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-ksz8863-setup
@@ -0,0 +1,60 @@
+#!/bin/sh
+
+# To determine if we are on a micrel ks8863 based device we can not read then
+# switch identifier register. This lack comes due to an unssported operation code
+# of the cpu to get the values from the micrel ethernet switch. Instead we read
+# the interal phy_id registers of the micrel switch.
+
+source env/data/print-msg-formats
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+phy_x1_addr=1
+phy_x2_addr=2
+
+# registers
+control_reg=0
+phy_id_high_reg=2
+phy_id_low_reg=3
+
+# register values
+#
+# Init values according to Data Sheet:
+# "AN enable" (Auto-negotiation enabled) = 1
+# "Hp_mdix" (HP Auto MDI/MDI-X mode) = 1
+#
+auto_neg_mdi_enable=4128	# 0x1020
+phy_id_high_val=34		# 0x22
+phy_id_low_val=5168		# 0x1430
+
+if [ "${global.autoboot}" = 0 -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+# read phy id regs to check if we are on a micrel based device. Its sufficient to
+# read only the phy id of phy_x1.
+miitool -x "${mii_bus}:${phy_x1_addr}:${phy_id_high_reg}" -p read_phy_id_high_val
+miitool -x "${mii_bus}:${phy_x1_addr}:${phy_id_low_reg}" -p read_phy_id_low_val
+
+if [ "${read_phy_id_high_val}" != "${phy_id_high_val}" ] && [ "${read_phy_id_low_val}" != "${phy_id_low_reg}" ]; then
+	exit 0
+fi
+
+echo -e ${info} "Micrel KSZ8863 switch detected"
+
+# enable auto-negotiation and auto-mdi-x mode
+miitool -w "${mii_bus}:${phy_x1_addr}:${control_reg}" -p auto_neg_mdi_enable
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable auto-neg-mdi PHY of port X1"
+	exit 1
+fi
+
+miitool -w "${mii_bus}:${phy_x2_addr}:${control_reg}" -p auto_neg_mdi_enable
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not enable auto-neg-mdi PHY of port X2"
+	exit 1
+fi
+
+exit 0
diff --git a/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup
new file mode 100644
index 0000000..f05cfd5
--- /dev/null
+++ b/defaultenv/defaultenv-pfc-base/init_post_autoboot/pfc-mv88e6321-setup
@@ -0,0 +1,173 @@
+#!/bin/sh
+
+# mii bus
+mii_bus=0
+
+# mii addresses
+sw_port0_addr=16
+g2_addr=28
+
+# mii registers
+sw_id_reg=3
+sw_port_status_reg=0
+g2_smi_cmd_reg=24
+g2_smi_data_reg=25
+
+# constants / flags
+mv88e6321_product_id=784
+
+sw_port_phy_detect_flag="0x1000"
+
+smi_busy_flag="0x8000"
+smi_cmd_c22_mode="0x1000"
+smi_cmd_write="0x400"
+smi_cmd_read="0x800"
+
+phy_power_down_flag="0x800"
+
+source env/data/print-msg-formats
+
+if [ "${global.autoboot}" = 0 -a "${global.pfc.boot_mode}" = "default" ]; then
+	exit 0
+fi
+
+miitool -x "${mii_bus}:${sw_port0_addr}:${sw_id_reg}" -p switch_id
+if [ "$?" != 0 ]; then
+	exit 0
+fi
+
+# ignore chip reversion
+let switch_product_id="${switch_id} >> 4"
+
+if [ ${switch_product_id} != ${mv88e6321_product_id} ]; then
+	exit 0
+fi
+
+echo -e ${info} "Marvel MV88E6321 switch detected"
+
+# set phy detection flag
+miitool -x "${mii_bus}:${sw_port0_addr}:${sw_port_status_reg}" -p sw_port0_status
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not read switch port0 status"
+	exit 1
+fi
+
+let sw_port0_new_status="${sw_port0_status} | ${sw_port_phy_detect_flag}"
+
+miitool -w "${mii_bus}:${sw_port0_addr}:${sw_port_status_reg}" -p sw_port0_new_status
+if [ "$?" != 0 ]; then
+	echo -e ${error} "Could not write new switch port0 status"
+	exit 1
+fi
+
+# power up external phy
+
+# wait for SMI command ready
+smi_busy=1
+smi_tries=3
+
+# the device address is in bits 9:5 of the smi command
+# ports 0, 1, 3, 4
+for device_address in 0 32 96 128; do
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+
+	# set power down of phy control register to zero
+	let g2_smi_cmd="${smi_busy_flag} | ${smi_cmd_c22_mode} | ${smi_cmd_read} | ${device_address}"
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI command"
+		exit 1
+	fi
+
+	miitool -x "${mii_bus}:${g2_addr}:${g2_smi_data_reg}" -p g2_smi_data
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not read G2 SMI data"
+		exit 1
+	fi
+
+	let g2_smi_data="${g2_smi_data} & ~${phy_power_down_flag}"
+
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_data_reg}" -p g2_smi_data
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI data"
+		exit 1
+	fi
+
+	smi_busy=1
+	smi_tries=3
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+
+	let g2_smi_cmd="${smi_busy_flag} | ${smi_cmd_c22_mode} | ${smi_cmd_write} | ${device_address}"
+	miitool -w "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+	if [ "$?" != 0 ]; then
+		echo -e ${error} "Could not write G2 SMI command"
+		exit 1
+	fi
+
+	# wait until phy is ready
+	smi_busy=1
+	smi_ties=3
+
+	while [ "${smi_busy}" != 0 ]; do
+		miitool -x "${mii_bus}:${g2_addr}:${g2_smi_cmd_reg}" -p g2_smi_cmd
+		if [ "$?" != 0 ]; then
+			echo -e ${error} "Could not read switch G2 SMI command register"
+			exit 1
+		fi
+
+		let smi_busy="${g2_smi_cmd} & ${smi_busy_flag}"
+
+		let smi_tries="${smi_tries} - 1"
+
+		if [ "${smi_busy}" != 0 ]; then
+			if [ "${smi_tries}" = 0 ]; then
+				echo -e ${error} "Switch SMI busy"
+				exit 1
+			else
+				sleep 1
+			fi
+		fi
+	done
+done
+
+exit 0
diff --git a/drivers/bus/omap-gpmc.c b/drivers/bus/omap-gpmc.c
index be9ef92..33ea59a 100644
--- a/drivers/bus/omap-gpmc.c
+++ b/drivers/bus/omap-gpmc.c
@@ -449,6 +449,12 @@ static struct dt_eccmode modes[] = {
 		.name = "bch8",
 		.mode = OMAP_ECC_BCH8_CODE_HW_ROMCODE,
 	},
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+	{
+		.name = "bch8-hw-det-sw",
+		.mode = OMAP_ECC_BCH8_CODE_HW_DETECTION_SW,
+	},
+#endif
 };
 
 static int gpmc_probe_nand_child(struct device_d *dev,
diff --git a/drivers/eeprom/at24.c b/drivers/eeprom/at24.c
index 4fae3a1..ffac69e 100644
--- a/drivers/eeprom/at24.c
+++ b/drivers/eeprom/at24.c
@@ -476,6 +476,12 @@ static int at24_probe(struct device_d *dev)
 		enum of_gpio_flags flags;
 		at24->wp_gpio = of_get_named_gpio_flags(dev->device_node,
 				"wp-gpios", 0, &flags);
+
+		if (at24->wp_gpio == -EPROBE_DEFER) {
+			err = at24->wp_gpio;
+			goto err_probe_defer;
+		}
+
 		if (gpio_is_valid(at24->wp_gpio)) {
 			at24->wp_active_low = flags & OF_GPIO_ACTIVE_LOW;
 			gpio_request(at24->wp_gpio, "eeprom-wp");
@@ -515,6 +521,7 @@ err_clients:
 
 	if (gpio_is_valid(at24->wp_gpio))
 		gpio_free(at24->wp_gpio);
+err_probe_defer:
 	kfree(at24->writebuf);
 err_device_name:
 	kfree(at24);
diff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c
index bdb34ca..61ddf43 100644
--- a/drivers/i2c/busses/i2c-omap.c
+++ b/drivers/i2c/busses/i2c-omap.c
@@ -1121,7 +1121,11 @@ i2c_omap_probe(struct device_d *pdev)
 	 * Also since the omap_i2c_read_reg uses reg_map_ip_* a
 	 * raw_readw is done.
 	 */
-	rev = __raw_readw(i2c_omap->base + 0x04);
+	if (!of_machine_is_compatible("ti,omap3") &&
+					!of_machine_is_compatible("ti,omap2"))
+		rev = __raw_readw(i2c_omap->base + 0x04);
+	else
+		rev = 0;
 
 	i2c_omap->scheme = OMAP_I2C_SCHEME(rev);
 	switch (i2c_omap->scheme) {
diff --git a/drivers/mci/mci-core.c b/drivers/mci/mci-core.c
index c6b4e02..88e7db2 100644
--- a/drivers/mci/mci-core.c
+++ b/drivers/mci/mci-core.c
@@ -35,6 +35,7 @@
 #include <block.h>
 #include <disks.h>
 #include <of.h>
+#include <of_gpio.h>
 #include <linux/err.h>
 
 #define MAX_BUFFER_NUMBER 0xffffffff
@@ -1579,29 +1580,23 @@ static const char *mci_boot_names[] = {
 	"user",
 };
 
-static int mci_register_partition(struct mci_part *part)
+static int mci_get_cd(struct param_d *param, void *priv)
 {
-	struct mci *mci = part->mci;
+	struct mci *mci = priv;
 	struct mci_host *host = mci->host;
-	const char *partnodename = NULL;
-	struct device_node *np;
-	int rc;
 
-	/*
-	 * An MMC/SD card acts like an ordinary disk.
-	 * So, re-use the disk driver to gain access to this media
-	 */
-	part->blk.dev = &mci->dev;
-	part->blk.ops = &mci_ops;
+	mci->cd = host->card_present(host);
 
-	rc = blockdevice_register(&part->blk);
-	if (rc != 0) {
-		dev_err(&mci->dev, "Failed to register MCI/SD blockdevice\n");
-		return rc;
-	}
-	dev_info(&mci->dev, "registered %s\n", part->blk.cdev.name);
+	return 0;
+}
 
-	np = host->hw_dev->device_node;
+static void mci_create_partitions_ondemand(struct mci_part *part)
+{
+	struct mci *mci = part->mci;
+	struct mci_host *host = mci->host;
+	struct device_node *np = host->hw_dev->device_node;
+	const char *partnodename = NULL;
+	int rc;
 
 	/* create partitions on demand */
 	switch (part->area_type) {
@@ -1617,7 +1612,7 @@ static int mci_register_partition(struct mci_part *part)
 	case MMC_BLK_DATA_AREA_MAIN:
 		break;
 	default:
-		return 0;
+		return;
 	}
 
 	rc = parse_partition_table(&part->blk);
@@ -1630,6 +1625,46 @@ static int mci_register_partition(struct mci_part *part)
 		of_parse_partitions(&part->blk.cdev, np);
 		of_partitions_register_fixup(&part->blk.cdev);
 	}
+}
+
+static int mci_register_partition(struct mci_part *part)
+{
+	struct mci *mci = part->mci;
+	int rc;
+
+	/*
+	 * An MMC/SD card acts like an ordinary disk.
+	 * So, re-use the disk driver to gain access to this media
+	 */
+	part->blk.dev = &mci->dev;
+	part->blk.ops = &mci_ops;
+
+	rc = blockdevice_register(&part->blk);
+	if (rc != 0) {
+		dev_err(&mci->dev, "Failed to register MCI/SD blockdevice\n");
+		return rc;
+	}
+	dev_info(&mci->dev, "registered %s\n", part->blk.cdev.name);
+
+	mci_create_partitions_ondemand(part);
+
+	return 0;
+}
+
+static int mci_set_scan(struct param_d *param, void *priv)
+{
+	struct mci *mci = priv;
+	int rc, i;
+
+	if (!mci->scan)
+		return 0;
+
+	rc = mci_check_if_already_initialized(mci);
+	if (rc == 0)
+		return rc;
+
+	for (i = 0; i < mci->nr_parts; i++)
+		mci_create_partitions_ondemand(&mci->part[i]);
 
 	return 0;
 }
@@ -1722,6 +1757,10 @@ static int mci_card_probe(struct mci *mci)
 		}
 	}
 
+	if (!mci->param_cd && host->card_present)
+		mci->param_cd = dev_add_param_bool(&mci->dev, "cd", NULL,
+						mci_get_cd, &mci->cd, mci);
+
 	dev_dbg(&mci->dev, "SD Card successfully added\n");
 
 on_error:
@@ -1834,6 +1873,14 @@ int mci_register(struct mci_host *host)
 		goto err_unregister;
 	}
 
+	mci->param_scan = dev_add_param_bool(&mci->dev, "scan",
+			mci_set_scan, NULL, &mci->scan, mci);
+
+	if (IS_ERR(mci->param_scan) && PTR_ERR(mci->param_probe) != -ENOSYS) {
+		dev_dbg(&mci->dev, "Failed to add 'scan' parameter to the MCI device\n");
+		goto err_unregister;
+	}
+
 	if (IS_ENABLED(CONFIG_MCI_INFO))
 		mci->dev.info = mci_info;
 
@@ -1904,6 +1951,8 @@ void mci_of_parse_node(struct mci_host *host,
 
 	host->non_removable = of_property_read_bool(np, "non-removable");
 	host->no_sd = of_property_read_bool(np, "no-sd");
+	host->cd_gpio = of_get_named_gpio(np, "cd-gpios", 0);
+	host->cd_inverted = of_property_read_bool(np, "cd-inverted");
 }
 
 void mci_of_parse(struct mci_host *host)
diff --git a/drivers/mci/omap_hsmmc.c b/drivers/mci/omap_hsmmc.c
index cbc69e4..bf820c8 100644
--- a/drivers/mci/omap_hsmmc.c
+++ b/drivers/mci/omap_hsmmc.c
@@ -27,6 +27,7 @@
 #include <errno.h>
 #include <io.h>
 #include <linux/err.h>
+#include <gpio.h>
 
 #include <mach/omap_hsmmc.h>
 
@@ -582,6 +583,18 @@ static int omap_mmc_detect(struct device_d *dev)
 	return mci_detect_card(&hsmmc->mci);
 }
 
+static int mmc_card_present(struct mci_host *mci)
+{
+	if (mci->non_removable)
+		return 1;
+
+	if (!gpio_is_valid(mci->cd_gpio) || gpio_direction_input(mci->cd_gpio))
+		return 0;
+
+	return mci->cd_inverted ? !gpio_get_value(mci->cd_gpio) :
+						gpio_get_value(mci->cd_gpio);
+}
+
 static int omap_mmc_probe(struct device_d *dev)
 {
 	struct resource *iores;
@@ -601,6 +614,7 @@ static int omap_mmc_probe(struct device_d *dev)
 	hsmmc->mci.send_cmd = mmc_send_cmd;
 	hsmmc->mci.set_ios = mmc_set_ios;
 	hsmmc->mci.init = mmc_init_setup;
+	hsmmc->mci.card_present = mmc_card_present;
 	hsmmc->mci.host_caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED |
 		MMC_CAP_MMC_HIGHSPEED | MMC_CAP_8_BIT_DATA;
 	hsmmc->mci.hw_dev = dev;
@@ -623,6 +637,9 @@ static int omap_mmc_probe(struct device_d *dev)
 
 		if (pdata->devname)
 			hsmmc->mci.devname = pdata->devname;
+
+		hsmmc->mci.cd_gpio = pdata->cd_gpio;
+		hsmmc->mci.cd_inverted = pdata->cd_inverted;
 	}
 
 	if (dev->device_node) {
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 6640a70..c1874bf 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -20,4 +20,23 @@ config STATE_DRV
 	depends on OFDEVICE
 	depends on STATE
 
+if MACH_WAGO_PFC_AM335X || MACH_WAGO_PFC_AM35XX || MACH_WAGO_VTPCTP_MX6
+config XSECTION
+	bool "Xsection driver"
+	select I2C
+	select I2C_OMAP if ARCH_OMAP
+	select I2C_IMX if ARCH_IMX
+	select EEPROM_AT24
+	help
+	  Controls the XSECTION items that are located e.g. in eeprom like
+	  devconf, boot-mode-id and ethaddr.
+
+config BOOTMATRIX
+	bool "Bootmatrix Driver"
+	help
+	  Detects the boot mode based on pressed keys and exports the boot mode
+	  as a device parameter.
+
+endif
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 487e4b8..db9f57d 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -5,3 +5,5 @@
 obj-$(CONFIG_JTAG)		+= jtag.o
 obj-$(CONFIG_SRAM)		+= sram.o
 obj-$(CONFIG_STATE_DRV)		+= state.o
+obj-$(CONFIG_XSECTION)		+= xsection.o
+obj-$(CONFIG_BOOTMATRIX) 	+= bootmatrix.o
diff --git a/drivers/misc/bootmatrix.c b/drivers/misc/bootmatrix.c
new file mode 100644
index 0000000..e7f7156
--- /dev/null
+++ b/drivers/misc/bootmatrix.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <driver.h>
+#include <init.h>
+#include <malloc.h>
+#include <of.h>
+#include <libbb.h>
+#include <fcntl.h>
+#include <linux/err.h>
+#include <gpio.h>
+#include <of_gpio.h>
+#include <linux/types.h>
+#include <linux/bitmap.h>
+#include <bootmatrix.h>
+#include <led_mode.h>
+
+#define MAX_KEY_BITS 8
+
+enum bootmatrix_states {
+	INIT,
+	MULTI_KEY_MODE,
+	SINGLE_KEY_MODE_STAGE1,
+	SINGLE_KEY_MODE_STAGE2,
+};
+
+enum bootmatrix_key_num {
+	RST = 0,
+	RUN,
+	STOP,
+	RESET,
+};
+
+struct bootmatrix_key {
+	int gpio;
+	int active_low;
+};
+
+struct bootmatrix {
+	struct device_d dev;
+	struct bootmatrix_key *keys;
+	struct param_d *param_mode;
+	int num_bootmatrix_keys;
+	int rst_timeout;
+	int mode;
+	bool single_key_mode;
+	DECLARE_BITMAP(matrix, MAX_KEY_BITS);
+};
+
+struct bootmatrix *bootmatrix;
+
+static void bootmatrix_get_current_key_values(struct bootmatrix *bootmatrix)
+{
+	int i, val, pressed;
+	struct bootmatrix_key *key;
+
+	bitmap_zero(bootmatrix->matrix, MAX_KEY_BITS);
+
+	for (i = RST; i < bootmatrix->num_bootmatrix_keys; i++) {
+
+		key = &bootmatrix->keys[i];
+		val = gpio_get_value(key->gpio);
+		pressed = val != key->active_low;
+
+		if (pressed)
+			set_bit(i, bootmatrix->matrix);
+	}
+}
+
+/* We implement the following two logics to detect the bootmode:
+ *
+ * SINGLE_KEY_MODE: some device have only one RST-key implemented. In this case
+ * the production mode is detected when the half of the configured timeout is
+ * reached. The setupfw mode is detected when the full configured timeout is
+ * reached.
+ *
+ * MULTI_KEY_MODE: this mode is the original mode for devices that have the keys
+ * RUN,STOP,RESET and RST implemented. For entering the setupfw mode one has to
+ * hold RST and RESET for a minimum of 7 sec. If one releases the RESET key the
+ * device enters production mode. In all other cases we will fallback into the
+ * default mode.
+ */
+static enum bootmatrix_mode bootmatrix_detect_mode(struct bootmatrix
+							*bootmatrix)
+{
+	enum bootmatrix_mode mode = DEFAULT;
+	enum bootmatrix_states state = INIT;
+	unsigned long *matrix = bootmatrix->matrix;
+	bool exit = false;
+	bool single_key = bootmatrix->single_key_mode;
+	int timeout = bootmatrix->rst_timeout;
+	uint64_t start;
+
+	bootmatrix_get_current_key_values(bootmatrix);
+	if (test_bit(RST, matrix) && (test_bit(RESET, matrix) || single_key)) {
+
+		led_mode_static("green", true);
+
+		start = get_time_ns();
+		while (!exit) {
+
+			bootmatrix_get_current_key_values(bootmatrix);
+			switch (state) {
+			case INIT:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (single_key && test_bit(RST, matrix)) {
+					state = SINGLE_KEY_MODE_STAGE1;
+				} else if (test_bit(RST, matrix) &&
+						test_bit(RESET, matrix)) {
+					state = MULTI_KEY_MODE;
+				}
+				break;
+
+			case SINGLE_KEY_MODE_STAGE1:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (is_timeout(start, (timeout / 2) *
+								      SECOND)) {
+					mode = PRODUCTION;
+					state = SINGLE_KEY_MODE_STAGE2;
+					led_mode_static("green", false);
+				}
+				break;
+
+			case SINGLE_KEY_MODE_STAGE2:
+				if (!test_bit(RST, matrix)) {
+					exit = true;
+				} else if (is_timeout(start, timeout * SECOND)) {
+					mode = SETUPFW;
+					exit = true;
+				}
+				break;
+
+			case MULTI_KEY_MODE:
+				if (!test_bit(RST, matrix)) {
+					mode = DEFAULT;
+					exit = true;
+				} else if (!test_bit(RESET, matrix) &&
+							test_bit(STOP, matrix)) {
+					mode = PRODUCTION;
+					exit = true;
+				} else if (is_timeout(start, timeout * SECOND)) {
+					mode = SETUPFW;
+					exit = true;
+				}
+				break;
+			}
+		}
+	}
+
+	return mode;
+}
+
+enum bootmatrix_mode bootmatrix_get_mode()
+{
+	if (!bootmatrix)
+		return -ENODEV;
+
+	if (bootmatrix->mode == UNKNOWN)
+		return -EPROBE_DEFER;
+
+	return bootmatrix->mode;
+}
+
+static int bootmatrix_probe_key(struct device_node *node,
+					struct bootmatrix_key *key, char *name)
+{
+	struct device_node *child;
+	enum of_gpio_flags flags;
+	int ret = 0;
+
+	child = of_find_node_by_name(node, name);
+	if (!child) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	key->gpio = of_get_named_gpio_flags(child, "gpios", 0, &flags);
+	if (key->gpio < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (flags & OF_GPIO_ACTIVE_LOW)
+		key->active_low = 1;
+
+	ret = gpio_request(key->gpio, name);
+	if (ret)
+		goto out;
+
+	ret = gpio_direction_input(key->gpio);
+
+out:
+	return ret < 0 ? ret : 0;
+}
+
+static int bootmatrix_probe_dt(struct bootmatrix *bootmatrix,
+				   struct device_node *node)
+{
+	int ret = 0;
+
+	bootmatrix->num_bootmatrix_keys = of_get_child_count(node);
+	bootmatrix->keys = xzalloc(bootmatrix->num_bootmatrix_keys *
+						sizeof(*bootmatrix->keys));
+
+	if (bootmatrix->num_bootmatrix_keys < 1) {
+		ret = -ENODEV;
+		goto out_free;
+	} else if (bootmatrix->num_bootmatrix_keys == 1) {
+		bootmatrix->single_key_mode = true;
+	} else {
+		bootmatrix->single_key_mode = false;
+	}
+
+	ret = of_property_read_u32(node, "rst-timeout-secs",
+						&bootmatrix->rst_timeout);
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RST], "rst");
+	if (ret)
+		goto out_free;
+
+	/* in single-key-mode we need only the rst key. if we found this key
+	 * terminate here.
+	 */
+	if (bootmatrix->single_key_mode)
+		goto out;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RUN], "run");
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[STOP], "stop");
+	if (ret)
+		goto out_free;
+
+	ret = bootmatrix_probe_key(node, &bootmatrix->keys[RESET], "reset");
+	if (ret)
+		goto out_free;
+
+out:
+	return 0;
+
+out_free:
+	free(bootmatrix->keys);
+	return ret;
+}
+
+static const char *bootmatrix_mode_names[] = {
+	"unknown",
+	"default",
+	"production",
+	"setupfw",
+};
+
+static int bootmatrix_probe(struct device_d *dev)
+{
+	int ret;
+	const char *alias;
+	struct device_node *np = dev->device_node;
+
+	bootmatrix = xzalloc(sizeof(*bootmatrix));
+	bootmatrix->dev.id = DEVICE_ID_SINGLE;
+	bootmatrix->dev.parent = dev;
+	dev->priv = bootmatrix;
+
+	if (!np) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = bootmatrix_probe_dt(bootmatrix, np);
+	if (ret)
+		goto out;
+
+	alias = of_alias_get(np);
+	if (!alias) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	safe_strncpy(bootmatrix->dev.name, alias, MAX_DRIVER_NAME);
+
+	ret = register_device(&bootmatrix->dev);
+	if (ret)
+		goto out;
+
+	bootmatrix->param_mode = dev_add_param_enum(&bootmatrix->dev, "mode",
+				NULL, NULL,
+				&bootmatrix->mode,
+				bootmatrix_mode_names,
+				ARRAY_SIZE(bootmatrix_mode_names),
+				bootmatrix);
+
+	if (IS_ERR(bootmatrix->param_mode)) {
+		ret = -ENODEV;
+		goto out_unreg;
+	}
+
+	bootmatrix->mode = bootmatrix_detect_mode(bootmatrix);
+
+	return 0;
+
+out_unreg:
+	unregister_device(&bootmatrix->dev);
+
+out:
+	free(bootmatrix);
+	dev_err(dev, "failed to probe %d\n", ret);
+
+	return ret;
+}
+
+static void bootmatrix_remove(struct device_d *dev)
+{
+	struct bootmatrix *bootmatrix = dev->priv;
+
+	dev_remove_parameters(&bootmatrix->dev);
+	unregister_device(&bootmatrix->dev);
+	free(bootmatrix->keys);
+	free(bootmatrix);
+}
+
+static __maybe_unused struct of_device_id bootmatrix_ids[] = {
+	{
+		.compatible = "bootmatrix",
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct driver_d bootmatrix_driver = {
+	.name = "bootmatrix",
+	.probe = bootmatrix_probe,
+	.remove = bootmatrix_remove,
+	.of_compatible = DRV_OF_COMPAT(bootmatrix_ids),
+};
+device_platform_driver(bootmatrix_driver);
diff --git a/drivers/misc/xsection.c b/drivers/misc/xsection.c
new file mode 100644
index 0000000..2412825
--- /dev/null
+++ b/drivers/misc/xsection.c
@@ -0,0 +1,460 @@
+/*
+ * Copyright (C) 2018 WAGO Kontakttechnik GmbH & Co. KG <http://global.wago.com>
+ * Author: Oleg Karfich <oleg.karfich@wago.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <driver.h>
+#include <init.h>
+#include <malloc.h>
+#include <of.h>
+#include <libbb.h>
+#include <fcntl.h>
+#include <linux/err.h>
+#include <net.h>
+#include <xsection.h>
+#include <fs.h>
+
+struct xsection_item {
+	struct cdev *cdev;
+	char *value_param;
+};
+
+struct xsection {
+	struct device_d dev;
+	struct xsection_item boot_mode_id;
+	struct xsection_item boot_mode_id_ext;
+	struct xsection_item devconf;
+	struct xsection_item ethaddr1;
+	struct xsection_item ethaddr2;
+	struct xsection_item blidx;
+	struct xsection_item blp_uii;
+};
+
+static struct xsection *xsection;
+
+static int xsection_access_item(struct xsection_item *xitem, void *buf,
+								int flags)
+{
+	int ret = 0;
+
+	if (!xitem || !buf || flags < 0)
+		return -EINVAL;
+
+	switch (flags) {
+	case O_RDONLY:
+		ret = cdev_read(xitem->cdev, buf, xitem->cdev->size, 0, 0);
+		break;
+	case O_WRONLY:
+		ret = cdev_write(xitem->cdev, buf, xitem->cdev->size, 0, 0);
+		break;
+	}
+
+	return ret;
+}
+
+int xsection_get_boot_mode_id(u8 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_boot_mode_id(u8 *value)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id, value,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_boot_mode_id_ext(u8 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id_ext, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_boot_mode_id_ext(u8 *value)
+{
+	return xsection ? xsection_access_item(&xsection->boot_mode_id_ext, value,
+							O_WRONLY) : -ENODEV;
+}
+int xsection_get_devconf(u16 *buf)
+{
+	return xsection ? xsection_access_item(&xsection->devconf, buf,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_devconf(u16 *value)
+{
+	return xsection ? xsection_access_item(&xsection->devconf, value,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_ethaddr1(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr1, ethaddr,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_ethaddr1(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr1, ethaddr,
+							O_WRONLY) : -ENODEV;
+}
+
+int xsection_get_ethaddr2(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr2, ethaddr,
+							O_RDONLY) : -ENODEV;
+}
+
+int xsection_set_ethaddr2(u8 ethaddr[6])
+{
+	return xsection ? xsection_access_item(&xsection->ethaddr2, ethaddr,
+							O_WRONLY) : -ENODEV;
+}
+
+static int xsection_param_get_ethaddr(struct xsection_item *xitem)
+{
+	int ret;
+	u8 buf[6];
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = xzalloc(sizeof("xx:xx:xx:xx:xx:xx"));
+
+	ethaddr_to_string(buf, xitem->value_param);
+
+	return 0;
+}
+
+static int xsection_param_set_ethaddr(struct xsection_item *xitem)
+{
+	int ret;
+	u8 buf[6];
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	ret = string_to_ethaddr(xitem->value_param, buf);
+	if (ret)
+		return ret;
+
+	ret = xsection_access_item(xitem, &buf, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_ethaddr2(struct param_d *p, void *priv)
+{
+	return xsection_param_get_ethaddr(priv);
+}
+
+static int xsection_param_set_ethaddr2(struct param_d *p, void *priv)
+{
+	return xsection_param_set_ethaddr(priv);
+}
+
+static int xsection_param_get_ethaddr1(struct param_d *p, void *priv)
+{
+	return xsection_param_get_ethaddr(priv);
+}
+
+static int xsection_param_set_ethaddr1(struct param_d *p, void *priv)
+{
+	return xsection_param_set_ethaddr(priv);
+}
+
+static int xsection_param_get_boot_mode_id(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%02x", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_boot_mode_id(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_devconf(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u16 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%04x", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_devconf(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u16 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_blidx(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf;
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%d", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_blidx(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 value;
+
+	if (!strcmp(xitem->value_param, ""))
+		return -EINVAL;
+
+	value = simple_strtoul(xitem->value_param, NULL, 0);
+	ret = xsection_access_item(xitem, &value, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+
+static int xsection_param_get_blp_uii(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+	u8 buf[40];
+
+	ret = xsection_access_item(xitem, &buf, O_RDONLY);
+	if (ret < 0)
+		return ret;
+
+	/* replace last byte with terminating null byte to avoid garbage in the
+	 * string device parameter.
+	 */
+	buf[39] = '\0';
+
+	free(xitem->value_param);
+	xitem->value_param = basprintf("%s", buf);
+
+	return 0;
+}
+
+static int xsection_param_set_blp_uii(struct param_d *p, void *priv)
+{
+	struct xsection_item *xitem = priv;
+	int ret;
+
+	if (!strcmp(xitem->value_param, "") || strlen(xitem->value_param) != 39)
+		return -EINVAL;
+
+	/* we need to set a <EOT> sign at the end per definition */
+	xitem->value_param[39] = 0x04;
+	ret = xsection_access_item(xitem, xitem->value_param, O_WRONLY);
+
+	return ret < 0 ? ret : 0;
+}
+static int xsection_add_dev_param(struct device_node *np,
+				struct xsection *xsection,
+				struct xsection_item *xitem, char *param_name,
+				int (*set)(struct param_d *p, void *priv),
+				int (*get)(struct param_d *p, void *priv))
+{
+	struct device_node *partition_node;
+	struct cdev *cdev;
+	struct param_d *param;
+	int ret = 0;
+	char *device_path;
+
+	partition_node = of_parse_phandle(np, param_name, 0);
+	if (!partition_node) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = of_find_path_by_node(partition_node, &device_path, 0);
+	if (ret == -EPROBE_DEFER)
+		goto out;
+
+	cdev = cdev_by_name(devpath_to_name(device_path));
+	if (!cdev) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	param = dev_add_param_string(&xsection->dev, param_name, set, get,
+				&xitem->value_param, xitem);
+
+	if (IS_ERR(param)) {
+		ret = -ENODEV;
+		goto out;
+	}
+
+	xitem->cdev = cdev;
+
+out:
+	return ret;
+}
+
+static int xsection_probe(struct device_d *dev)
+{
+	struct device_node *np = dev->device_node;
+	const char *alias;
+	int ret;
+
+	xsection = xzalloc(sizeof(*xsection));
+	xsection->dev.id = DEVICE_ID_SINGLE;
+	xsection->dev.parent = dev;
+	dev->priv = xsection;
+
+	alias = of_alias_get(np);
+	if (!alias) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	safe_strncpy(xsection->dev.name, alias, MAX_DRIVER_NAME);
+
+	ret = register_device(&xsection->dev);
+	if (ret)
+		goto out;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->boot_mode_id,
+					"boot_mode_id",
+					xsection_param_set_boot_mode_id,
+					xsection_param_get_boot_mode_id);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->boot_mode_id_ext,
+					"boot_mode_id_ext",
+					xsection_param_set_boot_mode_id,
+					xsection_param_get_boot_mode_id);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->devconf,
+					"devconf",
+					xsection_param_set_devconf,
+					xsection_param_get_devconf);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->ethaddr1,
+					"ethaddr1",
+					 xsection_param_set_ethaddr1,
+					 xsection_param_get_ethaddr1);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->ethaddr2,
+					"ethaddr2",
+					 xsection_param_set_ethaddr2,
+					 xsection_param_get_ethaddr2);
+	if (ret)
+		goto out_unreg;
+
+	ret = xsection_add_dev_param(np, xsection, &xsection->blidx,
+					"blidx",
+					 xsection_param_set_blidx,
+					 xsection_param_get_blidx);
+	if (ret)
+		goto out_unreg;
+
+	/* blp_uii is currently only used in pfc200 adv devices. So it's ok when
+	 * no "blp_uii" partition is found.
+	 */
+	xsection_add_dev_param(np, xsection, &xsection->blp_uii,
+					"blp_uii",
+					 xsection_param_set_blp_uii,
+					 xsection_param_get_blp_uii);
+
+	return 0;
+
+out_unreg:
+	unregister_device(&xsection->dev);
+out:
+	free(xsection);
+	xsection = NULL;
+
+	if (ret != -EPROBE_DEFER)
+		dev_err(dev, "failed to probe %d\n", ret);
+
+	return ret;
+}
+
+static void xsection_remove(struct device_d *dev)
+{
+	struct xsection *xsection = dev->priv;
+
+	dev_remove_parameters(&xsection->dev);
+	unregister_device(&xsection->dev);
+	free(xsection);
+	xsection = NULL;
+}
+
+static __maybe_unused struct of_device_id xsection_ids[] = {
+	{
+		.compatible = "xsection",
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct driver_d xsection_driver = {
+	.name = "xsection",
+	.probe = xsection_probe,
+	.remove = xsection_remove,
+	.of_compatible = DRV_OF_COMPAT(xsection_ids),
+};
+device_platform_driver(xsection_driver);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 2b4a478..e6aae12 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -23,6 +23,20 @@ config NAND_ECC_HW
 	default y
 	prompt "Support hardware ecc"
 
+config NAND_BCH_SUPPORT
+	bool
+	default y
+	prompt "Support for omap BCH handling"
+
+if NAND_ECC_HW
+
+config NAND_ECC_HW_SW_ERR_DETECTION
+	bool
+	select BCH
+	prompt "Enable software error detection"
+
+endif
+
 config NAND_ECC_HW_OOB_FIRST
 	bool
 	prompt "Support hardware ecc (oob first)"
diff --git a/drivers/mtd/nand/nand_omap_gpmc.c b/drivers/mtd/nand/nand_omap_gpmc.c
index d0b1699..cf49437 100644
--- a/drivers/mtd/nand/nand_omap_gpmc.c
+++ b/drivers/mtd/nand/nand_omap_gpmc.c
@@ -71,6 +71,10 @@
 #include <mach/gpmc.h>
 #include <mach/gpmc_nand.h>
 
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+#include <linux/bch.h>
+#endif
+
 #define GPMC_ECC_CONFIG_ECCENABLE		(1 << 0)
 #define GPMC_ECC_CONFIG_ECCCS(x)		(((x) & 0x7) << 1)
 #define GPMC_ECC_CONFIG_ECCTOPSECTOR(x)		(((x) & 0x7) << 4)
@@ -90,13 +94,24 @@
 static const uint8_t bch8_vector[] = {0xf3, 0xdb, 0x14, 0x16, 0x8b, 0xd2,
 		0xbe, 0xcc, 0xac, 0x6b, 0xff, 0x99, 0x7b};
 
+#ifdef CONFIG_NAND_BCH_SUPPORT
+
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+static uint8_t bch8_polynomial[] = {0xef, 0x51, 0x2e, 0x09, 0xed, 0x93, 0x9a, 0xc2,
+				    0x97, 0x79, 0xe5, 0x24, 0xb5};
+#else
 int omap_gpmc_decode_bch(int select_4_8, unsigned char *ecc, unsigned int *err_loc);
+#endif
+
+#endif
 
 static const char *ecc_mode_strings[] = {
 	"software",
 	"hamming_hw_romcode",
 	"bch8_hw",
 	"bch8_hw_romcode",
+	"bch8_hw_detsw",
+	"bch8_hw_detsw_legacy",
 };
 
 /** internal structure maintained for nand information */
@@ -233,14 +248,22 @@ static int __omap_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,
 {
 	struct nand_chip *nand = (struct nand_chip *)(mtd->priv);
 	struct gpmc_nand_info *oinfo = (struct gpmc_nand_info *)(nand->priv);
+	unsigned int val1 = 0x0;
+#ifdef CONFIG_NAND_BCH_SUPPORT
 	unsigned int reg;
-	unsigned int val1 = 0x0, val2 = 0x0;
+	unsigned int val2 = 0x0;
 	unsigned int val3 = 0x0, val4 = 0x0;
-	int i;
 	int ecc_size = 8;
+#endif
+	int i;
+
+	uint8_t *ecode = ecc_code;
 
 	switch (oinfo->ecc_mode) {
+#ifdef CONFIG_NAND_BCH_SUPPORT
 	case OMAP_ECC_BCH8_CODE_HW:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
 	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
 		for (i = 0; i < 4; i++) {
 			/*
@@ -270,6 +293,7 @@ static int __omap_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,
 			*ecc_code++ = (val1 & 0xFF);
 		}
 		break;
+#endif
 	case OMAP_ECC_HAMMING_CODE_HW_ROMCODE:
 		/* read ecc result */
 		val1 = readl(oinfo->gpmc_base + GPMC_ECC1_RESULT);
@@ -282,6 +306,21 @@ static int __omap_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,
 		return -EINVAL;
 	}
 
+	/* reset ptr */
+	ecc_code = ecode;
+
+#if defined(CONFIG_NAND_BCH_SUPPORT) && defined(CONFIG_NAND_ECC_HW_SW_ERR_DETECTION)
+	switch (oinfo->ecc_mode) {
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
+		for (i = 0; i < nand->ecc.total; i++)
+			*(ecc_code + i) = *(ecc_code + i) ^ bch8_polynomial[i];
+		break;
+	default:
+		break;
+	}
+#endif
+
 	return 0;
 }
 
@@ -291,6 +330,50 @@ static int omap_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,
 	return __omap_calculate_ecc(mtd, dat, ecc_code, 0);
 }
 
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+static int omap_correct_bch_sw(struct mtd_info *mtd, uint8_t *data,
+			     uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+	struct nand_chip *nand = (struct nand_chip *)(mtd->priv);
+
+	unsigned int errloc[8];
+	int i, count;
+
+#ifdef DEBUG
+        pr_info("%s: >>>> calc_ecc\n", __func__);
+	for (i = 0; i < nand->ecc.bytes; i++)
+		pr_info(" %x", calc_ecc[i]);
+	pr_info(" <<<\n");
+	pr_info("%s: >>>> read_ecc\n", __func__);
+	for (i = 0; i < nand->ecc.bytes; i++)
+		pr_info(" %x", read_ecc[i]);
+	pr_info(" <<<\n");
+#endif
+
+	count = decode_bch((struct bch_control*) nand->ecc.priv, NULL, nand->ecc.size, read_ecc , calc_ecc,
+			   NULL, errloc);
+
+	pr_debug("%s: count %d, ecc.size %d, ecc.bytes %d\n",
+		__func__, count, nand->ecc.size, nand->ecc.bytes);
+
+	if (count > 0) {
+		/* correct errors */
+		for (i = 0; i < count; i++) {
+			/* correct data only, not ecc bytes */
+			if (errloc[i] < (8 * 512))
+				data[errloc[i]/8] ^= 1 << (errloc[i] & 7);
+			pr_info("corrected bitflip %u\n", errloc[i]);
+		}
+	} else if (count < 0) {
+		pr_info("ecc unrecoverable error\n");
+	}
+
+	return count;
+}
+
+#else
+
 static int omap_correct_bch(struct mtd_info *mtd, uint8_t *dat,
 			     uint8_t *read_ecc, uint8_t *calc_ecc)
 {
@@ -360,6 +443,8 @@ static int omap_correct_bch(struct mtd_info *mtd, uint8_t *dat,
 
 	return bitflip_count;
 }
+#endif	/* CONFIG_NAND_ECC_HW_SW_ERR_DETECTION */
+#endif	/* CONFIG_NAND_BCH_SUPPORT */
 
 static int omap_correct_hamming(struct mtd_info *mtd, uint8_t *dat,
 			     uint8_t *read_ecc, uint8_t *calc_ecc)
@@ -430,6 +515,8 @@ static int omap_correct_data(struct mtd_info *mtd, uint8_t *dat,
 	switch (oinfo->ecc_mode) {
 	case OMAP_ECC_HAMMING_CODE_HW_ROMCODE:
 		return omap_correct_hamming(mtd, dat, read_ecc, calc_ecc);
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 	case OMAP_ECC_BCH8_CODE_HW:
 	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
 		/*
@@ -439,6 +526,12 @@ static int omap_correct_data(struct mtd_info *mtd, uint8_t *dat,
 		 */
 		__omap_calculate_ecc(mtd, dat, calc_ecc, 0);
 		return omap_correct_bch(mtd, dat, read_ecc, calc_ecc);
+#else
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
+		return omap_correct_bch_sw(mtd, dat, read_ecc, calc_ecc);
+#endif
+#endif
 	default:
 		return -EINVAL;
 	}
@@ -457,7 +550,10 @@ static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
 	int cs = 0;
 
 	switch (oinfo->ecc_mode) {
+#ifdef CONFIG_NAND_BCH_SUPPORT
 	case OMAP_ECC_BCH8_CODE_HW:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
 	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
 		if (mode == NAND_ECC_READ) {
 			eccsize1 = 0x1A; eccsize0 = 0x18;
@@ -469,9 +565,11 @@ static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
 			bch_wrapmode = 0x06;
 		}
 		break;
+#endif
 	case OMAP_ECC_HAMMING_CODE_HW_ROMCODE:
 		eccsize1 = ((ecc_size >> 1) - 1) << 22;
 		break;
+	default:
 	case OMAP_ECC_SOFT:
 		return;
 	}
@@ -491,7 +589,9 @@ static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
 			GPMC_ECC_SIZE_CONFIG_ECCSIZE0(0xff);
 		ecc_conf_val = dev_width | GPMC_ECC_CONFIG_ECCCS(cs) |
 			GPMC_ECC_CONFIG_ECCENABLE;
-	} else {
+	}
+#ifdef CONFIG_NAND_BCH_SUPPORT
+	else {
 		writel(GPMC_ECC_CONTROL_ECCPOINTER(1),
 				oinfo->gpmc_base + GPMC_ECC_CONTROL);
 
@@ -506,6 +606,7 @@ static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
 				GPMC_ECC_CONFIG_ECCCS(cs) |
 				GPMC_ECC_CONFIG_ECCENABLE);
 	}
+#endif
 
 	writel(ecc_size_conf_val, oinfo->gpmc_base + GPMC_ECC_SIZE_CONFIG);
 	writel(ecc_conf_val, oinfo->gpmc_base + GPMC_ECC_CONFIG);
@@ -513,6 +614,7 @@ static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
 			oinfo->gpmc_base + GPMC_ECC_CONTROL);
 }
 
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 static int omap_gpmc_read_buf_manual(struct mtd_info *mtd, struct nand_chip *chip,
 		void *buf, int bytes, int result_reg)
 {
@@ -529,6 +631,7 @@ static int omap_gpmc_read_buf_manual(struct mtd_info *mtd, struct nand_chip *chi
 
 	return bytes;
 }
+#endif
 
 /**
  * omap_read_buf_pref - read data from NAND controller into buffer
@@ -625,6 +728,9 @@ static void omap_write_buf_pref(struct mtd_info *mtd,
 	gpmc_prefetch_reset(info->gpmc_cs);
 }
 
+#ifdef CONFIG_NAND_BCH_SUPPORT
+
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 /*
  * read a page with the ecc layout used by the OMAP4 romcode. The
  * romcode expects an unusual ecc layout (f = free, e = ecc):
@@ -708,6 +814,8 @@ static int omap_gpmc_read_page_bch_rom_mode(struct mtd_info *mtd,
 
 	return max_bitflips;
 }
+#endif	/* CONFIG_NAND_ECC_HW_SW_ERR_DETECTION */
+#endif	/* CONFIG_NAND_BCH_SUPPORT */
 
 static int omap_gpmc_eccmode(struct gpmc_nand_info *oinfo,
 		enum gpmc_ecc_mode mode)
@@ -715,7 +823,7 @@ static int omap_gpmc_eccmode(struct gpmc_nand_info *oinfo,
 	struct mtd_info *minfo = &oinfo->minfo;
 	struct nand_chip *nand = &oinfo->nand;
 	int offset;
-	int i, j;
+	int i;
 
 	if (nand->options & NAND_BUSWIDTH_16)
 		nand->badblock_pattern = &bb_descrip_flashbased;
@@ -758,27 +866,87 @@ static int omap_gpmc_eccmode(struct gpmc_nand_info *oinfo,
 		omap_oobinfo.oobfree->length = minfo->oobsize -
 					offset - omap_oobinfo.eccbytes;
 		break;
+#ifdef CONFIG_NAND_BCH_SUPPORT
+#ifdef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:
+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY:
+		/* Init post-processing engine */
+		nand->ecc.priv = init_bch(13, BCH8_MAX_ERROR, 0); /* use default primitive
+								     polynomial (0x201b, m=13) */
+		oinfo->nand.ecc.bytes    = 13;
+		oinfo->nand.ecc.size     = 512;
+		oinfo->nand.ecc.strength = BCH8_MAX_ERROR;
+
+		oinfo->nand.ecc.steps = minfo->writesize / oinfo->nand.ecc.size;
+		oinfo->nand.ecc.total = oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes;
+		omap_oobinfo.eccbytes = oinfo->nand.ecc.total;
+
+		omap_oobinfo.oobfree->offset = offset; /* =1 */
+
+		if (mode == OMAP_ECC_BCH8_CODE_HW_DETECTION_SW)
+			omap_oobinfo.oobfree->length = minfo->oobsize -
+						offset - omap_oobinfo.eccbytes;
+		else
+			omap_oobinfo.oobfree->length = minfo->oobsize -
+						offset - oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes; //eccbytes
+
+#define BADBLOCK_MARKER_LENGTH    2
+		{
+			unsigned oob_index = BADBLOCK_MARKER_LENGTH;
+
+			if (mode == OMAP_ECC_BCH8_CODE_HW_DETECTION_SW) {
+				for (i = 0; i < omap_oobinfo.eccbytes; i++, oob_index++) {
+					omap_oobinfo.eccpos[i] = oob_index;
+					if (((i + 1) % oinfo->nand.ecc.bytes) == 0)
+						oob_index++;
+				}
+			} else { /* OMAP_ECC_BCH8_CODE_HW_DETECTION_SW_LEGACY */
+
+				oob_index = minfo->oobsize - oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes;
+
+				for (i = 0; i < oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes; i++)
+				        omap_oobinfo.eccpos[i] = i + oob_index;
+			}
+		}
+
+		break;
+#endif
 	case OMAP_ECC_BCH8_CODE_HW:
 		oinfo->nand.ecc.bytes    = 13;
 		oinfo->nand.ecc.size     = 512;
 		oinfo->nand.ecc.strength = BCH8_MAX_ERROR;
-		omap_oobinfo.oobfree->offset = offset;
+
+		oinfo->nand.ecc.steps = minfo->writesize / oinfo->nand.ecc.size;
+		oinfo->nand.ecc.total = oinfo->nand.ecc.steps * oinfo->nand.ecc.bytes;
+		omap_oobinfo.eccbytes = oinfo->nand.ecc.total;
+
+		omap_oobinfo.oobfree->offset = offset; /* =1 */
 		omap_oobinfo.oobfree->length = minfo->oobsize -
 					offset - omap_oobinfo.eccbytes;
-		offset = minfo->oobsize - oinfo->nand.ecc.bytes;
-		for (i = 0; i < oinfo->nand.ecc.bytes; i++)
+
+		offset = minfo->oobsize - oinfo->nand.ecc.total;
+
+		for (i = 0; i < omap_oobinfo.eccbytes; i++) {
 			omap_oobinfo.eccpos[i] = i + offset;
+		}
+
 		break;
+#ifndef CONFIG_NAND_ECC_HW_SW_ERR_DETECTION
 	case OMAP_ECC_BCH8_CODE_HW_ROMCODE:
-		oinfo->nand.ecc.bytes    = 13 + 1;
-		oinfo->nand.ecc.size     = 512;
-		oinfo->nand.ecc.strength = BCH8_MAX_ERROR;
-		nand->ecc.read_page = omap_gpmc_read_page_bch_rom_mode;
-		omap_oobinfo.oobfree->length = 0;
-		j = 0;
-		for (i = 2; i < 58; i++)
-			omap_oobinfo.eccpos[j++] = i;
+		{
+			int j;
+			oinfo->nand.ecc.bytes    = 13 + 1;
+			oinfo->nand.ecc.size     = 512;
+			oinfo->nand.ecc.strength = BCH8_MAX_ERROR;
+			nand->ecc.read_page = omap_gpmc_read_page_bch_rom_mode;
+			omap_oobinfo.oobfree->length = 0;
+			j = 0;
+			for (i = 2; i < 58; i++)
+				omap_oobinfo.eccpos[j++] = i;
+		}
 		break;
+#endif
+#endif
 	case OMAP_ECC_SOFT:
 		nand->ecc.layout = NULL;
 		nand->ecc.mode = NAND_ECC_SOFT;
@@ -952,7 +1120,11 @@ static int gpmc_nand_probe(struct device_d *pdev)
 	mdelay(1);
 
 	/* first scan to find the device and get the page size */
+#ifdef CONFIG_NAND_USE_CUSTOM_IDS
+	if (nand_scan_ident(minfo, 1, custom_nand_ids)) {
+#else
 	if (nand_scan_ident(minfo, 1, NULL)) {
+#endif
 		err = -ENXIO;
 		goto out_release_mem;
 	}
diff --git a/drivers/net/davinci_emac.c b/drivers/net/davinci_emac.c
index 75a917a..e0e32c5 100644
--- a/drivers/net/davinci_emac.c
+++ b/drivers/net/davinci_emac.c
@@ -190,6 +190,17 @@ static int davinci_emac_set_ethaddr(struct eth_device *edev, const unsigned char
 
 static int davinci_emac_init(struct eth_device *edev)
 {
+	struct davinci_emac_priv *priv = edev->priv;
+	uint32_t cnt;
+
+	/* Set DMA head and completion pointers to 0 */
+	for(cnt = 0; cnt < 8; cnt++) {
+		writel(0, (void *)priv->adap_emac + EMAC_TX0HDP + 4 * cnt);
+		writel(0, (void *)priv->adap_emac + EMAC_RX0HDP + 4 * cnt);
+		writel(0, (void *)priv->adap_emac + EMAC_TX0CP + 4 * cnt);
+		writel(0, (void *)priv->adap_emac + EMAC_RX0CP + 4 * cnt);
+	}
+
 	dev_dbg(&edev->dev, "* emac_init\n");
 	return 0;
 }
@@ -514,6 +525,19 @@ out:
 	return ret;
 }
 
+struct davinci_emac_platform_data *davinci_emac_probe_dt(struct device_node *np)
+{
+	struct davinci_emac_platform_data *pdata;
+
+	pdata = xzalloc(sizeof(*pdata));
+
+	of_property_read_u32(np, "phy-addr", &pdata->phy_addr);
+	pdata->force_link = of_property_read_bool(np, "force-link");
+	pdata->interface_rmii = of_property_read_bool(np, "interface-rmii");
+
+	return pdata;
+}
+
 static int davinci_emac_probe(struct device_d *dev)
 {
 	struct resource *iores;
@@ -524,11 +548,15 @@ static int davinci_emac_probe(struct device_d *dev)
 
 	dev_dbg(dev, "+ emac_probe\n");
 
-	if (!dev->platform_data) {
+	if (dev->device_node)
+		pdata = davinci_emac_probe_dt(dev->device_node);
+	else
+		pdata = dev->platform_data;
+
+	if (!pdata) {
 		dev_err(dev, "no platform_data\n");
 		return -ENODEV;
 	}
-	pdata = dev->platform_data;
 
 	priv = xzalloc(sizeof(*priv));
 	dev->priv = priv;
@@ -620,9 +648,18 @@ static void davinci_emac_remove(struct device_d *dev)
 	davinci_emac_halt(&priv->edev);
 }
 
+static __maybe_unused struct of_device_id davinci_emac_dt_ids[] = {
+	{
+		.compatible = "ti,am3517-emac",
+	}, {
+		/* sentinel */
+	}
+};
+
 static struct driver_d davinci_emac_driver = {
 	.name   = "davinci_emac",
 	.probe  = davinci_emac_probe,
 	.remove = davinci_emac_remove,
+	.of_compatible = DRV_OF_COMPAT(davinci_emac_dt_ids),
 };
 device_platform_driver(davinci_emac_driver);
diff --git a/drivers/of/of_path.c b/drivers/of/of_path.c
index f8bbf2c..5c3a020 100644
--- a/drivers/of/of_path.c
+++ b/drivers/of/of_path.c
@@ -83,7 +83,7 @@ static int __of_find_path(struct device_node *node, const char *part, char **out
 	}
 
 	if (dev->bus && !dev->driver)
-		return -ENODEV;
+		return -EPROBE_DEFER;
 
 	device_detect(dev);
 
diff --git a/drivers/usb/gadget/multi.c b/drivers/usb/gadget/multi.c
index d6edfb8..fe3bc15 100644
--- a/drivers/usb/gadget/multi.c
+++ b/drivers/usb/gadget/multi.c
@@ -182,8 +182,11 @@ static int multi_bind(struct usb_composite_dev *cdev)
 
 	strings_dev[USB_GADGET_MANUFACTURER_IDX].s = gadget->manufacturer;
 	strings_dev[USB_GADGET_PRODUCT_IDX].s = gadget->productname;
+	strings_dev[USB_GADGET_SERIAL_IDX].s = gadget->serial_number;
 
 	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
+	device_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;
+	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
 
 	config.label          = strings_dev[STRING_DESCRIPTION_IDX].s;
 	config.iConfiguration = strings_dev[STRING_DESCRIPTION_IDX].id;
diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index ed99b53..8f31a57 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -197,6 +197,8 @@ int usb_add_gadget_udc_release(struct device_d *parent, struct usb_gadget *gadge
 	gadget->productname = xstrdup(barebox_get_model());
 	dev_add_param_string(&gadget->dev, "productname", NULL, NULL,
 			&gadget->productname, NULL);
+	dev_add_param_string(&gadget->dev, "serial_number", NULL, NULL,
+			&gadget->serial_number, NULL);
 
 	strcpy(udc->dev.name, "udc");
 	udc->dev.id = DEVICE_ID_DYNAMIC;
diff --git a/fs/fs.c b/fs/fs.c
index 2a4d78c..43d1d85 100644
--- a/fs/fs.c
+++ b/fs/fs.c
@@ -2785,16 +2785,15 @@ int umount(const char *pathname)
 {
 	struct fs_device_d *fsdev = NULL, *f;
 	struct path path = {};
+	bool is_root = false;
 	int ret;
 
 	ret = filename_lookup(AT_FDCWD, getname(pathname), LOOKUP_FOLLOW, &path);
 	if (ret)
 		return ret;
 
-	if (path.dentry == d_root) {
-		path_put(&path);
-		return -EBUSY;
-	}
+	if (path.dentry == d_root)
+		is_root = true;
 
 	for_each_fs_device(f) {
 		if (path.dentry == f->vfsmount.mnt_root) {
@@ -2819,7 +2818,14 @@ int umount(const char *pathname)
 		return -EFAULT;
 	}
 
-	return fsdev_umount(fsdev);
+	ret = fsdev_umount(fsdev);
+	if (ret)
+		return ret;
+
+	if (is_root)
+		d_root = NULL;
+
+	return ret;
 }
 EXPORT_SYMBOL(umount);
 
diff --git a/fs/tftp.c b/fs/tftp.c
index 0d9ee6e..b82d8ba 100644
--- a/fs/tftp.c
+++ b/fs/tftp.c
@@ -35,6 +35,8 @@
 #include <linux/err.h>
 #include <kfifo.h>
 #include <linux/sizes.h>
+#include <magicvar.h>
+#include <globalvar.h>
 
 #define TFTP_PORT	69	/* Well known TFTP port number */
 
@@ -68,10 +70,15 @@
 #define STATE_DONE	8
 
 #define TFTP_BLOCK_SIZE		512	/* default TFTP block size */
+#define TFTP_MIN_BLOCK_SIZE	30	/* this range was empirically determined */
+#define TFTP_MAX_BLOCK_SIZE	1468
+
 #define TFTP_FIFO_SIZE		4096
 
 #define TFTP_ERR_RESEND	1
 
+static int global_tftp_block_size = TFTP_BLOCK_SIZE;
+
 struct file_priv {
 	struct net_connection *tftp_con;
 	int push;
@@ -138,14 +145,15 @@ static int tftp_send(struct file_priv *priv)
 				"tsize%c"
 				"%d%c"
 				"blksize%c"
-				"1432",
+				"%d",
 				priv->filename + 1, 0,
 				0,
 				0,
 				TIMEOUT, 0,
 				0,
 				priv->filesize, 0,
-				0);
+				0,
+				priv->blocksize);
 		pkt++;
 		len = pkt - xp;
 		break;
@@ -383,6 +391,15 @@ static struct file_priv *tftp_do_open(struct device_d *dev,
 
 	priv = xzalloc(sizeof(*priv));
 
+	if (global_tftp_block_size < TFTP_MIN_BLOCK_SIZE ||
+			global_tftp_block_size > TFTP_MAX_BLOCK_SIZE) {
+		pr_err("error: blocksize is unvalid (use: %d-%d)\n",
+				TFTP_MIN_BLOCK_SIZE,
+				TFTP_MAX_BLOCK_SIZE);
+		ret = -EINVAL;
+		goto out;
+	}
+
 	switch (accmode & O_ACCMODE) {
 	case O_RDONLY:
 		priv->push = 0;
@@ -400,7 +417,7 @@ static struct file_priv *tftp_do_open(struct device_d *dev,
 	priv->block = 1;
 	priv->err = -EINVAL;
 	priv->filename = dpath(dentry, fsdev->vfsmount.mnt_root);
-	priv->blocksize = TFTP_BLOCK_SIZE;
+	priv->blocksize = global_tftp_block_size;
 	priv->block_requested = -1;
 
 	priv->fifo = kfifo_alloc(TFTP_FIFO_SIZE);
@@ -733,6 +750,10 @@ static struct fs_driver_d tftp_driver = {
 
 static int tftp_init(void)
 {
+	globalvar_add_simple_int("tftp.blocksize", &global_tftp_block_size, "%u");
+
 	return register_fs_driver(&tftp_driver);
 }
 coredevice_initcall(tftp_init);
+
+BAREBOX_MAGICVAR_NAMED(global_tftp_block_size, global.tftp.blocksize, "TFTP Blocksize Option");
diff --git a/images/Makefile b/images/Makefile
index 5c4d99a..f8964ee 100644
--- a/images/Makefile
+++ b/images/Makefile
@@ -103,6 +103,7 @@ board = $(srctree)/arch/$(ARCH)/boards
 objboard = $(objtree)/arch/$(ARCH)/boards
 
 include $(srctree)/images/Makefile.am33xx
+include $(srctree)/images/Makefile.am35xx
 include $(srctree)/images/Makefile.bcm283x
 include $(srctree)/images/Makefile.imx
 include $(srctree)/images/Makefile.mvebu
diff --git a/images/Makefile.am33xx b/images/Makefile.am33xx
index 50fa019..2aa226d 100644
--- a/images/Makefile.am33xx
+++ b/images/Makefile.am33xx
@@ -135,6 +135,54 @@ pblx-$(CONFIG_MACH_VSCOM_BALTOS) += start_am33xx_baltos_sram
 FILE_barebox-am33xx-baltos-mlo.img = start_am33xx_baltos_sram.pblx.mlo
 am33xx-mlo-$(CONFIG_MACH_VSCOM_BALTOS) += barebox-am33xx-baltos-mlo.img
 
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += start_am33xx_pfc_750_810x_sdram
+FILE_barebox-am33xx-pfc-750-810x.img = start_am33xx_pfc_750_810x_sdram.pblx
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += barebox-am33xx-pfc-750-810x.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += start_am33xx_pfc_750_810x_sram_256mb
+FILE_barebox-am33xx-pfc-750-810x-mlo.img = start_am33xx_pfc_750_810x_sram_256mb.pblx.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_750_810x) += barebox-am33xx-pfc-750-810x-mlo.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += start_am33xx_pfc_750_8208_sdram
+FILE_barebox-am33xx-pfc-750-8208.img = start_am33xx_pfc_750_8208_sdram.pblx
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += barebox-am33xx-pfc-750-8208.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += start_am33xx_pfc_750_8208_sram_256mb
+FILE_barebox-am33xx-pfc-750-8208-mlo.img = start_am33xx_pfc_750_8208_sram_256mb.pblx.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_750_8208) += barebox-am33xx-pfc-750-8208-mlo.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += start_am33xx_pfc_750_821x_sdram
+FILE_barebox-am33xx-pfc-750-821x.img = start_am33xx_pfc_750_821x_sdram.pblx
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += barebox-am33xx-pfc-750-821x.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += start_am33xx_pfc_750_821x_sram_512mb
+FILE_barebox-am33xx-pfc-750-821x-mlo.img = start_am33xx_pfc_750_821x_sram_512mb.pblx.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_750_821x) += barebox-am33xx-pfc-750-821x-mlo.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_2850_311x) += start_am33xx_src_2850_311x_sdram
+FILE_barebox-am33xx-src-2850-311x.img = start_am33xx_src_2850_311x_sdram.pblx
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_2850_311x) += barebox-am33xx-src-2850-311x.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_2850_311x) += start_am33xx_src_2850_311x_sram_256mb
+FILE_barebox-am33xx-src-2850-311x-mlo.img = start_am33xx_src_2850_311x_sram_256mb.pblx.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_2850_311x) += barebox-am33xx-src-2850-311x-mlo.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += start_am33xx_pfc_768_330x_sdram
+FILE_barebox-am33xx-pfc-768-330x.img = start_am33xx_pfc_768_330x_sdram.pblx
+am33xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += barebox-am33xx-pfc-768-330x.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += start_am33xx_pfc_768_330x_sram_512mb
+FILE_barebox-am33xx-pfc-768-330x-mlo.img = start_am33xx_pfc_768_330x_sram_512mb.pblx.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM335X_768_330x) += barebox-am33xx-pfc-768-330x-mlo.img
+
+pblx-$(CONFIG_MACH_WAGO_AM335X_RMCB) += start_am33xx_rmcb_sdram
+FILE_barebox-am33xx-rmcb.img = start_am33xx_rmcb_sdram.pblx
+am33xx-barebox-$(CONFIG_MACH_WAGO_AM335X_RMCB) += barebox-am33xx-rmcb.img
+
+pblx-$(CONFIG_MACH_WAGO_AM335X_RMCB) += start_am33xx_rmcb_sram_128mb
+FILE_barebox-am33xx-rmcb-mlo.img = start_am33xx_rmcb_sram_128mb.pblx.mlo
+am33xx-mlo-$(CONFIG_MACH_WAGO_AM335X_RMCB) += barebox-am33xx-rmcb-mlo.img
+
 ifdef CONFIG_OMAP_BUILD_IFT
 image-y += $(am33xx-mlo-y)
 else
diff --git a/images/Makefile.am35xx b/images/Makefile.am35xx
new file mode 100644
index 0000000..f988a6f
--- /dev/null
+++ b/images/Makefile.am35xx
@@ -0,0 +1,28 @@
+
+# %.mlo - convert into mlo image
+# ----------------------------------------------------------------
+ifndef CONFIG_ARCH_AM33XX
+quiet_cmd_mlo_image = MLO     $@
+      cmd_mlo_image = scripts/omap_signGP -o $@ -l 0x40200000 -c $<
+endif
+
+# scripts/omap_signGP -o MLO -l 0x40200000 -c $< #
+
+$(obj)/%.mlo: $(obj)/% FORCE
+	$(call if_changed,mlo_image)
+
+ifdef CONFIG_OMAP_BUILD_IFT
+pblx-$(CONFIG_MACH_WAGO_PFC_AM35XX) += start_am35xx_pfc_750_820x_sram
+FILE_barebox-am35xx-pfc-750-820x-mlo.img = start_am35xx_pfc_750_820x_sram.pblx.mlo
+am35xx-mlo-$(CONFIG_MACH_WAGO_PFC_AM35XX) += barebox-am35xx-pfc-750-820x-mlo.img
+endif
+
+pblx-$(CONFIG_MACH_WAGO_PFC_AM35XX) += start_am35xx_pfc_750_820x_sdram
+FILE_barebox-am35xx-pfc-750-820x.img = start_am35xx_pfc_750_820x_sdram.pblx
+am35xx-barebox-$(CONFIG_MACH_WAGO_PFC_AM35XX) += barebox-am35xx-pfc-750-820x.img
+
+ifdef CONFIG_OMAP_BUILD_IFT
+image-y += $(am35xx-mlo-y)
+else
+image-y += $(am35xx-barebox-y)
+endif
diff --git a/images/Makefile.imx b/images/Makefile.imx
index f0014ac..fb41b15 100644
--- a/images/Makefile.imx
+++ b/images/Makefile.imx
@@ -526,6 +526,11 @@ CFG_start_zii_vf610_dev.pblx.imximg = $(board)/zii-vf610-dev/flash-header-zii-vf
 FILE_barebox-zii-vf610-dev.img = start_zii_vf610_dev.pblx.imximg
 image-$(CONFIG_MACH_ZII_VF610_DEV) += barebox-zii-vf610-dev.img
 
+pblx-$(CONFIG_MACH_WAGO_VTPCTP_MX6) += imx6q_vtpctp_start
+CFG_start_imx6q_vtpctp.pblx.imximg = $(board)/wago-vtpctp-imx6/flash-header-vtpctp_q.imxcfg
+FILE_barebox-imx6q-vtpctp.img = start_imx6q_vtpctp.pblx.imximg
+image-$(CONFIG_MACH_WAGO_VTPCTP_MX6) += barebox-imx6q-vtpctp.img
+
 # ----------------------- i.MX7 based boards ---------------------------
 pblx-$(CONFIG_MACH_FREESCALE_MX7_SABRESD) += start_imx7d_sabresd
 CFG_start_imx7d_sabresd.pblx.imximg = $(board)/freescale-mx7-sabresd/flash-header-mx7-sabresd.imxcfg
diff --git a/images/Makefile.socfpga b/images/Makefile.socfpga
index a075b36..9342835 100644
--- a/images/Makefile.socfpga
+++ b/images/Makefile.socfpga
@@ -25,6 +25,14 @@ $(obj)/%.socfpga-ocram-img: $(obj)/%.pblb $(obj)/barebox.z FORCE
 	$(call if_changed,socfpga_ocram_img,$(@F))
 
 # ----------------------- Cyclone5 based boards ---------------------------
+pblx-$(CONFIG_MACH_WAGO_PFC_CYCLONE5) += start_cyclone5_pfc_xload
+FILE_barebox-cyclone5-pfc-xload.img = start_cyclone5_pfc_xload.pblx.socfpgaimg
+socfpga-xload-$(CONFIG_MACH_WAGO_PFC_CYCLONE5) += barebox-cyclone5-pfc-xload.img
+
+pblx-$(CONFIG_MACH_WAGO_PFC_CYCLONE5) += start_cyclone5_pfc
+FILE_barebox-cyclone5-pfc.img = start_cyclone5_pfc.pblx
+socfpga-barebox-$(CONFIG_MACH_WAGO_PFC_CYCLONE5) += barebox-cyclone5-pfc.img
+
 pblx-$(CONFIG_MACH_SOCFPGA_ALTERA_SOCDK) += start_socfpga_socdk_xload
 FILE_barebox-socfpga-socdk-xload.img = start_socfpga_socdk_xload.pblx.socfpgaimg
 socfpga-xload-$(CONFIG_MACH_SOCFPGA_ALTERA_SOCDK) += barebox-socfpga-socdk-xload.img
diff --git a/include/bootmatrix.h b/include/bootmatrix.h
new file mode 100644
index 0000000..b71121a
--- /dev/null
+++ b/include/bootmatrix.h
@@ -0,0 +1,13 @@
+#ifndef __BOOTMATRIX_H
+#define __BOOTMATRIX_H
+
+enum bootmatrix_mode {
+	UNKNOWN = 0,
+	DEFAULT,
+	PRODUCTION,
+	SETUPFW,
+};
+
+enum bootmatrix_mode bootmatrix_get_mode(void);
+
+#endif /* __BOOTMATRIX_H */
diff --git a/include/led_mode.h b/include/led_mode.h
new file mode 100644
index 0000000..6a4e259
--- /dev/null
+++ b/include/led_mode.h
@@ -0,0 +1,10 @@
+#ifndef __LED_MODE_H
+#define __LED_MODE_H
+
+/* valid color strings are: red, green, yellow */
+int led_mode_static(char *color, bool state);
+
+/* valid color strings are: red, green */
+int led_mode_moving(char *color, unsigned int duration_ms, bool turn_off_anc);
+
+#endif /* __LED_MODE_H */
diff --git a/include/mci.h b/include/mci.h
index 072008e..37bc17e 100644
--- a/include/mci.h
+++ b/include/mci.h
@@ -402,8 +402,10 @@ struct mci_host {
 	unsigned max_req_size;
 	unsigned dsr_val;	/**< optional dsr value */
 	int use_dsr;		/**< optional dsr usage flag */
+	int cd_gpio;		/**< card detection gpio pin */
 	bool non_removable;	/**< device is non removable */
 	bool no_sd;		/**< do not send SD commands during initialization */
+	bool cd_inverted;	/**< inverts cd_gpio value */
 	struct regulator *supply;
 
 	/** init the host interface */
@@ -459,8 +461,12 @@ struct mci {
 	int dsr_imp;		/**< DSR implementation state from CSD */
 	char *ext_csd;
 	int probe;
+	int cd;
+	int scan;
 	struct param_d *param_probe;
 	struct param_d *param_boot;
+	struct param_d *param_cd;
+	struct param_d *param_scan;
 	int bootpart;
 
 	struct mci_part part[MMC_NUM_PHY_PARTITION];
diff --git a/include/net/davinci_emac.h b/include/net/davinci_emac.h
new file mode 100644
index 0000000..caead1f
--- /dev/null
+++ b/include/net/davinci_emac.h
@@ -0,0 +1,10 @@
+#ifndef __NET_DAVINCI_EMAC_H__
+#define __NET_DAVINCI_EMAC_H__
+
+struct davinci_emac_platform_data {
+	int phy_addr;
+	bool force_link;
+	bool interface_rmii;
+};
+
+#endif /* __NET_DAVINCI_EMAC_H__ */
diff --git a/include/usb/gadget.h b/include/usb/gadget.h
index 80418a9..4a1b135 100644
--- a/include/usb/gadget.h
+++ b/include/usb/gadget.h
@@ -561,6 +561,7 @@ struct usb_gadget {
 	uint32_t			product_id;
 	char				*manufacturer;
 	char				*productname;
+	char				*serial_number;
 };
 #define work_to_gadget(w)	(container_of((w), struct usb_gadget, work))
 
diff --git a/include/xsection.h b/include/xsection.h
new file mode 100644
index 0000000..dfb3708
--- /dev/null
+++ b/include/xsection.h
@@ -0,0 +1,19 @@
+#ifndef __XSECTION_H
+#define __XSECTION_H
+
+int xsection_get_boot_mode_id(u8 *buf);
+int xsection_set_boot_mode_id(u8 *value);
+
+int xsection_get_boot_mode_id_ext(u8 *buf);
+int xsection_set_boot_mode_id_ext(u8 *value);
+
+int xsection_get_devconf(u16 *buf);
+int xsection_set_devconf(u16 *value);
+
+int xsection_get_ethaddr1(u8 ethaddr[6]);
+int xsection_set_ethaddr1(u8 ethaddr[6]);
+
+int xsection_get_ethaddr2(u8 ethaddr[6]);
+int xsection_set_ethaddr2(u8 ethaddr[6]);
+
+#endif /* __XSECTION_H */
diff --git a/jenkins/Makefile b/jenkins/Makefile
new file mode 100644
index 0000000..a96fdc5
--- /dev/null
+++ b/jenkins/Makefile
@@ -0,0 +1,191 @@
+# Usage:
+#
+#      make -f jenkins/Makefile CROSS_COMPILE <target>
+# i.e. make -f jenkins/Makefile CROSS_COMPILE=/opt/LINARO.Toolchain.2017.10/arm-linux-gnueabihf/bin/arm-linux-gnueabihf- \
+#								images/arm/configs/am335x_pfc_defconfig images/arm/configs/am335x_pfc_mlo_defconfig
+#
+# or
+#
+#      make -f jenkins/Makefile [all|clean|...] DEFCONFIG="<defconfig1> <defconfig2>"
+# i.e. make -f jenkins/Makefile CROSS_COMPILE=/opt/LINARO.Toolchain-2017.10/arm-linux-gnueabihf/bin/arm-linux-gnueabihf- \
+#							    DEFCONFIG="arm/configs/am335x_pfc_defconfig arm/configs/am335x_pfc_mlo_defconfig" \
+#							    dist
+#
+# CROSS_COMPILE = default empty
+# ARCH = default auto detect using device config
+# VERBOSE = default off
+
+SHELL := /bin/sh
+
+.PHONY: default
+default: all
+
+space := 
+space += 
+
+TOOLCHAIN_PREFIX = 
+CROSS_COMPILE ?= $(TOOLCHAIN_PREFIX)
+ARCH ?= $(firstword $(subst /,$(space),$(DEFCONFIG)))
+
+VERBOSE =
+BUILDDIR = .build
+SRCDIR = .
+PROJECTNAME = $(notdir $(realpath $(SRCDIR)))
+SNAPSHOT_SUFFIX ?= $(addprefix -next.,$(SNAPSHOT))
+
+CONFIGURE_TARGETS  =
+CONFIGURE_TARGETS += $(addprefix $(BUILDDIR),$(defconfigsuffix))
+
+BUILD_TARGETS  =
+BUILD_TARGETS += $(kbuild_buildtargets)
+
+CHECK_TARGETS  =
+
+DIST_TARGETS  = 
+DIST_TARGETS += package_source
+DIST_TARGETS += package_binaries
+
+CLEAN_TARGETS  =
+CLEAN_TARGETS += $(addprefix clean,$(defconfigsuffix))
+
+#INSTALL_TARGETS  =
+#INSTALL_TARGETS += $(addprefix install,$(defconfigsuffix))
+
+########################################################################################################################
+# Internal macros and definitions
+packagesource_excludes  = 
+packagesource_excludes += '.git'
+packagesource_excludes += '.git/*'
+packagesource_excludes += 'jenkins'
+packagesource_excludes += 'jenkins/*'
+packagesource_excludes += '$(BUILDDIR)'
+packagesource_excludes += '$(BUILDDIR)/*'
+
+defconfigdir = $(SRCDIR)/arch
+defconfigfiles = $(shell find $(defconfigdir) -type f -name '*_defconfig')
+defconfigs = $(patsubst $(defconfigdir)/%,%,$(defconfigfiles))
+defconfigsuffix = $(addprefix /,$(filter $(DEFCONFIG),$(defconfigs)))
+
+kbuild_configuretargets  =
+kbuild_configuretargets += $(addprefix $(BUILDDIR)/,$(defconfigs))
+
+kbuild_buildtargets  = images
+
+kbuild_targets  = $(kbuild_buildtargets)
+kbuild_targets += clean
+
+# $(call makecmd,outputdir,targets[,makeflags])
+makecmd = $(MAKE) $(MFLAGS) $3 '-C$(SRCDIR)' 'O=$1' $2
+# $(call tgzcmd,outputfile,inputdir[,archive-root][,excludes...][,inputs])
+tgzcmd = tar \
+  -P \
+  -I 'gzip -n' \
+  --sort name \
+  $(addprefix --mtime @,$(SOURCE_DATE_EPOCH)) \
+  --owner 0 \
+  --group 0 \
+  $(addprefix --exclude ,$4) \
+  --transform 's/$(subst /,\/,$(realpath $2))/$(subst /,\/,$(or $3,$(notdir $2)))/' \
+  -cvf \
+  $1 \
+  $(realpath $(or $(wildcard $(addprefix $2/,$5)),$2))
+
+# $(call stage_suffix,defconfig)
+stage_suffix = $(if $(findstring _mlo_,$(lastword $(subst /,$(space),$(1)))),-mlo,)
+
+# Force eager evaluation
+defconfigs := $(defconfigs)
+VERSIONSUFFIX := $(VERSIONSUFFIX)
+CROSS_COMPILE := $(CROSS_COMPILE)
+
+ifeq ($(VERBOSE),1)
+  Q =
+else
+  Q = @
+endif
+
+ifeq ($(strip $(MAKE_RESTARTS)),)
+  ifeq ($(strip $(ARCH)),)
+    $(error ARCH='$(ARCH)' invalid)
+  endif
+  ifeq ($(strip $(defconfigsuffix)),)
+    $(info DEFCONFIG='$(DEFCONFIG)' not found)
+  endif
+endif
+
+export ARCH
+export CROSS_COMPILE
+
+########################################################################################################################
+# Rules
+
+-include $(BUILDDIR)/rules.mk
+
+.PHONY: configure all check dist install clean distclean
+
+$(BUILDDIR)/rules.mk: $(defconfigfiles) $(filter-out $(BUILDDIR)/rules.mk,$(MAKEFILE_LIST)) | $(BUILDDIR)
+	@ \
+	{ \
+	  printf '.NOTPARALLEL:\n'; \
+	  $(foreach target,$(kbuild_targets), \
+	    printf '.PHONY: $(target)\n'; \
+	    printf   '$(target) : $$(addprefix $(target),$$(defconfigsuffix))\n'; \
+	    printf   '\n'; \
+	    $(foreach defconfig,$(defconfigs), \
+	      printf '.PHONY: $(target)/$(defconfig)\n'; \
+	      printf '$(target)/$(defconfig): $$(MAKEFILE_LIST) | $$(BUILDDIR)/$(defconfig)\n'; \
+	      printf   '\t+$$(Q)$$(call makecmd,$$(BUILDDIR)/$(defconfig),$(target) $$(MAKEOVERRIDES))\n'; \
+	      printf   '\n'; \
+	    ) \
+	  ) \
+	} > $@
+	@{ \
+	  printf '\n'; \
+	  $(foreach defconfig,$(defconfigs), \
+	  printf '.PHONY: $$(BUILDDIR)/$(defconfig)/barebox-Binaries.tgz\n'; \
+	    printf '$$(BUILDDIR)/$(defconfig)/barebox-Binaries.tgz: $$(BUILDDIR)/$(defconfig)/include/config/kernel.release $(addsuffix /$(defconfig),images) $$(MAKEFILE_LIST) | $$(BUILDDIR)/$(defconfig)\n'; \
+		printf   '\t$$(Q)$$(call tgzcmd,$$@,$$(BUILDDIR)/$(defconfig)/images,,$$(packagebinary_excludes),*.img) \\\n'; \
+	    printf   '\t  && cp -f $$(abspath $$@) $$(BUILDDIR)/$(defconfig)/barebox-Binaries$(call stage_suffix,$(defconfig))-"$$$$(cat $$<)"$$(SNAPSHOT_SUFFIX).tgz\n'; \
+	    printf   '\n'; \
+	    printf '.PHONY: $$(BUILDDIR)/$(defconfig)/barebox-Source.tgz\n'; \
+	    printf '$$(BUILDDIR)/$(defconfig)/barebox-Source.tgz: $$(BUILDDIR)/$(defconfig)/include/config/kernel.release $$(BUILDDIR)/barebox-Source.tgz $$(MAKEFILE_LIST) | $$(BUILDDIR)/$(defconfig)\n'; \
+	    printf   '\t$$(Q)cp -f $$(abspath $$(BUILDDIR)/barebox-Source.tgz) $$(BUILDDIR)/$(defconfig)/barebox-Source-"$$$$(cat $$<)"$$(SNAPSHOT_SUFFIX).tgz\n'; \
+	    printf   '\n'; \
+		printf '$$(BUILDDIR)/$(defconfig)/include/config/kernel.release:\n'; \
+	    printf   '\t+$$(Q)$$(call makecmd,$$(BUILDDIR)/$(defconfig),include/config/kernel.release $$(MAKEOVERRIDES))\n'; \
+	    printf   '\n'; \
+	    ) \
+	} >> $@
+
+$(kbuild_configuretargets): $(MAKEFILE_LIST)
+	+$(Q)$(call makecmd,$@,$(notdir $@) $(MAKEOVERRIDES))
+
+.PHONY: $(BUILDDIR)/barebox-Source.tgz
+$(BUILDDIR)/barebox-Source.tgz: $(SRCDIR) $(MAKEFILE_LIST)
+	$(Q)$(call tgzcmd,$@,$<,$(PROJECTNAME),$(packagesource_excludes))
+
+.PHONY: package_binaries
+package_binaries: $(addsuffix /barebox-Binaries.tgz,$(addprefix $(BUILDDIR),$(defconfigsuffix)))
+
+.PHONY: package_source
+package_source : $(addsuffix /barebox-Source.tgz,$(addprefix $(BUILDDIR),$(defconfigsuffix)))
+
+configure: $(CONFIGURE_TARGETS)
+
+all: $(BUILD_TARGETS)
+
+check: $(CHECK_TARGETS)
+
+dist: configure $(DIST_TARGETS)
+
+clean: $(CLEAN_TARGETS)
+
+distclean:
+	$(Q)-rm -rf $(BUILDDIR)
+
+$(BUILDDIR):
+	$(Q)mkdir -p $@
+
+debug-print-%:
+	@printf '%s:\n' $*; \
+	 printf '%s\n' $($*)
diff --git a/jenkins/am335x_pfc.jenkinsfile b/jenkins/am335x_pfc.jenkinsfile
new file mode 100644
index 0000000..1ab9e95
--- /dev/null
+++ b/jenkins/am335x_pfc.jenkinsfile
@@ -0,0 +1,94 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "am335x_pfc"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig", "arm/configs/${defConfigName}_mlo_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*",
+                                        ".build/${defConfigs[1]}/images/*.img",
+                                        ".build/${defConfigs[1]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'oliver.rohe@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/jenkins/am335x_pfc_adv.jenkinsfile b/jenkins/am335x_pfc_adv.jenkinsfile
new file mode 100644
index 0000000..8aef0a8
--- /dev/null
+++ b/jenkins/am335x_pfc_adv.jenkinsfile
@@ -0,0 +1,94 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "am335x_pfc_adv"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig", "arm/configs/${defConfigName}_mlo_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*",
+                                        ".build/${defConfigs[1]}/images/*.img",
+                                        ".build/${defConfigs[1]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'heinrich.toews@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/jenkins/am35xx_pfc.jenkinsfile b/jenkins/am35xx_pfc.jenkinsfile
new file mode 100644
index 0000000..c4ceb27
--- /dev/null
+++ b/jenkins/am35xx_pfc.jenkinsfile
@@ -0,0 +1,94 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "am35xx_pfc"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig", "arm/configs/${defConfigName}_mlo_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*",
+                                        ".build/${defConfigs[1]}/images/*.img",
+                                        ".build/${defConfigs[1]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'heinrich.toews@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/jenkins/imx6_vtpctp.jenkinsfile b/jenkins/imx6_vtpctp.jenkinsfile
new file mode 100644
index 0000000..9eb65dd
--- /dev/null
+++ b/jenkins/imx6_vtpctp.jenkinsfile
@@ -0,0 +1,92 @@
+@Library('com.wago.pipeline@v2') _
+
+import com.wago.pipeline.configuration.Toolchains
+
+def toolchain = Toolchains.LINARO_9_2_2019_12_ARM_LINUX_GNUEABIHF
+
+@NonCPS
+boolean isReleaseBranch(String branchName) {
+  branchName ==~ /^maint-.*/
+}
+
+boolean isRelease() {
+  isReleaseBranch(BRANCH_NAME)
+}
+
+String getChannel() {
+  if(!isRelease()) {
+    return "development/${BRANCH_NAME}"
+  }
+  return 'release'
+}
+
+@NonCPS
+static List<String> toStringList(Map map, String separator = '=') {
+  map.collect { "${it.key}${separator}${it.value}" }
+}
+
+Map envConfigMap = [
+  MAKE_IMAGE: 'wago/devt/ubuntu/ptxdist/2017.11.1:1.8.0',
+  TOOLCHAIN_IMAGE: toolchain.image,
+  RELEASE: isRelease(),
+]
+
+List<String> envConfig = toStringList(envConfigMap)
+
+String defConfigName = "imx6_vtpctp"
+List<String> defConfigs = ["arm/configs/${defConfigName}_defconfig"]
+
+List<String> bareboxConfig = toStringList([
+  PROJECTNAME: 'barebox',
+  CROSS_COMPILE: 'arm-linux-gnueabihf-',
+  DEFCONFIG: defConfigs.join(" ")
+])
+
+makefileProject {
+
+  scm this.scm
+
+  environment(envConfig)
+
+  build {
+    makeVars(bareboxConfig)
+    makefiles(['jenkins/Makefile'])
+    all {
+      target 'all'
+      additionalTargets([ 'dist' ])
+      enableParallel true
+    }
+  }
+
+  deploy {
+    uploadToArtifactory("kernel-generic-dev-local/wago/barebox/${this.getChannel()}/${defConfigName}") {
+      String sourceModule = 'barebox-Source'
+      target(sourceModule) {
+          // same source for mlo and 2nd stage artefacts
+          includes([".build/${defConfigs[0]}/${sourceModule}-*.tgz"])
+      }
+
+      String binaryModule = 'barebox-Binaries'
+      List<String> binaryArtefacts = [  ".build/${defConfigs[0]}/images/*.img",
+                                        ".build/${defConfigs[0]}/images/*.pbl*"]
+      target(binaryModule) {
+        includes(binaryArtefacts)
+      }
+
+      promote()
+      if(this.isRelease()) {
+        promoteInteractive()
+      }
+    }
+  }
+
+  mail {
+    def productStakeholders = [
+      'oleg.karfich@wago.com',
+      'heinrich.toews@wago.com'
+    ]
+    toOnStatusChange(productStakeholders)
+    toOnFailure(productStakeholders)
+  }
+
+}
diff --git a/localversion-wago b/localversion-wago
new file mode 100644
index 0000000..b04bdb5
--- /dev/null
+++ b/localversion-wago
@@ -0,0 +1 @@
+w03.05.01_12
diff --git a/net/eth.c b/net/eth.c
index 9dc4411..a7297ff 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -327,11 +327,11 @@ static int eth_of_fixup(struct device_node *root, void *unused)
 	 * ever loaded.
 	 */
 	list_for_each_entry(addr, &ethaddr_list, list)
-		eth_of_fixup_node(root, addr->node ? addr->node->full_name : NULL,
+		eth_of_fixup_node(root, NULL,
 				  addr->ethid, addr->ethaddr);
 
 	for_each_netdev(edev)
-		eth_of_fixup_node(root, edev->nodepath, edev->dev.id, edev->ethaddr);
+		eth_of_fixup_node(root, NULL, edev->dev.id, edev->ethaddr);
 
 	return 0;
 }
diff --git a/scripts/checkpatch.pl b/scripts/checkpatch.pl
index 48ad493..9a6f6e2 100755
--- a/scripts/checkpatch.pl
+++ b/scripts/checkpatch.pl
@@ -330,7 +330,7 @@ sub top_of_kernel_tree {
 	my @tree_check = (
 		"arch", "commands", "common", "COPYING", "defaultenv",
 		"Documentation", "drivers", "fs", "include", "lib",
-		"MAKEALL", "Makefile", "net", "README", "scripts", "TODO"
+		"MAKEALL", "Makefile", "net", "README", "scripts"
 	);
 
 	foreach my $check (@tree_check) {
