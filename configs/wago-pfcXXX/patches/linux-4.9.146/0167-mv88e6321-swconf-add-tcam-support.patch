From 86a28b2d6b0441d35feab8ecbe03d0eba6f2816d Mon Sep 17 00:00:00 2001
From: Andreas Schmidt <andreas.schmidt@wago.com>
Date: Wed, 25 Apr 2018 14:45:33 +0200
Subject: [PATCH 167/292] mv88e6321-swconf: add tcam support

Signed-off-by: Andreas Schmidt <andreas.schmidt@wago.com>
---
 drivers/net/dsa/mv88e6xxx/mv88e6xxx.h |  13 +
 drivers/net/phy/Makefile              |   2 +-
 drivers/net/phy/mv88e6321-cfg.c       | 492 +++++++++++++++++-
 drivers/net/phy/mv88e6321_tcam.c      | 928 ++++++++++++++++++++++++++++++++++
 drivers/net/phy/mv88e6321_tcam.h      | 202 ++++++++
 5 files changed, 1627 insertions(+), 10 deletions(-)
 create mode 100644 drivers/net/phy/mv88e6321_tcam.c
 create mode 100644 drivers/net/phy/mv88e6321_tcam.h

diff --git a/drivers/net/dsa/mv88e6xxx/mv88e6xxx.h b/drivers/net/dsa/mv88e6xxx/mv88e6xxx.h
index e572121..907a18a 100644
--- a/drivers/net/dsa/mv88e6xxx/mv88e6xxx.h
+++ b/drivers/net/dsa/mv88e6xxx/mv88e6xxx.h
@@ -151,6 +151,19 @@
 #define PORT_ASSOC_VECTOR_REFRESH_LOCKED	BIT(11)
 #define PORT_ATU_CONTROL	0x0c
 #define PORT_PRI_OVERRIDE	0x0d
+#define PORT_PRI_OVERRIDE_DA_MASK		(0x3 << 14)
+#define PORT_PRI_OVERRIDE_SA_MASK		(0x3 << 12)
+#define PORT_PRI_OVERRIDE_VTU_MASK		(0x3 << 10)
+#define PORT_PRI_OVERRIDE_MIRROR_SA_MISS	BIT(9)
+#define PORT_PRI_OVERRIDE_MIRROR_VTU_MISS	BIT(8)
+#define PORT_PRI_OVERRIDE_TRAP_DA_MISS		BIT(7)
+#define PORT_PRI_OVERRIDE_TRAP_SA_MISS		BIT(6)
+#define PORT_PRI_OVERRIDE_TRAP_VTU_MISS		BIT(5)
+#define PORT_PRI_OVERRIDE_TRAP_TCAM_MISS	BIT(4)
+#define PORT_PRI_OVERRIDE_TCAM_MODE_MASK	0x3
+#define PORT_PRI_OVERRIDE_TCAM_MODE_DISABLED	0x0
+#define PORT_PRI_OVERRIDE_TCAM_MODE_48		0x1
+#define PORT_PRI_OVERRIDE_TCAM_MODE_96		0x2
 #define PORT_ETH_TYPE		0x0f
 #define PORT_IN_DISCARD_LO	0x10
 #define PORT_IN_DISCARD_HI	0x11
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index 467fef8..4749281 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -56,4 +56,4 @@ obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
-obj-$(CONFIG_SWCFG_MV88E6321)   += mv88e6321-cfg.o
+obj-$(CONFIG_SWCFG_MV88E6321)   += mv88e6321-cfg.o mv88e6321_tcam.o
diff --git a/drivers/net/phy/mv88e6321-cfg.c b/drivers/net/phy/mv88e6321-cfg.c
index 4e64efa..ccd690d 100644
--- a/drivers/net/phy/mv88e6321-cfg.c
+++ b/drivers/net/phy/mv88e6321-cfg.c
@@ -7,7 +7,8 @@
  *
  * Licensed under the GPL version 2
  */
-#define DEBUG
+
+#define pr_fmt(fmt)     "mv88e6321: " fmt
 
 #include <linux/module.h>
 #include <linux/string.h>
@@ -20,11 +21,15 @@
 #include <linux/phy.h>
 #include <linux/switch.h>
 #include <linux/mv88e6321.h>
+#include <linux/of_fdt.h>
 #include <linux/of_gpio.h>
 #include <linux/of_mdio.h>
 #include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
 
 #include "../dsa/mv88e6xxx/mv88e6xxx.h"
+#include "mv88e6321_tcam.h"
 
 #define DRIVER_NAME		"mv88e6321"
 
@@ -56,10 +61,27 @@
 
 extern struct mv88e6xxx_chip *global_chip;
 
+struct tcam_info {
+	struct list_head list;
+	struct device_attribute dev_attr;
+	const char *title;
+	u8 id;
+	s16 next_id;
+	u16 reg_frame_type;
+};
+
 struct mv88e6321_info {
 	struct device *dev;
+	struct switch_dev *swdev;
 	int reset_gpio;
 	bool reset;
+#ifdef CONFIG_OF
+	struct mutex tcam_lock;
+	void *tcam_fdt;
+	struct device_node *tcam_np;
+	struct tcam_info tcam_info_head;
+	char tcam_buf[2000];
+#endif
 } *mvinfo;
 
 static int mv88e6321_soft_reset(void)
@@ -69,6 +91,7 @@ static int mv88e6321_soft_reset(void)
 
 static u8 cur_reg = 0;
 static u8 cur_phy_reg = 0;
+static int cur_tcam_id = 0;
 
 static int mv88e6321_sw_set_mdio_phy(struct switch_dev *dev,
 				     const struct switch_attr *attr,
@@ -86,6 +109,14 @@ static int mv88e6321_sw_set_mdio_reg(struct switch_dev *dev,
         return 0;
 }
 
+static int mv88e6321_sw_set_tcam_id(struct switch_dev *dev,
+				     const struct switch_attr *attr,
+				     struct switch_val *val)
+{
+        cur_tcam_id = val->value.i;
+        return 0;
+}
+
 static int mv88e6321_sw_get_mdio_phy(struct switch_dev *dev,
 				     const struct switch_attr *attr,
 				     struct switch_val *val)
@@ -102,6 +133,14 @@ static int mv88e6321_sw_get_mdio_reg(struct switch_dev *dev,
         return 0;
 }
 
+static int mv88e6321_sw_get_tcam_id(struct switch_dev *dev,
+				     const struct switch_attr *attr,
+				     struct switch_val *val)
+{
+        val->value.i = cur_tcam_id;
+        return 0;
+}
+
 static int mv88e6321_sw_set_mdio_write(struct switch_dev *dev,
 				       const struct switch_attr *attr,
 				       struct switch_val *val)
@@ -367,6 +406,309 @@ static inline int mv88e6321_sw_get_dsa_enable(struct switch_dev *dev,
 }
 #endif
 
+#ifdef CONFIG_OF
+
+static struct tcam_info* mv88e6321_get_tcam_info_by_title(const char *title)
+{
+	struct tcam_info *ret = NULL, *tcam_info = NULL;
+
+	list_for_each_entry(tcam_info, &mvinfo->tcam_info_head.list, list) {
+		if (strcmp(tcam_info->title, title) == 0) {
+			ret = tcam_info;
+			goto out;
+		}
+	}
+
+out:
+	return ret;
+}
+
+static ssize_t store_tcam_entry_enable(struct device* dev,
+				       struct device_attribute *attr,
+			               const char *buf, size_t count)
+{
+	ssize_t ret = count;
+	struct tcam_info *tcam_info = NULL;
+	struct mii_bus *bus = mvinfo->swdev->mii_bus;
+
+	if (count == 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	tcam_info = mv88e6321_get_tcam_info_by_title(attr->attr.name);
+
+	if (tcam_info) {
+		if (buf[0] == '0' || buf[0] == 0)
+			ret = mv88e6321_disable_tcam(bus, tcam_info->id);
+		else
+			ret = mv88e6321_enable_tcam(bus, tcam_info->id,
+						    tcam_info->reg_frame_type);
+		if (ret >= 0)
+			ret = count;
+	} else {
+		ret = -EEXIST;
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static ssize_t show_tcam_entry_enable(struct device* dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	ssize_t ret = 0;
+	struct tcam_info *tcam_info = NULL;
+	struct mii_bus *bus = mvinfo->swdev->mii_bus;
+
+	tcam_info = mv88e6321_get_tcam_info_by_title(attr->attr.name);
+
+	if (tcam_info) {
+		if (mv88e6321_is_tcam_enabled(bus, tcam_info->id))
+			snprintf(buf, PAGE_SIZE, "%d", 1);
+		else
+			snprintf(buf, PAGE_SIZE, "%d", 0);
+		ret = 1;
+	} else {
+		ret = -EEXIST;
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static int mv88e6321_add_device_file(struct device *dev, struct tcam_info
+				     *tcam_info)
+{
+	int ret = 0;
+	pr_debug("create device file: %s\n", tcam_info->title);
+
+	tcam_info->dev_attr.attr.name = tcam_info->title,
+	tcam_info->dev_attr.attr.mode = S_IWUSR | S_IRUGO;
+
+	tcam_info->dev_attr.show = show_tcam_entry_enable;
+	tcam_info->dev_attr.store = store_tcam_entry_enable;
+
+	ret = device_create_file(dev, &tcam_info->dev_attr);
+
+	pr_debug("%s ret: %d\n", __func__, ret);
+
+	return ret;
+}
+
+static void mv88e6321_cleanup_tcam(struct mv88e6321_info *pdata)
+{
+	struct tcam_info *tcam_info = NULL, *tcam_info_tmp = NULL;
+
+	/* cleanup all tcam entries on switch */
+	mv88e6321_flush_tcam(pdata->swdev->mii_bus, -1);
+
+	/* remove all sysfs device files */
+	list_for_each_entry_safe(tcam_info, tcam_info_tmp,
+				 &pdata->tcam_info_head.list, list) {
+		pr_debug("%s del tcam_info: %p title: %s\n", __func__,
+			 tcam_info, tcam_info->title);
+		device_remove_file(pdata->dev, &tcam_info->dev_attr);
+		list_del(&tcam_info->list);
+		devm_kfree(pdata->dev, tcam_info);
+	}
+
+	if (pdata->tcam_fdt) {
+		devm_kfree(pdata->dev, pdata->tcam_fdt);
+		pdata->tcam_fdt = NULL;
+	}
+
+	if (pdata->tcam_np) {
+		kfree(pdata->tcam_np);
+		pdata->tcam_np = NULL;
+	}
+}
+
+static int mv88e6321_set_tcam_entry(struct mii_bus *bus,
+				    struct tcam_entry *tcam_entry)
+{
+	int ret = 0;
+	u16 reg_frame_type = 0;
+	struct tcam_info *tcam_info = NULL;
+
+	/* disable TCAM entry by default */
+	reg_frame_type = tcam_entry->reg_frame_type;
+	tcam_entry->reg_frame_type = 0x00FF;
+
+	ret = mv88e6321_load_tcam(bus, tcam_entry);
+	if (ret < 0)
+		goto out;
+
+	tcam_info = devm_kzalloc(mvinfo->dev, sizeof(struct tcam_info),
+				 GFP_KERNEL);
+	if (!tcam_info) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	tcam_info->title = tcam_entry->title;
+	tcam_info->id = tcam_entry->orig_id;
+	if (tcam_entry->is96frame)
+		tcam_info->next_id = tcam_entry->next_id;
+	else
+		tcam_info->next_id = -1;
+	tcam_info->reg_frame_type = reg_frame_type;
+
+	list_add(&tcam_info->list, &mvinfo->tcam_info_head.list);
+
+	ret = mv88e6321_add_device_file(mvinfo->dev, tcam_info);
+	if (ret < 0)
+		goto out_free_tcam_info;
+
+	pr_debug("tcam entry: %s added\n", tcam_info->title);
+
+	return 0;
+
+out_free_tcam_info:
+	list_del(&tcam_info->list);
+	devm_kfree(mvinfo->dev, tcam_info);
+out:
+	return ret;
+}
+
+static int mv88e6321_sw_set_tcam(struct switch_dev *dev,
+				 const struct switch_attr *attr,
+				 struct switch_val *val)
+{
+	int ret = 0;
+	struct tcam_entries tcam_entries;
+	struct tcam_entry *tcam_entry = NULL;
+	struct tcam_entry *tcam_entry_tmp = NULL;
+
+	memset(&tcam_entries, 0, sizeof(struct tcam_entries));
+	INIT_LIST_HEAD(&tcam_entries.head.list);
+
+	mutex_lock_interruptible(&mvinfo->tcam_lock);
+
+	if (mvinfo->tcam_np) {
+		ret = of_get_tcam_entry(&tcam_entries, mvinfo->tcam_np);
+		if (ret < 0)
+			goto out;
+
+		ret = mv88e6321_set_tcam_mode(dev->mii_bus, &tcam_entries);
+		if (ret < 0)
+			goto out_free_tcam_infos;
+
+		list_for_each_entry(tcam_entry, &tcam_entries.head.list, list) {
+			ret = mv88e6321_set_tcam_entry(dev->mii_bus,
+						       tcam_entry);
+			if (ret < 0)
+				goto out_free_tcam_infos;
+		}
+	} else
+		ret = -ENODATA;
+
+	goto out_free_tcam_entries;
+
+out_free_tcam_infos:
+	mv88e6321_cleanup_tcam(mvinfo);
+out_free_tcam_entries:
+	list_for_each_entry_safe(tcam_entry, tcam_entry_tmp,
+				 &tcam_entries.head.list, list) {
+		list_del(&tcam_entry->list);
+		kfree(tcam_entry);
+	}
+out:
+	mutex_unlock(&mvinfo->tcam_lock);
+	pr_debug("%s ret: %d\n", __func__, ret);
+	return ret;
+}
+
+static int mv88e6321_sw_get_tcam(struct switch_dev *dev,
+				 const struct switch_attr *attr,
+				 struct switch_val *val)
+{
+	int ret = 0;
+	struct mii_bus *bus = dev->mii_bus;
+	struct tcam_entry tcam_entry;
+
+	if (cur_tcam_id < 0 || cur_tcam_id > 255)
+		return -EINVAL;
+
+	memset(mvinfo->tcam_buf, 0, sizeof(mvinfo->tcam_buf));
+	memset(&tcam_entry, 0, sizeof(tcam_entry));
+
+	mutex_lock_interruptible(&mvinfo->tcam_lock);
+	ret = mv88e6321_get_tcam(bus, cur_tcam_id, &tcam_entry);
+	if (ret < 0)
+		goto out;
+
+	ret = mv88e6321_tcam_to_string(&tcam_entry, mvinfo->tcam_buf,
+				       sizeof(mvinfo->tcam_buf));
+	if (ret < 0)
+		goto out;
+
+	val->value.s = mvinfo->tcam_buf;
+out:
+	mutex_unlock(&mvinfo->tcam_lock);
+	return ret;
+}
+
+static int mv88e6321_sw_flush_tcam(struct switch_dev *dev,
+				   const struct switch_attr *attr,
+				   struct switch_val *val)
+{
+	int ret = 0;
+	struct mii_bus *bus = dev->mii_bus;
+	struct tcam_info *tcam_info = NULL, *tcam_info_tmp = NULL;
+
+	mutex_lock_interruptible(&mvinfo->tcam_lock);
+
+	if (cur_tcam_id < 0)
+		mv88e6321_cleanup_tcam(mvinfo);
+	else if (cur_tcam_id <= 255) {
+		list_for_each_entry_safe(tcam_info, tcam_info_tmp,
+					 &mvinfo->tcam_info_head.list, list) {
+			if (tcam_info->id == cur_tcam_id) {
+				mv88e6321_flush_tcam(bus, cur_tcam_id);
+				if (tcam_info->next_id >= 0)
+					mv88e6321_flush_tcam(bus,
+							     tcam_info->next_id);
+				device_remove_file(mvinfo->dev,
+						   &tcam_info->dev_attr);
+				list_del(&tcam_info->list);
+				kfree(tcam_info);
+				goto out;
+			}
+		}
+		ret = -EEXIST;
+	} else
+		ret = -EINVAL;
+
+out:
+	mutex_unlock(&mvinfo->tcam_lock);
+	return ret;
+}
+
+static int mv88e6321_sw_get_tcam_debug(struct switch_dev *dev,
+				       const struct switch_attr *attr,
+				       struct switch_val *val)
+{
+	int ret = 0;
+	struct mii_bus *bus = dev->mii_bus;
+
+	if (cur_tcam_id >= 0 && cur_tcam_id <= 255)
+		ret = mv88e6321_get_tcam_debug(bus, cur_tcam_id);
+	else
+		ret = -EINVAL;
+
+	if (ret >= 0) {
+		val->value.i = ret;
+		ret = 0;
+	}
+
+	return ret;
+}
+#endif
+
 static struct switch_attr mv88e6321_global_attrs[] = {
         {
                 .type = SWITCH_TYPE_NOVAL,
@@ -388,10 +730,35 @@ static struct switch_attr mv88e6321_global_attrs[] = {
         }, {
                 .type = SWITCH_TYPE_INT,
                 .name = "mdio_rw_mdio_generic",
-                .description = "Read/Write with selected mdio registers (not nested)",
+                .description = "Read/Write with selected mdio registers",
                 .set = mv88e6321_sw_set_mdio_write,
                 .get = mv88e6321_sw_get_mdio_read,
         },
+#ifdef CONFIG_OF
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "tcam_id",
+		.description = "Read/Write TCAM id",
+		.set = mv88e6321_sw_set_tcam_id,
+		.get = mv88e6321_sw_get_tcam_id,
+	}, {
+		.type = SWITCH_TYPE_STRING,
+		.name = "tcam",
+		.description = "Read/Write TCAM entry to MV88e6321",
+		.set = mv88e6321_sw_set_tcam,
+		.get = mv88e6321_sw_get_tcam,
+	}, {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "tcam_flush",
+		.description = "Flush TCAM entry from MV88E6321",
+		.set = mv88e6321_sw_flush_tcam,
+	}, {
+		.type = SWITCH_TYPE_INT,
+		.name = "tcam_debug",
+		.description = "Read TCAM debug register",
+		.get = mv88e6321_sw_get_tcam_debug,
+	},
+#endif
 #ifdef CONFIG_NET_DSA_MV88E6XXX
         {
                 .type = SWITCH_TYPE_INT,
@@ -419,6 +786,90 @@ struct switch_dev_ops mv88e6321_switch_dev_ops = {
         .reset_switch = mv88e6321_sw_reset,
 };
 
+#ifdef CONFIG_OF
+
+static ssize_t show_tcam_dtb(struct device* dev, struct device_attribute *attr,
+			     char *buf)
+{
+	ssize_t ret = 0;
+	struct mv88e6321_info *pdata = dev->platform_data;
+
+	mutex_lock_interruptible(&pdata->tcam_lock);
+
+	if (pdata && pdata->tcam_fdt) {
+		size_t fdt_size = 0;
+		u32 *pos = pdata->tcam_fdt + 4;
+		fdt_size = le32_to_cpu(*pos);
+		pr_debug("fdt size %d\n", fdt_size);
+
+		if (fdt_size < 40 || fdt_size > PAGE_SIZE) {
+			dev_err(dev, "Invalid FDT size %d\n", fdt_size);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(buf, pdata->tcam_fdt, fdt_size);
+		ret = fdt_size;
+	}
+
+out:
+	mutex_unlock(&pdata->tcam_lock);
+	return ret;
+}
+
+static ssize_t store_tcam_dtb(struct device* dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	ssize_t ret = 0;
+	struct mv88e6321_info *pdata = dev->platform_data;
+
+	/* dtb should be smaller than PAGE_SIZE
+	 * because it will be showen. Maximum buffer
+	 * size in show function is PAGE_SIZE.
+	 * 40 byte it fdt header, so it is min size*/
+	if (count < 40 || count > PAGE_SIZE) {
+		dev_err(dev, "Invalid size of FDT (%d)\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	mutex_lock_interruptible(&pdata->tcam_lock);
+
+	mv88e6321_cleanup_tcam(pdata);
+
+	pdata->tcam_fdt = devm_kzalloc(dev, count, GFP_KERNEL);
+
+	if (!pdata->tcam_fdt) {
+		dev_err(dev, "Couldn't allocate memory for fdt\n");
+		ret = -ENOMEM;
+		goto out_unlock;
+	}
+
+	memcpy(pdata->tcam_fdt, buf, count);
+
+	if (IS_ERR(of_fdt_unflatten_tree(pdata->tcam_fdt, NULL,
+					 &pdata->tcam_np))) {
+		dev_err(dev, "Unflatten device tree failed\n");
+		ret = -ENOMEM;
+		goto fdt_free_out;
+	}
+
+	ret = count;
+	goto out_unlock;
+
+fdt_free_out:
+	devm_kfree(dev, pdata->tcam_fdt);
+	pdata->tcam_fdt = NULL;
+out_unlock:
+	mutex_unlock(&pdata->tcam_lock);
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(tcam_dtb, S_IWUSR | S_IRUGO, show_tcam_dtb, store_tcam_dtb);
+
+#endif
+
 struct mv88e6321_info *of_get_mv_pdata(struct device *dev)
 {
 	struct device_node *np = dev->of_node;
@@ -447,7 +898,8 @@ struct mv88e6321_info *of_get_mv_pdata(struct device *dev)
 			dev_err(dev, "No gpio reset pin given\n");
 		} else {
 			ret = devm_gpio_request_one(dev, mvinfo->reset_gpio,
-						    GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+						    GPIOF_OUT_INIT_HIGH |
+						    GPIOF_EXPORT_DIR_FIXED,
 						    "SWCFG: Switch Reset Pin");
 			if (ret < 0) {
 				dev_err(dev, "failed to claim gpio-reset pin\n");
@@ -525,7 +977,7 @@ static struct switch_dev *of_get_swdev(struct device *dev)
 			goto out_err_free;
 		}
 
-		dev_info(dev, "mii_bus: found and using '%s'\n", swdev->mii_bus->name);
+		dev_dbg(dev, "mii_bus: found and using '%s'\n", swdev->mii_bus->name);
 
 		swdev->of_node = np;
 		swdev->ops = &mv88e6321_switch_dev_ops;
@@ -541,11 +993,11 @@ static struct switch_dev *of_get_swdev(struct device *dev)
 
 static void mv88e6321_hw_reset(struct mv88e6321_info *mvinfo)
 {
-	dev_info(mvinfo->dev, "Going to reset gpio%d\n", mvinfo->reset_gpio);
+	dev_dbg(mvinfo->dev, "Going to reset gpio%d\n", mvinfo->reset_gpio);
 	gpio_set_value(mvinfo->reset_gpio, 0);
 	mdelay(100);
 	gpio_set_value(mvinfo->reset_gpio, 1);
-	dev_info(mvinfo->dev, "mv88e6321 switch resetted!\n");
+	dev_info(mvinfo->dev, "switch resetted!\n");
 }
 
 static int mv88e6321_probe(struct platform_device *pdev)
@@ -554,14 +1006,14 @@ static int mv88e6321_probe(struct platform_device *pdev)
 	struct mv88e6321_info *pdata;
 	int ret;
 
-	pr_info("%s/%d\n", __func__, __LINE__);
+	pr_debug("%s/%d\n", __func__, __LINE__);
 
 	if (pdev->dev.of_node) {
 		swdev = of_get_swdev(&pdev->dev);
 		if (IS_ERR(swdev))
 			return PTR_ERR(swdev);
 
-		dev_info(&pdev->dev, "SWCFG: switch device '%s'\n", swdev->name);
+		dev_info(&pdev->dev, "switch device '%s'\n", swdev->name);
 
 		pdata = of_get_mv_pdata(&pdev->dev);
 		if (IS_ERR(pdata))
@@ -584,6 +1036,7 @@ static int mv88e6321_probe(struct platform_device *pdev)
 		dev_info(&pdev->dev, "Detected Family ID 0x%x, Chip ID 0x%x\n", chipid[0], chipid[1] >> 4);
 #endif
 
+	pdata->swdev = swdev;
 	pdev->dev.platform_data = pdata;
 
 #if 0
@@ -594,19 +1047,40 @@ static int mv88e6321_probe(struct platform_device *pdev)
 	mv88e6321_fns->nwrite = mv88e6321_smi_nwrite;
         mv88e6321_fns->setup_dflt_cfg = mv88e6321_setup_dflt_cfg;
 #endif
+#ifdef CONFIG_OF
+	INIT_LIST_HEAD(&pdata->tcam_info_head.list);
+	ret = device_create_file(&pdev->dev, &dev_attr_tcam_dtb);
+	if (ret) {
+		dev_err(&pdev->dev, "Couln't create device file %d\n", ret);
+		return ret;
+	}
+
+	mutex_init(&pdata->tcam_lock);
+#endif
 
         if ((ret = register_switch(swdev, NULL))) {
                 pr_info("%s: switch registration failed\n", __func__);
                 return ret;
         }
 
-	dev_info(&pdev->dev, "SWCONFIG: MV88E6321 Driver probed\n");
+	dev_info(&pdev->dev, "driver probed\n");
 
 	return 0;
 }
 
 static int mv88e6321_remove(struct platform_device *pdev)
 {
+#ifdef CONFIG_OF
+	struct mv88e6321_info *pdata = pdev->dev.platform_data;
+	mutex_lock_interruptible(&pdata->tcam_lock);
+
+	device_remove_file(&pdev->dev, &dev_attr_tcam_dtb);
+	mv88e6321_cleanup_tcam(pdata);
+
+	mutex_unlock(&pdata->tcam_lock);
+
+#endif
+	unregister_switch(pdata->swdev);
 	return 0;
 }
 
diff --git a/drivers/net/phy/mv88e6321_tcam.c b/drivers/net/phy/mv88e6321_tcam.c
new file mode 100644
index 0000000..8c60a10
--- /dev/null
+++ b/drivers/net/phy/mv88e6321_tcam.c
@@ -0,0 +1,928 @@
+#define pr_fmt(fmt)     "mv88e6321: tcam:" fmt
+
+#include <linux/delay.h>
+#include "mv88e6321_tcam.h"
+#include "../dsa/mv88e6xxx/mv88e6xxx.h"
+
+#define OF_TCAM_ENTRIES_PROP_READ_U8(__np, __name, __out, __ret, __goto) { \
+u32 val__ = 0; \
+if ((__ret = of_property_read_u32(__np, __name, &val__)) < 0) { \
+	pr_err("no %s property found for tcam entry %s ret: (%d)\n", \
+	       __name, __np->name, __ret); \
+	goto __goto; \
+} \
+tcam_entries->__out = (u8)val__; \
+pr_debug("tcam set %s = 0x%04X\n", __name, val__); \
+} while(0)
+
+#define OF_TCAM_ENTRIES_PROP_READ_OPT_U8(__np, __name, __out, __ret, __goto) { \
+u32 val__ = 0; \
+if (of_property_read_u32(__np, __name, &val__) >= 0) { \
+	tcam_entries->__out = (u8)val__; \
+	pr_debug("tcam set %s = 0x%04X\n", __name, val__); \
+} \
+} while(0)
+
+#define OF_TCAM_PROP_READ_U8(__np, __name, __out, __ret, __goto) { \
+u32 val__ = 0; \
+if ((__ret = of_property_read_u32(__np, __name, &val__)) < 0) { \
+	pr_err("no %s property found for tcam entry %s ret: (%d)\n", \
+	       __name, __np->name, __ret); \
+	kfree(tcam_entry); \
+	goto __goto; \
+} \
+tcam_entry->__out = (u8)val__; \
+pr_debug("tcam set %s = 0x%04X\n", __name, val__); \
+} while(0)
+
+#define OF_TCAM_PROP_READ_OPT_U8(__np, __name, __out) { \
+u32 val__ = 0; \
+if (of_property_read_u32(__np, __name, &val__) >= 0) { \
+	tcam_entry->__out = (u8)val__; \
+	pr_debug("tcam set %s = 0x%04X\n", __name, val__); \
+} \
+} while (0)
+
+#define OF_TCAM_PROP_READ_U16(__np, __name, __out, __ret, __goto) { \
+u32 val__ = 0; \
+if ((__ret = of_property_read_u32(__np, __name, &val__)) < 0) { \
+	pr_err("no %s property found for tcam entry %s\n", \
+	       __name, __np->name); \
+	kfree(tcam_entry); \
+	goto __goto; \
+} \
+tcam_entry->__out = (u16)val__; \
+pr_debug("tcam set %s = 0x%04X\n", __name, val__); \
+} while (0)
+
+#define OF_TCAM_PROP_READ_COND_U8(__np, __name, __mask, __out, __ret, __goto) { \
+	if (tcam_entry->__mask) \
+		OF_TCAM_PROP_READ_U8(__np, __name, __out, __ret, __goto); \
+} while (0)
+
+#define OF_TCAM_PROP_READ_COND_U16(__np, __name, __mask, __out, __ret, __goto) { \
+	if (tcam_entry->__mask) \
+		OF_TCAM_PROP_READ_U16(__np, __name, __out, __ret, __goto); \
+} while (0)
+
+#define OF_TCAM_PROP_READ_BOOL(__np, __name, __out) {\
+if (of_property_read_bool(__np, __name)) {\
+	tcam_entry->__out = 1; \
+	pr_debug("tcam set %s = 1\n", __name); \
+} \
+} while(0)
+
+static int of_set_frame_data(struct tcam_entry *tcam_entry,
+			     struct device_node *np)
+{
+	int ret = 0;
+	u8 buf[TCAM_FRAME_DATA_MAX_SIZE];
+	u8 is_mask = 0;
+	u8 is_96_mask = 0;
+
+	/* get frame data mask */
+	ret = of_property_read_variable_u8_array(np, "frame-data-mask",
+						 buf, 0,
+						 TCAM_FRAME_DATA_MAX_SIZE);
+	if (ret > 0) {
+		while(ret--) {
+			pr_debug("frame_data[%d].mask = 0x%02X\n",
+				 ret, buf[ret]);
+			tcam_entry->frame_data[ret].mask = buf[ret];
+			is_mask |= buf[ret];
+			if (ret >= 48)
+				is_96_mask |= buf[ret];
+		}
+		ret = 0;
+	} else if (ret == 0) {
+		ret = -ENODATA;
+		goto out;
+	}
+
+	if (is_mask) {
+		/* get frame data */
+		ret = of_property_read_variable_u8_array(np, "frame-data", buf,
+						0, TCAM_FRAME_DATA_MAX_SIZE);
+		if (ret > 0) {
+			while (ret--) {
+				pr_debug("frame_data[%d].data = 0x%02X\n",
+					 ret, buf[ret]);
+				tcam_entry->frame_data[ret].data = buf[ret];
+			}
+			ret = 0;
+		} else if (ret == 0) {
+			ret = -ENODATA;
+			goto out;
+		}
+	}
+
+	tcam_entry->is96frame = (is_96_mask) ? 1 : 0;
+
+	if (ret >= 0)
+		ret = 0;
+out:
+	return ret;
+}
+
+int of_get_tcam_entry(struct tcam_entries *tcam_entries,
+			     struct device_node *np)
+{
+	int ret = 0;
+	struct device_node *tcam_np = NULL;
+	struct device_node *child = NULL;
+	struct tcam_entry *tcam_entry = NULL;
+	struct tcam_entry *tcam_entry_tmp = NULL;
+
+	tcam_np = of_find_compatible_node(np, NULL, "mv88e6321,tcam");
+
+	if (!tcam_np) {
+		pr_err("no compatible device node found\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	OF_TCAM_ENTRIES_PROP_READ_U8(tcam_np, "tcam-mode-port-mask", port_mask,
+				     ret, out);
+
+	OF_TCAM_ENTRIES_PROP_READ_OPT_U8(tcam_np, "debug-port", debug_port,
+				     ret, out);
+
+	for_each_child_of_node(tcam_np, child) {
+		pr_info("process tcam entry node %s\n",	child->name);
+
+		tcam_entry = kmalloc(sizeof(struct tcam_entry), GFP_KERNEL);
+		if (!tcam_entry) {
+			pr_err("allocate tcam entry failed\n");
+			ret = -ENOMEM;
+			goto out_free;
+		}
+
+		memset(tcam_entry, 0, sizeof(*tcam_entry));
+
+		tcam_entry->title = child->name;
+
+		OF_TCAM_PROP_READ_U8(child, "id", orig_id, ret, out_free);
+		OF_TCAM_PROP_READ_OPT_U8(child, "frame-type-mask",
+					 mask_frame_type);
+		OF_TCAM_PROP_READ_COND_U8(child, "frame-type", mask_frame_type,
+					  frame_type, ret, out_free);
+		OF_TCAM_PROP_READ_U8(child, "ppri-mask", mask_ppri, ret,
+				     out_free);
+		OF_TCAM_PROP_READ_COND_U8(child, "ppri", mask_ppri, orig_ppri,
+					  ret, out_free);
+		OF_TCAM_PROP_READ_U8(child, "pvid-mask", mask_pvid, ret,
+				     out_free);
+		OF_TCAM_PROP_READ_COND_U16(child, "pvid", mask_pvid, orig_pvid,
+					   ret, out_free);
+		OF_TCAM_PROP_READ_OPT_U8(child, "spv-mask", mask_spv);
+		OF_TCAM_PROP_READ_COND_U8(child, "spv", mask_spv, spv, ret,
+					  out_free);
+		OF_TCAM_PROP_READ_BOOL(child, "vid-override", vid_override);
+		OF_TCAM_PROP_READ_COND_U16(child, "vid-data", vid_override, vid,
+					   ret, out_free);
+		OF_TCAM_PROP_READ_BOOL(child, "interrupt", interrupt);
+		OF_TCAM_PROP_READ_BOOL(child, "inc-tcam-ctr", inc_tcam_ctr);
+		OF_TCAM_PROP_READ_BOOL(child, "fpri-override", fpri_override);
+		OF_TCAM_PROP_READ_COND_U8(child, "fpri-data", fpri_override,
+					  fpri, ret, out_free);
+		OF_TCAM_PROP_READ_BOOL(child, "qpri-override", qpri_override);
+		OF_TCAM_PROP_READ_COND_U8(child, "qpri-data", qpri_override,
+					  qpri, ret, out_free);
+		OF_TCAM_PROP_READ_U8(child, "next-id", next_id, ret, out_free);
+		OF_TCAM_PROP_READ_BOOL(child, "dpv-override", dpv_override);
+		OF_TCAM_PROP_READ_COND_U8(child, "dpv-data", dpv_override, dpv,
+					  ret, out_free);
+		OF_TCAM_PROP_READ_BOOL(child, "ld-balance-override",
+					  ld_balance_override);
+		OF_TCAM_PROP_READ_COND_U8(child, "ld-balance-data",
+				    ld_balance_override, ld_balance, ret,
+				    out_free);
+		OF_TCAM_PROP_READ_BOOL(child, "action-override",
+				       action_override);
+		OF_TCAM_PROP_READ_COND_U16(child, "action-data",
+					   action_override, action, ret,
+					   out_free);
+
+		ret = of_set_frame_data(tcam_entry, child);
+		if (ret) {
+			kfree(tcam_entry);
+			goto out_free;
+		}
+
+		/* let every tcam_entry have same debug port */
+		tcam_entry->debug_port = tcam_entries->debug_port;
+
+		list_add(&tcam_entry->list, &tcam_entries->head.list);
+	}
+
+	goto out;
+
+out_free:
+	list_for_each_entry_safe(tcam_entry, tcam_entry_tmp,
+				 &tcam_entries->head.list, list) {
+		list_del(&tcam_entry->list);
+		kfree(tcam_entry);
+	}
+out:
+	return ret;
+}
+
+#define TCAM_WRITE_REG(__reg, __val, __bus, __ret, __goto_err) { \
+if (__bus) {\
+	__ret = mdiobus_write(__bus, TCAM_ADDR, __reg, __val); \
+	pr_debug("write reg addr: 0x%02X reg: 0x%02X val: 0x%04X ret: %d\n", \
+		 TCAM_ADDR, __reg, __val, __ret); \
+	if (__ret < 0) { \
+		pr_err("write failed to addr: 0x%02X reg: 0x%02X val: 0x%04X ret: %d\n", \
+		       TCAM_ADDR, __reg, __val, __ret); \
+		goto __goto_err; \
+	} \
+} else \
+	__ret = -ENODEV; \
+} while(0)
+
+#define TCAM_READ_REG(__reg, __bus, __ret, __goto_err) {\
+if (__bus) { \
+	__ret = mdiobus_read(__bus, TCAM_ADDR, __reg); \
+	pr_debug("read reg addr: 0x%02X reg: 0x%02X ret: 0x%04X\n", \
+		 TCAM_ADDR, __reg, __ret); \
+	if (__ret < 0) { \
+		pr_err("read failed from addr: 0x%02X reg: 0x%02X ret: %d\n", \
+		       TCAM_ADDR, __reg, __ret); \
+		goto __goto_err; \
+	} \
+} else \
+	__ret = -ENODEV; \
+} while(0)
+
+static inline int mv88e6321_write_tcam_pg_hdr(struct mii_bus *bus,
+				       struct tcam_entry *tcam_entry)
+{
+	int ret = 0;
+
+	tcam_entry->busy = 1;
+	TCAM_WRITE_REG(TCAM_REG_PG_HDR, tcam_entry->reg_pg_hdr, bus, ret, out);
+
+out:
+	return ret;
+}
+
+
+static inline int mv88e6321_wait_tcam_ready(struct mii_bus *bus)
+{
+	int ret = 0;
+	int attempt;
+
+	for (attempt = 0; attempt < 16; ++attempt) {
+		TCAM_READ_REG(TCAM_REG_PG_HDR, bus, ret, out);
+
+		if (!(ret & TCAM_PG_HDR_BUSY))
+			goto out;
+
+		usleep_range(1000, 2000);
+	}
+
+	ret = -ETIMEDOUT;
+	pr_err("timeout while waiting for tcam ready\n");
+
+out:
+	return ret;
+}
+
+
+static int mv88e6321_load_tcam_page2(struct mii_bus *bus,
+				     struct tcam_entry *tcam_entry, int entry_no)
+{
+	int ret = 0;
+
+	tcam_entry->pg = 2;
+
+	pr_debug("load page 2\n");
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	if (entry_no == 0 && tcam_entry->is96frame)
+		tcam_entry->cnt = 1;
+	else
+		tcam_entry->cnt = 0;
+
+
+	TCAM_WRITE_REG(TCAM_REG_PG2_ACTION_4, tcam_entry->reg_action_4,
+		       bus, ret, out);
+	TCAM_WRITE_REG(TCAM_REG_PG2_ACTION_3, tcam_entry->reg_action_3,
+		       bus, ret, out);
+	TCAM_WRITE_REG(TCAM_REG_PG2_ACTION_2, tcam_entry->reg_action_2,
+		       bus, ret, out);
+	TCAM_WRITE_REG(TCAM_REG_PG2_ACTION_1, tcam_entry->reg_action_1,
+		       bus, ret, out);
+
+	TCAM_WRITE_REG(TCAM_REG_PG2_DEBUG_PORT, tcam_entry->reg_debug,
+		       bus, ret, out);
+
+	ret = mv88e6321_write_tcam_pg_hdr(bus, tcam_entry);
+out:
+	return ret;
+}
+
+static int mv88e6321_load_tcam_page1(struct mii_bus *bus,
+				     struct tcam_entry *tcam_entry, int entry_no)
+{
+	int ret = 0;
+	int i = 22;
+	int max = 0;
+	int reg = 0;
+
+	tcam_entry->pg = 1;
+
+	pr_debug("load page 1\n");
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	if (entry_no > 0)
+		i = 70;
+
+	max = i + 26;
+
+	for (reg = 2; i < max; ++i, ++reg)
+		TCAM_WRITE_REG(reg, tcam_entry->frame_data[i].reg_data, bus,
+			       ret, out);
+out:
+	return ret;
+}
+
+static int mv88e6321_load_tcam_page0(struct mii_bus *bus,
+				     struct tcam_entry *tcam_entry, int entry_no)
+{
+	int ret = 0;
+	int i = 0;
+	int max = 0;
+	int reg = 0;
+	u16 reg_frame_type = 0;
+
+	tcam_entry->pg = 0;
+
+	pr_debug("load page 0\n");
+
+	if (tcam_entry->frame_type == TCAM_FT_PROV_TAG && entry_no == 0) {
+		tcam_entry->id_pvid = (tcam_entry->orig_pvid & 0xFF);
+		tcam_entry->pvid = ((tcam_entry->orig_pvid >> 8) & 0xF);
+		tcam_entry->mask_id_pvid = (tcam_entry->mask_pvid & 0xFF);
+		tcam_entry->mask_ppri_pvid = (((u16)tcam_entry->mask_ppri)<<8);
+		tcam_entry->mask_ppri_pvid += ((tcam_entry->mask_pvid>>8)&0xF);
+	}
+
+	if (entry_no > 0) {
+		reg_frame_type = 0xC000;
+		reg_frame_type += TCAM_FT_CONTINUE;
+	} else {
+		reg_frame_type = tcam_entry->reg_frame_type;
+	}
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	TCAM_WRITE_REG(TCAM_REG_PG0_KEY_1, reg_frame_type,
+		       bus, ret, out);
+	TCAM_WRITE_REG(TCAM_REG_PG0_KEY_2, tcam_entry->reg_spv,
+		       bus, ret, out);
+	TCAM_WRITE_REG(TCAM_REG_PG0_KEY_3, tcam_entry->reg_ppri_pvid,
+		       bus, ret, out);
+	TCAM_WRITE_REG(TCAM_REG_PG0_KEY_4, tcam_entry->reg_id_ppri,
+		       bus, ret, out);
+
+	if (entry_no > 0)
+		i = 48;
+
+	max = i + 22;
+
+	for (reg = 6; i < max; ++i, ++reg)
+		TCAM_WRITE_REG(reg, tcam_entry->frame_data[i].reg_data, bus,
+			       ret, out);
+
+	ret = mv88e6321_write_tcam_pg_hdr(bus, tcam_entry);
+out:
+	return ret;
+}
+
+int mv88e6321_load_tcam(struct mii_bus *bus,
+			struct tcam_entry *tcam_entry)
+{
+	int ret = 0;
+	int entry_no = 1;
+
+	tcam_entry->op = TCAM_OP_LOAD;
+
+	if (tcam_entry->is96frame) {
+		entry_no = 2;
+	}
+
+	while(entry_no--) {
+		if (entry_no > 0) {
+			tcam_entry->id_pvid = tcam_entry->next_id;
+			tcam_entry->mask_id_pvid = 0xFF;
+			tcam_entry->id = tcam_entry->next_id;
+			tcam_entry->next_id = 0;
+		} else {
+			tcam_entry->id_pvid = 0;
+			tcam_entry->mask_id_pvid = 0;
+			tcam_entry->next_id = tcam_entry->id;
+			tcam_entry->id = tcam_entry->orig_id;
+		}
+
+		ret = mv88e6321_load_tcam_page2(bus, tcam_entry, entry_no);
+		if (ret < 0)
+			goto out;
+
+		ret = mv88e6321_load_tcam_page1(bus, tcam_entry, entry_no);
+		if (ret < 0)
+			goto out;
+
+		ret = mv88e6321_load_tcam_page0(bus, tcam_entry, entry_no);
+		if (ret < 0)
+			goto out;
+	}
+
+out:
+	pr_debug("%s ret: %d\n", __func__, ret);
+	return ret;
+}
+
+static int mv88e6321_get_tcam_pg0(struct mii_bus *bus, struct tcam_entry
+				  *tcam_entry, int entry_no)
+{
+	int ret = 0;
+	int i = 0;
+	int reg = 0;
+	int max = 0;
+
+	pr_debug("read tcam page 0\n");
+
+	tcam_entry->pg = 0;
+
+	ret = mv88e6321_write_tcam_pg_hdr(bus, tcam_entry);
+	if (ret < 0)
+		goto out;
+
+	if (entry_no == 0) {
+		TCAM_READ_REG(TCAM_REG_PG0_KEY_1, bus, ret, out);
+		tcam_entry->reg_frame_type = ((u16)ret);
+
+		if (tcam_entry->reg_frame_type != 0x00FF) {
+			tcam_entry->is_valid = 1;
+		} else
+			goto out;
+
+		TCAM_READ_REG(TCAM_REG_PG0_KEY_2, bus, ret, out);
+		tcam_entry->reg_spv = ((u16)ret);
+		TCAM_READ_REG(TCAM_REG_PG0_KEY_3, bus, ret, out);
+		tcam_entry->reg_ppri_pvid = ((u16)ret);
+		tcam_entry->mask_ppri = (((u8)tcam_entry->mask_ppri_pvid) >> 4);
+		tcam_entry->orig_pvid = tcam_entry->pvid;
+		tcam_entry->orig_pvid <<= 8;
+		tcam_entry->mask_pvid = (tcam_entry->mask_ppri_pvid & 0xF);
+		tcam_entry->mask_pvid <<= 8;
+		TCAM_READ_REG(TCAM_REG_PG0_KEY_4, bus, ret, out);
+		tcam_entry->reg_id_ppri = ((u16)ret);
+		tcam_entry->orig_pvid += tcam_entry->id_pvid;
+		tcam_entry->mask_pvid += tcam_entry->mask_id_pvid;
+	}
+
+	if (entry_no > 0)
+		i = 48;
+
+	max = i + 22;
+
+	for (reg = 6; i < max; ++i, ++reg) {
+		TCAM_READ_REG(reg, bus, ret, out);
+		tcam_entry->frame_data[i].reg_data = ((u16)ret);
+	}
+out:
+	return ret;
+}
+
+static int mv88e6321_get_tcam_pg1(struct mii_bus *bus, struct tcam_entry
+				  *tcam_entry, int entry_no)
+{
+	int ret = 0;
+	int i = 22;
+	int reg = 0;
+	int max = 0;
+
+	pr_debug("read tcam page 1\n");
+
+	tcam_entry->pg = 1;
+
+	ret = mv88e6321_write_tcam_pg_hdr(bus, tcam_entry);
+	if (ret < 0)
+		goto out;
+
+	if (entry_no > 0)
+		i = 70;
+
+	max = i + 26;
+
+	for (reg = 2; i < max; ++i, ++reg) {
+		TCAM_READ_REG(reg, bus, ret, out);
+		tcam_entry->frame_data[i].reg_data = ((u16)ret);
+	}
+out:
+	return ret;
+}
+
+static int mv88e6321_get_tcam_pg2(struct mii_bus *bus, struct tcam_entry
+				  *tcam_entry, int entry_no)
+{
+	int ret = 0;
+
+	pr_debug("read tcam page 2\n");
+
+	tcam_entry->pg = 2;
+
+	if (entry_no == 0) {
+		ret = mv88e6321_write_tcam_pg_hdr(bus, tcam_entry);
+		if (ret < 0)
+			goto out;
+
+		TCAM_READ_REG(TCAM_REG_PG2_ACTION_1, bus, ret, out);
+		tcam_entry->reg_action_1 = ((u16)ret);
+		TCAM_READ_REG(TCAM_REG_PG2_ACTION_2, bus, ret, out);
+		tcam_entry->reg_action_2 = ((u16)ret);
+		TCAM_READ_REG(TCAM_REG_PG2_ACTION_3, bus, ret, out);
+		tcam_entry->reg_action_3 = ((u16)ret);
+		TCAM_READ_REG(TCAM_REG_PG2_ACTION_4, bus, ret, out);
+		tcam_entry->reg_action_4 = ((u16)ret);
+		TCAM_READ_REG(TCAM_REG_PG2_DEBUG_PORT, bus, ret, out);
+		tcam_entry->reg_debug = ((u16)ret);
+		TCAM_READ_REG(TCAM_REG_PG2_DEBUG, bus, ret, out);
+		tcam_entry->reg_hit = ((u16)ret);
+	}
+
+out:
+	return ret;
+}
+
+
+int mv88e6321_get_tcam(struct mii_bus *bus, u8 id, struct tcam_entry *tcam_entry)
+{
+	int ret = 0;
+	int i = 0;
+
+	tcam_entry->id = tcam_entry->orig_id = id;
+	tcam_entry->op = TCAM_OP_READ;
+
+	for (i = 0; i < 2; ++i) {
+		if (i > 0) {
+			tcam_entry->id = tcam_entry->next_id;
+		}
+
+		ret = mv88e6321_get_tcam_pg0(bus, tcam_entry, i);
+		if (ret < 0 || !tcam_entry->is_valid)
+			goto out;
+
+		ret = mv88e6321_get_tcam_pg1(bus, tcam_entry, i);
+		if (ret < 0)
+			goto out;
+
+		ret = mv88e6321_get_tcam_pg2(bus, tcam_entry, i);
+		if (ret < 0)
+			goto out;
+
+		if (!tcam_entry->cnt)
+			break;
+	}
+
+out:
+	pr_debug("%s ret: %d\n", __func__, ret);
+	return ret;
+}
+
+int mv88e6321_tcam_to_string(struct tcam_entry *tcam_entry,
+			     char *buffer, size_t size)
+{
+	int ret = 0;
+	int i = 0;
+	char *p = buffer;
+
+
+	if (!tcam_entry->is_valid) {
+		p += sprintf(p, "TCAM with ID %d is disabled", tcam_entry->id);
+		goto out;
+	}
+	p += sprintf(p, "\n\t\tTCAM            ID: %d\n", tcam_entry->orig_id);
+
+	p += sprintf(p, "\t\tTCAM    frame type: 0x%02X mask: 0x%02X\n",
+		     tcam_entry->frame_type, tcam_entry->mask_frame_type);
+	p += sprintf(p, "\t\tTCAM           spv: 0x%02X mask: 0x%02X\n",
+		     tcam_entry->spv, tcam_entry->mask_spv);
+	p += sprintf(p, "\t\tTCAM          ppri: 0x%02X mask: 0x%02X\n",
+		     tcam_entry->ppri, tcam_entry->mask_ppri);
+
+	if (tcam_entry->mask_frame_type &&
+	    tcam_entry->frame_type == TCAM_FT_PROV_TAG) {
+		p += sprintf(p, "\t\tTCAM          pvid: 0x%04X mask: 0x%04X\n",
+			     tcam_entry->orig_pvid, tcam_entry->mask_pvid);
+	}
+
+	p += sprintf(p, "\t\tTCAM        cnt id: 0x%02X mask: 0x%02X\n",
+		     tcam_entry->id_pvid, tcam_entry->mask_id_pvid);
+	p += sprintf(p, "\t\tTCAM    frame data: [MASK:DATA]");
+
+	for(i = 0; i < 48; ++i) {
+		if (!(i % 16))
+			p += sprintf(p, "\n\t\t\t");
+		p += sprintf(p, "%02X:%02X ",
+			     tcam_entry->frame_data[i].mask,
+			     tcam_entry->frame_data[i].data);
+	}
+
+	if (tcam_entry->cnt) {
+		for(i = 48; i < TCAM_FRAME_DATA_MAX_SIZE; ++i) {
+			if (!(i % 16))
+				p += sprintf(p, "\n\t\t\t");
+			p += sprintf(p, "%02X:%02X ",
+				     tcam_entry->frame_data[i].mask,
+				     tcam_entry->frame_data[i].data);
+		}
+	}
+
+	p += sprintf(p, "\n\t\tTCAM      continue: %d\n", tcam_entry->cnt);
+	p += sprintf(p, "\t\tTCAM     interrupt: %d\n", tcam_entry->interrupt);
+	p += sprintf(p, "\t\tTCAM      inc ctrl: %d\n", tcam_entry->inc_tcam_ctr);
+	p += sprintf(p, "\t\tTCAM  override vid: %d vid: 0x%04X\n",
+		     tcam_entry->vid_override, tcam_entry->vid);
+	p += sprintf(p, "\t\tTCAM    next index: %d\n", tcam_entry->next_id);
+	p += sprintf(p, "\t\tTCAM override qpri: %d qpri: 0x%02X\n",
+		     tcam_entry->qpri_override, tcam_entry->qpri);
+	p += sprintf(p, "\t\tTCAM override fpri: %d fpri: 0x%02X\n",
+		     tcam_entry->fpri_override, tcam_entry->fpri);
+	p += sprintf(p, "\t\tTACM  override dpv: %d dpv: 0x%04X\n",
+		     tcam_entry->dpv_override, tcam_entry->dpv);
+	p += sprintf(p, "\t\tTCAM  override act: %d action: 0x%04X\n",
+		     tcam_entry->action_override,tcam_entry->action);
+	p += sprintf(p, "\t\tTCAM   override lb: %d load balance: 0x%02X\n",
+		     tcam_entry->ld_balance_override, tcam_entry->ld_balance);
+	p += sprintf(p, "\t\tTCAM    debug port: %d\n", tcam_entry->debug_port);
+	p += sprintf(p, "\t\tTCAM           hit: 0x%04X\n", tcam_entry->reg_hit);
+
+out:
+	return ret;
+}
+
+#define MV88E6321_PORTS		7
+
+#define PORT_REG(__reg)		(0x10 + (__reg))
+
+static inline int mv88e6321_set_port_state(struct mii_bus *bus, u16 addr,
+					   u16 state, u16 *old_reg_val)
+{
+	int ret = 0;
+	u16 reg = PORT_CONTROL;
+
+	ret = mdiobus_read(bus, addr, reg);
+	if (ret < 0) {
+		pr_err("read failed from addr: %d reg: %d ret: %d\n", addr, reg,
+		       ret);
+		goto out;
+	}
+
+	if (old_reg_val)
+		*old_reg_val = (u16)ret;
+
+	ret &= ~PORT_CONTROL_STATE_MASK;
+	ret |= state;
+	ret = mdiobus_write(bus, addr, reg, ret);
+	if (ret < 0) {
+		pr_err("write failed to addr: %d reg: %d ret: %d\n", addr, reg,
+		       ret);
+		goto out;
+	}
+
+out:
+	return ret;
+}
+
+static int mv88e6321_enable_tcam_mode(struct mii_bus *bus, u16 addr,
+				      u16 port_prio_val)
+{
+	int ret = 0;
+	u16 reg = PORT_PRI_OVERRIDE;
+	u16 port_ctrl_val = 0;
+
+	/*TODO: currently this function support only 96byte tcam mode.
+	 * This mode includes 48byte tcam mode too. In future only
+	 * 48byte mode could be implemented.*/
+
+	/* disable port before chage tcam mode */
+	ret = mv88e6321_set_port_state(bus, addr,
+				       PORT_CONTROL_STATE_DISABLED,
+				       &port_ctrl_val);
+	if (ret < 0)
+		goto out;
+
+	port_prio_val &= ~PORT_PRI_OVERRIDE_TCAM_MODE_MASK;
+	port_prio_val |= PORT_PRI_OVERRIDE_TCAM_MODE_96;
+
+	ret = mdiobus_write(bus, addr, reg, port_prio_val);
+	if (ret < 0) {
+		pr_err("write failed to addr: %d reg: %d ret: %d\n",
+		       addr, reg, ret);
+		goto out;
+	}
+
+	/* set old port state after tcam mode changing */
+	ret = mv88e6321_set_port_state(bus, addr, port_ctrl_val &
+				       PORT_CONTROL_STATE_MASK, NULL);
+	if (ret < 0)
+		goto out;
+
+out:
+	return ret;
+}
+
+int mv88e6321_set_tcam_mode(struct mii_bus *bus,
+			       struct tcam_entries *tcam_entries)
+{
+	int ret = 0;
+	int addr = PORT_REG(0);
+	u8 mask = 1;
+
+	for (; addr < PORT_REG(MV88E6321_PORTS); ++addr) {
+		u16 reg = PORT_PRI_OVERRIDE;
+		if (mask & tcam_entries->port_mask) {
+			ret = mdiobus_read(bus, addr, reg);
+			if (ret < 0) {
+				pr_err("read failed from addr: %d reg: %d " \
+				       "ret: %d\n", addr, reg, ret);
+				goto out;
+			}
+			if ((ret & PORT_PRI_OVERRIDE_TCAM_MODE_MASK) !=
+			    PORT_PRI_OVERRIDE_TCAM_MODE_96) {
+				ret = mv88e6321_enable_tcam_mode(bus, addr, ret);
+			}
+		}
+		mask <<= 1;
+	}
+
+out:
+	pr_debug("%s ret: %d\n", __func__, ret);
+	return ret;
+}
+
+int mv88e6321_flush_tcam(struct mii_bus *bus, int id)
+{
+	int ret = 0;
+	struct tcam_entry tcam_entry;
+
+	memset(&tcam_entry, 0, sizeof(struct tcam_entry));
+
+	if (id < 0)
+		tcam_entry.op = TCAM_OP_FLUSH_ALL;
+	else if (id >= 0 && id <= 255)
+		tcam_entry.op = TCAM_OP_FLUSH;
+	else
+		goto out;
+
+	tcam_entry.id = id;
+
+	if (id < 0)
+		pr_debug("flush all TCAM\n");
+	else
+		pr_debug("flush TCAM ID:%d\n", id);
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_write_tcam_pg_hdr(bus, &tcam_entry)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+out:
+	return ret;
+}
+
+int mv88e6321_enable_tcam(struct mii_bus *bus, u8 id, u16 reg_frame_type)
+{
+	int ret = 0;
+	struct tcam_entry tcam_entry;
+
+	memset(&tcam_entry, 0, sizeof(struct tcam_entry));
+
+	tcam_entry.op = TCAM_OP_READ;
+	tcam_entry.pg = 0;
+	tcam_entry.id = id;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_write_tcam_pg_hdr(bus, &tcam_entry)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	TCAM_WRITE_REG(TCAM_REG_PG0_KEY_1, reg_frame_type, bus, ret, out);
+
+	tcam_entry.op = TCAM_OP_LOAD;
+
+	if ((ret = mv88e6321_write_tcam_pg_hdr(bus, &tcam_entry)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+out:
+	return ret;
+}
+
+int mv88e6321_disable_tcam(struct mii_bus *bus, u8 id)
+{
+	int ret = 0;
+	struct tcam_entry tcam_entry;
+
+	memset(&tcam_entry, 0, sizeof(struct tcam_entry));
+
+	tcam_entry.op = TCAM_OP_READ;
+	tcam_entry.pg = 0;
+	tcam_entry.id = id;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_write_tcam_pg_hdr(bus, &tcam_entry)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	TCAM_WRITE_REG(TCAM_REG_PG0_KEY_1, 0xFF, bus, ret, out);
+
+	tcam_entry.op = TCAM_OP_LOAD;
+
+	if ((ret = mv88e6321_write_tcam_pg_hdr(bus, &tcam_entry)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+out:
+	return ret;
+}
+
+int mv88e6321_is_tcam_enabled(struct mii_bus *bus, u8 id)
+{
+	int ret = 0;
+	struct tcam_entry tcam_entry;
+
+	memset(&tcam_entry, 0, sizeof(struct tcam_entry));
+
+	tcam_entry.op = TCAM_OP_READ;
+	tcam_entry.pg = 0;
+	tcam_entry.id = id;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_write_tcam_pg_hdr(bus, &tcam_entry)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	TCAM_READ_REG(TCAM_REG_PG0_KEY_1, bus, ret, out);
+
+	if (ret == 0xFF)
+		ret = 0;
+	else
+		ret = 1;
+out:
+	return ret;
+}
+
+int mv88e6321_get_tcam_debug(struct mii_bus *bus, u8 id)
+{
+	int ret = 0;
+	struct tcam_entry tcam_entry;
+
+	memset(&tcam_entry, 0, sizeof(struct tcam_entry));
+
+	tcam_entry.op = TCAM_OP_READ;
+	tcam_entry.pg = 2;
+	tcam_entry.id = id;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_write_tcam_pg_hdr(bus, &tcam_entry)) < 0)
+		goto out;
+
+	if ((ret = mv88e6321_wait_tcam_ready(bus)) < 0)
+		goto out;
+
+	TCAM_READ_REG(TCAM_REG_PG2_DEBUG, bus, ret, out);
+out:
+	return ret;
+}
diff --git a/drivers/net/phy/mv88e6321_tcam.h b/drivers/net/phy/mv88e6321_tcam.h
new file mode 100644
index 0000000..5ea070d
--- /dev/null
+++ b/drivers/net/phy/mv88e6321_tcam.h
@@ -0,0 +1,202 @@
+#ifndef __MV88E6321_TCAM__
+#define __MV88E6321_TCAM__
+
+#include <linux/mdio.h>
+#include <linux/list.h>
+#include <linux/of.h>
+
+#define TCAM_FRAME_DATA_MAX_SIZE 96
+
+struct tcam_frame_data{
+	union {
+		struct {
+			u16 data:8;
+			u16 mask:8;
+		};
+
+		u16 reg_data;
+	};
+};
+
+struct tcam_entry {
+	const char *title;
+	struct list_head list;
+	u8 orig_id;
+	u8 is_valid;
+	union {
+		struct {
+			u16 id:8;
+			u16 res0:2;
+			u16 pg:2;
+			u16 op:3;
+			u16 busy:1;
+		};
+
+		u16 reg_pg_hdr;
+	};
+
+	union {
+		struct {
+			u16 res1:6;
+			u16 frame_type:2;
+			u16 res2:6;
+			u16 mask_frame_type:2;
+		};
+
+		u16 reg_frame_type;
+	};
+
+	union {
+		struct {
+			u16 spv:7;
+			u16 res3:1;
+			u16 mask_spv:7;
+		};
+
+		u16 reg_spv;
+	};
+
+	u16 orig_pvid;
+	u8 orig_ppri;
+	u16 mask_pvid;
+	u8 mask_ppri;
+	union {
+		struct {
+			u16 pvid:4;
+			u16 ppri:4;
+			u16 mask_ppri_pvid:8;
+		};
+
+		u16 reg_ppri_pvid;
+	};
+
+	union {
+		struct {
+			u16 id_pvid:8;
+			u16 mask_id_pvid:8;
+		};
+
+		u16 reg_id_ppri;
+	};
+
+	u8 is96frame;
+	struct tcam_frame_data frame_data[TCAM_FRAME_DATA_MAX_SIZE];
+
+	union {
+		struct {
+			u16 vid:12;
+			u16 vid_override:1;
+			u16 inc_tcam_ctr:1;
+			u16 interrupt:1;
+			u16 cnt:1;
+		};
+
+		u16 reg_action_1;
+	};
+
+	union {
+		struct {
+			u16 fpri:3;
+			u16 fpri_override:1;
+			u16 qpri:2;
+			u16 res4:1;
+			u16 qpri_override:1;
+			u16 next_id:8;
+		};
+
+		u16 reg_action_2;
+	};
+
+	union {
+		struct {
+			u16 dpv:7;
+			u16 res5:4;
+			u16 dpv_override:1;
+		};
+
+		u16 reg_action_3;
+	};
+
+	union {
+		struct {
+			u16 ld_balance:3;
+			u16 ld_balance_override:1;
+			u16 action:11;
+			u16 action_override:1;
+		};
+
+		u16 reg_action_4;
+	};
+
+	union {
+		struct {
+			u16 debug_port:4;
+		};
+
+		u16 reg_debug;
+	};
+
+	union {
+		struct {
+			u16 hit_low:8;
+			u16 hit_high:8;
+		};
+
+		u16 reg_hit;
+	};
+};
+
+struct tcam_entries {
+	u8 port_mask;
+	u8 debug_port;
+
+	struct tcam_entry head;
+};
+
+#define TCAM_OP_NOP		0
+#define TCAM_OP_FLUSH_ALL	1
+#define TCAM_OP_FLUSH		2
+#define TCAM_OP_LOAD		3
+#define TCAM_OP_GET_NEXT	4
+#define TCAM_OP_READ		5
+
+#define TCAM_FT_NORM_NET	0
+#define TCAM_FT_CONTINUE	0
+#define TCAM_FT_DSA_TAG		1
+#define TCAM_FT_PROV_TAG	2
+
+#define TCAM_ADDR		0x1D
+
+#define TCAM_REG_PG_HDR		0
+
+#define TCAM_REG_PG0_KEY_1	0x2
+#define TCAM_REG_PG0_KEY_2	0x3
+#define TCAM_REG_PG0_KEY_3	0x4
+#define TCAM_REG_PG0_KEY_4	0x5
+
+#define TCAM_REG_PG2_ACTION_1	0x2
+#define TCAM_REG_PG2_ACTION_2	0x3
+#define TCAM_REG_PG2_ACTION_3	0x4
+#define TCAM_REG_PG2_ACTION_4	0x5
+#define TCAM_REG_PG2_DEBUG_PORT	0x1C
+#define TCAM_REG_PG2_DEBUG	0x1F
+
+#define TCAM_PG_HDR_BUSY	((u16)1 << 15)
+
+int of_get_tcam_entry(struct tcam_entries *tcam_entries,
+		      struct device_node *np);
+int mv88e6321_set_tcam_mode(struct mii_bus *bus,
+			    struct tcam_entries *tcam_entries);
+int mv88e6321_load_tcam(struct mii_bus *bus,
+			struct tcam_entry *tcam_entry);
+int mv88e6321_get_tcam(struct mii_bus *bus, u8 id,
+		       struct tcam_entry *tcam_entry);
+int mv88e6321_flush_tcam(struct mii_bus *bus, int id);
+int mv88e6321_enable_tcam(struct mii_bus *bus, u8 id, u16 reg_frame_type);
+int mv88e6321_disable_tcam(struct mii_bus *bus, u8 id);
+int mv88e6321_is_tcam_enabled(struct mii_bus *bus, u8 id);
+int mv88e6321_get_tcam_debug(struct mii_bus *bus, u8 id);
+int mv88e6321_tcam_to_string(struct tcam_entry *tcam_entry,
+			     char *buffer, size_t size);
+
+#endif
-- 
2.7.4

