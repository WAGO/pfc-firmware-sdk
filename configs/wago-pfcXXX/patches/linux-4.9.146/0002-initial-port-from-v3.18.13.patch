From 0fb96f25db100ffb60a16541f3fd7f0ce4afddb0 Mon Sep 17 00:00:00 2001
From: Heinrich Toews <heinrich.toews@wago.com>
Date: Wed, 16 Nov 2016 14:37:49 +0000
Subject: [PATCH] initial port from v3.18.13

remove Lauterbach files

kconfig: fix conflicts
---
 Documentation/devicetree/bindings/mfd/tps65218.txt |   58 +
 arch/arm/boot/dts/Makefile                         |   16 +-
 arch/arm/boot/dts/am33xx.dtsi                      |    7 +
 arch/arm/boot/dts/am3517.dtsi                      |   23 +-
 arch/arm/boot/dts/omap3.dtsi                       |    4 +
 arch/arm/boot/dts/pxc-nandparts.dtsi               |   60 +
 arch/arm/boot/dts/tps65218.dtsi                    |   41 +
 arch/arm/boot/dts/wago-pfc100-cmtests.dtsi         |   56 +
 arch/arm/boot/dts/wago-pfc100-devconf-000c.dts     |   46 +
 arch/arm/boot/dts/wago-pfc100-devconf-0028.dts     |   46 +
 arch/arm/boot/dts/wago-pfc100-dip.dtsi             |   29 +
 arch/arm/boot/dts/wago-pfc100-evb.dts              |  627 ++++++
 arch/arm/boot/dts/wago-pfc100-hw01.dts             |  750 +++++++
 arch/arm/boot/dts/wago-pfc100-musb.dtsi            |   44 +
 arch/arm/boot/dts/wago-pfc100-setupfw.dts          |   79 +
 arch/arm/boot/dts/wago-pfc100-uart1.dtsi           |   29 +
 arch/arm/boot/dts/wago-pfc100.dts                  |  810 ++++++++
 arch/arm/boot/dts/wago-pfc100.dtsi                 |  829 ++++++++
 arch/arm/boot/dts/wago-pfc100_mz.dts               |  645 ++++++
 arch/arm/boot/dts/wago-pfc200-can.dtsi             |   33 +
 arch/arm/boot/dts/wago-pfc200-devconf-000a.dts     |   58 +
 arch/arm/boot/dts/wago-pfc200-devconf-000c.dts     |   46 +
 arch/arm/boot/dts/wago-pfc200-devconf-000e.dts     |   59 +
 arch/arm/boot/dts/wago-pfc200-devconf-000f.dts     |   86 +
 arch/arm/boot/dts/wago-pfc200-devconf-001c.dts     |  130 ++
 arch/arm/boot/dts/wago-pfc200-devconf-004e.dts     |   51 +
 arch/arm/boot/dts/wago-pfc200-dpc31.dtsi           |  112 ++
 arch/arm/boot/dts/wago-pfc200-musb.dtsi            |   45 +
 arch/arm/boot/dts/wago-pfc200-setupfw.dts          |  109 +
 arch/arm/boot/dts/wago-pfc200-uart1.dtsi           |   35 +
 arch/arm/boot/dts/wago-pfc200.dts                  |  601 ++++++
 arch/arm/boot/dts/wago-pfc200.dtsi                 |  743 +++++++
 arch/arm/boot/dts/wago-pfc200v2-dcan.dtsi          |   22 +
 arch/arm/boot/dts/wago-pfc200v2-netx.dtsi          |   85 +
 arch/arm/boot/dts/wago-pfc200v2-setupfw.dts        |   84 +
 arch/arm/boot/dts/wago-pfc200v2.dtsi               |  927 +++++++++
 arch/arm/configs/wago_pfc_generic_defconfig        |  492 +++++
 arch/arm/plat-omap/counter_32k.c                   |   23 +-
 arch/arm/plat-omap/include/plat/omap-serial.h      |  214 ++
 arch/arm/plat-omap/io-cnt.c                        |  279 +++
 drivers/bus/omap_l3_smx.c                          |    6 +
 drivers/iio/pwm-omap.c                             |  273 +++
 drivers/leds/leds-pca955x.c                        |  115 +-
 drivers/misc/Kconfig                               |   11 +
 drivers/misc/Makefile                              |    1 +
 drivers/misc/ti_sn74lv165a.c                       |  296 +++
 drivers/net/can/ti_hecc.c                          |  156 +-
 drivers/net/ethernet/micrel/Kconfig                |    5 +
 drivers/net/ethernet/micrel/Makefile               |    1 +
 drivers/net/ethernet/micrel/ksz8863.c              |  261 +++
 drivers/net/phy/Kconfig                            |   34 +
 drivers/net/phy/Makefile                           |    3 +
 drivers/net/phy/ksz8863-cfg.c                      | 1726 ++++++++++++++++
 drivers/net/phy/ksz8863-phy.c                      |  136 ++
 drivers/net/phy/mdio-bitbang.c                     |   30 +
 drivers/net/phy/swconfig.c                         | 1121 +++++++++++
 drivers/net/phy/swconfig_leds.c                    |  354 ++++
 drivers/net/usb/Kconfig                            |    6 +
 drivers/net/usb/qmi_wwan.c                         |  125 ++
 drivers/rtc/Kconfig                                |    8 +
 drivers/rtc/rtc-rs5c372.c                          |  269 ++-
 drivers/tty/n_tty.c                                |   13 +-
 drivers/tty/serial/Kconfig                         |   17 +
 drivers/tty/serial/Makefile                        |    2 +
 drivers/tty/serial/omap-serial-rtu.c               | 2111 ++++++++++++++++++++
 drivers/tty/serial/omap-serial-rtu.h               |  222 ++
 drivers/tty/serial/omap-serial.c                   |    2 +-
 drivers/tty/serial/pfc-modbus-rtu.c                |  484 +++++
 drivers/tty/serial/serial_reg_rtu.h                |  390 ++++
 drivers/tty/tty_ioctl.c                            |    2 +-
 drivers/uio/uio.c                                  |    2 +-
 drivers/uio/uio_dmem_genirq.c                      |   69 +-
 drivers/uio/uio_pdrv_genirq.c                      |    7 +-
 drivers/usb/gadget/legacy/mass_storage.c           |    2 +-
 drivers/usb/musb/am35x.c                           |   62 +-
 drivers/usb/musb/musb_gadget.c                     |   47 +-
 drivers/usb/serial/option.c                        |    7 +
 drivers/usb/serial/qcserial.c                      |    2 +
 drivers/watchdog/gpio_wdt.c                        |   42 +-
 include/linux/interrupt.h                          |    6 +
 include/linux/ksz8863.h                            |  186 ++
 include/linux/netdevice.h                          |    4 +
 include/linux/phy.h                                |    1 +
 include/linux/platform_data/gpio-omap.h            |    1 -
 include/linux/platform_data/pfc-modbus-rtu.h       |   74 +
 include/linux/sched.h                              |    3 +
 include/linux/switch.h                             |  254 +++
 include/linux/tty.h                                |    1 +
 include/misc/wago-tests.h                          |   30 +
 include/trace/events/dsa.h                         |   50 +
 include/trace/events/pxc.h                         |  367 ++++
 include/uapi/asm-generic/ioctls.h                  |    7 +
 include/uapi/linux/Kbuild                          |    1 +
 include/uapi/linux/if_ether.h                      |    1 +
 include/uapi/linux/switch.h                        |  103 +
 kernel/fork.c                                      |    4 +
 kernel/irq/Kconfig                                 |    7 +
 kernel/irq/Makefile                                |    1 +
 kernel/irq/manage.c                                |   16 +
 kernel/irq/wsysinit-prio-table.c                   |  187 ++
 kernel/trace/trace.c                               |    5 +-
 net/bridge/br_device.c                             |    9 +
 net/bridge/br_if.c                                 |    9 +-
 net/core/dev.c                                     |   44 +-
 net/ipv4/igmp.c                                    |   10 +-
 samples/modbus_test/test_MbRtuDriver.c             |  243 +++
 scripts/Lauterbach/StartLinuxKernel.cmm            |   99 +
 scripts/uboot-startup.txt                          |   26 +
 108 files changed, 18504 insertions(+), 98 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/mfd/tps65218.txt
 create mode 100644 arch/arm/boot/dts/pxc-nandparts.dtsi
 create mode 100644 arch/arm/boot/dts/tps65218.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc100-cmtests.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc100-devconf-000c.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc100-devconf-0028.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc100-dip.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc100-evb.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc100-hw01.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc100-musb.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc100-setupfw.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc100-uart1.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc100.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc100.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc100_mz.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-can.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc200-devconf-000a.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-devconf-000c.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-devconf-000e.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-devconf-000f.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-devconf-001c.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-devconf-004e.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-dpc31.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc200-musb.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc200-setupfw.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200-uart1.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc200.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc200v2-dcan.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc200v2-netx.dtsi
 create mode 100644 arch/arm/boot/dts/wago-pfc200v2-setupfw.dts
 create mode 100644 arch/arm/boot/dts/wago-pfc200v2.dtsi
 create mode 100644 arch/arm/configs/wago_pfc_generic_defconfig
 create mode 100644 arch/arm/plat-omap/include/plat/omap-serial.h
 create mode 100644 arch/arm/plat-omap/io-cnt.c
 create mode 100644 drivers/iio/pwm-omap.c
 create mode 100644 drivers/misc/ti_sn74lv165a.c
 create mode 100644 drivers/net/ethernet/micrel/ksz8863.c
 create mode 100644 drivers/net/phy/ksz8863-cfg.c
 create mode 100644 drivers/net/phy/ksz8863-phy.c
 create mode 100644 drivers/net/phy/swconfig.c
 create mode 100644 drivers/net/phy/swconfig_leds.c
 create mode 100644 drivers/tty/serial/omap-serial-rtu.c
 create mode 100644 drivers/tty/serial/omap-serial-rtu.h
 create mode 100644 drivers/tty/serial/pfc-modbus-rtu.c
 create mode 100644 drivers/tty/serial/serial_reg_rtu.h
 create mode 100644 include/linux/ksz8863.h
 create mode 100644 include/linux/platform_data/pfc-modbus-rtu.h
 create mode 100644 include/linux/switch.h
 create mode 100644 include/misc/wago-tests.h
 create mode 100644 include/trace/events/dsa.h
 create mode 100644 include/trace/events/pxc.h
 create mode 100644 include/uapi/linux/switch.h
 create mode 100644 kernel/irq/wsysinit-prio-table.c
 create mode 100644 samples/modbus_test/test_MbRtuDriver.c
 create mode 100644 scripts/Lauterbach/StartLinuxKernel.cmm
 create mode 100644 scripts/uboot-startup.txt

diff --git a/Documentation/devicetree/bindings/mfd/tps65218.txt b/Documentation/devicetree/bindings/mfd/tps65218.txt
new file mode 100644
index 0000000..5845df7
--- /dev/null
+++ b/Documentation/devicetree/bindings/mfd/tps65218.txt
@@ -0,0 +1,58 @@
+The TPS65218 Integrated Power Management Chips.
+These chips are connected to an I2C bus.
+
+Required properties:
+- compatible : Must be "ti,tps65218";
+- interrupts : This I2C device has an IRQ line connected to the main SoC
+- interrupt-controller : Since the tps65218 supports several interrupts
+  internally, it is considered as an interrupt controller cascaded to the SoC.
+- #interrupt-cells = <2>;
+- interrupt-parent : The parent interrupt controller GIC.
+
+Optional nodes:
+- TPS65218 chip has sub modules. Mainly the DCDCs and regulators.
+
+Example:
+/*
+ * Integrated Power Management Chip
+ */
+tps65218: tps65218@24 {
+	reg = <0x24>;
+	compatible = "ti,tps65218";
+	interrupts = <GIC_SPI 7 IRQ_TYPE_NONE>; /* NMIn */
+	interrupt-parent = <&gic>;
+	interrupt-controller;
+	#interrupt-cells = <2>;
+
+	dcdc1: regulator-dcdc1 {
+		compatible = "ti,tps65218-dcdc1";
+		/* VDD_CORE voltage limits min of OPP50 and max of OPP100 */
+		regulator-name = "vdd_core";
+		regulator-min-microvolt = <912000>;
+		regulator-max-microvolt = <1144000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	dcdc2: regulator-dcdc2 {
+		compatible = "ti,tps65218-dcdc2";
+		/* VDD_MPU voltage limits min of OPP50 and max of OPP_NITRO */
+		regulator-name = "vdd_mpu";
+		regulator-min-microvolt = <912000>;
+		regulator-max-microvolt = <1378000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	dcdc3: regulator-dcdc3 {
+		compatible = "ti,tps65218-dcdc3";
+	};
+
+	ldo1: regulator-ldo1 {
+		compatible = "ti,tps65218-ldo1";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 7037201..dfdbded 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -560,7 +560,21 @@ dtb-$(CONFIG_SOC_AM33XX) += \
 	am335x-shc.dtb \
 	am335x-sbc-t335.dtb \
 	am335x-sl50.dtb \
-	am335x-wega-rdk.dtb
+	am335x-wega-rdk.dtb \
+        wago-pfc100-hw01.dtb \
+        wago-pfc100.dtb \
+        wago-pfc100-devconf-000c.dtb \
+        wago-pfc100-devconf-0028.dtb \
+        wago-pfc100-setupfw.dtb \
+        wago-pfc200.dtb \
+        wago-pfc200-devconf-000a.dtb \
+	wago-pfc200-devconf-000c.dtb \
+	wago-pfc200-devconf-000e.dtb \
+	wago-pfc200-devconf-000f.dtb \
+	wago-pfc200-devconf-001c.dtb \
+	wago-pfc200-devconf-004e.dtb \
+	wago-pfc200-setupfw.dtb \
+	wago-pfc200v2-setupfw.dtb
 dtb-$(CONFIG_ARCH_OMAP4) += \
 	omap4-duovero-parlor.dtb \
 	omap4-kc1.dtb \
diff --git a/arch/arm/boot/dts/am33xx.dtsi b/arch/arm/boot/dts/am33xx.dtsi
index a3277e6..139e521 100644
--- a/arch/arm/boot/dts/am33xx.dtsi
+++ b/arch/arm/boot/dts/am33xx.dtsi
@@ -36,6 +36,7 @@
 		phy1 = &usb1_phy;
 		ethernet0 = &cpsw_emac0;
 		ethernet1 = &cpsw_emac1;
+		mdio-gpio0 = &bitbang_mdio0;
 	};
 
 	cpus {
@@ -811,6 +812,12 @@
 				status = "disabled";
 			};
 
+			bitbang_mdio0: gpio_mdio {
+			       compatible = "virtual,mdio-gpio";
+			       #address-cells = <1>;
+			       #size-cells = <0>;
+			};
+
 			cpsw_emac0: slave@4a100200 {
 				/* Filled in by U-Boot */
 				mac-address = [ 00 00 00 00 00 00 ];
diff --git a/arch/arm/boot/dts/am3517.dtsi b/arch/arm/boot/dts/am3517.dtsi
index d022b6b..082d28f 100644
--- a/arch/arm/boot/dts/am3517.dtsi
+++ b/arch/arm/boot/dts/am3517.dtsi
@@ -17,12 +17,15 @@
 
 	ocp@68000000 {
 		am35x_otg_hs: am35x_otg_hs@5c040000 {
-			compatible = "ti,omap3-musb";
+			compatible = "ti,musb-am35x";
 			ti,hwmods = "am35x_otg_hs";
 			status = "disabled";
 			reg = <0x5c040000 0x1000>;
 			interrupts = <71>;
 			interrupt-names = "mc";
+			multipoint = <1>;
+			num-eps = <16>;
+			ram-bits = <12>;
 		};
 
 		davinci_emac: ethernet@0x5c000000 {
@@ -71,6 +74,20 @@
 			pinctrl-single,register-width = <16>;
 			pinctrl-single,function-mask = <0xff1f>;
 		};
+
+		ti_hecc: can@0x5c050000 {
+			compatible = "ti,hecc";
+			//ti,hwmods = "???"; /* ??? */
+			status = "disabled";
+			reg = <0x5c050000 0x4000>;
+			interrupts = <24>;
+			ti,hecc-scc-hecc-offset = <0x0>;
+			ti,hecc-scc-ram-offset = <0x3000>;
+			ti,hecc-ram-offset = <0x3000>;
+			ti,hecc-mbx-offset = <0x2000>;
+			ti,hecc-int-line = <0x0>;
+			ti,hecc-version = <0x1>;
+		};
 	};
 };
 
@@ -95,5 +112,9 @@
 	status = "disabled";
 };
 
+&usb_otg_hs {
+	status = "disabled";
+};
+
 /include/ "am35xx-clocks.dtsi"
 /include/ "omap36xx-am35xx-omap3430es2plus-clocks.dtsi"
diff --git a/arch/arm/boot/dts/omap3.dtsi b/arch/arm/boot/dts/omap3.dtsi
index 2008648..78ca949 100644
--- a/arch/arm/boot/dts/omap3.dtsi
+++ b/arch/arm/boot/dts/omap3.dtsi
@@ -377,6 +377,7 @@
 			       <&sdma 42>;
 			dma-names = "tx0", "rx0", "tx1", "rx1",
 				    "tx2", "rx2", "tx3", "rx3";
+			status = "disabled";
 		};
 
 		mcspi2: spi@4809a000 {
@@ -392,6 +393,7 @@
 			       <&sdma 45>,
 			       <&sdma 46>;
 			dma-names = "tx0", "rx0", "tx1", "rx1";
+			status = "disabled";
 		};
 
 		mcspi3: spi@480b8000 {
@@ -407,6 +409,7 @@
 			       <&sdma 23>,
 			       <&sdma 24>;
 			dma-names = "tx0", "rx0", "tx1", "rx1";
+			status = "disabled";
 		};
 
 		mcspi4: spi@480ba000 {
@@ -419,6 +422,7 @@
 			ti,spi-num-cs = <1>;
 			dmas = <&sdma 70>, <&sdma 71>;
 			dma-names = "tx0", "rx0";
+			status = "disabled";
 		};
 
 		hdqw1w: 1w@480b2000 {
diff --git a/arch/arm/boot/dts/pxc-nandparts.dtsi b/arch/arm/boot/dts/pxc-nandparts.dtsi
new file mode 100644
index 0000000..5fa8710
--- /dev/null
+++ b/arch/arm/boot/dts/pxc-nandparts.dtsi
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&nand {
+	        /* 4 x 128k MLOs */
+		partition@0 {
+			label = "mlo0";
+			reg = <0x0 0x20000>;
+		};
+
+		partition@1 {
+			label = "mlo1";
+			reg = <0x20000 0x20000>;
+		};
+
+		partition@2 {
+			label = "mlo2";
+			reg = <0x40000 0x20000>;
+		};
+
+		partition@3 {
+			label = "mlo3";
+			reg = <0x60000 0x20000>;
+		};
+
+	        /* 16 x 128k: 4 x stage2 (4x128k) */
+		partition@4 {
+			label = "boot0";
+			reg = <0x80000 0x80000>;
+		};
+
+		partition@5 {
+			label = "boot1";
+			reg = <0x100000 0x80000>;
+		};
+
+		partition@6 {
+			label = "boot2";
+			reg = <0x180000 0x80000>;
+		};
+
+		partition@7 {
+			label = "boot3";
+			reg = <0x200000 0x80000>;
+		};
+
+		partition@8 {
+			label = "ubidata";
+			/*
+			 * Size 0x0 extends partition to
+			 * end of nand flash.
+			 */
+			reg = <0x280000 0x0>;
+		};
+};
diff --git a/arch/arm/boot/dts/tps65218.dtsi b/arch/arm/boot/dts/tps65218.dtsi
new file mode 100644
index 0000000..70b9512
--- /dev/null
+++ b/arch/arm/boot/dts/tps65218.dtsi
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&tps {
+	compatible = "ti,tps65218";
+	interrupt-controller;
+	#interrupt-cells = <2>;
+
+	dcdc1: regulator-dcdc1 {
+		compatible = "ti,tps65218-dcdc1";
+	};
+
+	dcdc2: regulator-dcdc2 {
+		compatible = "ti,tps65218-dcdc2";
+	};
+
+	dcdc3: regulator-dcdc3 {
+		compatible = "ti,tps65218-dcdc3";
+	};
+
+	dcdc4: regulator-dcdc4 {
+		compatible = "ti,tps65218-dcdc4";
+	};
+
+	dcdc5: regulator-dcdc5 {
+		compatible = "ti,tps65218-dcdc5";
+	};
+
+	dcdc6: regulator-dcdc6 {
+		compatible = "ti,tps65218-dcdc6";
+	};
+
+	ldo1: regulator-ldo1 {
+		compatible = "ti,tps65218-ldo1";
+	};
+};
diff --git a/arch/arm/boot/dts/wago-pfc100-cmtests.dtsi b/arch/arm/boot/dts/wago-pfc100-cmtests.dtsi
new file mode 100644
index 0000000..3fd7348
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-cmtests.dtsi
@@ -0,0 +1,56 @@
+/ {
+	cmtests {
+		compatible = "wago,testenv";
+		i2c-leds {
+			LED_BASE_DIR="/sys/class/i2c-dev/i2c-0/device/0-0060/leds";
+			LED_NUM="6";
+			LED_TYPE="DUAL";
+			LED_1_GREEN="sys-green";
+			LED_1_RED="sys-red";
+			LED_2_GREEN="run-green";
+			LED_2_RED="run-red";
+			LED_3_GREEN="io-green";
+			LED_3_RED="io-red";
+			LED_4_GREEN="ms-green";
+			LED_4_RED="ms-red";
+			LED_5_GREEN="ns-green";
+			LED_5_RED="ns-red";
+			LED_6_GREEN="usr-green";
+			LED_6_RED="usr-red";
+		};
+
+		i2c-eeprom {
+			EEPROM_ACCESS_FILE="/sys/class/i2c-dev/i2c-0/device/0-0054/eeprom";
+		};
+
+		i2c-rtc {
+			GPIO_RTC_INTNO="117";
+			RTC_INTMODEPATH="/sys/class/rtc/rtc0/device/intmode";
+		};
+
+		kbus {
+		};
+
+		nvram {
+		};
+
+		pmic-usb {
+		};
+
+		eth-switch {
+		};
+
+		gpios {
+			GPIO_DIR="/sys/class/gpio";
+			GPIO_UART1_SEL="/sys/class/gpio/gpio115";
+			GPIO_UART1_RTS="/sys/class/gpio/gpio13";
+			GPIO_UART1_TXD="/sys/class/gpio/gpio15";
+			GPIO_RESET_ALL="/sys/class/gpio/gpio111";
+			GPIO_UART1_CTS="/sys/class/gpio/gpio12";
+			GPIO_UART1_RXD="/sys/class/gpio/gpio14";
+		};
+
+		sd-card {
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/wago-pfc100-devconf-000c.dts b/arch/arm/boot/dts/wago-pfc100-devconf-000c.dts
new file mode 100644
index 0000000..1b38ebd
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-devconf-000c.dts
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc100.dtsi"
+#include "wago-pfc100-uart1.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x000C
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  x  x
+ *                                             |  |
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  |  |  |  |  PROFIBUS_SL
+ *                                       |  |  |  |  CAN
+ *                                       |  |  |  RS232_485
+ *                                       |  |  ETHERNET_IP
+ *                                       |  3G_MODEM
+ *					 DIP_SWITCH
+ *   x: reserved for future use
+ *
+ */
diff --git a/arch/arm/boot/dts/wago-pfc100-devconf-0028.dts b/arch/arm/boot/dts/wago-pfc100-devconf-0028.dts
new file mode 100644
index 0000000..8a3d277
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-devconf-0028.dts
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc100.dtsi"
+#include "wago-pfc100-dip.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x0028
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  x  |  x  x  x
+ *                                       |     |
+ *                                       |     |
+ *                                       |     ETHERNET_IP
+ *  					 DIP_SWITCH
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  |  |  |  |  PROFIBUS_SL
+ *                                       |  |  |  |  CAN
+ *                                       |  |  |  RS232_485
+ *                                       |  |  ETHERNET_IP
+ *                                       |  3G_MODEM
+ *					 DIP_SWITCH
+ *   x: reserved for future use
+ *
+ */
diff --git a/arch/arm/boot/dts/wago-pfc100-dip.dtsi b/arch/arm/boot/dts/wago-pfc100-dip.dtsi
new file mode 100644
index 0000000..debff5af
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-dip.dtsi
@@ -0,0 +1,29 @@
+&am33xx_pinmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_dip_pins>;
+
+	uart1_dip_pins: pinmux_uart1_dip_pins { /* optional uart1 with dip switch */
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_txd.gpio0_15 */		//d15
+			0x180 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* uart1_rxd.gpio0_14 */		//d16
+			0x17c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_rtsn.gpio0_13 */		//d17
+			/* is not used in this configuration */
+			0x178 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* uart1_ctsn.gpio0_12 */		//d18
+			0x1a4 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* mcasp0_fsr.gpio3_19 */		//c13
+		>;
+	};
+};
+
+/ {
+	dip-switch {
+		/* ti,sn74lv165a 8-bit shifit register */
+		compatible = "ti,sn74lv165a";
+
+		gpios = <&gpio0 15 GPIO_ACTIVE_HIGH	/* clk */
+			 &gpio0 14 GPIO_ACTIVE_LOW	/* output */
+			 &gpio0 13 GPIO_ACTIVE_LOW	/* load */
+		>;
+
+		clk,period = <2>; /* clk period time in ms */
+	};
+};
diff --git a/arch/arm/boot/dts/wago-pfc100-evb.dts b/arch/arm/boot/dts/wago-pfc100-evb.dts
new file mode 100644
index 0000000..834af65
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-evb.dts
@@ -0,0 +1,627 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am33xx.dtsi"
+
+/ {
+	model = "WAGO PFC100 EVB";
+	compatible = "wago,pfc100-evb", "ti,am33xx";
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&vdd1_reg>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x8000000>; /* 128 MB */
+	};
+
+	vrlb_reg: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "v_rlb";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	vsd_reg: fixedregulator@1 {
+		compatible = "regulator-fixed";
+		regulator-name = "v_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vmmc_reg>;
+	};
+
+	nop-phy@0 {
+		compatible = "usb-nop-xceiv";
+	};
+
+	nop-phy@1 {
+		compatible = "usb-nop-xceiv";
+	};
+
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+
+	num-cs = <3>;
+	num-waitpins = <1>;
+	status = "okay";
+	ranges = <
+		0 0 0x08000000 0x01000000	/* CS0: NAND */
+		2 0 0x01000000 0x01000000	/* CS2: FPGA */
+	>;
+
+	nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		elm_id = <&elm>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		sys-led {
+			gpios = <&gpio3 0 1>; /* active low */
+			linux,default-trigger = "heartbeat";
+			default-state = "off";
+		};
+	};
+};
+
+&am33xx_pinmux {
+
+	/* Do we need this? */
+	mmc1_pins: pinmux_mmc1_pins {
+		/* for pin mux offset calc: doc_offset - 0x800h = dts-offset */
+		pinctrl-single,pins = <
+			0x190 (PIN_INPUT_PULLDOWN | MUX_MODE4)	/* mcasp0_aclkx.mmc0_sdcd */
+			0x1A0 (PIN_INPUT_PULLDOWN | MUX_MODE4)	/* mcasp0_aclkr.mmc0_sdwp */
+			0x104 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_cmd.mmc0_cmd   */
+			0x100 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_clk.mmc0_clk   */
+			0x0fc (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat0.mmc0_dat0 */
+			0x0f8 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat1.mmc0_dat1 */
+			0x0f4 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat2.mmc0_dat2 */
+			0x0f0 (PIN_INPUT_PULLUP | MUX_MODE0)	/* mmc0_dat3.mmc0_dat3 */
+		>;
+	};
+
+	dcan0_pins: pinmux_dcan0_pins {
+		 pinctrl-single,pins = <
+			 0x11c 0x01	/* mii1_txd3.dcan0_tx_mux0, OUTPUT_PULLDOWN | MODE1 */
+			 0x120 0x21	/* mii1_txd2.dcan0_rx_mux0, INPUT_PULLDOWN | MODE1 */
+		 >;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x000 0x20	/* gpmc_ad0, INPUT_PULLDOWN | MODE0 */
+			0x004 0x20	/* gpmc_ad1, INPUT_PULLDOWN | MODE0 */
+			0x008 0x20	/* gpmc_ad2, INPUT_PULLDOWN | MODE0 */
+			0x00c 0x20	/* gpmc_ad3, INPUT_PULLDOWN | MODE0 */
+			0x010 0x20	/* gpmc_ad4, INPUT_PULLDOWN | MODE0 */
+			0x014 0x20	/* gpmc_ad5, INPUT_PULLDOWN | MODE0 */
+			0x018 0x20	/* gpmc_ad6, INPUT_PULLDOWN | MODE0 */
+			0x01c 0x20	/* gpmc_ad7, INPUT_PULLDOWN | MODE0 */
+			0x020 0x20	/* gpmc_ad8, INPUT_PULLDOWN | MODE0 */
+			0x024 0x20	/* gpmc_ad9, INPUT_PULLDOWN | MODE0 */
+			0x028 0x20	/* gpmc_ad10, INPUT_PULLDOWN | MODE0 */
+			0x02c 0x20	/* gpmc_ad11, INPUT_PULLDOWN | MODE0 */
+			0x030 0x20	/* gpmc_ad12, INPUT_PULLDOWN | MODE0 */
+			0x034 0x20	/* gpmc_ad13, INPUT_PULLDOWN | MODE0 */
+			0x038 0x20	/* gpmc_ad14, INPUT_PULLDOWN | MODE0 */
+			0x03c 0x20	/* gpmc_ad15, INPUT_PULLDOWN | MODE0 */
+			0x070 0x30	/* gpmc_wait0, INPUT_PULLUP | MODE0 */
+			0x07c 0x10	/* gpmc_csn0, OUTPUT_PULLUP | MODE0 */
+			0x080 0x10	/* gpmc_csn1, OUTPUT_PULLUP | MODE0 */
+			0x084 0x10	/* gpmc_csn2, OUTPUT_PULLUP | MODE0 */
+			0x090 0x10	/* gpmc_advn_ale, OUTPUT_PULLUP | MODE0 */
+			0x094 0x10	/* gpmc_oen_ren, OUTPUT_PULLUP | MODE0 */
+			0x098 0x10	/* gpmc_wen, OUTPUT_PULLUP | MODE0 */
+			0x09c 0x10	/* gpmc_ben0_cle.gpmc_be0n_cle, OUTPUT_PULLUP | MODE0 */
+			0x0b8 0x09	/* lcd_data6.gpmc_a6_mux1, OUTPUT | MODE1 */
+			0x0bc 0x09	/* lcd_data7.gpmc_a7_mux1, OUTPUT | MODE1 */
+			0x0e0 0x09	/* lcd_vsync.gpmc_a8_mux1, OUTPUT | MODE1 */
+			0x0e4 0x09	/* lcd_hsync.gpmc_a9_mux1, OUTPUT | MODE1 */
+		>;
+	};
+
+	spi0_pins: pinmux_spi0_pins {
+		pinctrl-single,pins = <
+			0x150 0x28	/* spi0_sclk, INPUT | MODE0 */
+			0x154 0x28	/* spi0_d0, INPUT | MODE0 */
+			0x158 0x28	/* spi0_d1, INPUT | MODE0 */
+			0x15c 0x10	/* spi0_cs0, OUTPUT_PULLUP | MODE0 */
+			0x160 0x10	/* spi0_cs1, OUTPUT_PULLUP | MODE0 */
+		>;
+	};
+
+	usb0_pins: pinmux_usb0_pins { /* USB-HOST */
+		pinctrl-single,pins = <
+			0x208 0x28	/* usb0_dm, INPUT | MODE0 */
+			0x20c 0x28	/* usb0_dp, INPUT | MODE0 */
+			0x210 0x28	/* usb0_ce, INPUT | MODE0 */
+			0x214 0x28	/* usb0_id, INPUT | MODE0 */
+			0x218 0x28	/* usb0_vbus, INPUT | MODE0 */
+			0x21c 0x00	/* usb0_drvvbus, OUTPUT_PULLDOWN | MODE0 */
+		>;
+	};
+
+	usb1_pins: pinmux_usb1_pins { /* USB-OTG */
+		pinctrl-single,pins = <
+			0x220 0x28	/* usb1_dm, INPUT | MODE0 */
+			0x224 0x28	/* usb1_dp, INPUT | MODE0 */
+			0x228 0x28	/* usb1_ce, INPUT | MODE0 */
+			0x22c 0x28	/* usb1_id, INPUT | MODE0 */
+			0x230 0x28	/* usb1_vbus, INPUT | MODE0 */
+			0x234 0x00	/* usb1_drvvbus, OUTPUT_PULLDOWN | MODE0 */
+		>;
+	};
+
+	i2c1_pins: pinmux_i2c1_pins {
+		pinctrl-single,pins = <
+			//0x168 0x2b	/* uart0_ctsn.i2c1_sda_mux1, INPUT | MODE3 */
+			//0x16c 0x2b	/* uart0_rtsn.i2c1_scl_mux1, INPUT | MODE3 */
+			0x168 0x73	/* uart0_ctsn.i2c1_sda_mux1, SLEWCTRL_SLOW | INPUT_PULLUP | MODE0 */
+			0x16c 0x73	/* uart0_rtsn.i2c1_scl_mux1, SLEWCTRL_SLOW | INPUT_PULLUP | MODE0 */
+		>;
+	};
+
+	uart0_pins: pinmux_uart0_pins {
+		pinctrl-single,pins = <
+			//0x170 0x28	/* uart0_rxd, INPUT | MODE0 */
+			//0x174 0x08	/* uart0_txd, OUTPUT | MODE0 */
+			0x170 0x30	/* uart0_rxd */
+			0x174 0x00	/* uart0_txd */
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins {
+		pinctrl-single,pins = <
+			//0x188 0x28	/* i2c0_sda, INPUT | MODE0 */
+			//0x18c 0x28	/* i2c0_scl, INPUT | MODE0 */
+			0x188 0x70	/* i2c0_sda, SLEWCTRL_SLOW | INPUT_PULLUP | MODE0 */
+			0x18c 0x70	/* i2c0_scl, SLEWCTRL_SLOW | INPUT_PULLUP | MODE0 */
+		>;
+	};
+
+	cpsw_default_pins: pinmux_cpsw_default_pins {
+		pinctrl-single,pins = <
+			0x110 (PIN_INPUT_PULLDOWN | MUX_MODE1)  /* mii1_rx_er.rmii1_rxer */
+			0x114 (PIN_OUTPUT_PULLDOWN | MUX_MODE1) /* mii1_tx_en.rmii1_txen */
+			0x124 (PIN_OUTPUT_PULLDOWN | MUX_MODE1) /* mii1_txd1.rmii1_txd1 */
+			0x128 (PIN_OUTPUT_PULLDOWN | MUX_MODE1) /* mii1_txd0.rmii1_txd0 */
+			0x13c (PIN_INPUT_PULLDOWN | MUX_MODE1)  /* mii1_rxd1.rmii1_rxd1 */
+			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE1)  /* mii1_rxd0.rmii1_rxd0 */
+			0x144 (PIN_INPUT_PULLDOWN | MUX_MODE0)  /* rmii1_ref_clk.rmii1_refclk (or INPUT_PULLUP? */
+		>;
+	};
+
+	cpsw_sleep_pins: pinmux_cpsw_sleep_pins {
+		pinctrl-single,pins = <
+			0x110 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x114 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x124 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x128 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x13c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x140 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x144 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+		>;
+	};
+
+	gpio_bitbang_mdio_pins: pinmux_gpio_bitbang_mdio_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE7)	/* M17: mdio.gpio0_0 (mdio_data), SLEWCTRL_FAST?? */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE7)			/* M18:  mdc.gpio0_1 (mdio_clk)                   */
+		>;
+	};
+
+	gpio_bitbang_mdio_sleep_pins: pinmux_gpio_bitbang_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLDOWN | MUX_MODE7)
+			0x14c (PIN_INPUT_PULLDOWN | MUX_MODE7)
+		>;
+	};
+
+	gpio3_pins: pinmux_gpio3_pins {
+		pinctrl-single,pins = <
+			0x108 0x17	/* mii1_col.gpio3[0], OUTPUT_PULLUP | MODE7 (SYS_LED) */
+			0x118 0x17	/* mii1_rx_dv.gpio3[4], OUTPUT_PULLUP | MODE7 (WD_nEN) */
+			0x12c 0x27	/* mii1_tx_clk.gpio3[9], INPUT_PULLDOWN | MODE7 (DBG_IO_0) */
+			0x130 0x27	/* mii1_rx_clk.gpio3[10], INPUT_PULLDOWN | MODE7 (DBG_IO_1) */
+			0x194 0x37	/* mcasp0_fsx.gpio3[15], INPUT_PULLUP | MODE7 (IOEXP_nINT) */
+			0x19c 0x27	/* mcasp0_ahclkr.gpio3[17], INPUT_PULLDOWN | MODE7 (RS232/RS485_SEL) */
+			0x1a4 0x37	/* mcasp0_fsr.gpio3[19], INPUT_PULLUP | MODE7 (PRUETHPHY_nRST) */
+/*				0x1ac 0x37	/* mcasp0_ahclkx.gpio3[21], INPUT_PULLUP | MODE7 (VCC+24V_nFAIL) */
+			0x1e4 0x37	/* emu0.gpio3[7], INPUT_PULLUP | MODE7 (RMVB_nRELOAD) */
+			0x1e8 0x37	/* emu1.gpio3[8], INPUT_PULLUP | MODE7 (RMVB_INITDONE) */
+		>;
+	};
+
+	gpio2_pins: pinmux_gpio2_pins {
+		pinctrl-single,pins = <
+			0x134 0x27	/* mii1_rxd3.gpio2[18], INPUT_PULLDOWN | MODE7 (DBG_IO_3) */
+			0x138 0x27	/* mii1_rxd2.gpio2[19], INPUT_PULLDOWN | MODE7 (DBG_IO_2) */
+			0x1a8 0x26      /* mcasp0_axr1.pr1_pru0_pru_r31[6], INPUT_PULLDOWN | MODE6 */
+			0x1ac 0x0d     /* mcasp0_ahclkx.gpio3[21], OUTPUT | MODE5 */
+			0x0a4 0x0d      /* lcd_data1.pr1_mii0_txen_mux1, OUTPUT | MODE5 */
+		>;
+	};
+
+	ecap0_pins: pinmux_ecap0_pins {
+		pinctrl-single,pins = <
+			0x164 0x10      /* ecap0_in_pwm0_out, OUTPUT_PULLUP | MODE0 */ // is PULLUP correct?
+		>;
+	};
+
+	pru_pins: pinmux_pru_pins {
+		pinctrl-single,pins = <
+			0x040 0x25	/* gpmc_a0.pr1_mii_mt1_clk, INPUT_PULLDOWN | MODE5 */
+			0x044 0x05	/* gpmc_a1.pr1_mii1_txd3, OUTPUT_PULLDOWN | MODE5 */
+			0x048 0x05	/* gpmc_a2.pr1_mii1_txd2, OUTPUT_PULLDOWN | MODE5 */
+			0x04c 0x05	/* gpmc_a3.pr1_mii1_txd1, OUTPUT_PULLDOWN | MODE5 */
+			0x050 0x05	/* gpmc_a4.pr1_mii1_txd0, OUTPUT_PULLDOWN | MODE5 */
+			0x054 0x25	/* gpmc_a5.pr1_mii1_rxd3, INPUT_PULLDOWN | MODE5 */
+			0x058 0x25	/* gpmc_a6.pr1_mii1_rxd2, INPUT_PULLDOWN | MODE5 */
+			0x05c 0x25	/* gpmc_a7.pr1_mii1_rxd1, INPUT_PULLDOWN | MODE5 */
+			0x060 0x25	/* gpmc_a8.pr1_mii1_rxd0, INPUT_PULLDOWN | MODE5 */
+			0x064 0x25	/* gpmc_a9.pr1_mii_mr1_clk, INPUT_PULLDOWN | MODE5 */
+			0x068 0x25	/* gpmc_a10.pr1_mii1_rxdv, INPUT_PULLDOWN | MODE5 */
+			0x06c 0x25	/* gpmc_a11.pr1_mii1_rxer, INPUT_PULLDOWN | MODE5 */
+			0x074 0x15	/* gpmc_wpn.pr1_mii1_txen, OUTPUT_PULLUP | MODE5 */
+			0x078 0x35	/* gpmc_ben1.pr1_mii1_rxlink, INPUT_PULLUP | MODE5 */
+			0x088 0x35	/* gpmc_csn3.pr1_mdio_data, INPUT_PULLUP | MODE5 */
+			0x08c 0x05	/* gpmc_clk.pr1_mdio_mdclk, OUTPUT_PULLDOWN | MODE5 */
+			0x0a0 0x2a	/* lcd_data0.pr1_mii_mt0_clk_mux1, INPUT | MODE2 */
+/*			0x0a4 0x0a	/* lcd_data1.pr1_mii0_txen_mux1, OUTPUT | MODE2 */
+			0x0a8 0x0a	/* lcd_data2.pr1_mii0_txd3_mux1, OUTPUT | MODE2 */
+			0x0ac 0x0a	/* lcd_data3.pr1_mii0_txd2_mux1, OUTPUT | MODE2 */
+			0x0b0 0x0a	/* lcd_data4.pr1_mii0_txd1_mux1, OUTPUT | MODE2 */
+			0x0b4 0x0a	/* lcd_data5.pr1_mii0_txd0_mux1, OUTPUT | MODE2 */
+			0x0c0 0x2d	/* lcd_data8.pr1_mii0_rxd3, INPUT | MODE5 */
+			0x0c4 0x2d	/* lcd_data9.pr1_mii0_rxd2, INPUT | MODE5 */
+			0x0c8 0x2d	/* lcd_data10.pr1_mii0_rxd1, INPUT | MODE5 */
+			0x0cc 0x2d	/* lcd_data11.pr1_mii0_rxd0, INPUT | MODE5 */
+			0x0d0 0x2d	/* lcd_data12.pr1_mii0_rxlink, INPUT | MODE5 */
+			0x0d4 0x2d	/* lcd_data13.pr1_mii0_rxer, INPUT | MODE5 */
+			0x0d8 0x2d	/* lcd_data14.pr1_mii_mr0_clk, INPUT | MODE5 */
+			0x0dc 0x2d	/* lcd_data15.pr1_mii0_rxdv, INPUT | MODE5 */
+			0x0e8 0x2f	/* lcd_pclk.gpio2[24], INPUT | MODE7 (PRU_MII0_CRS) */ // is MODE7 correct?
+			0x0ec 0x2f	/* lcd_ac_bias_en.gpio2[25], INPUT | MODE7 (PRU_MII1_CRS) */ // is MODE7 correct?
+			0x178 0x2d	/* uart1_ctsn.pr1_uart0_cts_n_mux1, INPUT | MODE5 */
+			0x17c 0x0d	/* uart1_rtsn.pr1_uart0_rts_n_mux1, OUTPUT | MODE5 */
+			0x180 0x2d	/* uart1_rxd.pr1_uart0_rxd_mux1, INPUT | MODE5 */
+			0x184 0x0d	/* uart1_txd.pr1_uart0_txd_mux1, OUTPUT | MODE5 */
+			0x198 0x36	/* mcasp0_axr0.pr1_pru0_pru_r31[2], INPUT_PULLUP | MODE6 */
+/*			0x1a8 0x26	/* mcasp0_axr1.pr1_pru0_pru_r31[6], INPUT_PULLDOWN | MODE6 */
+		>;
+	};
+};
+
+&usb {
+	status = "okay";
+	pinctrl-0 = <&usb0_pins &usb1_pins>;
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb0_phy {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+&usb0 { /* usb0 - host */
+	status = "okay";
+	dr_mode = "host";
+};
+
+&usb1 { /* usb1 - otg */
+	status = "okay";
+};
+
+&cppi41dma {
+	status = "okay";
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&vmmc_reg>;
+	bus-width = <4>;
+};
+
+&edma {
+	ti,edma-xbar-event-map = <32 12   /* GPIOEVT2 - GPIO2 Bank */
+				  28  8   /* pi_x_dma_event_intr0 */
+				  29  9   /* pi_x_dma_event_intr1 */
+				  16 58
+				  17 59
+				  18 60
+				  19 59
+				  20 14
+				  21 15>;
+
+};
+
+&dcan0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&dcan0_pins>;
+};
+
+&gpio2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio2_pins>;
+};
+
+&gpio3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+
+	spi0_0: spidev@0 {
+		compatible = "spidev";
+		reg = <0>;
+		spi-max-frequency = <10000000>; // FIXME
+	};
+
+	spi0_1: spidev@1 {
+		compatible = "spidev";
+		reg = <1>;
+		spi-max-frequency = <10000000>; // FIXME
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+
+	pcf8574 {
+		compatible = "nxp,pcf8574";
+		reg = <0x20>;
+	};
+
+	pca9535@21 {
+		compatible = "nxp,pca9535";
+		reg = <0x21>;
+	};
+
+	pca9535@22 {
+		compatible = "nxp,pca9535";
+		reg = <0x22>;
+	};
+
+	at24cs128n {
+		compatible = "atmel,24c128";
+		reg = <0x54>;
+	};
+
+	rtc_r2221t {
+		compatible = "ricoh,r2221tl";
+		reg = <0x32>;
+	};
+
+	tps: tps65910@2d {
+		compatible = "ti,tps65910";
+		reg = <0x2d>;
+	};
+};
+
+&i2c1 {
+	/* status = "okay"; */
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
+};
+
+&mac {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&cpsw_default_pins>;
+	pinctrl-1 = <&cpsw_sleep_pins>;
+	mac_control = <0x8021>; /* force 100MBit full-duplex */
+};
+
+&bitbang_mdio0 {
+       pinctrl-names = "default", "sleep";
+       pinctrl-0 = <&gpio_bitbang_mdio_pins>;
+       pinctrl-1 = <&gpio_bitbang_mdio_sleep_pins>;
+       gpios = <&gpio0 1 0	/* 0: mdc  */
+		&gpio0 0 0>;   	/* 1: mdio */
+
+       ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+       };
+       ethernet-phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <2>;
+       };
+};
+
+/* This is a workaround.
+ * PHY_ID 1 of KSZ8863 is port 1 and is bound to the emac0 interface.
+ * If port 1 gets down due to an unplugged cable and port 2 gets up
+ * the interface emac0 will be disabled. We have only a 1:1 relation here.
+ * drivers/net/ethernet/ti/cpsw.c was changed to ignore phy->link adjustment
+ */
+&cpsw_emac0 {
+	phy_id = <&bitbang_mdio0>, <1>;
+	phy-mode = "rmii";
+};
+
+&cpsw_emac1 {
+	phy_id = <&bitbang_mdio0>, <2>;
+	phy-mode = "rmii";
+};
+
+&phy_sel {
+	rmii-clock-ext;
+};
+
+#include "tps65910.dtsi"
+
+&tps {
+	vcc1-supply = <&vrlb_reg>;
+	vcc2-supply = <&vrlb_reg>;
+	vcc3-supply = <&vrlb_reg>;
+	vcc4-supply = <&vrlb_reg>;
+	vcc5-supply = <&vrlb_reg>;
+	vcc6-supply = <&vrlb_reg>;
+	vcc7-supply = <&vrlb_reg>;
+	vccio-supply = <&vrlb_reg>;
+
+	regulators {
+
+		vrtc_reg: regulator@0 {
+			regulator-always-on;
+		};
+
+		vio_reg: regulator@1 {
+			regulator-name = "v_ddr";
+			regulator-min-microvolt = <1500000>;
+			regulator-max-microvolt = <1500000>;
+			regulator-always-on;
+			regulator-boot-on;
+		};
+
+		vdd1_reg: regulator@2 {
+			/* VDD_MPU voltage limits 0.95V - 1.26V with +/-4% tolerance */
+			regulator-name = "vdd_mpu";
+			regulator-min-microvolt = <912500>;
+			regulator-max-microvolt = <1312500>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd2_reg: regulator@3 {
+			/* VDD_CORE voltage limits 0.95V - 1.1V with +/-4% tolerance */
+			regulator-name = "vdd_core";
+			regulator-min-microvolt = <1100000>;
+			regulator-max-microvolt = <1100000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vdd3_reg: regulator@4 {
+			regulator-name = "v_otg";
+		};
+
+		vdig2_reg: regulator@6 {
+			regulator-name = "v_pll";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vaux2_reg: regulator@10 {
+			regulator-name = "v_peth";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+			regulator-boot-on;
+		};
+
+		vaux33_reg: regulator@11 {
+			regulator-name = "v_ceth";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+			regulator-boot-on;
+		};
+
+		vmmc_reg: regulator@12 {
+			regulator-name = "v_io";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+			regulator-boot-on;
+		};
+	};
+};
+
+/* do we need this ?? */
+&tscadc {
+	adc {
+		ti,adc-channels = <8>;
+	};
+};
+
+/* do we need this ?? */
+&epwmss0 {
+	status = "okay";
+
+	ecap0: ecap@48300100 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ecap0_pins>;
+	};
+};
+
+&ocmcram {
+	 ti,no_idle_on_suspend;
+};
diff --git a/arch/arm/boot/dts/wago-pfc100-hw01.dts b/arch/arm/boot/dts/wago-pfc100-hw01.dts
new file mode 100644
index 0000000..a0eebfd
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-hw01.dts
@@ -0,0 +1,750 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "am33xx.dtsi"
+
+/ {
+	model = "WAGO PFC100 HW01";
+	compatible = "wago,pfc10x", "ti,am33xx";
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&dcdc4_reg>;
+		};
+	};
+
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x8000000>; /* 128 MB */
+	};
+
+
+	vxe164_reg: fixedregulator@0 {	/* XE164 +3V3  System voltage */
+		compatible = "regulator-fixed";
+		regulator-name = "vxe164";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dcdc4_reg>;
+	};
+
+	vsd_reg: fixedregulator@1 {		/* SD Card +3V3 Systemvoltage over power switch */
+		compatible = "regulator-fixed";
+		regulator-name = "v_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+                vin-supply = <&dcdc4_reg>;
+	};
+
+	ksz8863_reset {
+		compatible = "micrel,ksz8863-reset";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		gpio-reset = <&gpio2 21 GPIO_ACTIVE_LOW>;	/* gpio2_21: RMII2.EN-PHY */
+		reset-switch;
+		status = "okay";
+	};
+
+	UIO_NVRAM@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x1000000 0x20000>;  /* 128k 16bit NVRAM */
+	};
+
+	wsysinit_init {
+		compatible = "wago,sysinit";
+		add-sysfs-entries;
+	};
+
+
+	dsa@0 {
+		compatible = "marvell,dsa";
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* interrupts = <10>; --> not supported from the driver! */
+
+		/* master netdevice (eth0) */
+		dsa,ethernet = <&mac>; /* TODO: should we use 'cpsw_emac1' instead? */
+		dsa,mii-bus = <&bitbang_mdio0>;
+
+		switch@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <16 0>;	/* MDIO address 16, switch 0 in tree */
+
+			port@0 {
+				reg = <0>;
+				label = "ethX1";
+                                phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "ethX2";
+                                phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <2>;
+				label = "eth0";
+			};
+		};
+	};
+};
+
+&uart0 { /* debug interface over JTAG Connector */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_rs_pins>;
+	status = "okay";
+	rts-gpio = <&gpio0 13 GPIO_ACTIVE_HIGH>;
+	rs485en-gpio = <&gpio3 19 GPIO_ACTIVE_LOW>;
+	rs485-rts-active-high;
+	/* rs485-rx-during-tx; */ // we only support 2-wire mode
+	rs485-rts-delay = <1 1>;
+	/* linux,rs485-enabled-at-boot-time; */
+};
+
+&uart4 { /* KBUS Firmware download */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins>;
+	status = "okay";
+};
+
+&elm {	/* ??? */
+	status = "okay";
+};
+
+&gpmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+
+	num-cs = <2>;	/* only two devices */
+	num-waitpins = <1>;
+	status = "okay";
+	ranges = <
+		0 0 0x08000000 0x01000000	/* CS0: NAND */
+		1 0 0x01000000 0x01000000	/* CS1: NVRAM */
+	>;
+
+	nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ti,elm-id = <&elm>;
+	};
+
+	nor@1,0 { /* NVRAM Device 128k */
+		reg = <1 0 0x1000000>;
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <30>;
+		gpmc,cs-wr-off-ns = <21>;
+		gpmc,adv-on-ns = <0>;
+		gpmc,adv-rd-off-ns = <0>;
+		gpmc,adv-wr-off-ns = <0>;
+		gpmc,oe-on-ns = <13>;
+		gpmc,oe-off-ns = <30>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <21>;
+		gpmc,rd-cycle-ns = <30>;
+		gpmc,wr-cycle-ns = <26>;
+		gpmc,access-ns = <25>;
+		gpmc,wr-access-ns = <9>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <10>;
+		gpmc,cycle2cycle-samecsen;
+		gpmc,cycle2cycle-diffcsen;
+		gpmc,wait-on-read = "false";
+		gpmc,wait-on-write = "false";
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+/* for pin mux offset calc: doc_offset - 0x800h = dts-offset */
+&am33xx_pinmux {
+
+	uart0_pins: pinmux_uart0_pins { /* debug interface over JTAG Connector */
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP		| MUX_MODE0)  	                /* uart0_rxd.uart0_rxd */ 		//e15
+			0x174 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)  	/* uart0_txd.uart0_txd */		//e16
+		>;
+	};
+
+	uart1_rs_pins: pinmux_uart1_rs_pins { /* optional uart1 rs232/485 */
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT 		| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_txd.uart1_txd */		//d15
+			0x180 (PIN_INPUT 		| MUX_MODE0)	/* uart1_rxd.uart1_rxd */		//d16
+			0x178 (PIN_INPUT 		| MUX_MODE0)	/* uart1_ctsn.uart1_ctsn */		//d18
+			// 0x17C (PIN_OUTPUT 		| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_rtsn.uart1_rtsn */		//d17
+			0x17c (PIN_OUTPUT_PULLDOWN	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_rtsn.gpio0_13 */		//d17   rts-gpio
+			0x1a4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mcasp0_fsr.gpio3_19 */		//c13   rs485-sel
+		>;
+	};
+
+	uart1_dip_pins: pinmux_uart1_dip_pins {//optional uart1 with dip switch
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_txd.gpio0_15 */		//d15
+			0x180 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* uart1_rxd.gpio0_14 */		//d16
+			0x17c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_rtsn.gpio0_13 */		//d17
+			/* is not used in this configuration */
+			0x178 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* uart1_ctsn.gpio0_12 */		//d18
+			0x1a4 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* mcasp0_fsr.gpio3_19 */		//c13
+		>;
+	};
+
+	uart4_pins: pinmux_uart4_pins { /* KBUS firmware download / handshake */
+		 pinctrl-single,pins = <
+			0x168 (PIN_INPUT_PULLUP		| MUX_MODE1)  	                /* uart0_ctsn.uart4_rxd */ 		//e18
+			0x16c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE1)  	/* uart0_rtsn.uart4_txd */		//e17
+		 >;
+	};
+
+	spi0_pins: pinmux_spi0_pins { /* KBUS data communication */
+		pinctrl-single,pins = <
+			0x150 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_sclk.spio_sclk */ 	//a17
+			0x154 (PIN_INPUT_PULLUP		| MUX_MODE0)	                /* spi0_d0.spi0.d0     */	//b17 miso
+			0x158 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_d1spi0.d1      */	//b16 mosi
+			0x15c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_cs0.spi0_cs0   */	//a16 cs
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins { /* PMIC, RTC, LED-GPIO-Expander, EEPROM */
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_sda.i2c0_sda */		//c17
+			0x18c (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_scl.i2c0_scl */		//c16
+		>;
+	};
+
+	 mmc1_pins: pinmux_mmc1_pins {
+		 pinctrl-single,pins = <
+			0x104 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_cmd.mmc0_cmd   */	//g18
+			0x100 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_clk.mmc0_clk   */	//g17
+			0x0fc (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat0.mmc0_dat0 */	//g16
+			0x0f8 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat1.mmc0_dat1 */	//g15
+			0x0f4 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat2.mmc0_dat2 */	//f18
+			0x0f0 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat3.mmc0_dat3 */	//f17
+			0x190 (PIN_INPUT_PULLUP 	| MUX_MODE4)  	                /* mcasp0_aclkx.mmc0_sdcd */    //a13
+		 >;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins { // 16x data and 19x address and 8x control   // NAND 8-bit on cs0   and NvRAM 16-bit on cs1
+		pinctrl-single,pins = <
+			//data
+			0x000 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad0.gpmc_ad0 */		//u7
+			0x004 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad1.gpmc_ad1 */		//v7
+			0x008 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad2.gpmc_ad2 */		//r8
+			0x00c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad3.gpmc_ad3 */		//t8
+			0x010 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad4.gpmc_ad4 */		//u8
+			0x014 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad5.gpmc_ad5 */		//v8
+			0x018 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad6.gpmc_ad6 */		//r9
+			0x01c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad7.gpmc_ad7 */		//t9
+			0x020 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad8.gpmc_ad8 */		//u10
+			0x024 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad9.gpmc_ad9 */		//t10
+			0x028 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad10.gpmc_ad10 */	//t11
+			0x02c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad11.gpmc_ad11 */	//u12
+			0x030 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad12.gpmc_ad12 */	//t12
+			0x034 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad13.gpmc_ad13 */	//r12
+			0x038 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad14.gpmc_ad14 */	//v13
+			0x03c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad15.gpmc_ad15 */	//u13
+			//address
+			0x0A0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data0.gpmc_a0 */		//r1
+			0x0A4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data1.gpmc_a1 */		//r2
+			0x0A8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data2.gpmc_a2 */		//r3
+			0x0AC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data3.gpmc_a3 */		//r4
+			0x0B0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data4.gpmc_a4 */		//t1
+			0x0B4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data5.gpmc_a5 */		//t2
+			0x0B8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data6.gpmc_a6 */		//t3
+			0x0BC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data7.gpmc_a7 */		//t4
+			0x0E0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_vsync.gpmc_a8 */		//u5
+			0x0E4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_hsync.gpmc_a9 */		//r5
+			0x0E8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_pclk.gpmc_a10 */		//v5
+			0x0EC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_ac_bias_en.gpmc_a11 *///r6
+			0x0C0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data8.gpmc_a12 */	//u1
+			0x0C4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data9.gpmc_a13 */	//u2
+			0x0C8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data10.gpmc_a14 */	//u3
+			0x0CC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data11.gpmc_a15 */	//u4
+			0x0D0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data12.gpmc_a16 */	//v2
+			0x0D4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data13.gpmc_a17 */	//v3
+			0x0D8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data14.gpmc_a18 */	//v4
+			0x0DC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data15.gpmc_a19 */	//t5
+			//control
+			0x09c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ben0_cle.gpmc_be0n_cle */	//t6
+			0x090 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_advn_ale.gpmc_advn_ale */	//r7
+			0x094 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_oen_ren.gpmc_oen_ren */		//t7
+			0x098 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_wen.gpmc_wen */				//u6
+			0x07c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn0.gpmc_csn0 */			//v6
+			0x080 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn1.gpmc_csn1 */			//u9
+			0x084 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE1)	/* gpmc_csn2.gpmc_be1n */			//v9
+			0x070 (PIN_INPUT_PULLUP	 	| MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */			//t17
+			0x08C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* gpmc_clk.gpio2_1 */				//v12
+		>;
+	};
+
+	ksz8863_pins: pinmux_ksz8863_pins {
+		pinctrl-single,pins = <
+			0x140 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)   	/* mii1_rxd0.gpio2_21 */		//m16  	Enable
+			0x078 (PIN_INPUT_PULLUP 	| MUX_MODE7)   	                /* mii1_rxd0.gpio1_28 */		//u18	Interrupt
+		>;
+	};
+
+	cpsw_default_pins: pinmux_cpsw_default_pins {// RMII2 Ethernet Switch
+		pinctrl-single,pins = <
+			0x040 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a0.rmii2_txen */		//r13
+            0x050 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a4.rmii2_txd1 */		//r14
+            0x054 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a5.rmii2_txd0 */		//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a10.rmii2_rxd1 */		//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a11.rmii2_rxd0 */		//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_wpn.rmii2_rxer */		//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE1)  	/* mii1_col.rmii2_refclk */		//h16
+            0x088 (PIN_INPUT          	| MUX_MODE2)  	/* gpmc_csn3.rmii2_crs_dv */	//t13
+		>;
+	};
+
+	cpsw_sleep_pins: pinmux_cpsw_sleep_pins {
+		pinctrl-single,pins = <
+			0x040 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a0.gpio1_16 */			//r13
+            0x050 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a4.gpio1_20 */			//r14
+            0x054 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a5.gpio1_21 */			//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a10.gpio1_26 */			//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a11.gpio1_27 */			//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_wpn.gpio0_31 */			//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* mii1_col.gpio3_0 */			//h16
+            0x088 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_csn3.gpio2_0 */			//t13
+		>;
+	};
+
+	gpio_bitbang_mdio_pins: pinmux_gpio_bitbang_mdio_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE7)	/* M17: mdio.gpio0_0 (mdio_data), SLEWCTRL_FAST?? */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE7)			/* M18:  mdc.gpio0_1 (mdio_clk)                   */
+		>;
+	};
+
+	gpio_bitbang_mdio_sleep_pins: pinmux_gpio_bitbang_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mdio.gpio0_0 */				//m17
+			0x14c (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* mdc.gpio0_1   */				//m18
+		>;
+	};
+
+	wdg_pins: pinmux_wdg_pins {
+		pinctrl-single,pins = <
+			0x11c (PIN_OUTPUT_PULLDOWN	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd3.gpio0_16 */		//j18	TRIG-WD
+			0x120 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd2.gpio0_17 */		//k15	nEN-WD
+		>;
+	};
+
+	kbus_pins: pinmux_kbus_pins {
+		pinctrl-single,pins = <
+			0x05C (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)    /* gpmc_a7.gpio1_23 */		//t15	NIRQ
+			0x064 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a9.gpio1_25 */		//u16	NRST
+			0x060 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a8.gpio1_24 */		//v16	CMDSEL
+
+			/* Change ERRST3 to nRDY due to HW Limitations of nNMI */
+			0x1b4 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* xdma_event_intr1.gpio0_20 */	//d14	ERRST3-->nRDY
+			0x1C0 (PIN_INPUT_PULLUP 	| MUX_MODE0) 	                /* nnmi */			//b18	NRDY (not used)
+
+			0x058 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* gpmc_a6.gpio1_22 */		//u15	NSYNC
+
+			/* Error Pin */
+			0x110 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_rxerr.gpio3_2 */	//j15	NERR
+
+			/* Error State Pins (not used) */
+			0x114 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_txen.gpio3_3 */		//j16	ERRST0
+			0x118 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_rxdv.gpio3_4 */		//j17	ERRST1
+			0x1b0 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* xdma_event_intr0.gpio0_19 */	//a15	ERRST2
+		>;
+	};
+
+	gsm_pins: pinmux_gsm_pins {
+		pinctrl-single,pins = <
+			0x04c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a3.gpio1_19 */			//t14	3G-PWR-KEY
+			0x048 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a2.gpio1_18 */			//u14	3G-Reset
+		>;
+	};
+
+	gpio3_pins: pinmux_gpio3_pins {
+		pinctrl-single,pins = <
+			0x194 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_fsx.gpio3_15    */	//b13  	RESET-ALL-BUT
+			0x198 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_axr0.gpio3_16   */	//d12	nRST-BAS
+			0x19c (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_ahclkr.gpio3_17 */	//c12	nSTOP-BAS
+			0x1A0 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_aclkr.gpio3_18  */	//b12  	nRUN-BAS
+			0x1A8 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mcasp0_axr1.gpio3_20 /  */	//d13	nINT-PMIC
+			0x1Ac (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mcasp0_ahclkx.gpio3_21  */	//a14	nINT-RTC
+		>;
+	};
+
+	ecap0_pins: pinmux_ecap0_pins {
+		pinctrl-single,pins = <
+			0x160 (PIN_INPUT | MUX_MODE2)      			/* spi0_cs1.ecap1_in_pwm1_out */ 	//c15  rtc 32kHu capture in
+		>;
+	};
+};
+
+&cppi41dma {
+	status = "okay";
+};
+
+&gpio3 { /* BAS, Button, Interrupt RTC & PMIC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+
+	kbus0: kbus@0 {	/* KBUS on cs0 */
+		compatible = "wago,spi-kbus";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&kbus_pins>;
+		reg = <0>;
+		spi-max-frequency = <10000000>; /* FIXME */
+		kbus,dma-boost; /* this enables dma boosting */
+		kbus,dma-boost-prio   = <85>;
+		kbus,dma-default-prio = <50>;
+
+
+		/* some should be active low, keep all to high for compatibility reasons */
+		kbus,gpio-nrst   = <&gpio1 25 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nsync  = <&gpio1 22 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-cmdsel = <&gpio1 24 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nirq   = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nerr   = <&gpio3  2 GPIO_ACTIVE_HIGH>;
+
+		/*
+		 * The number of err state pins decreased to three.
+		 * The function of ErrSt3-Pin will be changed to nRDY (Input/GPIO-IRQ).
+		 * The external active low sensitive nNMI pin
+		 * originally reserved for nRDY is not compatible with current
+		 * Slave CPU Protocol handling which requires edge detection.
+		 * ErrSt3 (&gpio0 20 GPIO_ACTIVE_HIGH) --> nRDY
+		 *
+		 */
+		kbus,gpio-errst  = <&gpio3  3 GPIO_ACTIVE_HIGH    /* 0..2 */
+				    &gpio3  4 GPIO_ACTIVE_HIGH
+				    &gpio0 19 GPIO_ACTIVE_HIGH>;
+
+		kbus,gpio-nrdy   = <&gpio0 20 GPIO_ACTIVE_HIGH>;
+
+	};
+};
+
+&i2c0 {
+        status = "okay";
+        clock-frequency = <400000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&i2c0_pins>;
+
+        pca9552@60 {
+                compatible = "nxp,pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+                reg = <0x60>;
+
+		sys-red@0 {
+		      label = "sys-red";
+		      reg = <0>;
+		      linux,default-trigger = "none";
+		};
+
+		sys-green@1 {
+		      label = "sys-green";
+		      reg = <1>;
+		      linux,default-trigger = "heartbeat";
+		};
+
+		run-red@2 {
+		      label = "run-red";
+		      reg = <2>;
+		      linux,default-trigger = "none";
+		};
+
+		run-green@3 {
+		      label = "run-green";
+		      reg = <3>;
+		      linux,default-trigger = "none";
+		};
+
+		io-red@4 {
+		      label = "io-red";
+		      reg = <4>;
+		      linux,default-trigger = "none";
+		};
+
+		io-green@5 {
+		      label = "io-green";
+		      reg = <5>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-red@6 {
+		      label = "ms-red";
+		      reg = <6>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-green@7 {
+		      label = "ms-green";
+		      reg = <7>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-red@8 {
+		      label = "ns-red";
+		      reg = <8>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-green@9 {
+		      label = "ns-green";
+		      reg = <9>;
+		      linux,default-trigger = "none";
+		};
+
+		usr-red@10 {
+		      label = "usr-red";
+		      reg = <10>;
+		      linux,default-trigger = "none";
+		};
+
+		usr-green@11 {
+		      label = "usr-green";
+		      reg = <11>;
+		      linux,default-trigger = "none";
+		};
+        };
+
+        at24cs128n {
+                compatible = "atmel,24c512";
+                reg = <0x54>;
+        };
+
+        rtc_r2221t {
+                compatible = "ricoh,r2221tl";
+                reg = <0x32>;
+        };
+
+        tps: tps65218@24 {
+                compatible = "ti,tps65218";
+                reg = <0x24>;
+        };
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default_pins>;
+	pinctrl-1 = <&cpsw_sleep_pins>;
+	mac_control = <0x18021>; /* force 100MBit full-duplex */
+	active_slave = <1>;
+};
+
+&bitbang_mdio0 {
+       pinctrl-names = "default", "sleep";
+       pinctrl-0 = <&gpio_bitbang_mdio_pins>;
+       pinctrl-1 = <&gpio_bitbang_mdio_sleep_pins>;
+       gpios = <&gpio0 1 0	/* 0: mdc  */
+		&gpio0 0 0>;   	/* 1: mdio */
+
+       ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+       };
+       ethernet-phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <2>;
+       };
+};
+
+/*
+ * Use a fixed phy for emac0 and emac1.
+ * When 'cpsw,use-fixed-phy' is set the mdio bus device will be
+ * overwritten by the fixed-bus.
+ */
+&cpsw_emac0 { /* TODO: we should remove this for we are not using dual-mac mode, emac1 is active here */
+	cpsw,use-fixed-phy;
+	phy_id = <&bitbang_mdio0>, <1>;
+	phy-mode = "rmii";
+};
+
+&cpsw_emac1 {
+	cpsw,use-fixed-phy;
+	phy_id = <&bitbang_mdio0>, <2> /* should be '&fixed-mdio0', will fix it later */;
+	phy-mode = "rmii";
+};
+
+&phy_sel {
+	rmii-clock-ext;
+};
+
+&tps {
+        interrupts = <47>;
+        interrupt-parent = <&intc>;
+        compatible = "ti,tps65218";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+
+        dcdc1_reg: regulator-dcdc1 {
+                 compatible = "ti,tps65218-dcdc1";
+                /* VDD_CORE +1V1-CORE voltage limits */
+                regulator-name = "vdd_CORE";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc2_reg: regulator-dcdc2 {
+                 compatible = "ti,tps65218-dcdc2";
+                /* VDD_MPU +1V1-MPU voltage limits */
+                regulator-name = "vdd_MPU";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc3_reg: regulator-dcdc3 {
+                 compatible = "ti,tps65218-dcdc3";
+                /* VDD_DDR +1V5-DDR voltage limits */
+                regulator-name = "vdd_DDR";
+                regulator-min-microvolt = <1500000>;
+                regulator-max-microvolt = <1500000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc4_reg: regulator-dcdc4 {
+                 compatible = "ti,tps65218-dcdc4";
+                /* VDD_LOGIC +3V3 voltage limits */
+                regulator-name = "vdd_LOGIC";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+		/*
+		dcdc1_sw:	dcdcswitch-dcdc1{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_SD +3V3-SD voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-on;
+		*/
+
+		/*
+		dcdc2_sw:	dcdcswitch-dcdc2{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_USB +5V0-USB voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <4750000>;
+                dcdcswitch-max-microvolt = <5250000>;
+                dcdcswitch-boot-off;
+		*/
+
+		/*
+		dcdc3_sw:	dcdcswitch-dcdc3{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_LS +3V3-LS voltage not used in PFC100
+                dcdcswitch-name = "vdd_Last";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-off;
+		*/
+        config2_reg: regulator-config2 {
+                 compatible = "ti,tps65218-config2";
+                /* VDD_Logic current set to 1 Ampere*/
+                regulator-name = "vdd_CONFIG2";
+                regulator-min-microamp = <1000000>;/*TODO*/
+                regulator-max-microamp = <1000000>;/*TODO in drivers/regulator/tps65218-regulator.c */
+                regulator-boot-on;
+                regulator-always-on;
+        };
+        ldo1: regulator-ldo1 {	//VDD-PLL  +1V8
+                compatible = "ti,tps65218-ldo1";
+                regulator-name = "ldo1";
+                regulator-always-on;
+        };
+};
+
+/* do we need this ?? */
+&tscadc {
+	adc {
+		//AIN0 	= +5V0 Local Bus voltage	pmic-in
+		//AIN1	= +3V3  IO system voltage 	dcdc4_reg
+		//AIN2-7	not used
+		ti,adc-channels = <8>;
+	};
+};
+
+/* do we need this ?? */ //optional RTC 32kHz clock in cature
+&epwmss0 {
+	status = "okay";
+
+	ecap0: ecap@48300100 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ecap0_pins>;
+	};
+};
+
+&ocmcram {//???
+	 ti,no_idle_on_suspend;
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&dcdc4_reg>;
+	bus-width = <4>;
+};
diff --git a/arch/arm/boot/dts/wago-pfc100-musb.dtsi b/arch/arm/boot/dts/wago-pfc100-musb.dtsi
new file mode 100644
index 0000000..295e210
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-musb.dtsi
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&am33xx_pinmux {
+	usb_otg_pins: pinmux_usb_otg_pins {
+		pinctrl-single,pins = <
+			/* USB OTG Mux Config */
+			0x234 (PIN_INPUT_PULLDOWN | MUX_MODE0)  /* usb1_drvvbus.usb1_drvvbus */
+		>;
+	};
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+/* usb1 - host */
+&usb1 {
+	status        = "okay";
+	dr_mode       = "host";
+	pinctrl-names = "default";
+	pinctrl-0     = <&usb_otg_pins>;
+
+	multipoint = <1>;
+	num-eps    = <16>;
+	ram-bits   = <12>;
+
+	interface-type = <0>;	/* ULPI */
+	mode           = <1>;	/* HOST Mode */
+	power          = <250>;	/* can supply 100mA when operating in host mode */
+};
diff --git a/arch/arm/boot/dts/wago-pfc100-setupfw.dts b/arch/arm/boot/dts/wago-pfc100-setupfw.dts
new file mode 100644
index 0000000..482174d
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-setupfw.dts
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc100.dtsi"
+#include "wago-pfc100-uart1.dtsi"
+#include "wago-pfc100-musb.dtsi"
+#include "wago-pfc100-cmtests.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x000C
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  x  x
+ *                                             |  |
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  |  PROFIBUS_SL
+ *                                             |  |  CAN
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *   x: reserved for future use
+ *
+ */
+
+/ {
+	target_info {
+		/*
+		 * maybe we should change the drivers name
+		 * to something like "wago,information" ??
+		*/
+		compatible = "wago,testenv";
+
+		board_info {
+			model = "pfc100";
+			id = "750-81xx";
+		};
+
+		led_info {
+			/* conforms to led order on device, see node "pca9552@60".
+			 * we assume, that every led has to colors (red, green).
+			 * so we only allow the colors red,green,orange
+			 */
+			led_array_red = "sys:run:io:ms:ns:usr";
+		};
+	};
+};
+
+&uart1 {
+	/* uart1 disabled for cmtest gpio test */
+	status = "disabled";
+};
+
+&oms {
+	/* disable oms driver for cmtest gpio test */
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/wago-pfc100-uart1.dtsi b/arch/arm/boot/dts/wago-pfc100-uart1.dtsi
new file mode 100644
index 0000000..313174b
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100-uart1.dtsi
@@ -0,0 +1,29 @@
+&am33xx_pinmux {
+	uart1_rs_pins: pinmux_uart1_rs_pins { /* optional uart1 rs232/485 */
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT 		| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_txd.uart1_txd */		//d15
+			0x180 (PIN_INPUT 		| MUX_MODE0)	/* uart1_rxd.uart1_rxd */		//d16
+			0x178 (PIN_INPUT 		| MUX_MODE0)	/* uart1_ctsn.uart1_ctsn */		//d18
+			0x17C (PIN_OUTPUT 		| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_rtsn.uart1_rtsn */		//d17
+			// 0x17c (PIN_OUTPUT_PULLDOWN	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_rtsn.gpio0_13 */		//d17   rts-gpio
+			0x1a4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mcasp0_fsr.gpio3_19 */		//c13   rs485-sel
+		>;
+	};
+};
+
+&uart1 {
+	compatible = "ti,omap3-uart-rtu";
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_rs_pins>;
+
+	//rts-gpio = <&gpio0 13 GPIO_ACTIVE_HIGH>;
+	rs485en-gpio = <&gpio3 19 GPIO_ACTIVE_LOW>;
+	rs485-rts-active-high;
+
+	/* rs485-rx-during-tx; */ // we only support 2-wire mode
+
+	rs485-rts-delay = <1 1>;
+
+	/* linux,rs485-enabled-at-boot-time; */
+};
diff --git a/arch/arm/boot/dts/wago-pfc100.dts b/arch/arm/boot/dts/wago-pfc100.dts
new file mode 100644
index 0000000..4f9eb90
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100.dts
@@ -0,0 +1,810 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "am33xx.dtsi"
+
+/ {
+	model = "WAGO PFC100 HW02";
+	compatible = "wago,pfc10x", "ti,am33xx";
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&dcdc2_reg>;
+
+			/*
+			 * To consider voltage drop between PMIC and SoC,
+			 * tolerance value is reduced to 2% from 4% and
+			 * voltage value is increased as a precaution.
+			 */
+			operating-points = <
+				/* kHz    uV */
+				/*1000000  1325000*/
+				 /*800000  1260000*/
+				 /*720000  1200000*/
+				 600000  1100000
+				 300000  950000
+			>;
+		};
+	};
+
+	aliases {
+		mdio-gpio0 = &bitbang_mdio0;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+
+	vxe164_reg: fixedregulator@0 {	/* XE164 +3V3  System voltage */
+		compatible = "regulator-fixed";
+		regulator-name = "vxe164";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dcdc4_reg>;
+	};
+
+	vsd_reg: fixedregulator@1 {		/* SD Card +3V3 Systemvoltage over power switch */
+		compatible = "regulator-fixed";
+		regulator-name = "v_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+                vin-supply = <&dcdc4_reg>;
+	};
+
+	ksz8863 {
+		compatible = "micrel,ksz8863";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		status = "okay";
+
+		ksz,reset-switch;
+		ksz,gpio-reset = <&gpio2 21 GPIO_ACTIVE_LOW>;	/* gpio2_21: RMII2.EN-PHY */
+		ksz,disable-internal-ldo;
+		ksz,mii-bus = <&bitbang_mdio0>;
+	};
+
+	UIO_NVRAM@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x1000000 0x20000>;  /* 128k 16bit NVRAM */
+	};
+
+	wsysinit_init {
+		compatible = "wago,sysinit";
+		add-sysfs-entries;
+	};
+
+	ksz8863_reset {
+		compatible = "micrel,ksz8863-reset";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		gpio-reset = <&gpio2 21 GPIO_ACTIVE_LOW>;	/* gpio2_21: RMII2.EN-PHY */
+		reset-switch;
+		status = "okay";
+	};
+
+	dsa@0 {
+		compatible = "marvell,dsa";
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* interrupts = <10>; --> not supported from the driver! */
+
+		/* master netdevice (eth0) */
+		dsa,ethernet = <&mac>; /* TODO: should we use 'cpsw_emac1' instead? */
+		dsa,mii-bus = <&bitbang_mdio0>;
+
+		switch@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <16 0>;	/* MDIO address 16, switch 0 in tree */
+
+			port@0 {
+				reg = <0>;
+				label = "ethX1";
+				phy-handle = <&phy1>;
+				phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "ethX2";
+				phy-handle = <&phy2>;
+				phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <2>;
+				label = "cpu";
+			};
+		};
+	};
+};
+
+&uart0 { /* debug interface over JTAG Connector */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_rs_pins>;
+	status = "okay";
+	rts-gpio = <&gpio0 13 GPIO_ACTIVE_HIGH>;
+	rs485en-gpio = <&gpio3 19 GPIO_ACTIVE_LOW>;
+	rs485-rts-active-high;
+	/* rs485-rx-during-tx; */ // we only support 2-wire mode
+	rs485-rts-delay = <1 1>;
+	/* linux,rs485-enabled-at-boot-time; */
+};
+
+&uart4 { /* KBUS Firmware download */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins>;
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+
+	num-cs = <2>;	/* only two devices */
+	num-waitpins = <1>;
+	status = "okay";
+	ranges = <
+		0 0 0x00000000 0x01000000	/* CS0: NAND, 16M */
+		1 0 0x01000000 0x01000000	/* CS1: NVRAM, 16M */
+	>;
+
+	nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ti,elm-id = <&elm>;
+	};
+
+        nvram: nor@1,0 { /* NVRAM Device 128k */
+		reg = <1 0 0x1000000>;
+
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <50>;
+		gpmc,cs-wr-off-ns = <30>;
+		gpmc,adv-on-ns = <0>;
+		gpmc,adv-rd-off-ns = <0>;
+		gpmc,adv-wr-off-ns = <0>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <50>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <30>;
+		gpmc,rd-cycle-ns = <50>;
+		gpmc,wr-cycle-ns = <30>;
+		gpmc,access-ns = <40>;
+		gpmc,wr-access-ns = <10>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <10>;
+		gpmc,cycle2cycle-samecsen;
+		gpmc,cycle2cycle-diffcsen;
+		gpmc,wait-on-read = "false";
+		gpmc,wait-on-write = "false";
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+/* for pin mux offset calc: doc_offset - 0x800h = dts-offset */
+&am33xx_pinmux {
+
+	uart0_pins: pinmux_uart0_pins { /* debug interface over JTAG Connector */
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP		| MUX_MODE0)  	                /* uart0_rxd.uart0_rxd */ 		//e15
+			0x174 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)  	/* uart0_txd.uart0_txd */		//e16
+		>;
+	};
+
+	uart1_rs_pins: pinmux_uart1_rs_pins { /* optional uart1 rs232/485 */
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT 		| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_txd.uart1_txd */		//d15
+			0x180 (PIN_INPUT 		| MUX_MODE0)	/* uart1_rxd.uart1_rxd */		//d16
+			0x178 (PIN_INPUT 		| MUX_MODE0)	/* uart1_ctsn.uart1_ctsn */		//d18
+			// 0x17C (PIN_OUTPUT 		| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_rtsn.uart1_rtsn */		//d17
+			0x17c (PIN_OUTPUT_PULLDOWN	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_rtsn.gpio0_13 */		//d17   rts-gpio
+			0x1a4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mcasp0_fsr.gpio3_19 */		//c13   rs485-sel
+		>;
+	};
+
+	uart1_dip_pins: pinmux_uart1_dip_pins {//optional uart1 with dip switch
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_txd.gpio0_15 */		//d15
+			0x180 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* uart1_rxd.gpio0_14 */		//d16
+			0x17c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_rtsn.gpio0_13 */		//d17
+			/* is not used in this configuration */
+			0x178 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* uart1_ctsn.gpio0_12 */		//d18
+			0x1a4 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	                /* mcasp0_fsr.gpio3_19 */		//c13
+		>;
+	};
+
+	uart4_pins: pinmux_uart4_pins { /* KBUS firmware download / handshake */
+		 pinctrl-single,pins = <
+			0x168 (PIN_INPUT_PULLUP		| MUX_MODE1)  	                /* uart0_ctsn.uart4_rxd */ 		//e18
+			0x16c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE1)  	/* uart0_rtsn.uart4_txd */		//e17
+		 >;
+	};
+
+	spi0_pins: pinmux_spi0_pins { /* KBUS data communication */
+		pinctrl-single,pins = <
+			0x150 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_sclk.spio_sclk */ 	//a17
+			0x154 (PIN_INPUT_PULLUP		| MUX_MODE0)	                /* spi0_d0.spi0.d0     */	//b17 miso
+			0x158 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_d1spi0.d1      */	//b16 mosi
+			0x15c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_cs0.spi0_cs0   */	//a16 cs
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins { /* PMIC, RTC, LED-GPIO-Expander, EEPROM */
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_sda.i2c0_sda */		//c17
+			0x18c (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_scl.i2c0_scl */		//c16
+		>;
+	};
+
+	 mmc1_pins: pinmux_mmc1_pins {
+		 pinctrl-single,pins = <
+			0x104 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_cmd.mmc0_cmd   */	//g18
+			0x100 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_clk.mmc0_clk   */	//g17
+			0x0fc (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat0.mmc0_dat0 */	//g16
+			0x0f8 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat1.mmc0_dat1 */	//g15
+			0x0f4 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat2.mmc0_dat2 */	//f18
+			0x0f0 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat3.mmc0_dat3 */	//f17
+			0x190 (PIN_INPUT_PULLUP 	| MUX_MODE4)  	                /* mcasp0_aclkx.mmc0_sdcd */    //a13
+		 >;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins { // 16x data and 19x address and 8x control   // NAND 8-bit on cs0   and NvRAM 16-bit on cs1
+		pinctrl-single,pins = <
+			//data
+			0x000 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad0.gpmc_ad0 */		//u7
+			0x004 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad1.gpmc_ad1 */		//v7
+			0x008 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad2.gpmc_ad2 */		//r8
+			0x00c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad3.gpmc_ad3 */		//t8
+			0x010 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad4.gpmc_ad4 */		//u8
+			0x014 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad5.gpmc_ad5 */		//v8
+			0x018 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad6.gpmc_ad6 */		//r9
+			0x01c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad7.gpmc_ad7 */		//t9
+			0x020 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad8.gpmc_ad8 */		//u10
+			0x024 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad9.gpmc_ad9 */		//t10
+			0x028 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad10.gpmc_ad10 */	//t11
+			0x02c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad11.gpmc_ad11 */	//u12
+			0x030 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad12.gpmc_ad12 */	//t12
+			0x034 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad13.gpmc_ad13 */	//r12
+			0x038 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad14.gpmc_ad14 */	//v13
+			0x03c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad15.gpmc_ad15 */	//u13
+			//address
+			0x0A0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data0.gpmc_a0 */		//r1
+			0x0A4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data1.gpmc_a1 */		//r2
+			0x0A8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data2.gpmc_a2 */		//r3
+			0x0AC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data3.gpmc_a3 */		//r4
+			0x0B0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data4.gpmc_a4 */		//t1
+			0x0B4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data5.gpmc_a5 */		//t2
+			0x0B8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data6.gpmc_a6 */		//t3
+			0x0BC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data7.gpmc_a7 */		//t4
+			0x0E0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_vsync.gpmc_a8 */		//u5
+			0x0E4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_hsync.gpmc_a9 */		//r5
+			0x0E8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_pclk.gpmc_a10 */		//v5
+			0x0EC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_ac_bias_en.gpmc_a11 *///r6
+			0x0C0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data8.gpmc_a12 */	//u1
+			0x0C4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data9.gpmc_a13 */	//u2
+			0x0C8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data10.gpmc_a14 */	//u3
+			0x0CC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data11.gpmc_a15 */	//u4
+			0x0D0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data12.gpmc_a16 */	//v2
+			0x0D4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data13.gpmc_a17 */	//v3
+			0x0D8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data14.gpmc_a18 */	//v4
+			0x0DC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data15.gpmc_a19 */	//t5
+			//control
+			0x09c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ben0_cle.gpmc_be0n_cle */	//t6
+			0x090 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_advn_ale.gpmc_advn_ale */	//r7
+			0x094 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_oen_ren.gpmc_oen_ren */		//t7
+			0x098 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_wen.gpmc_wen */				//u6
+			0x07c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn0.gpmc_csn0 */			//v6
+			0x080 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn1.gpmc_csn1 */			//u9
+			0x084 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE1)	/* gpmc_csn2.gpmc_be1n */			//v9
+			0x070 (PIN_INPUT_PULLUP	 	| MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */			//t17
+			0x08C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* gpmc_clk.gpio2_1 */				//v12
+		>;
+	};
+
+	ksz8863_pins: pinmux_ksz8863_pins {
+		pinctrl-single,pins = <
+			0x140 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)   	/* mii1_rxd0.gpio2_21 */		//m16  	Enable
+			0x078 (PIN_INPUT_PULLUP 	| MUX_MODE7)   	                /* mii1_rxd0.gpio1_28 */		//u18	Interrupt
+		>;
+	};
+
+	cpsw_default_pins: pinmux_cpsw_default_pins {// RMII2 Ethernet Switch
+		pinctrl-single,pins = <
+			0x040 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a0.rmii2_txen */		//r13
+            0x050 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a4.rmii2_txd1 */		//r14
+            0x054 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a5.rmii2_txd0 */		//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a10.rmii2_rxd1 */		//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a11.rmii2_rxd0 */		//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_wpn.rmii2_rxer */		//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE1)  	/* mii1_col.rmii2_refclk */		//h16
+            0x088 (PIN_INPUT          	| MUX_MODE2)  	/* gpmc_csn3.rmii2_crs_dv */	//t13
+		>;
+	};
+
+	cpsw_sleep_pins: pinmux_cpsw_sleep_pins {
+		pinctrl-single,pins = <
+			0x040 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a0.gpio1_16 */			//r13
+            0x050 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a4.gpio1_20 */			//r14
+            0x054 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a5.gpio1_21 */			//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a10.gpio1_26 */			//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a11.gpio1_27 */			//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_wpn.gpio0_31 */			//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* mii1_col.gpio3_0 */			//h16
+            0x088 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_csn3.gpio2_0 */			//t13
+		>;
+	};
+
+	gpio_bitbang_mdio_pins: pinmux_gpio_bitbang_mdio_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE7)	/* M17: mdio.gpio0_0 (mdio_data), SLEWCTRL_FAST?? */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE7)			/* M18:  mdc.gpio0_1 (mdio_clk)                   */
+		>;
+	};
+
+	gpio_bitbang_mdio_sleep_pins: pinmux_gpio_bitbang_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mdio.gpio0_0 */				//m17
+			0x14c (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* mdc.gpio0_1   */				//m18
+		>;
+	};
+
+	wdg_pins: pinmux_wdg_pins {
+		pinctrl-single,pins = <
+			0x11c (PIN_OUTPUT_PULLDOWN	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd3.gpio0_16 */		//j18	TRIG-WD
+			0x120 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd2.gpio0_17 */		//k15	nEN-WD
+		>;
+	};
+
+	kbus_pins: pinmux_kbus_pins {
+		pinctrl-single,pins = <
+			0x05C (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)    /* gpmc_a7.gpio1_23 */		//t15	NIRQ
+			0x064 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a9.gpio1_25 */		//u16	NRST
+			0x060 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a8.gpio1_24 */		//v16	CMDSEL
+
+			/* Change ERRST3 to nRDY due to HW Limitations of nNMI */
+			0x1b4 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* xdma_event_intr1.gpio0_20 */	//d14	ERRST3-->nRDY
+			0x1C0 (PIN_INPUT_PULLUP 	| MUX_MODE0) 	                /* nnmi */			//b18	NRDY (not used)
+
+			0x058 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* gpmc_a6.gpio1_22 */		//u15	NSYNC
+
+			/* Error Pin */
+			0x110 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_rxerr.gpio3_2 */	//j15	NERR
+
+			/* Error State Pins (not used) */
+			0x114 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_txen.gpio3_3 */		//j16	ERRST0
+			0x118 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_rxdv.gpio3_4 */		//j17	ERRST1
+			0x1b0 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* xdma_event_intr0.gpio0_19 */	//a15	ERRST2
+		>;
+	};
+
+	gsm_pins: pinmux_gsm_pins {
+		pinctrl-single,pins = <
+			0x04c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a3.gpio1_19 */			//t14	3G-PWR-KEY
+			0x048 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a2.gpio1_18 */			//u14	3G-Reset
+		>;
+	};
+
+	gpio3_pins: pinmux_gpio3_pins {
+		pinctrl-single,pins = <
+			0x194 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_fsx.gpio3_15    */	//b13  	RESET-ALL-BUT
+			0x198 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_axr0.gpio3_16   */	//d12	nRST-BAS
+			0x19c (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_ahclkr.gpio3_17 */	//c12	nSTOP-BAS
+			0x1A0 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_aclkr.gpio3_18  */	//b12  	nRUN-BAS
+			0x1A8 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mcasp0_axr1.gpio3_20 /  */	//d13	nINT-PMIC
+			0x1Ac (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mcasp0_ahclkx.gpio3_21  */	//a14	nINT-RTC
+		>;
+	};
+
+	ecap0_pins: pinmux_ecap0_pins {
+		pinctrl-single,pins = <
+			0x160 (PIN_INPUT | MUX_MODE2)      			/* spi0_cs1.ecap1_in_pwm1_out */ 	//c15  rtc 32kHu capture in
+		>;
+	};
+};
+
+&cppi41dma {
+	status = "okay";
+};
+
+&gpio3 { /* BAS, Button, Interrupt RTC & PMIC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+
+	kbus0: kbus@0 {	/* KBUS on cs0 */
+		compatible = "wago,spi-kbus";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&kbus_pins>;
+		reg = <0>;
+		spi-max-frequency = <10000000>; /* FIXME */
+		kbus,dma-boost; /* this enables dma boosting */
+		kbus,dma-boost-prio   = <85>;
+		kbus,dma-default-prio = <50>;
+
+
+		/* some should be active low, keep all to high for compatibility reasons */
+		kbus,gpio-nrst   = <&gpio1 25 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nsync  = <&gpio1 22 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-cmdsel = <&gpio1 24 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nirq   = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nerr   = <&gpio3  2 GPIO_ACTIVE_HIGH>;
+
+		/*
+		 * The number of err state pins decreased to three.
+		 * The function of ErrSt3-Pin will be changed to nRDY (Input/GPIO-IRQ).
+		 * The external active low sensitive nNMI pin
+		 * originally reserved for nRDY is not compatible with current
+		 * Slave CPU Protocol handling which requires edge detection.
+		 * ErrSt3 (&gpio0 20 GPIO_ACTIVE_HIGH) --> nRDY
+		 *
+		 */
+		kbus,gpio-errst  = <&gpio3  3 GPIO_ACTIVE_HIGH    /* 0..2 */
+				    &gpio3  4 GPIO_ACTIVE_HIGH
+				    &gpio0 19 GPIO_ACTIVE_HIGH>;
+
+		kbus,gpio-nrdy   = <&gpio0 20 GPIO_ACTIVE_HIGH>;
+
+	};
+};
+
+&i2c0 {
+        status = "okay";
+        clock-frequency = <400000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&i2c0_pins>;
+
+        pca9552@60 {
+                compatible = "nxp,pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+                reg = <0x60>;
+
+		sys-red@0 {
+		      label = "sys-red";
+		      reg = <0>;
+		      linux,default-trigger = "none";
+		};
+
+		sys-green@1 {
+		      label = "sys-green";
+		      reg = <1>;
+		      linux,default-trigger = "heartbeat";
+		};
+
+		run-red@2 {
+		      label = "run-red";
+		      reg = <2>;
+		      linux,default-trigger = "none";
+		};
+
+		run-green@3 {
+		      label = "run-green";
+		      reg = <3>;
+		      linux,default-trigger = "none";
+		};
+
+		io-red@4 {
+		      label = "io-red";
+		      reg = <4>;
+		      linux,default-trigger = "none";
+		};
+
+		io-green@5 {
+		      label = "io-green";
+		      reg = <5>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-red@6 {
+		      label = "ms-red";
+		      reg = <6>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-green@7 {
+		      label = "ms-green";
+		      reg = <7>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-red@8 {
+		      label = "ns-red";
+		      reg = <8>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-green@9 {
+		      label = "ns-green";
+		      reg = <9>;
+		      linux,default-trigger = "none";
+		};
+
+		usr-red@10 {
+		      label = "usr-red";
+		      reg = <10>;
+		      linux,default-trigger = "none";
+		};
+
+		usr-green@11 {
+		      label = "usr-green";
+		      reg = <11>;
+		      linux,default-trigger = "none";
+		};
+        };
+
+        at24cs128n {
+                compatible = "atmel,24c512";
+                reg = <0x54>;
+
+		pagesize = <128>;
+        };
+
+        rtc_r2221t {
+                compatible = "ricoh,r2221tl";
+                reg = <0x32>;
+        };
+
+        tps: tps65218@24 {
+                compatible = "ti,tps65218";
+                reg = <0x24>;
+        };
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default_pins>;
+	pinctrl-1 = <&cpsw_sleep_pins>;
+	mac_control = <0x18021>; /* force 100MBit full-duplex */
+	active_slave = <1>;
+	status = "okay";
+
+        fixedbus: fixed-bus {
+		bus-id = "fixed-0";
+	};
+};
+
+&bitbang_mdio0 {
+       status = "okay";
+       pinctrl-names = "default", "sleep";
+       pinctrl-0 = <&gpio_bitbang_mdio_pins>;
+       pinctrl-1 = <&gpio_bitbang_mdio_sleep_pins>;
+       gpios = <&gpio0 1 0	/* 0: mdc  */
+		&gpio0 0 0>;   	/* 1: mdio */
+
+       phy1: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+       };
+
+       phy2: ethernet-phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <2>;
+       };
+};
+
+/*
+ * Use a fixed phy for emac1.
+ * that's rgmii2
+ */
+&cpsw_emac1 {
+	cpsw,use-fixed-phy;
+	phy_id = <&fixedbus>, <1>;
+	phy-mode = "rmii";
+};
+
+&phy_sel {
+	rmii-clock-ext;
+};
+
+&tps {
+        interrupts = <47>;
+        interrupt-parent = <&intc>;
+        compatible = "ti,tps65218";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+
+        dcdc1_reg: regulator-dcdc1 {
+                 compatible = "ti,tps65218-dcdc1";
+                /* VDD_CORE +1V1-CORE voltage limits */
+                regulator-name = "vdd_CORE";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc2_reg: regulator-dcdc2 {
+                 compatible = "ti,tps65218-dcdc2";
+                /* VDD_MPU +1V1-MPU voltage limits */
+                regulator-name = "vdd_MPU";
+		regulator-min-microvolt = <912000>;
+		regulator-max-microvolt = <1378000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc3_reg: regulator-dcdc3 {
+                 compatible = "ti,tps65218-dcdc3";
+                /* VDD_DDR +1V5-DDR voltage limits */
+                regulator-name = "vdd_DDR";
+                regulator-min-microvolt = <1500000>;
+                regulator-max-microvolt = <1500000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc4_reg: regulator-dcdc4 {
+                 compatible = "ti,tps65218-dcdc4";
+                /* VDD_LOGIC +3V3 voltage limits */
+                regulator-name = "vdd_LOGIC";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+		/*
+		dcdc1_sw:	dcdcswitch-dcdc1{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_SD +3V3-SD voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-on;
+		*/
+
+		/*
+		dcdc2_sw:	dcdcswitch-dcdc2{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_USB +5V0-USB voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <4750000>;
+                dcdcswitch-max-microvolt = <5250000>;
+                dcdcswitch-boot-off;
+		*/
+
+		/*
+		dcdc3_sw:	dcdcswitch-dcdc3{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_LS +3V3-LS voltage not used in PFC100
+                dcdcswitch-name = "vdd_Last";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-off;
+		*/
+        config2_reg: regulator-config2 {
+                 compatible = "ti,tps65218-config2";
+                /* VDD_Logic current set to 1 Ampere*/
+                regulator-name = "vdd_CONFIG2";
+                regulator-min-microamp = <1000000>;/*TODO*/
+                regulator-max-microamp = <1000000>;/*TODO in drivers/regulator/tps65218-regulator.c */
+                regulator-boot-on;
+                regulator-always-on;
+        };
+        ldo1: regulator-ldo1 {	//VDD-PLL  +1V8
+                compatible = "ti,tps65218-ldo1";
+                regulator-name = "ldo1";
+                regulator-always-on;
+        };
+};
+
+/* do we need this ?? */
+&tscadc {
+	adc {
+		//AIN0 	= +5V0 Local Bus voltage	pmic-in
+		//AIN1	= +3V3  IO system voltage 	dcdc4_reg
+		//AIN2-7	not used
+		ti,adc-channels = <8>;
+	};
+};
+
+/* do we need this ?? */ //optional RTC 32kHz clock in cature
+&epwmss0 {
+	status = "okay";
+
+	ecap0: ecap@48300100 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ecap0_pins>;
+	};
+};
+
+&ocmcram {//???
+	 ti,no_idle_on_suspend;
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&dcdc4_reg>;
+	bus-width = <4>;
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+
+&usb1 { /* usb1 - OTG */
+	status = "okay";
+        dr_mode = "host";
+};
+
+&sham {
+	status = "okay";
+};
+
+&aes {
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/wago-pfc100.dtsi b/arch/arm/boot/dts/wago-pfc100.dtsi
new file mode 100644
index 0000000..45edc88
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100.dtsi
@@ -0,0 +1,829 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "am33xx.dtsi"
+
+/* Varianten beim PFC100
+ *
+ * 750-8101: 2ETH, DIP
+ * 750-8102: 2ETH, RS232/485
+ *
+ */
+
+
+/ {
+	model = "WAGO PFC100 HW02";
+	compatible = "wago,pfc10x", "ti,am33xx";
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&dcdc2_reg>;
+
+			/*
+			 * To consider voltage drop between PMIC and SoC,
+			 * tolerance value is reduced to 2% from 4% and
+			 * voltage value is increased as a precaution.
+			 */
+			operating-points = <
+				/* kHz    uV */
+				/*1000000  1325000*/
+				/* 800000  1260000*/
+				/* 720000  1200000*/
+				 600000  1100000
+				 300000  950000
+			>;
+		};
+	};
+
+	aliases {
+		mdio-gpio0 = &bitbang_mdio0;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+
+	vxe164_reg: fixedregulator@0 {	/* XE164 +3V3  System voltage */
+		compatible = "regulator-fixed";
+		regulator-name = "vxe164";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dcdc4_reg>;
+	};
+
+	vsd_reg: fixedregulator@1 {		/* SD Card +3V3 Systemvoltage over power switch */
+		compatible = "regulator-fixed";
+		regulator-name = "v_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+                vin-supply = <&dcdc4_reg>;
+	};
+
+	ksz8863 {
+		compatible = "micrel,ksz8863";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		status = "okay";
+
+		ksz,reset-switch;
+		ksz,gpio-reset = <&gpio2 21 GPIO_ACTIVE_LOW>;	/* gpio2_21: RMII2.EN-PHY */
+		ksz,disable-internal-ldo;
+		ksz,mii-bus = <&bitbang_mdio0>;
+	};
+
+	UIO_NVRAM@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x1000000 0x20000>;  /* 128k 16bit NVRAM */
+	};
+
+	wsysinit_init {
+		compatible = "wago,sysinit";
+		add-sysfs-entries;
+
+		tty,service   = "ttyO0";
+		tty,rs232-485 = "ttyO1";
+
+		board,variant = "pfc100";
+
+		/* sysclock adjustments,
+		   empirical values */
+		adjtimex,tick = <10000>;
+		adjtimex,frequency = <2000000>;
+	};
+
+	/*
+	   this name of the gpio-keys device is a
+	   historical heritage from 3.6.11 kernel.
+	   the device-name is checked in omsd. So we
+	   need to adapt this configuration
+	*/
+	oms: PAC-Operating-Mode-Switch {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+
+		run {
+			label = "RUN";
+			gpios = <&gpio3 18 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 114 */
+			linux,code = <1>;
+			linux,input-type = <5>;  /* EV_SW */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		stop {
+			label = "STOP";
+			gpios = <&gpio3 17 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 113 */
+			linux,code = <2>;
+			linux,input-type = <5>;  /* EV_SW */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		reset {
+			label = "RESET";
+			gpios = <&gpio3 16 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 112 */
+			linux,code = <3>;
+			linux,input-type = <1>;  /* EV_KEY */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		reset_all {
+			label = "RESET_ALL";
+			gpios = <&gpio3 15 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 111 */
+			linux,code = <4>;
+			linux,input-type = <1>;  /* EV_KEY */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+	};
+
+	dsa@0 {
+		compatible = "marvell,dsa";
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* interrupts = <10>; --> not supported from the driver! */
+
+		/* master netdevice (eth0) */
+		dsa,ethernet = <&mac>; /* TODO: should we use 'cpsw_emac1' instead? */
+		dsa,mii-bus = <&bitbang_mdio0>;
+
+		switch@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <16 0>;	/* MDIO address 16, switch 0 in tree */
+
+			port@0 {
+				reg = <1>;
+				label = "ethX1";
+				phy-handle = <&phy1>;
+				phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <2>;
+				label = "ethX2";
+				phy-handle = <&phy2>;
+				phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <3>;
+				label = "cpu";
+			};
+		};
+	};
+
+	watchdog: watchdog {
+		/* XC6124 */
+		compatible = "linux,wdt-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&watchdog_pins>;
+
+		gpio-en = <&gpio0 17 GPIO_ACTIVE_LOW>;
+		gpios = <&gpio0 16 GPIO_ACTIVE_LOW>;
+
+		hw_algo = "toggle";
+		hw_margin_ms = <1600>;
+		status = "okay";
+	};
+};
+
+&uart0 { /* debug interface over JTAG Connector */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&uart1 {
+	status = "disabled";
+};
+
+&uart4 { /* KBUS Firmware download */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins>;
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+
+	num-cs = <2>;	/* only two devices */
+	num-waitpins = <1>;
+	status = "okay";
+	ranges = <
+		0 0 0x00000000 0x01000000	/* CS0: NAND, 16M */
+		1 0 0x01000000 0x01000000	/* CS1: NVRAM, 16M */
+	>;
+
+	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ti,elm-id = <&elm>;
+	};
+
+        nvram: nor@1,0 { /* NVRAM Device 128k */
+		reg = <1 0 0x1000000>;
+
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <50>;
+		gpmc,cs-wr-off-ns = <30>;
+		gpmc,adv-on-ns = <0>;
+		gpmc,adv-rd-off-ns = <0>;
+		gpmc,adv-wr-off-ns = <0>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <50>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <30>;
+		gpmc,rd-cycle-ns = <50>;
+		gpmc,wr-cycle-ns = <30>;
+		gpmc,access-ns = <40>;
+		gpmc,wr-access-ns = <10>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <10>;
+		gpmc,cycle2cycle-samecsen;
+		gpmc,cycle2cycle-diffcsen;
+		gpmc,wait-on-read = "false";
+		gpmc,wait-on-write = "false";
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+/* for pin mux offset calc: doc_offset - 0x800h = dts-offset */
+&am33xx_pinmux {
+
+	uart0_pins: pinmux_uart0_pins { /* debug interface over JTAG Connector */
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP		| MUX_MODE0)  	                /* uart0_rxd.uart0_rxd */ 		//e15
+			0x174 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)  	/* uart0_txd.uart0_txd */		//e16
+		>;
+	};
+
+	uart4_pins: pinmux_uart4_pins { /* KBUS firmware download / handshake */
+		 pinctrl-single,pins = <
+			0x168 (PIN_INPUT_PULLUP		| MUX_MODE1)  	                /* uart0_ctsn.uart4_rxd */ 		//e18
+			0x16c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE1)  	/* uart0_rtsn.uart4_txd */		//e17
+		 >;
+	};
+
+	spi0_pins: pinmux_spi0_pins { /* KBUS data communication */
+		pinctrl-single,pins = <
+			0x150 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_sclk.spio_sclk */ 	//a17
+			0x154 (PIN_INPUT_PULLUP		| MUX_MODE0)	                /* spi0_d0.spi0.d0     */	//b17 miso
+			0x158 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_d1spi0.d1      */	//b16 mosi
+			0x15c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_cs0.spi0_cs0   */	//a16 cs
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins { /* PMIC, RTC, LED-GPIO-Expander, EEPROM */
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_sda.i2c0_sda */		//c17
+			0x18c (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_scl.i2c0_scl */		//c16
+		>;
+	};
+
+	 mmc1_pins: pinmux_mmc1_pins {
+		 pinctrl-single,pins = <
+			0x104 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_cmd.mmc0_cmd   */	//g18
+			0x100 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_clk.mmc0_clk   */	//g17
+			0x0fc (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat0.mmc0_dat0 */	//g16
+			0x0f8 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat1.mmc0_dat1 */	//g15
+			0x0f4 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat2.mmc0_dat2 */	//f18
+			0x0f0 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat3.mmc0_dat3 */	//f17
+			0x190 (PIN_INPUT_PULLUP 	| MUX_MODE7)  	                /* mcasp0_aclkx.mmc0_sdcd */    //a13
+		 >;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins { // 16x data and 19x address and 8x control   // NAND 8-bit on cs0   and NvRAM 16-bit on cs1
+		pinctrl-single,pins = <
+			//data
+			0x000 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad0.gpmc_ad0 */		//u7
+			0x004 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad1.gpmc_ad1 */		//v7
+			0x008 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad2.gpmc_ad2 */		//r8
+			0x00c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad3.gpmc_ad3 */		//t8
+			0x010 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad4.gpmc_ad4 */		//u8
+			0x014 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad5.gpmc_ad5 */		//v8
+			0x018 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad6.gpmc_ad6 */		//r9
+			0x01c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad7.gpmc_ad7 */		//t9
+			0x020 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad8.gpmc_ad8 */		//u10
+			0x024 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad9.gpmc_ad9 */		//t10
+			0x028 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad10.gpmc_ad10 */	//t11
+			0x02c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad11.gpmc_ad11 */	//u12
+			0x030 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad12.gpmc_ad12 */	//t12
+			0x034 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad13.gpmc_ad13 */	//r12
+			0x038 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad14.gpmc_ad14 */	//v13
+			0x03c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad15.gpmc_ad15 */	//u13
+			//address
+			0x0A0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data0.gpmc_a0 */		//r1
+			0x0A4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data1.gpmc_a1 */		//r2
+			0x0A8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data2.gpmc_a2 */		//r3
+			0x0AC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data3.gpmc_a3 */		//r4
+			0x0B0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data4.gpmc_a4 */		//t1
+			0x0B4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data5.gpmc_a5 */		//t2
+			0x0B8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data6.gpmc_a6 */		//t3
+			0x0BC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data7.gpmc_a7 */		//t4
+			0x0E0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_vsync.gpmc_a8 */		//u5
+			0x0E4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_hsync.gpmc_a9 */		//r5
+			0x0E8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_pclk.gpmc_a10 */		//v5
+			0x0EC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_ac_bias_en.gpmc_a11 *///r6
+			0x0C0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data8.gpmc_a12 */	//u1
+			0x0C4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data9.gpmc_a13 */	//u2
+			0x0C8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data10.gpmc_a14 */	//u3
+			0x0CC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data11.gpmc_a15 */	//u4
+			0x0D0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data12.gpmc_a16 */	//v2
+			0x0D4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data13.gpmc_a17 */	//v3
+			0x0D8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data14.gpmc_a18 */	//v4
+			0x0DC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data15.gpmc_a19 */	//t5
+			//control
+			0x09c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ben0_cle.gpmc_be0n_cle */	//t6
+			0x090 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_advn_ale.gpmc_advn_ale */	//r7
+			0x094 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_oen_ren.gpmc_oen_ren */		//t7
+			0x098 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_wen.gpmc_wen */				//u6
+			0x07c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn0.gpmc_csn0 */			//v6
+			0x080 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn1.gpmc_csn1 */			//u9
+			0x084 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE1)	/* gpmc_csn2.gpmc_be1n */			//v9
+			0x070 (PIN_INPUT_PULLUP	 	| MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */			//t17
+			0x08C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* gpmc_clk.gpio2_1 */				//v12
+		>;
+	};
+
+	ksz8863_pins: pinmux_ksz8863_pins {
+		pinctrl-single,pins = <
+			0x140 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)   	/* mii1_rxd0.gpio2_21 */		//m16  	Enable
+			0x078 (PIN_INPUT_PULLUP 	| MUX_MODE7)   	                /* mii1_rxd0.gpio1_28 */		//u18	Interrupt
+		>;
+	};
+
+	cpsw_default_pins: pinmux_cpsw_default_pins {// RMII2 Ethernet Switch
+		pinctrl-single,pins = <
+			0x040 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a0.rmii2_txen */		//r13
+            0x050 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a4.rmii2_txd1 */		//r14
+            0x054 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a5.rmii2_txd0 */		//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a10.rmii2_rxd1 */		//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a11.rmii2_rxd0 */		//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_wpn.rmii2_rxer */		//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE1)  	/* mii1_col.rmii2_refclk */		//h16
+            0x088 (PIN_INPUT          	| MUX_MODE2)  	/* gpmc_csn3.rmii2_crs_dv */	//t13
+		>;
+	};
+
+	cpsw_sleep_pins: pinmux_cpsw_sleep_pins {
+		pinctrl-single,pins = <
+			0x040 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a0.gpio1_16 */			//r13
+            0x050 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a4.gpio1_20 */			//r14
+            0x054 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a5.gpio1_21 */			//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a10.gpio1_26 */			//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a11.gpio1_27 */			//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_wpn.gpio0_31 */			//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* mii1_col.gpio3_0 */			//h16
+            0x088 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_csn3.gpio2_0 */			//t13
+		>;
+	};
+
+	gpio_bitbang_mdio_pins: pinmux_gpio_bitbang_mdio_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE7)	/* M17: mdio.gpio0_0 (mdio_data), SLEWCTRL_FAST?? */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE7)			/* M18:  mdc.gpio0_1 (mdio_clk)                   */
+		>;
+	};
+
+	gpio_bitbang_mdio_sleep_pins: pinmux_gpio_bitbang_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mdio.gpio0_0 */				//m17
+			0x14c (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* mdc.gpio0_1   */				//m18
+		>;
+	};
+
+	watchdog_pins: pinmux_watchdog_pins {
+		pinctrl-single,pins = <
+			0x11c (PIN_OUTPUT_PULLDOWN	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd3.gpio0_16 */		//j18	TRIG-WD
+			0x120 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd2.gpio0_17 */		//k15	nEN-WD
+		>;
+	};
+
+	kbus_pins: pinmux_kbus_pins {
+		pinctrl-single,pins = <
+			0x05C (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)    /* gpmc_a7.gpio1_23 */		//t15	NIRQ
+			0x064 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a9.gpio1_25 */		//u16	NRST
+			0x060 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a8.gpio1_24 */		//v16	CMDSEL
+
+			/* Change ERRST3 to nRDY due to HW Limitations of nNMI */
+			0x1b4 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* xdma_event_intr1.gpio0_20 */	//d14	ERRST3-->nRDY
+			0x1C0 (PIN_INPUT_PULLUP 	| MUX_MODE0) 	                /* nnmi */			//b18	NRDY (not used)
+
+			0x058 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* gpmc_a6.gpio1_22 */		//u15	NSYNC
+
+			/* Error Pin */
+			0x110 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_rxerr.gpio3_2 */	//j15	NERR
+
+			/* Error State Pins (not used) */
+			0x114 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_txen.gpio3_3 */		//j16	ERRST0
+			0x118 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* mii1_rxdv.gpio3_4 */		//j17	ERRST1
+			0x1b0 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* xdma_event_intr0.gpio0_19 */	//a15	ERRST2
+		>;
+	};
+
+	gsm_pins: pinmux_gsm_pins {
+		pinctrl-single,pins = <
+			0x04c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a3.gpio1_19 */			//t14	3G-PWR-KEY
+			0x048 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a2.gpio1_18 */			//u14	3G-Reset
+		>;
+	};
+
+	gpio3_pins: pinmux_gpio3_pins {
+		pinctrl-single,pins = <
+			0x194 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_fsx.gpio3_15    */	//b13  	RESET-ALL-BUT
+			0x198 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_axr0.gpio3_16   */	//d12	nRST-BAS
+			0x19c (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_ahclkr.gpio3_17 */	//c12	nSTOP-BAS
+			0x1A0 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_aclkr.gpio3_18  */	//b12  	nRUN-BAS
+			0x1A8 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mcasp0_axr1.gpio3_20 /  */	//d13	nINT-PMIC
+			0x1Ac (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mcasp0_ahclkx.gpio3_21  */	//a14	nINT-RTC
+		>;
+	};
+
+	ecap0_pins: pinmux_ecap0_pins {
+		pinctrl-single,pins = <
+			0x160 (PIN_INPUT | MUX_MODE2)      			/* spi0_cs1.ecap1_in_pwm1_out */ 	//c15  rtc 32kHu capture in
+		>;
+	};
+};
+
+&cppi41dma {
+	status = "okay";
+};
+
+&gpio3 { /* BAS, Button, Interrupt RTC & PMIC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+	spi-rt;
+	spi-rt-prio = <81>;
+
+	kbus0: kbus@0 {	/* KBUS on cs0 */
+		compatible = "wago,spi-kbus";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&kbus_pins>;
+		reg = <0>;
+		spi-max-frequency = <10000000>; /* FIXME */
+		kbus,dma-boost; /* this enables dma boosting */
+		kbus,dma-boost-prio   = <85>;
+		kbus,dma-boost-irq-thread = "irq/19-edma";
+		kbus,dma-default-prio = <50>;
+
+		/*
+		 * announce used tty-device in /sys/class/wago/system.
+		 * is needed to link this device to /dev/ttyKbus
+		 */
+		kbus,tty-device = "ttyO4"; /* corresponds to &uart4*/
+
+
+		/* some should be active low, keep all to high for compatibility reasons */
+		kbus,gpio-nrst   = <&gpio1 25 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nsync  = <&gpio1 22 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-cmdsel = <&gpio1 24 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nirq   = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nerr   = <&gpio3  2 GPIO_ACTIVE_HIGH>;
+
+		kbus,gpio-nrdy   = <&gpio0 20 GPIO_ACTIVE_HIGH>;
+
+	};
+};
+
+&i2c0 {
+        status = "okay";
+        clock-frequency = <400000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&i2c0_pins>;
+
+        pca9552@60 {
+                compatible = "nxp,pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+                reg = <0x60>;
+
+		sys-red@0 {
+		      label = "sys-red";
+		      reg = <0>;
+		      linux,default-trigger = "timer";
+		};
+
+		sys-green@1 {
+		      label = "sys-green";
+		      reg = <1>;
+		      linux,default-trigger = "timer";
+		};
+
+		run-red@2 {
+		      label = "run-red";
+		      reg = <2>;
+		      linux,default-trigger = "none";
+		};
+
+		run-green@3 {
+		      label = "run-green";
+		      reg = <3>;
+		      linux,default-trigger = "none";
+		};
+
+		io-red@4 {
+		      label = "io-red";
+		      reg = <4>;
+		      linux,default-trigger = "none";
+		};
+
+		io-green@5 {
+		      label = "io-green";
+		      reg = <5>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-red@6 {
+		      label = "ms-red";
+		      reg = <6>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-green@7 {
+		      label = "ms-green";
+		      reg = <7>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-red@8 {
+		      label = "ns-red";
+		      reg = <8>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-green@9 {
+		      label = "ns-green";
+		      reg = <9>;
+		      linux,default-trigger = "none";
+		};
+
+		usr-red@10 {
+		      label = "usr-red";
+		      reg = <10>;
+		      linux,default-trigger = "none";
+		};
+
+		usr-green@11 {
+		      label = "usr-green";
+		      reg = <11>;
+		      linux,default-trigger = "none";
+		};
+        };
+
+        at24cs128n {
+                compatible = "atmel,24c512";
+                reg = <0x54>;
+
+		pagesize = <128>;
+        };
+
+        rtc_r2221t {
+                compatible = "ricoh,r2221tl";
+                reg = <0x32>;
+
+		interrupt-parent = <&gpio3>;
+		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;
+        };
+
+
+        tps: tps65218@24 {
+                compatible = "ti,tps65218";
+                reg = <0x24>;
+        };
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default_pins>;
+	pinctrl-1 = <&cpsw_sleep_pins>;
+	mac_control = <0x18021>; /* force 100MBit full-duplex */
+	active_slave = <1>;
+	status = "okay";
+};
+
+&bitbang_mdio0 {
+       status = "okay";
+       pinctrl-names = "default", "sleep";
+       pinctrl-0 = <&gpio_bitbang_mdio_pins>;
+       pinctrl-1 = <&gpio_bitbang_mdio_sleep_pins>;
+       gpios = <&gpio0 1 0	/* 0: mdc  */
+		&gpio0 0 0>;   	/* 1: mdio */
+
+       phy1: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+       };
+
+       phy2: ethernet-phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <2>;
+       };
+};
+
+/*
+ * Use a fixed phy for emac1.
+ * that's rgmii2
+ */
+&cpsw_emac1 {
+	phy-mode = "rmii";
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&phy_sel {
+	rmii-clock-ext;
+};
+
+&tps {
+        interrupts = <47>;
+        interrupt-parent = <&intc>;
+        compatible = "ti,tps65218";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+
+        dcdc1_reg: regulator-dcdc1 {
+                 compatible = "ti,tps65218-dcdc1";
+                /* VDD_CORE +1V1-CORE voltage limits */
+                regulator-name = "vdd_CORE";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc2_reg: regulator-dcdc2 {
+                 compatible = "ti,tps65218-dcdc2";
+                /* VDD_MPU +1V1-MPU voltage limits */
+                regulator-name = "vdd_MPU";
+		regulator-min-microvolt = <912000>;
+		regulator-max-microvolt = <1378000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc3_reg: regulator-dcdc3 {
+                 compatible = "ti,tps65218-dcdc3";
+                /* VDD_DDR +1V5-DDR voltage limits */
+                regulator-name = "vdd_DDR";
+                regulator-min-microvolt = <1500000>;
+                regulator-max-microvolt = <1500000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc4_reg: regulator-dcdc4 {
+                 compatible = "ti,tps65218-dcdc4";
+                /* VDD_LOGIC +3V3 voltage limits */
+                regulator-name = "vdd_LOGIC";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+		/*
+		dcdc1_sw:	dcdcswitch-dcdc1{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_SD +3V3-SD voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-on;
+		*/
+
+		/*
+		dcdc2_sw:	dcdcswitch-dcdc2{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_USB +5V0-USB voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <4750000>;
+                dcdcswitch-max-microvolt = <5250000>;
+                dcdcswitch-boot-off;
+		*/
+
+		/*
+		dcdc3_sw:	dcdcswitch-dcdc3{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_LS +3V3-LS voltage not used in PFC100
+                dcdcswitch-name = "vdd_Last";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-off;
+		*/
+        config2_reg: regulator-config2 {
+                 compatible = "ti,tps65218-config2";
+                /* VDD_Logic current set to 1 Ampere*/
+                regulator-name = "vdd_CONFIG2";
+                regulator-min-microamp = <1000000>;/*TODO*/
+                regulator-max-microamp = <1000000>;/*TODO in drivers/regulator/tps65218-regulator.c */
+                regulator-boot-on;
+                regulator-always-on;
+        };
+        ldo1: regulator-ldo1 {	//VDD-PLL  +1V8
+                compatible = "ti,tps65218-ldo1";
+                regulator-name = "ldo1";
+                regulator-always-on;
+        };
+};
+
+/* do we need this ?? */
+&tscadc {
+	adc {
+		//AIN0 	= +5V0 Local Bus voltage	pmic-in
+		//AIN1	= +3V3  IO system voltage 	dcdc4_reg
+		//AIN2-7	not used
+		ti,adc-channels = <8>;
+	};
+};
+
+/* do we need this ?? */ //optional RTC 32kHz clock in cature
+&epwmss0 {
+	status = "okay";
+
+	ecap0: ecap@48300100 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ecap0_pins>;
+	};
+};
+
+&ocmcram {//???
+	 ti,no_idle_on_suspend;
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&dcdc4_reg>;
+	bus-width = <4>;
+	cd-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>; /* GPIO 116 */
+};
+
+&sham {
+	status = "okay";
+};
+
+&aes {
+	status = "okay";
+};
+
+/include/ "pxc-nandparts.dtsi"
diff --git a/arch/arm/boot/dts/wago-pfc100_mz.dts b/arch/arm/boot/dts/wago-pfc100_mz.dts
new file mode 100644
index 0000000..711f45a
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc100_mz.dts
@@ -0,0 +1,645 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am33xx.dtsi"
+
+/ {
+	model = "WAGO PFC100";
+	compatible = "wago,pac100", "ti,am33xx";
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&dcdc4_reg>;
+		};
+	};
+
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x8000000>; /* 128 MB */
+	};
+
+
+	vxe164_reg: fixedregulator@0 {	//XE164 +3V3  System voltage
+		compatible = "regulator-fixed";
+		regulator-name = "vxe164";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dcdc4_reg>;
+	};
+
+	vsd_reg: fixedregulator@1 {		//SD Card +3V3 Systemvoltage over power switch
+		compatible = "regulator-fixed";
+		regulator-name = "v_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+                vin-supply = <&dcdc4_reg>;
+	};
+
+	nop-phy@0 {
+		compatible = "usb-nop-xceiv";
+	};
+
+	nop-phy@1 {
+		compatible = "usb-nop-xceiv";
+	};
+
+	ksz8863_reset {
+		compatible = "micrel,ksz8863-reset";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		gpio-reset = <&gpio1 28 GPIO_ACTIVE_LOW>;	//gpio1_28 RMII2.nINT-PHY  Input is activ low with extern Pullp
+		reset-switch;
+		status = "okay";
+	};
+};
+
+&uart0 {//debug interface over JTAG Connector
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&elm {	//???
+	status = "okay";
+};
+
+&gpmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+
+	num-cs = <2>;	//only two devices
+	num-waitpins = <1>;
+	status = "okay";
+	ranges = <
+		0 0 0x08000000 0x01000000	/* CS0: NAND */
+		1 0 0x01000000 0x01000000	/* CS1: NnRAM */
+	>;
+
+	nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		elm_id = <&elm>;
+	};
+
+	nvram@1,0 {
+		reg = <1 0 0>;
+		/* GPMC_CONFIG1_1 */
+		gpmc,sync-clk = <0>;
+		gpmc,wait-on-read = "false";
+		gpmc,wait-on-write = "false";
+		/* nvram-bus-width = <16>; */
+		gpmc,device-nor = "true";
+		gpmc,device-width = <2>; /* 1: 8bit, 2: 16bit */
+
+		/* GPMC_CONFIG2_1 */
+		gpmc,cs-wr-off = <21>;
+		gpmc,cs-rd-off = <30>; /* ns */
+		gpmc,cd-delay = <0>;
+		gpmc,cs-on = <0>;
+
+		/* GPMC_CONFG3_1 */
+		gpmc,adv-wr-off = <0>;
+		gpmc,adv-rd-off = <0>;
+		gpmc,adv-on = <0>;
+		gpmc,adv-delay = <0>;
+
+		/* GPMC_CONFIG4_1 */
+		gpmc,we-off = <21>;
+		gpmc,we-delay = <0>;
+		gpmc,we-on = <0>;
+		gpmc,oe-off = <30>;
+		gpmc,oe-delay = <0>;
+		gpmc,oe-on = <13>;
+
+		/* GPMC_CONFIG5_1 */
+		gpmc,rd-access = <25>;
+		gpmc,wr-cycle = <26>;
+		gpmc,rd-cycle = <30>;
+
+		/* GPMC_CONFIG6_1 */
+		gpmc,wr-access = <9>;
+		gpmc,wr-data-mux-bus = <0>;
+		gpmc,cycl-delay = <10>;
+		gpmc,cycl2same = <1>;
+		gpmc,cycl2diff = <1>;
+
+	};
+};
+
+/* for pin mux offset calc: doc_offset - 0x800h = dts-offset */
+&am33xx_pinmux {
+
+	uart0_pins: pinmux_uart0_pins {//debug interface over JTAG Connector
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP		| MUX_MODE0)  	/* uart0_rxd.uart0_rxd */ 		//e15
+			0x174 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)  	/* uart0_txd.uart0_txd */		//e16
+		>;
+	};
+
+	uart1_rs_pins: pinmux_uart1_rs_pins {//optional uart1 rs232/485
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT 			| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_txd.uart1_txd */		//d15
+			0x180 (PIN_INPUT 			| MUX_MODE0)	/* uart1_rxd.uart1_rxd */		//d16
+			0x178 (PIN_INPUT 			| MUX_MODE0)	/* uart1_ctsn.uart1_ctsn */		//d18
+			0x17C (PIN_OUTPUT 			| SLEWCTRL_SLOW	| MUX_MODE0)	/* uart1_rtsn.uart1_rtsn */		//d17
+			0x17C (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mcasp0_fsr.gpio3_19 */		//c13   rs232/ 485 select
+		>;
+	};
+
+	uart1_dip_pins: pinmux_uart1_dip_pins {//optional uart1 with dip switch
+		pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_txd.gpio0_15 */		//d15
+			0x180 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* uart1_rxd.gpio0_14 */		//d16
+			0x17C (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)	/* uart1_rtsn.gpio0_13 */		//d17
+			//is not used in this configuration
+			0x178 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* uart1_ctsn.gpio0_12 */		//d18
+			0x17C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* mcasp0_fsr.gpio3_19 */		//c13
+		>;
+	};
+
+	uart1_dcan0_pins: pinmux_uart1_dcan0_pins {// optional over uart1 cts[d18]=can-tx and rts[d17]=can-rx
+		 pinctrl-single,pins = <
+			0x178 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE2)	/* uart1_ctsn.dcan0_tx */		//d18
+			0x17C (PIN_INPUT_PULLDOWN 	| MUX_MODE2)	/* uart1_rtsn.dcan0_rx */		//d17
+			//is not used in this configuration
+			0x184 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* uart1_txd.gpio0_15 */		//d15
+			0x180 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* uart1_rxd.gpio0_14 */		//d16
+			0x17C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* mcasp0_fsr.gpio3_19 */		//c13
+		 >;
+	};
+
+	uart1_dps_pins: pinmux_uart1_dps_pins {// optional over uart1 txd[d15] = profibus-tx and rxd[d16] = profibus-rx and [c13] = profibus-rts if cpu with PRU
+		 pinctrl-single,pins = <
+			0x184 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE5)	/* uart1_txd.pr1_uart0_txd */		//d15
+			0x180 (PIN_INPUT_PULLDOWN 	| MUX_MODE5)	/* uart1_rxd.pr1_uart0_rxd */		//d16
+			0x17C (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE5)	/* mcasp0_fsr.pr1_pru0_pru_r30_5 */	//c13
+			//is not used in this configuration
+			0x178 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* uart1_ctsn.dcan0_tx */			//d18
+			0x17C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* uart1_rtsn.dcan0_rx */			//d17
+		 >;
+	};
+
+	uart4_pins: pinmux_uart4_pins {// KBUS firmware download
+		 pinctrl-single,pins = <
+			0x168 (PIN_INPUT_PULLUP		| MUX_MODE1)  	/* uart0_ctsn.uart4_rxd */ 		//e18
+			0x16c (PIN_OUTPUT_PULLUP	|SLEWCTRL_SLOW	| MUX_MODE1)  	/* uart0_rtsn.uart4_txd */		//e17
+		 >;
+	};
+
+	/* htoews: Kann weggelassen werden */
+	usb1_pins: pinmux_usb1_pins { /* USB-HOST for GSM Achtung!!! PADCOFIG REGISTER von USB0*/
+		pinctrl-single,pins = <
+			0x208 (PIN_INPUT 			| MUX_MODE0)	/* usb0_dm */		//r18
+			0x20c (PIN_INPUT 			| MUX_MODE0)	/* usb0_dp */		//r17
+			0x210 (PIN_INPUT_PULLDOWN	| MUX_MODE0)	/* usb0_ce */		//p18
+			0x214 (PIN_INPUT 			| MUX_MODE0)	/* usb0_id */		//P17
+			0x218 (PIN_INPUT			| MUX_MODE0)	/* usb0_vbus */		//t18
+			0x21c (PIN_OUTPUT_PULLDOWN	| MUX_MODE0)	/* usb0_drvvbus*/	//f15
+		>;
+	};
+
+	spi0_pins: pinmux_spi0_pins {// for KBUS communication
+		pinctrl-single,pins = <
+			0x150 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_sclk.spio_sclk*/ 	//a17
+			0x154 (PIN_INPUT_PULLUP		| MUX_MODE0)	/* spi0_d0.spi0.d0 */		//b17 miso
+			0x158 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_d1spi0.d1 */		//b16 mosi
+			0x15c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_cs0.spi0_cs0 */		//a16 cs
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins {//PMIC, RTC, LED-Expander, EEPROM
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_sda.i2c0_sda */		//c17
+			0x18c (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_scl.i2c0_scl */		//c16
+		>;
+	};
+
+	 mmc1_pins: pinmux_mmc1_pins {//SD on MMC0  why mmc1???
+		 pinctrl-single,pins = <
+			0x104 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_cmd.mmc0_cmd   */	//g18
+			0x100 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_clk.mmc0_clk   */	//g17
+			0x0fc (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat0.mmc0_dat0 */	//g16
+			0x0f8 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat1.mmc0_dat1 */	//g15
+			0x0f4 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat2.mmc0_dat2 */	//f18
+			0x0f0 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat3.mmc0_dat3 */	//f17
+			0x190 (PIN_INPUT_PULLUP 	| MUX_MODE4)  	/* mcasp0_aclkx.mmc0_sdcd *///a13
+		 >;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins { // 16x data and 19x address and 8x control   // NAND 8-bit on cs0   and NvRAM 16-bit on cs1
+		pinctrl-single,pins = <
+			//data
+			0x000 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad0.gpmc_ad0 */		//u7
+			0x004 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad1.gpmc_ad1 */		//v7
+			0x008 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad2.gpmc_ad2 */		//r8
+			0x00c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad3.gpmc_ad3 */		//t8
+			0x010 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad4.gpmc_ad4 */		//u8
+			0x014 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad5.gpmc_ad5 */		//v8
+			0x018 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad6.gpmc_ad6 */		//r9
+			0x01c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad7.gpmc_ad7 */		//t9
+			0x020 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad8.gpmc_ad8 */		//u10
+			0x024 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad9.gpmc_ad9 */		//t10
+			0x028 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad10.gpmc_ad10 */	//t11
+			0x02c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad11.gpmc_ad11 */	//u12
+			0x030 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad12.gpmc_ad12 */	//t12
+			0x034 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad13.gpmc_ad13 */	//r12
+			0x038 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad14.gpmc_ad14 */	//v13
+			0x03c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad15.gpmc_ad15 */	//u13
+			//address
+			0x0A0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data0.gpmc_a0 */		//r1
+			0x0A4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data1.gpmc_a1 */		//r2
+			0x0A8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data2.gpmc_a2 */		//r3
+			0x0AC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data3.gpmc_a3 */		//r4
+			0x0B0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data4.gpmc_a4 */		//t1
+			0x0B4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data5.gpmc_a5 */		//t2
+			0x0B8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data6.gpmc_a6 */		//t3
+			0x0BC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data7.gpmc_a7 */		//t4
+			0x0E0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_vsync.gpmc_a8 */		//u5
+			0x0E4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_hsync.gpmc_a9 */		//r5
+			0x0E8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_pclk.gpmc_a10 */		//v5
+			0x0EC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_ac_bias_en.gpmc_a11 *///r6
+			0x0C0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data8.gpmc_a12 */	//u1
+			0x0C4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data9.gpmc_a13 */	//u2
+			0x0C8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data10.gpmc_a14 */	//u3
+			0x0CC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data11.gpmc_a15 */	//u4
+			0x0D0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data12.gpmc_a16 */	//v2
+			0x0D4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data13.gpmc_a17 */	//v3
+			0x0D8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data14.gpmc_a18 */	//v4
+			0x0DC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data15.gpmc_a19 */	//t5
+			//control
+			0x09c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ben0_cle.gpmc_be0n_cle */	//t6
+			0x090 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_advn_ale.gpmc_advn_ale */	//r7
+			0x094 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_oen_ren.gpmc_oen_ren */		//t7
+			0x098 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_wen.gpmc_wen */				//u6
+			0x07c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn0.gpmc_csn0 */			//v6
+			0x080 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn1.gpmc_csn1 */			//u9
+			0x084 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE1)	/* gpmc_csn2.gpmc_be1n */			//v9
+			0x070 (PIN_INPUT_PULLUP	 	| MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */			//t17
+			0x08C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* gpmc_clk.gpio2_1 */				//v12
+		>;
+	};
+
+	ksz8863_pins: pinmux_ksz8863_pins {
+		pinctrl-single,pins = <
+			0x140 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)   	/* mii1_rxd0.gpio2_21 */		//m16  	Enable
+			0x078 (PIN_INPUT_PULLUP 	| MUX_MODE7)   	/* mii1_rxd0.gpio1_28 */		//u18	Interrupt
+		>;
+	};
+
+	cpsw_default_pins: pinmux_cpsw_default_pins {// RMII2 Ethernet Switch
+		pinctrl-single,pins = <
+			0x040 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a0.rmii2_txen */		//r13
+            0x050 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a4.rmii2_txd1 */		//r14
+            0x054 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a5.rmii2_txd0 */		//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a10.rmii2_rxd1 */		//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a11.rmii2_rxd0 */		//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_wpn.rmii2_rxer */		//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE1)  	/* mii1_col.rmii2_refclk */		//h16
+            0x088 (PIN_INPUT          	| MUX_MODE2)  	/* gpmc_csn3.rmii2_crs_dv */	//t13
+		>;
+	};
+
+	cpsw_sleep_pins: pinmux_cpsw_sleep_pins {
+		pinctrl-single,pins = <
+			0x040 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a0.gpio1_16 */			//r13
+            0x050 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a4.gpio1_20 */			//r14
+            0x054 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a5.gpio1_21 */			//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a10.gpio1_26 */			//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a11.gpio1_27 */			//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_wpn.gpio0_31 */			//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* mii1_col.gpio3_0 */			//h16
+            0x088 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_csn3.gpio2_0 */			//t13
+		>;
+	};
+
+	davinci_mdio_default_pins: pinmux_davinci_mdio_default_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* mdio.mdio_data */			//m17
+			0x14c (PIN_INPUT_PULLUP 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* mdc.mdio_clk   */			//m18  (clock default output !)
+		>;
+	};
+
+	davinci_mdio_sleep_pins: pinmux_davinci_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mdio.gpio0_0 */				//m17
+			0x14c (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* mdc.gpio0_1   */				//m18
+		>;
+	};
+
+	wdg_pins: pinmux_wdg_pins {
+		pinctrl-single,pins = <
+			0x11c (PIN_OUTPUT_PULLDOWN	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd3.gpio0_16 */		//j18	TRIG-WD
+			0x120 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)	/* mii1_txd2.gpio0_17 */		//k15	nEN-WD
+		>;
+	};
+
+	kbus_pins: pinmux_kbus_pins {
+		pinctrl-single,pins = <
+			0x1C0 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* nnmi*/						//b18	NRDY
+			0x05C (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* gpmc_a7.gpio1_23 */			//t15	NIRQ
+			0x064 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a9.gpio1_25 */			//u16	NRST
+			0x060 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a8.gpio1_24 */			//v16	CMDSEL
+			0x058 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a6.gpio1_22 */			//u15	NSYNC
+			0x1b0 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* xdma_event_intr0.gpio0_19 */	//a15	ERRST2
+			0x1b4 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* xdma_event_intr1.gpio0_20 */	//d14	ERRST3
+			0x114 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mii1_txen.gpio3_3 */			//j16	ERRST0
+			0x118 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mii1_rxdv.gpio3_4 */			//j17	ERRST1
+			0x110 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mii1_rxerr.gpio3_2 */		//j15	NERR
+		>;
+	};
+
+	gsm_pins: pinmux_gsm_pins {
+		pinctrl-single,pins = <
+			0x04c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a3.gpio1_19 */			//t14	3G-PWR-KEY
+			0x048 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a2.gpio1_18 */			//u14	3G-Reset
+		>;
+	};
+
+	gpio3_pins: pinmux_gpio3_pins {
+		pinctrl-single,pins = <
+			0x198 (PIN_INPUT 			| MUX_MODE7) 	/* mcasp0_axr0.gpio3_16 /  */	//d12	nRST-BAS
+			0x19c (PIN_INPUT 			| MUX_MODE7) 	/* mcasp0_ahclkr.gpio3_17*/		//c12	nSTOP-BAS
+			0x1A0 (PIN_INPUT 			| MUX_MODE7) 	/* mcasp0_aclkr.gpio3_18 */		//b12  	nRUN-BAS
+			0x194 (PIN_INPUT 			| MUX_MODE7) 	/* mcasp0_fsx.gpio3_15 */		//b13  	RESET-ALL-BUT
+			0x1A8 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mcasp0_axr1.gpio3_20 /  */	//d13	nINT-PMIC
+			0x1Ac (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mcasp0_ahclkx.gpio3_21  */	//a14	nINT-RTC
+		>;
+	};
+
+	ecap0_pins: pinmux_ecap0_pins {
+		pinctrl-single,pins = <
+			0x160 (PIN_INPUT | MUX_MODE2)      			/* spi0_cs1.ecap1_in_pwm1_out */ 	//c15  rtc 32kHu capture in
+		>;
+	};
+
+};
+
+&usb {
+	status = "okay";
+	pinctrl-0 = <&usb1_pins>;
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+&usb1 { /* usb0 - OTG */
+	status = "okay";
+};
+
+&cppi41dma {	//???????????
+	status = "okay";
+};
+
+&dcan0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&dcan0_pins>;
+};
+
+&gpio3 {	//BAS, Button, Interrupt RTC & PMIC
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+
+	spi0_0: spidev@0 {	//KBUS on cs0
+		compatible = "spidev";
+		reg = <0>;
+		spi-max-frequency = <10000000>; // FIXME
+	};
+
+};
+
+&i2c0 {
+        status = "okay";
+        clock-frequency = <400000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&i2c0_pins>;
+
+        pca9552BS@60 {
+                compatible = "nxp,pca955x";
+                reg = <0x60>;
+        };
+
+        at24cs128n {
+                compatible = "atmel,24c128";
+                reg = <0x54>;
+        };
+
+        rtc_r2221t {
+                compatible = "ricoh,r2221tl";
+                reg = <0x32>;
+        };
+
+        tps: tps65218@24 {
+                compatible = "ti,tps65218";
+                reg = <0x24>;
+        };
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default_pins>;
+	pinctrl-1 = <&cpsw_sleep_pins>;
+	mac_control = <0x18021>; /* force 100MBit full-duplex */
+	active_slave = <1>;
+};
+
+&davinci_mdio {
+	pinctrl-names = "default";
+	pinctrl-0 = <&davinci_mdio_default_pins>;
+	pinctrl-1 = <&davinci_mdio_sleep_pins>;
+};
+
+/* This is a workaround.
+ * PHY_ID 1 of KSZ8863 is port 1 and is bound to the emac0 interface.
+ * If port 1 gets down due to an unplugged cable and port 2 gets up
+ * the interface emac0 will be disabled. We have only a 1:1 relation here.
+ * drivers/net/ethernet/ti/cpsw.c was changed to ignore phy->link adjustment
+ */
+&cpsw_emac0 {
+	phy_id = <&davinci_mdio>, <1>;
+	phy-mode = "rmii";
+};
+
+&cpsw_emac1 {
+	phy_id = <&davinci_mdio>, <2>;
+	phy-mode = "rmii";
+};
+
+&phy_sel {
+	rmii-clock-ext;
+};
+
+&tps {
+        interrupts = <47>;
+        interrupt-parent = <&intc>;
+        compatible = "ti,tps65218";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+
+        dcdc1_reg: regulator-dcdc1 {
+                 compatible = "ti,tps65218-dcdc1";
+                /* VDD_CORE +1V1-CORE voltage limits */
+                regulator-name = "vdd_CORE";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc2_reg: regulator-dcdc2 {
+                 compatible = "ti,tps65218-dcdc2";
+                /* VDD_MPU +1V1-MPU voltage limits */
+                regulator-name = "vdd_MPU";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc3_reg: regulator-dcdc3 {
+                 compatible = "ti,tps65218-dcdc3";
+                /* VDD_DDR +1V5-DDR voltage limits */
+                regulator-name = "vdd_DDR";
+                regulator-min-microvolt = <1500000>;
+                regulator-max-microvolt = <1500000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc4_reg: regulator-dcdc4 {
+                 compatible = "ti,tps65218-dcdc4";
+                /* VDD_LOGIC +3V3 voltage limits */
+                regulator-name = "vdd_LOGIC";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+		/*
+		dcdc1_sw:	dcdcswitch-dcdc1{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_SD +3V3-SD voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-on;
+		*/
+
+		/*
+		dcdc2_sw:	dcdcswitch-dcdc2{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_USB +5V0-USB voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <4750000>;
+                dcdcswitch-max-microvolt = <5250000>;
+                dcdcswitch-boot-off;
+		*/
+
+		/*
+		dcdc3_sw:	dcdcswitch-dcdc3{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_LS +3V3-LS voltage not used in PFC100
+                dcdcswitch-name = "vdd_Last";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-off;
+		*/
+        config2_reg: regulator-config2 {
+                 compatible = "ti,tps65218-config2";
+                /* VDD_Logic current set to 1 Ampere*/
+                regulator-name = "vdd_CONFIG2";
+                regulator-min-microamp = <1000000>;/*TODO*/
+                regulator-max-microamp = <1000000>;/*TODO in drivers/regulator/tps65218-regulator.c */
+                regulator-boot-on;
+                regulator-always-on;
+        };
+        ldo1: regulator-ldo1 {	//VDD-PLL  +1V8
+                compatible = "ti,tps65218-ldo1";
+                regulator-name = "ldo1";
+                regulator-always-on;
+        };
+};
+
+/* do we need this ?? */
+&tscadc {
+	adc {
+		//AIN0 	= +5V0 Local Bus voltage	pmic-in
+		//AIN1	= +3V3  IO system voltage 	dcdc4_reg
+		//AIN2-7	not used
+		ti,adc-channels = <8>;
+	};
+};
+
+/* do we need this ?? */ //optional RTC 32kHz clock in cature
+&epwmss0 {
+	status = "okay";
+
+	ecap0: ecap@48300100 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ecap0_pins>;
+	};
+};
+
+&ocmcram {//???
+	 ti,no_idle_on_suspend;
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&dcdc4_reg>;
+	/* cd-gpios = <&gpio3 14 GPIO_ACTIVE_LOW>; */
+	bus-width = <4>;
+	/* ti,vcc-aux-disable-is-sleep; */
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-can.dtsi b/arch/arm/boot/dts/wago-pfc200-can.dtsi
new file mode 100644
index 0000000..1209f01
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-can.dtsi
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&omap3_pmx_core {
+        can_pins: pinmux_can_pins {
+		pinctrl-single,pins = <
+			/* CAN-LEDs */
+			0x154 (PIN_OUTPUT | MUX_MODE4)		          /* McBSP4_CLKX   -> CAN-RUN_green     GPIO_152 */
+			0x156 (PIN_OUTPUT | MUX_MODE4)		          /* McBSP4_DR     -> CAN-RUN_red       GPIO_153 */
+			0x158 (PIN_OUTPUT | MUX_MODE4)		          /* McBSP4_DX     -> CAN-ERR_green     GPIO_154 */
+			0x15a (PIN_OUTPUT | MUX_MODE4)		          /* McBSP4_FSX    -> CAN-ERR_red       GPIO_155 */
+			0x15c (PIN_OUTPUT | MUX_MODE4)		          /* McBSP1_CLKR   -> CAN-TX_green      GPIO_156 */
+			0x15e (PIN_OUTPUT | MUX_MODE4)		          /* McBSP1_FSR    -> CAN-TX_red        GPIO_157 */
+			0x160 (PIN_OUTPUT | MUX_MODE4)		          /* McBSP1_DX     -> CAN-RX_green      GPIO_158 */
+			0x162 (PIN_OUTPUT | MUX_MODE4)		          /* McBSP1_DR     -> CAN-RX_red        GPIO_159 */
+
+			/* CAN */
+			0x1e4 (PIN_OUTPUT | MUX_MODE0)		          /* HECC1_TXD     -> CAN_TxD */
+			0x1e6 (PIN_INPUT | MUX_MODE0)		          /* HECC1_RXD     -> CAN_RxD */
+		>;
+	};
+};
+
+&ti_hecc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&can_pins>;
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-devconf-000a.dts b/arch/arm/boot/dts/wago-pfc200-devconf-000a.dts
new file mode 100644
index 0000000..18639e6
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-devconf-000a.dts
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200.dtsi"
+#include "wago-pfc200-can.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x000A
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  x  |  x
+ *                                             |     CAN
+ *                                             |
+ *                                             ETHERNET_IP
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  |  |  |  |  PROFIBUS_SL
+ *                                       |  |  |  |  CAN
+ *                                       |  |  |  RS232_485
+ *                                       |  |  ETHERNET_IP
+ *                                       |  3G_MODEM
+ *					 DIP_SWITCH
+ *   x: reserved for future use
+ *
+ */
+
+&u7_g {
+	label = "can-green";
+	gpios = <&gpio3 24 0>;
+	linux,default-trigger = "none";
+};
+
+&u7_r {
+	label = "can-red";
+	gpios = <&gpio3 25 0>;
+	linux,default-trigger = "none";
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-devconf-000c.dts b/arch/arm/boot/dts/wago-pfc200-devconf-000c.dts
new file mode 100644
index 0000000..73f8bd6
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-devconf-000c.dts
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you u7 redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200.dtsi"
+#include "wago-pfc200-uart1.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x000C
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  x  x
+ *                                             |  |
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  |  |  |  |  PROFIBUS_SL
+ *                                       |  |  |  |  CAN
+ *                                       |  |  |  RS232_485
+ *                                       |  |  ETHERNET_IP
+ *                                       |  3G_MODEM
+ *					 DIP_SWITCH
+ *   x: reserved for future use
+ *
+ */
diff --git a/arch/arm/boot/dts/wago-pfc200-devconf-000e.dts b/arch/arm/boot/dts/wago-pfc200-devconf-000e.dts
new file mode 100644
index 0000000..ed54de1
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-devconf-000e.dts
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200.dtsi"
+#include "wago-pfc200-uart1.dtsi"
+#include "wago-pfc200-can.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x000E
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  |  x
+ *                                             |  |  CAN
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  |  |  |  |  PROFIBUS_SL
+ *                                       |  |  |  |  CAN
+ *                                       |  |  |  RS232_485
+ *                                       |  |  ETHERNET_IP
+ *                                       |  3G_MODEM
+ *					 DIP_SWITCH
+ *   x: reserved for future use
+ *
+ */
+
+&u7_g {
+	label = "can-green";
+	gpios = <&gpio3 24 0>;
+	linux,default-trigger = "none";
+};
+
+&u7_r {
+	label = "can-red";
+	gpios = <&gpio3 25 0>;
+	linux,default-trigger = "none";
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-devconf-000f.dts b/arch/arm/boot/dts/wago-pfc200-devconf-000f.dts
new file mode 100644
index 0000000..f4e5e17
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-devconf-000f.dts
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200.dtsi"
+#include "wago-pfc200-uart1.dtsi"
+#include "wago-pfc200-can.dtsi"
+#include "wago-pfc200-dpc31.dtsi"
+#include "wago-pfc200-musb.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x000F
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  |  PROFIBUS_SL
+ *                                             |  |  CAN
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  |  |  |  |  PROFIBUS_SL
+ *                                       |  |  |  |  CAN
+ *                                       |  |  |  RS232_485
+ *                                       |  |  ETHERNET_IP
+ *                                       |  3G_MODEM
+ *					 DIP_SWITCH
+ *   x: reserved for future use
+ *
+ */
+
+&u6_g {
+	label = "bf-green";
+	gpios = <&gpio3 2 0>;
+	linux,default-trigger = "none";
+};
+
+&u6_r {
+	label = "bf-red";
+	gpios = <&gpio3 3 0>;
+	linux,default-trigger = "none";
+};
+
+&u5_g {
+	label = "dia-green";
+	gpios = <&gpio3 6 0>;
+	linux,default-trigger = "none";
+};
+
+&u5_r {
+	label = "dia-red";
+	gpios = <&gpio3 7 0>;
+	linux,default-trigger = "none";
+};
+
+
+&u7_g {
+	label = "can-green";
+	gpios = <&gpio3 24 0>;
+	linux,default-trigger = "none";
+};
+
+&u7_r {
+	label = "can-red";
+	gpios = <&gpio3 25 0>;
+	linux,default-trigger = "none";
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-devconf-001c.dts b/arch/arm/boot/dts/wago-pfc200-devconf-001c.dts
new file mode 100644
index 0000000..838e0d6
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-devconf-001c.dts
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you u7 redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200.dtsi"
+#include "wago-pfc200-uart1.dtsi"
+#include "wago-pfc200-musb.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x001C
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  |  |  |  x  x
+ *                                          |  |  |
+ *                                          |  |  RS232_485
+ *                                          |  ETHERNET_IP
+ *                                          3G_MODEM
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  |  |  |  |  |  PROFIBUS_SL
+ *                                       |  |  |  |  CAN
+ *                                       |  |  |  RS232_485
+ *                                       |  |  ETHERNET_IP
+ *                                       |  3G_MODEM
+ *					 DIP_SWITCH
+ *   x: reserved for future use
+ *
+ */
+
+&u7_g {
+	label = "usr-green";
+	gpios = <&gpio3 24 0>;
+	linux,default-trigger = "none";
+};
+
+&u7_r {
+	label = "usr-red";
+	gpios = <&gpio3 25 0>;
+	linux,default-trigger = "none";
+};
+
+&u1_g {
+	label = "net-green";
+	gpios = <&gpio3 22 0>;
+	linux,default-trigger = "none";
+};
+&u1_r {
+	label = "net-red";
+	gpios = <&gpio3 23 0>;
+	linux,default-trigger = "none";
+};
+
+&u2_g {
+        label = "s1-green";
+        gpios = <&gpio3 18 0>;
+        linux,default-trigger = "none";
+};
+
+&u2_r {
+        label = "s1-red";
+        gpios = <&gpio3 19 0>;
+        linux,default-trigger = "none";
+};
+
+&u3_g {
+        label = "s2-green";
+        gpios = <&gpio3 14 0>;
+        linux,default-trigger = "none";
+};
+
+&u3_r {
+        label = "s2-red";
+        gpios = <&gpio3 15 0>;
+        linux,default-trigger = "none";
+};
+
+&u4_g {
+        label = "s3-green";
+        gpios = <&gpio3 10 0>;
+        linux,default-trigger = "none";
+};
+
+&u4_r {
+        label = "s3-red";
+        gpios = <&gpio3 11 0>;
+        linux,default-trigger = "none";
+};
+
+&u5_g {
+        label = "s4-green";
+        gpios = <&gpio3 6 0>;
+        linux,default-trigger = "none";
+};
+
+&u5_r {
+        label = "s4-red";
+        gpios = <&gpio3 7 0>;
+        linux,default-trigger = "none";
+};
+
+&u6_g {
+        label = "s5-green";
+        gpios = <&gpio3 2 0>;
+        linux,default-trigger = "none";
+        };
+
+&u6_r {
+        label = "s5-red";
+        gpios = <&gpio3 3 0>;
+        linux,default-trigger = "none";
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-devconf-004e.dts b/arch/arm/boot/dts/wago-pfc200-devconf-004e.dts
new file mode 100644
index 0000000..c11c99b
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-devconf-004e.dts
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200v2.dtsi"
+#include "wago-pfc100-uart1.dtsi"
+#include "wago-pfc200v2-netx.dtsi"
+#include "wago-pfc200v2-dcan.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x004E
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  |  x  x  |  |  |  x
+ *                                    |        |  |  CAN
+ *                                    |        |  RS232_485
+ *                                    |        ETHERNET_IP
+ *                                    PROFIBUS_DPM
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  |  |  |  |  |  |  PROFIBUS_SL
+ *                                    |  |  |  |  |  CAN
+ *                                    |  |  |  |  RS232_485
+ *                                    |  |  |  ETHERNET_IP
+ *                                    |  |  3G_MODEM
+ *				      |	 DIP_SWITCH
+ *                                    PROFIBUS_DPM
+ *
+ *   x: reserved for future use
+ *
+ */
diff --git a/arch/arm/boot/dts/wago-pfc200-dpc31.dtsi b/arch/arm/boot/dts/wago-pfc200-dpc31.dtsi
new file mode 100644
index 0000000..526f496
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-dpc31.dtsi
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	/* dpc31 is on cs1 */
+	UIO_DPC31_XINT@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x1000000 0x4000>; /* 8k * 2 = 16k, needed because of 16Bit addressing */
+		interrupt-parent = <&gpio3>;
+		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;	/* gpio3_1 / gpio_65 */
+	};
+
+	UIO_DPC31_SYNC@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		interrupt-parent = <&gpio6>;
+		interrupts = <1 IRQ_TYPE_EDGE_RISING>;	/* gpio6_1 / gpio_161 */
+	};
+
+	UIO_DPC31_DXOUT@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		interrupt-parent = <&gpio6>;
+		interrupts = <0 IRQ_TYPE_EDGE_RISING>;	/* gpio6_0 / gpio_160 */
+	};
+};
+
+&omap3_pmx_core {
+        dpc31_pins: pinmux_dpc31_pins {
+		pinctrl-single,pins = <
+		  /* gpmc */
+		  // OMAP3_CORE1_IOPAD(0x20b0, PIN_OUTPUT | MUX_MODE4) /* gpmc_ncs1.gpmc_ncs1     -> GPMC-nCS1-FB */
+		  // OMAP3_CORE1_IOPAD(0x20ce, PIN_INPUT | MUX_MODE0)  /* gpmc_wait1.gpmc_wait1 -> GPMC-WAIT1-DPC31 */
+		  /* gpios */
+		  OMAP3_CORE1_IOPAD(0x20D2, PIN_INPUT | MUX_MODE4)  /* gpmc_wait3.gpio3_1    -> SYS_nDMAREQ1
+	                                                             * GPIO Interrupt (GPIO_65): DCP31 XINT (PG5)
+	                                                             * Also useable for DMA transfers.
+	                                                             */
+		  OMAP3_CORE1_IOPAD(0x2194, PIN_INPUT | MUX_MODE4)  /* mcbsp_clks.gpio6_0    -> FB-EEPROM-LOADED (= DPC31_DXCH)
+	                                                             * GPIO Interrupt (GPIO_160): DPC31_DXCH, DCP31 IRR14 (PB3)
+	                                                             * Active on new output data ... (optional)
+	                                                             */
+		  OMAP3_CORE1_IOPAD(0x2196, PIN_OUTPUT | MUX_MODE4) /* mcbsp1_fsx.gpio6_1    -> FB-nSYNC (= DPC31_SYNC)
+	                                                             * GPIO Interrupt (GPIO_161): DPC31_SYNC, DCP31 RES (PB2)
+	                                                             * Fieldbus Sync Signal (optional)
+	                                                             */
+		  OMAP3_CORE1_IOPAD(0x2198, PIN_OUTPUT | MUX_MODE4) /* mcbsp1_clkx.gpio6_2   -> FB-nRST (= nExt_RESET) --> GPIO_162 */
+		>;
+	};
+};
+
+/* #define PAC200_DPC31_GPIO__INT_SYS_NDMAREQ1        65: gpio3_1 */
+/* #define PAC200_DPC31_GPIO__INT_DXCH               160: gpio6_0 */
+/* #define PAC200_DPC31_GPIO__INT_FB_NSYNC           161: gpio6_1 */
+/* #define PAC200_DPC31_GPIO__RESET                  162: gpio6_2 */
+
+&wsysinit {
+	pinctrl-names = "default";
+	pinctrl-0 = <&dpc31_pins>;
+
+	dp,reset;
+	dp,gpio-rst = <&gpio6 2 GPIO_ACTIVE_HIGH>; /* dpc31 reset */
+};
+
+&gpmc {
+        dpc31: nor@1,0 {
+		reg = <1 0 0x1000000>; /* 8k * 2 = 16k, needed because of 16Bit addressing
+					* minimum is 16M - set it here */
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+
+		gpmc,cs-on-ns = <42>;
+		gpmc,cs-rd-off-ns = <144>;
+		gpmc,cs-wr-off-ns = <144>;
+
+		gpmc,adv-on-ns = <12>;
+		gpmc,adv-rd-off-ns = <156>;
+		gpmc,adv-wr-off-ns = <156>;
+
+		gpmc,oe-on-ns = <42>;
+		gpmc,oe-off-ns = <144>;
+
+		gpmc,we-on-ns = <42>;
+		gpmc,we-off-ns = <114>;
+
+		gpmc,rd-cycle-ns = <168>;
+		gpmc,wr-cycle-ns = <168>;
+
+		gpmc,access-ns = <150>;
+		gpmc,wr-access-ns = <54>;
+
+		gpmc,wr-data-mux-bus-ns = <18>;
+
+		gpmc,cycle2cycle-delay-ns = <0>;
+
+		gpmc,time-para-granularity;
+		gpmc,mux-add-data = <2>; /* address-data multiplexing mode */
+
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+
+		gpmc,wait-pin = <1>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-musb.dtsi b/arch/arm/boot/dts/wago-pfc200-musb.dtsi
new file mode 100644
index 0000000..609a527
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-musb.dtsi
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&omap3_pmx_core {
+        usb_otg_pins: pinmux_usb_otg_pins {
+		pinctrl-single,pins = <
+			/* USB OTG Mux Config */
+			0x1e2 (PIN_INPUT_PULLDOWN | MUX_MODE0)  /* usb0_drvvbus.usb0_drvvbus */
+			0x128 (PIN_OUTPUT | MUX_MODE4)          /* mmc2_clk.gpio5_2 - gpio_130: 3G Modem Reset */
+			0x12c (PIN_OUTPUT | MUX_MODE4)          /* mmc2_dat0.gpio5_4 - gpio_132: 3G Modem Power */
+		>;
+	};
+};
+
+/*
+ * To manually drive usb0_drvbus pin use the gpio setting below
+ *
+ * pinctrl:
+ *     0x1e2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  // usb0_drvvbus.gpio_125
+ *
+ * &wsysinit {
+ *      // assert gpio during boot
+ *	musb,drvvbus-gpio = <&gpio4 29 GPIO_ACTIVE_HIGH>;
+ * };
+ *
+ */
+
+&am35x_otg_hs {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&usb_otg_pins>;
+
+	multipoint = <1>;
+	num-eps = <16>;
+	ram-bits = <12>;
+
+	interface-type = <0>; 	/* ULPI */
+	mode = <1>;		/* HOST Mode */
+	power = <250>;		/* can supply 100mA when operating in host mode */
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-setupfw.dts b/arch/arm/boot/dts/wago-pfc200-setupfw.dts
new file mode 100644
index 0000000..a767794
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-setupfw.dts
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200.dtsi"
+#include "wago-pfc200-uart1.dtsi"
+#include "wago-pfc200-can.dtsi"
+#include "wago-pfc200-dpc31.dtsi"
+#include "wago-pfc200-musb.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x000F
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  |  PROFIBUS_SL
+ *                                             |  |  CAN
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  x  x  x  |  |  |  PROFIBUS_SL
+ *                                             |  |  CAN
+ *                                             |  RS232_485
+ *                                             ETHERNET_IP
+ *   x: reserved for future use
+ *
+ */
+
+/ {
+	target_info {
+		/*
+		 * maybe we should change the drivers name
+		 * to something like "wago,information" ??
+		*/
+		compatible = "wago,testenv";
+
+		board_info {
+			model                     = "pfc200";
+			id                        = "750-82xx";
+			nand_ecc_hamming          = "true";
+			eeprom_write_protect_gpio = "170";
+		};
+
+		led_info {
+			/* conforms to led order on device, see label "leds".
+			 * we assume, that every led has to colors (red, green).
+			 * so we only allow the colors red,green,orange
+			 */
+			led_array_red = "u1:u2:u3:u4:dia:bf:sys:run:io:ms:ns:can";
+		};
+	};
+};
+
+&u6_g {
+        label = "bf-green";
+        gpios = <&gpio3 2 0>;
+        linux,default-trigger = "none";
+};
+
+&u6_r {
+        label = "bf-red";
+        gpios = <&gpio3 3 0>;
+        linux,default-trigger = "none";
+};
+
+&u5_g {
+        label = "dia-green";
+        gpios = <&gpio3 6 0>;
+        linux,default-trigger = "none";
+};
+
+&u5_r {
+        label = "dia-red";
+        gpios = <&gpio3 7 0>;
+        linux,default-trigger = "none";
+};
+
+
+&u7_g {
+        label = "can-green";
+        gpios = <&gpio3 24 0>;
+        linux,default-trigger = "none";
+};
+
+&u7_r {
+        label = "can-red";
+        gpios = <&gpio3 25 0>;
+        linux,default-trigger = "none";
+};
diff --git a/arch/arm/boot/dts/wago-pfc200-uart1.dtsi b/arch/arm/boot/dts/wago-pfc200-uart1.dtsi
new file mode 100644
index 0000000..d2548d2
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200-uart1.dtsi
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&omap3_pmx_core {
+
+        uart1_rs_pins: pinmux_uart1_rs_pins {
+		pinctrl-single,pins = <
+			OMAP3_CORE1_IOPAD(0x21d2, PIN_OUTPUT | MUX_MODE4) /* mcspi1_cs2.gpio6_16 (gpio_176) sel_rs232/485 */
+			//OMAP3_CORE1_IOPAD(0x217e, PIN_OUTPUT | MUX_MODE4) /* uart1_rts.gpio5_21 (gpio_149) rts-gpio */
+                        0x150 (PIN_INPUT | MUX_MODE0)		          /* uart1_cts.uart1_cts */
+                        0x14e (PIN_OUTPUT | MUX_MODE0)		          /* uart1_rts.uart1_rts */
+                        0x152 (WAKEUP_EN | PIN_INPUT | MUX_MODE0)         /* uart1_rx.uart1_rx */
+                        0x14c (PIN_OUTPUT | MUX_MODE0)		          /* uart1_tx.uart1_tx */
+		>;
+	};
+};
+
+&uart1 {
+        compatible = "ti,omap3-uart-rtu";
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_rs_pins>;
+
+	//rts-gpio = <&gpio5 21 GPIO_ACTIVE_HIGH>;
+	rs485en-gpio = <&gpio6 16 GPIO_ACTIVE_LOW>;
+	rs485-rts-active-high;
+	/* rs485-rx-during-tx; */ // we only support 2-wire mode
+	rs485-rts-delay = <1 1>;
+	/* linux,rs485-enabled-at-boot-time; */
+};
diff --git a/arch/arm/boot/dts/wago-pfc200.dts b/arch/arm/boot/dts/wago-pfc200.dts
new file mode 100644
index 0000000..ade8748
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200.dts
@@ -0,0 +1,601 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "am3517.dtsi"
+
+/ {
+	model = "WAGO PFC200 (AM3505)";
+	compatible = "wago,pfc200", "ti,am3517-evm", "ti,am3517", "ti,omap3";
+
+	aliases {
+		mdio-gpio0 = &bitbang_mdio0;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+        vmmc_fixed: vmmc {
+                compatible = "regulator-fixed";
+                regulator-name = "vmmc_fixed";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+        };
+
+	ksz8863 {
+		compatible = "micrel,ksz8863";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		status = "okay";
+
+		ksz,reset-switch;
+		ksz,gpio-reset = <&gpio5 8 GPIO_ACTIVE_LOW>;	/* gpio2_21: RMII2.EN-PHY */
+		//ksz,disable-internal-ldo;
+		ksz,mii-bus = <&bitbang_mdio0>;
+	};
+
+/* #define PAC200_DPC31_GPIO__INT_SYS_NDMAREQ1        65: gpio3_1 */
+/* #define PAC200_DPC31_GPIO__INT_DXCH               160: gpio6_0 */
+/* #define PAC200_DPC31_GPIO__INT_FB_NSYNC           161: gpio6_1 */
+/* #define PAC200_DPC31_GPIO__RESET                  162: gpio6_2 */
+
+	/* common init entries */
+	wsysinit_init {
+		status = "okay";
+		compatible = "wago,sysinit";
+		pinctrl-names = "default";
+		pinctrl-0 = <&dpc31_pins>;
+		fb,reset;
+		fb,gpio-rst = <&gpio6 2 GPIO_ACTIVE_LOW>;	/* dpc31 reset */
+
+		add-sysfs-entries;
+	};
+
+        bitbang_mdio0: gpio_mdio {
+		compatible = "virtual,mdio-gpio";
+                #address-cells = <1>;
+                #size-cells = <0>;
+
+	};
+
+	dsa@0 {
+		compatible = "marvell,dsa";
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* interrupts = <10>; --> not supported from the driver! */
+
+		/* master netdevice (eth0) */
+		dsa,ethernet = <&davinci_emac>; /* TODO: should we use 'cpsw_emac1' instead? */
+		dsa,mii-bus = <&bitbang_mdio0>;
+
+		switch@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <16 0>;	/* MDIO address 16, switch 0 in tree */
+
+			port@0 {
+				reg = <0>;
+				label = "ethX2";	/* phys are twisted on hw */
+				phy-handle = <&phy1>;
+				phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "ethX1";
+				phy-handle = <&phy2>;
+				phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <2>;
+				label = "cpu";
+			};
+		};
+	};
+
+	/* nvram is on cs2 */
+	UIO_NVRAM@0x2000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x2000000 0x20000>; /* 128k */
+	};
+
+	/* dpc31 is on cs1 */
+	UIO_DPC31_XINT@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x1000000 0x4000>; /* 8k * 2 = 16k, needed because of 16Bit addressing */
+		interrupt-parent = <&gpio3>;
+		interrupts = <1 IRQ_TYPE_EDGE_FALLING>;	/* gpio3_1 / gpio_65 */
+	};
+
+	UIO_DPC31_SYNC@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		interrupt-parent = <&gpio6>;
+		interrupts = <1 IRQ_TYPE_EDGE_RISING>;	/* gpio6_1 / gpio_161 */
+	};
+
+	UIO_DPC31_DXOUT@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		interrupt-parent = <&gpio6>;
+		interrupts = <0 IRQ_TYPE_EDGE_RISING>;	/* gpio6_0 / gpio_160 */
+	};
+};
+
+&omap3_pmx_core {
+	pinctrl-names = "default";
+	pinctrl-0 = <
+		&led_pins
+	>;
+
+        uart1_rs_pins: pinmux_uart1_rs_pins {
+		pinctrl-single,pins = <
+			OMAP3_CORE1_IOPAD(0x21d2, PIN_OUTPUT | MUX_MODE4) /* mcspi1_cs2.gpio6_16 (gpio_176) sel_rs232/485 */
+			OMAP3_CORE1_IOPAD(0x217e, PIN_OUTPUT | MUX_MODE4) /* uart1_rts.gpio5_21 (gpio_149) rts-gpio */
+                        0x150 (PIN_INPUT | MUX_MODE0)		/* uart1_cts.uart1_cts */
+                        0x14e (PIN_OUTPUT | MUX_MODE0)		/* uart1_rts.uart1_rts */
+                        0x152 (WAKEUP_EN | PIN_INPUT | MUX_MODE0) /* uart1_rx.uart1_rx */
+                        0x14c (PIN_OUTPUT | MUX_MODE0)		/* uart1_tx.uart1_tx */
+		>;
+	};
+
+	uart2_pins: pinmux_uart2_pins {
+		pinctrl-single,pins = <
+                        0x14a (WAKEUP_EN | PIN_INPUT | MUX_MODE0) /* uart2_rx.uart2_rx */
+                        0x148 (PIN_OUTPUT | MUX_MODE0)		/* uart2_tx.uart2_tx */
+		>;
+	};
+
+        mcspi1_pins: pinmux_mcspi1_pins {
+		pinctrl-single,pins = <
+			OMAP3_CORE1_IOPAD(0x21c8, PIN_INPUT | MUX_MODE0) /* mcspi1_clk.mcspi1_clk */
+			OMAP3_CORE1_IOPAD(0x21ca, PIN_OUTPUT | MUX_MODE0) /* mcspi1_simo.mcspi1_simo */
+			OMAP3_CORE1_IOPAD(0x21cc, PIN_INPUT | MUX_MODE0) /* mcspi1_somi.mcspi1_somi */
+			OMAP3_CORE1_IOPAD(0x21ce, PIN_OUTPUT | MUX_MODE0) /* mcspi1_cs0.mcspi1_cs0 */
+		>;
+	};
+
+	kbus_pins: pinmux_kbus_pins {
+		pinctrl-single,pins = <
+			OMAP3_CORE1_IOPAD(0x21ea, PIN_OUTPUT | MUX_MODE4) /* ccdc_vd.gpio4_1     -> KBus-nIRQ_GPIO97 */
+
+			OMAP3_CORE1_IOPAD(0x21ec, PIN_INPUT | MUX_MODE4)  /* ccdc_wen.gpio4_2    -> KBus-ErrSt0_GPIO98 */
+			OMAP3_CORE1_IOPAD(0x21ee, PIN_INPUT | MUX_MODE4)  /* ccdc_data0.gpio4_3  -> KBus-ErrSt1_GPIO99 */
+			OMAP3_CORE1_IOPAD(0x21f0, PIN_INPUT | MUX_MODE4)  /* ccdc_data1.gpio4_4  -> KBus-ErrSt2_GPIO100 */
+			OMAP3_CORE1_IOPAD(0x21f2, PIN_INPUT | MUX_MODE4)  /* ccdc_data2.gpio4_5  -> KBus-ErrSt3_GPIO101 */
+
+			OMAP3_CORE1_IOPAD(0x21f4, PIN_INPUT | MUX_MODE4)  /* ccdc_data3.gpio4_6  -> KBus-nErr_GPIO102 */
+			OMAP3_CORE1_IOPAD(0x21f6, PIN_OUTPUT | MUX_MODE4) /* ccdc_data4.gpio4_7  -> KBus-CmdSel_GPIO103 */
+			OMAP3_CORE1_IOPAD(0x21f8, PIN_INPUT | MUX_MODE4)  /* ccdc_data5.gpio4_8  -> KBus-nRDY_GPIO104 */
+			OMAP3_CORE1_IOPAD(0x21fa, PIN_OUTPUT | MUX_MODE4) /* ccdc_data6.gpio4_9  -> KBus-nRST_GPIO105 */
+			OMAP3_CORE1_IOPAD(0x21fc, PIN_INPUT | MUX_MODE4)  /* ccdc_data7.gpio4_10 -> KBus-nSync_GPIO106 */
+		>;
+	};
+
+
+        dpc31_pins: pinmux_dpc31_pins {
+		pinctrl-single,pins = <
+		  /* gpmc */
+		  // OMAP3_CORE1_IOPAD(0x20b0, PIN_OUTPUT | MUX_MODE4) /* gpmc_ncs1.gpmc_ncs1     -> GPMC-nCS1-FB */
+		  // OMAP3_CORE1_IOPAD(0x20ce, PIN_INPUT | MUX_MODE0)  /* gpmc_wait1.gpmc_wait1 -> GPMC-WAIT1-DPC31 */
+		  /* gpios */
+		  OMAP3_CORE1_IOPAD(0x20D2, PIN_INPUT | MUX_MODE4)  /* gpmc_wait3.gpio3_1    -> SYS_nDMAREQ1
+	                                                             * GPIO Interrupt (GPIO_65): DCP31 XINT (PG5)
+	                                                             * Also useable for DMA transfers.
+	                                                             */
+		  OMAP3_CORE1_IOPAD(0x2194, PIN_INPUT | MUX_MODE4)  /* mcbsp_clks.gpio6_0    -> FB-EEPROM-LOADED (= DPC31_DXCH)
+	                                                             * GPIO Interrupt (GPIO_160): DPC31_DXCH, DCP31 IRR14 (PB3)
+	                                                             * Active on new output data ... (optional)
+	                                                             */
+		  OMAP3_CORE1_IOPAD(0x2196, PIN_OUTPUT | MUX_MODE4) /* mcbsp1_fsx.gpio6_1    -> FB-nSYNC (= DPC31_SYNC)
+	                                                             * GPIO Interrupt (GPIO_161): DPC31_SYNC, DCP31 RES (PB2)
+	                                                             * Fieldbus Sync Signal (optional)
+	                                                             */
+		  OMAP3_CORE1_IOPAD(0x2198, PIN_OUTPUT | MUX_MODE4) /* mcbsp1_clkx.gpio6_2   -> FB-nRST (= nExt_RESET) --> GPIO_162 */
+		>;
+	};
+
+	led_pins: pinmux_led_pins {
+		pinctrl-single,pins = <
+		        0x0a4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_pclk.gpio_66: led_1_1_green */
+		        0x0a6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_hsync.gpio_67: led_1_1_red */
+		        0x0a8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_vsync.gpio_68: led_1_2_green */
+		        0x0aa (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_acbias.gpio_69: led_1_2_red */
+
+		        0x0ac (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data0.gpio_70: led_2_1_green */
+		        0x0ae (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data1.gpio_71: led_2_1_red */
+		        0x0b0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data2.gpio_72: led_2_2_green */
+		        0x0b2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data3.gpio_73: led_2_2_red */
+
+		        0x0b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data4.gpio_74: led_3_1_green */
+		        0x0b6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data5.gpio_75: led_3_1_red */
+		        0x0b8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data6.gpio_76: led_3_2_green */
+		        0x0ba (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data7.gpio_77: led_3_2_red */
+
+		        0x0bc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data8.gpio_78: led_4_1_green */
+		        0x0be (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data9.gpio_79: led_4_1_red */
+		        0x0c0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data10.gpio_80: led_4_2_green */
+		        0x0c2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data11.gpio_81: led_4_2_red */
+
+		        0x0c4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data12.gpio_82: led_5_1_green */
+		        0x0c6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data13.gpio_83: led_5_1_red */
+		        0x0c8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data14.gpio_84: led_5_2_green */
+		        0x0ca (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data15.gpio_85: led_5_2_red */
+
+		        0x0cc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data16.gpio_86: led_6_1_green */
+		        0x0ce (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data17.gpio_87: led_6_1_red */
+		        0x0d0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data18.gpio_88: led_6_2_green */
+		        0x0d2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data19.gpio_89: led_6_2_red */
+		>;
+	};
+
+	ksz8863_pins: pinmux_ksz8863_pins {
+		pinctrl-single,pins = <
+		        0x134 (PIN_OUTPUT | MUX_MODE4) /* mmc2_dat4.gpio5_8 (gpio_136) nrst_switch */
+			OMAP3_CORE1_IOPAD(0x2168, PIN_INPUT | MUX_MODE4) /* mmc2_dat6.gpio5_10 (gpio_138) nintswitch */
+		>;
+	};
+
+	emac_pins: pinmux_emac_pins {
+		pinctrl-single,pins = <
+		        0x1d2 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd0.rmii_rxd0           */
+		        0x1d4 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd1.rmii_rxd1           */
+		        0x1d6 (PIN_INPUT | MUX_MODE0)           /* rmii_crs_dv.rmii_crs_dv       */
+		        0x1d8 (PIN_INPUT | MUX_MODE0)           /* rmii_rxer.rmii_rxer           */
+		        0x1da (PIN_OUTPUT_PULLUP | MUX_MODE0)   /* rmii_txd0.rmii_txd0           */
+		        0x1dc (PIN_INPUT | MUX_MODE0)           /* rmii_txd1.rmii_txd1           */
+		        0x1de (PIN_INPUT | MUX_MODE0)           /* rmii_txen.rmii_txen           */
+		        0x1e0 (PIN_INPUT | MUX_MODE0)           /* rmii_50mhz_clk.rmii_50mhz_clk */
+		>;
+	};
+
+	gpio_bitbang_mdio_pins: pinmux_gpio_bitbang_mdio_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+		        0x1ce (PIN_INPUT_PULLUP  | MUX_MODE4)  /* rmii_mdio_data.gpio4_11 (gpio107) */
+		        0x1d0 (PIN_OUTPUT_PULLUP | MUX_MODE4)   /* rmii_mdio_clk.gpio4_12 (gpio108)   */
+		>;
+	};
+
+	gpio_bitbang_mdio_sleep_pins: pinmux_gpio_bitbang_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+		        0x1ce (PIN_INPUT_PULLUP   | MUX_MODE4)  /* rmii_mdio_data.rmii_mdio_data */
+		        0x1d0 (PIN_INPUT_PULLDOWN | MUX_MODE4)   /* rmii_mdio_clk.rmii_mdio_clk   */
+		>;
+	};
+
+	/* For all pins: offset is 0x48002030 */
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x114 (PIN_INPUT_PULLUP | MUX_MODE0)	/* sdmmc1_clk.sdmmc1_clk */
+			0x116 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_cmd.sdmmc1_cmd */
+			0x118 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat0.sdmmc1_dat0 */
+			0x11a (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat1.sdmmc1_dat1 */
+			0x11c (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat2.sdmmc1_dat2 */
+			0x11e (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat3.sdmmc1_dat3 */
+
+			0x10c (PIN_INPUT  | MUX_MODE4)   /* mcbsp2_fsx.gpio4_20 - SD-MMC1-CD (gpio_116) */
+			0x10e (PIN_OUTPUT | MUX_MODE4)   /* mcbsp2_clkx.gpio4_21 - SD-MMC1-EN (gpio_117) */
+			/* this macro makes it easier:
+			 * e.g. mcbsp2_dr.gpio4_22 - SD-MMC1-WP (gpio_118):
+			 * OMAP3_CORE1_IOPAD(0x2140, PIN_INPUT | MUX_MODE4)
+			 */
+			0x110 (PIN_INPUT | MUX_MODE4)    /* mcbsp2_dr.gpio4_22 - SD-MMC1-WP (gpio_118) */
+			0x13a (PIN_OUTPUT | MUX_MODE4)   /* mmc2_dat7.gpio5_11 - SD-MMC1-RW (gpio_139) */
+		>;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x04a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a1.gpmc_a1 */
+			0x04c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a2.gpmc_a2 */
+			0x04e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a3.gpmc_a3 */
+			0x050 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a4.gpmc_a4 */
+			0x052 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a5.gpmc_a5 */
+			0x054 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a6.gpmc_a6 */
+			0x056 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a7.gpmc_a7 */
+			0x058 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a8.gpmc_a8 */
+			0x05a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a9.gpmc_a9 */
+			0x05c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a10.gpmc_a10 */
+
+			0x06c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d8.gpmc_d8 */
+			0x06e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d9.gpmc_d9 */
+			0x070 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d10.gpmc_d10 */
+			0x072 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d11.gpmc_d11 */
+			0x074 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d12.gpmc_d12 */
+			0x076 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d13.gpmc_d13 */
+			0x078 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d14.gpmc_d14 */
+			0x07a (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d15.gpmc_d15 */
+
+			0x07e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs0.gpmc_ncs0 */
+			0x080 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs1.gpmc_ncs1 */
+			0x082 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs2.gpmc_ncs2 */
+			0x08c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_clk.gpmc_clk */
+
+			0x090 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nadv_ale.gpmc_nadv_ale */
+			0x092 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_noe.gpmc_noe */
+			0x094 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nwe */
+
+			0x096 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe0_cle.gpmc_nbe0_cle */
+
+			0x098 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe1.gpmc_nbe1 */
+			0x09a (PIN_INPUT | MUX_MODE0)	/* gpmc_nwp.gpmc_nwp */
+
+			0x09c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */
+			0x09e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait1.gpmc_wait1 */
+			0x0a0 (PIN_INPUT_PULLUP | MUX_MODE4)	/* gpmc_wait2.gpio_64 */
+			//0x0a2 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait3.gpmc_wait3 */
+		>;
+	};
+};
+
+&bitbang_mdio0 {
+       pinctrl-names = "default", "sleep";
+       pinctrl-0 = <&gpio_bitbang_mdio_pins>;
+       pinctrl-1 = <&gpio_bitbang_mdio_sleep_pins>;
+       gpios = <&gpio4 12 0	/* 0: mdc  */
+		&gpio4 11 0>;   /* 1: mdio */
+
+       phy1: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+       };
+
+       phy2: ethernet-phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <2>;
+       };
+};
+
+&davinci_emac {
+	     status = "okay";
+	     fixed-link {
+		     speed = <100>;
+		     full-duplex;
+	     };
+};
+
+&ti_hecc {
+	     status = "okay";
+};
+
+&uart1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_rs_pins>;
+
+	rts-gpio = <&gpio5 21 GPIO_ACTIVE_HIGH>;
+	rs485en-gpio = <&gpio6 16 GPIO_ACTIVE_LOW>;
+	rs485-rts-active-high;
+	/* rs485-rx-during-tx; */ // we only support 2-wire mode
+	rs485-rts-delay = <1 1>;
+	/* linux,rs485-enabled-at-boot-time; */
+};
+
+&uart2 { /* KBUS Firmware download */
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart2_pins>;
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+
+        rtc_r2221t {
+                compatible = "ricoh,r2221tl";
+                reg = <0x32>;
+        };
+
+	24c512@54 {
+		compatible = "24c512";
+		reg = <0x54>;
+
+		pagesize = <128>;
+	};
+};
+
+&i2c3 {
+	clock-frequency = <400000>;
+};
+
+&mmc1 {
+        status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&vmmc_fixed>;
+	bus-width = <4>;
+	cd-gpios = <&gpio4 20 GPIO_ACTIVE_HIGH>;
+	wp-gpios = <&gpio4 22 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+      status = "disabled";
+};
+
+&mmc3 {
+      status = "disabled";
+};
+
+&mcspi1 {
+        status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mcspi1_pins>;
+
+	kbus0: kbus@0 {	/* KBUS on cs0 */
+		compatible = "wago,spi-kbus";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&kbus_pins>;
+		reg = <0>;
+		spi-max-frequency = <10000000>; /* FIXME */
+		kbus,dma-boost; /* this enables dma boosting */
+		kbus,dma-boost-prio   = <85>;
+		kbus,dma-default-prio = <50>;
+
+		/* some should be active low, keep all to high for compatibility reasons */
+		kbus,gpio-nrst   = <&gpio4  9 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nsync  = <&gpio4 10 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-cmdsel = <&gpio4  7 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nirq   = <&gpio4  1 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nerr   = <&gpio4  6 GPIO_ACTIVE_HIGH>;
+
+		kbus,gpio-errst  = <&gpio4  2 GPIO_ACTIVE_HIGH    /* 0..2 */
+				    &gpio4  3 GPIO_ACTIVE_HIGH
+				    &gpio4  4 GPIO_ACTIVE_HIGH>; /* On pfc200 we have one more:
+								  * &gpio4  4 GPIO_ACTIVE_HIGH
+								  * but keep it in sync with pfc100
+								  */
+
+		kbus,gpio-nrdy   = <&gpio4  8 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&gpmc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+	num-cs = <3>;
+	num-waitpins = <4>;
+	ranges = <
+		0 0 0x00000000 0x01000000	/* CS0: NAND, 16M */
+		1 0 0x01000000 0x01000000	/* CS1: FB/DPC31, 16M */
+		2 0 0x02000000 0x01000000	/* CS2: NVRAM, 16M */
+	>;
+
+	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <36>;
+		gpmc,cs-wr-off-ns = <36>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <24>;
+		gpmc,adv-wr-off-ns = <36>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <30>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <48>;
+		gpmc,access-ns = <54>;
+		gpmc,rd-cycle-ns = <72>;
+		gpmc,wr-cycle-ns = <72>;
+
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+
+		gpmc,wr-access-ns = <30>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+        dpc31: nor@1,0 {
+		reg = <1 0 0x1000000>; /* 8k * 2 = 16k, needed because of 16Bit addressing
+					* minimum is 16M - set it here */
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+
+		gpmc,cs-on-ns = <42>;
+		gpmc,cs-rd-off-ns = <144>;
+		gpmc,cs-wr-off-ns = <144>;
+
+		gpmc,adv-on-ns = <12>;
+		gpmc,adv-rd-off-ns = <156>;
+		gpmc,adv-wr-off-ns = <156>;
+
+		gpmc,oe-on-ns = <42>;
+		gpmc,oe-off-ns = <144>;
+
+		gpmc,we-on-ns = <42>;
+		gpmc,we-off-ns = <114>;
+
+		gpmc,rd-cycle-ns = <168>;
+		gpmc,wr-cycle-ns = <168>;
+
+		gpmc,access-ns = <150>;
+		gpmc,wr-access-ns = <54>;
+
+		gpmc,wr-data-mux-bus-ns = <18>;
+
+		gpmc,cycle2cycle-delay-ns = <0>;
+
+		gpmc,time-para-granularity;
+		gpmc,mux-add-data = <2>; /* address-data multiplexing mode */
+
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+
+		gpmc,wait-pin = <1>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+        nvram: nor@2,0 { /* NVRAM Device 128k */
+		reg = <2 0 0x1000000>;
+
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+
+		gpmc,cs-on-ns = <12>;
+		gpmc,cs-rd-off-ns = <54>;
+		gpmc,cs-wr-off-ns = <30>;
+
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <54>;
+		gpmc,adv-wr-off-ns = <30>;
+
+		gpmc,oe-on-ns = <12>;
+		gpmc,oe-off-ns = <54>;
+
+		gpmc,we-on-ns = <12>;
+		gpmc,we-off-ns = <30>;
+
+		gpmc,rd-cycle-ns = <54>;
+		gpmc,wr-cycle-ns = <30>;
+
+		gpmc,access-ns = <48>;
+
+		gpmc,wr-access-ns = <18>;
+		gpmc,wr-data-mux-bus-ns = <12>;
+
+		gpmc,time-para-granularity;
+		gpmc,mux-add-data = <2>; /* address-data multiplexing mode */
+
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wait-on-read = "false";
+		gpmc,wait-on-write = "false";
+
+		gpmc,cycle2cycle-delay-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+/include/ "pxc-nandparts.dtsi"
diff --git a/arch/arm/boot/dts/wago-pfc200.dtsi b/arch/arm/boot/dts/wago-pfc200.dtsi
new file mode 100644
index 0000000..fba8f74
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200.dtsi
@@ -0,0 +1,743 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "am3517.dtsi"
+
+/ {
+	model = "WAGO PFC200 (AM3505)";
+	compatible = "wago,pfc200", "ti,am3517-evm", "ti,am3517", "ti,omap3";
+
+	aliases {
+		mdio-gpio0 = &bitbang_mdio0;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+        vmmc_fixed: vmmc {
+                compatible = "regulator-fixed";
+                regulator-name = "vmmc_fixed";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+        };
+
+	ksz8863 {
+		compatible = "micrel,ksz8863";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		status = "okay";
+
+		ksz,reset-switch;
+		ksz,gpio-reset = <&gpio5 8 GPIO_ACTIVE_LOW>;	/* gpio2_21: RMII2.EN-PHY */
+		//ksz,disable-internal-ldo;
+		ksz,mii-bus = <&bitbang_mdio0>;
+	};
+
+	/* common init entries */
+        wsysinit: wsysinit_init {
+		status = "okay";
+		compatible = "wago,sysinit";
+
+		add-sysfs-entries;
+
+		nand,eccmode = "hamming_hw_romcode";
+
+		tty,service   = "ttyO2";
+		tty,rs232-485 = "ttyO0";
+	
+		board,variant = "pfc200";
+
+		/* sysclock adjustments,
+		   empirical values */
+		adjtimex,tick = <10000>;
+		adjtimex,frequency = <3473408>;
+	};
+
+        bitbang_mdio0: gpio_mdio {
+		compatible = "virtual,mdio-gpio";
+                #address-cells = <1>;
+                #size-cells = <0>;
+
+	};
+
+	/*
+	   this name of the gpio-keys device is a
+	   historical heritage from 3.6.11 kernel.
+	   the device-name is checked in omsd. So we
+	   need to adapt this configuration
+	*/
+	PAC-Operating-Mode-Switch {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+
+		run {
+			label = "RUN";
+			gpios = <&gpio3 26 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 90 */
+			linux,code = <1>;
+			linux,input-type = <5>;  /* EV_SW */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		stop {
+			label = "STOP";
+			gpios = <&gpio3 27 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 91 */
+			linux,code = <2>;
+			linux,input-type = <5>;  /* EV_SW */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		reset {
+			label = "RESET";
+			gpios = <&gpio3 28 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 92 */
+			linux,code = <3>;
+			linux,input-type = <1>;  /* EV_KEY */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		reset_all {
+			label = "RESET_ALL";
+			gpios = <&gpio3 29 GPIO_ACTIVE_HIGH>; /* BAS_RUN GPIO 93 */
+			linux,code = <4>;
+			linux,input-type = <1>;  /* EV_KEY */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+	};
+
+	dsa@0 {
+		compatible = "marvell,dsa";
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* interrupts = <10>; --> not supported from the driver! */
+
+		/* master netdevice (eth0) */
+		dsa,ethernet = <&davinci_emac>; /* TODO: should we use 'cpsw_emac1' instead? */
+		dsa,mii-bus = <&bitbang_mdio0>;
+
+		switch@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <16 0>;	/* MDIO address 16, switch 0 in tree */
+
+			port@0 {
+				reg = <2>;
+				label = "ethX1";	/* phys are twisted on hw */
+				phy-handle = <&phy2>;
+				phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "ethX2";
+				phy-handle = <&phy1>;
+				phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <3>;
+				label = "cpu";
+			};
+		};
+	};
+
+	/* nvram is on cs2 */
+	UIO_NVRAM@0x2000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x2000000 0x20000>; /* 128k */
+	};
+
+	leds: gpio-leds {
+		compatible = "gpio-leds";
+
+		u1_g: u1-green@0 {
+			label = "u1-green";
+			gpios = <&gpio3 22 0>;
+			linux,default-trigger = "none";
+		};
+
+		u1_r: u1-red@1 {
+			label = "u1-red";
+			gpios = <&gpio3 23 0>;
+			linux,default-trigger = "none";
+		};
+
+		u2_g: u2-green@2 {
+			label = "u2-green";
+			gpios = <&gpio3 18 0>;
+			linux,default-trigger = "none";
+		};
+
+		u2_r: u2-red@3 {
+			label = "u2-red";
+			gpios = <&gpio3 19 0>;
+			linux,default-trigger = "none";
+		};
+
+		u3_g: u3-green@4 {
+			label = "u3-green";
+			gpios = <&gpio3 14 0>;
+			linux,default-trigger = "none";
+		};
+
+		u3_r: u3-red@5 {
+			label = "u3-red";
+			gpios = <&gpio3 15 0>;
+			linux,default-trigger = "none";
+		};
+
+		u4_g: u4-green@6 {
+			label = "u4-green";
+			gpios = <&gpio3 10 0>;
+			linux,default-trigger = "none";
+		};
+
+		u4_r: u4-red@7 {
+			label = "u4-red";
+			gpios = <&gpio3 11 0>;
+			linux,default-trigger = "none";
+		};
+
+		u5_g: u5-green@8 {
+			label = "u5-green";
+			gpios = <&gpio3 6 0>;
+			linux,default-trigger = "none";
+		};
+
+		u5_r: u5-red@9 {
+			label = "u5-red";
+			gpios = <&gpio3 7 0>;
+			linux,default-trigger = "none";
+		};
+
+		u6_g: u6-green@10 {
+			label = "u6-green";
+			gpios = <&gpio3 2 0>;
+			linux,default-trigger = "none";
+			};
+
+		u6_r: u6-red@11 {
+			label = "u6-red";
+			gpios = <&gpio3 3 0>;
+			linux,default-trigger = "none";
+		};
+
+		sys_g: sys-green@12 {
+			label = "sys-green";
+			gpios = <&gpio3 4 0>;
+			linux,default-trigger = "timer";
+		};
+
+		sys_r: sys-red@13 {
+			label = "sys-red";
+			gpios = <&gpio3 5 0>;
+			linux,default-trigger = "timer";
+		};
+
+
+		run_g: run-green@14 {
+			label = "run-green";
+			gpios = <&gpio3 8 0>;
+			linux,default-trigger = "none";
+		};
+
+		run_r: run-red@15 {
+			label = "run-red";
+			gpios = <&gpio3 9 0>;
+			linux,default-trigger = "none";
+		};
+
+
+		io_g: io-green@16 {
+			label = "io-green";
+			gpios = <&gpio3 12 0>;
+			linux,default-trigger = "none";
+		};
+
+		io_r: io-red@17 {
+			label = "io-red";
+			gpios = <&gpio3 13 0>;
+			linux,default-trigger = "none";
+		};
+
+
+		ms_g: ms-green@18 {
+			label = "ms-green";
+			gpios = <&gpio3 16 0>;
+			linux,default-trigger = "none";
+		};
+
+		ms_r: ms-red@19 {
+			label = "ms-red";
+			gpios = <&gpio3 17 0>;
+			linux,default-trigger = "none";
+		};
+
+
+		ns_g: ns-green@20 {
+			label = "ns-green";
+			gpios = <&gpio3 20 0>;
+			linux,default-trigger = "none";
+		};
+
+		ns_r: ns-red@21 {
+			label = "ns-red";
+			gpios = <&gpio3 21 0>;
+			linux,default-trigger = "none";
+		};
+
+		u7_g: u7-green@22 {
+			label = "u7-green";
+			gpios = <&gpio3 24 0>;
+			linux,default-trigger = "none";
+		};
+
+		u7_r: u7-red@23 {
+			label = "u7-red";
+			gpios = <&gpio3 25 0>;
+			linux,default-trigger = "none";
+		};
+	};
+
+	watchdog: watchdog {
+		/* XC6124 */
+		compatible = "linux,wdt-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&watchdog_pins>;
+
+		gpio-en = <&gpio6 3 GPIO_ACTIVE_LOW>; /* 163 - EN */
+		gpios = <&gpio6 4 GPIO_ACTIVE_LOW>;   /* 164 - WDI */
+
+		hw_algo = "toggle";
+		hw_margin_ms = <1600>;
+		status = "okay";
+	};
+};
+
+&omap3_pmx_core {
+	pinctrl-names = "default";
+	pinctrl-0 = <
+		&led_pins
+	>;
+
+	uart2_pins: pinmux_uart2_pins {
+		pinctrl-single,pins = <
+                        0x14a (WAKEUP_EN | PIN_INPUT | MUX_MODE0) /* uart2_rx.uart2_rx */
+                        0x148 (PIN_OUTPUT | MUX_MODE0)		/* uart2_tx.uart2_tx */
+		>;
+	};
+
+        mcspi1_pins: pinmux_mcspi1_pins {
+		pinctrl-single,pins = <
+			OMAP3_CORE1_IOPAD(0x21c8, PIN_INPUT | MUX_MODE0) /* mcspi1_clk.mcspi1_clk */
+			OMAP3_CORE1_IOPAD(0x21ca, PIN_OUTPUT | MUX_MODE0) /* mcspi1_simo.mcspi1_simo */
+			OMAP3_CORE1_IOPAD(0x21cc, PIN_INPUT | MUX_MODE0) /* mcspi1_somi.mcspi1_somi */
+			OMAP3_CORE1_IOPAD(0x21ce, PIN_OUTPUT | MUX_MODE0) /* mcspi1_cs0.mcspi1_cs0 */
+		>;
+	};
+
+	kbus_pins: pinmux_kbus_pins {
+		pinctrl-single,pins = <
+			OMAP3_CORE1_IOPAD(0x21ea, PIN_OUTPUT | MUX_MODE4) /* ccdc_vd.gpio4_1     -> KBus-nIRQ_GPIO97 */
+
+			OMAP3_CORE1_IOPAD(0x21ec, PIN_INPUT | MUX_MODE4)  /* ccdc_wen.gpio4_2    -> KBus-ErrSt0_GPIO98 */
+			OMAP3_CORE1_IOPAD(0x21ee, PIN_INPUT | MUX_MODE4)  /* ccdc_data0.gpio4_3  -> KBus-ErrSt1_GPIO99 */
+			OMAP3_CORE1_IOPAD(0x21f0, PIN_INPUT | MUX_MODE4)  /* ccdc_data1.gpio4_4  -> KBus-ErrSt2_GPIO100 */
+			OMAP3_CORE1_IOPAD(0x21f2, PIN_INPUT | MUX_MODE4)  /* ccdc_data2.gpio4_5  -> KBus-ErrSt3_GPIO101 */
+
+			OMAP3_CORE1_IOPAD(0x21f4, PIN_INPUT | MUX_MODE4)  /* ccdc_data3.gpio4_6  -> KBus-nErr_GPIO102 */
+			OMAP3_CORE1_IOPAD(0x21f6, PIN_OUTPUT | MUX_MODE4) /* ccdc_data4.gpio4_7  -> KBus-CmdSel_GPIO103 */
+			OMAP3_CORE1_IOPAD(0x21f8, PIN_INPUT | MUX_MODE4)  /* ccdc_data5.gpio4_8  -> KBus-nRDY_GPIO104 */
+			OMAP3_CORE1_IOPAD(0x21fa, PIN_OUTPUT | MUX_MODE4) /* ccdc_data6.gpio4_9  -> KBus-nRST_GPIO105 */
+			OMAP3_CORE1_IOPAD(0x21fc, PIN_INPUT | MUX_MODE4)  /* ccdc_data7.gpio4_10 -> KBus-nSync_GPIO106 */
+		>;
+	};
+
+	led_pins: pinmux_led_pins {
+		pinctrl-single,pins = <
+		        0x0a4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_pclk.gpio_66: led_1_1_green */
+		        0x0a6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_hsync.gpio_67: led_1_1_red */
+		        0x0a8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_vsync.gpio_68: led_1_2_green */
+		        0x0aa (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_acbias.gpio_69: led_1_2_red */
+
+		        0x0ac (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data0.gpio_70: led_2_1_green */
+		        0x0ae (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data1.gpio_71: led_2_1_red */
+		        0x0b0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data2.gpio_72: led_2_2_green */
+		        0x0b2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data3.gpio_73: led_2_2_red */
+
+		        0x0b4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data4.gpio_74: led_3_1_green */
+		        0x0b6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data5.gpio_75: led_3_1_red */
+		        0x0b8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data6.gpio_76: led_3_2_green */
+		        0x0ba (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data7.gpio_77: led_3_2_red */
+
+		        0x0bc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data8.gpio_78: led_4_1_green */
+		        0x0be (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data9.gpio_79: led_4_1_red */
+		        0x0c0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data10.gpio_80: led_4_2_green */
+		        0x0c2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data11.gpio_81: led_4_2_red */
+
+		        0x0c4 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data12.gpio_82: led_5_1_green */
+		        0x0c6 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data13.gpio_83: led_5_1_red */
+		        0x0c8 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data14.gpio_84: led_5_2_green */
+		        0x0ca (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data15.gpio_85: led_5_2_red */
+
+		        0x0cc (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data16.gpio_86: led_6_1_green */
+		        0x0ce (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data17.gpio_87: led_6_1_red */
+		        0x0d0 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data18.gpio_88: led_6_2_green */
+		        0x0d2 (PIN_OUTPUT_PULLDOWN | MUX_MODE4)  /* dss_data19.gpio_89: led_6_2_red */
+		>;
+	};
+
+	ksz8863_pins: pinmux_ksz8863_pins {
+		pinctrl-single,pins = <
+		        0x134 (PIN_OUTPUT | MUX_MODE4) /* mmc2_dat4.gpio5_8 (gpio_136) nrst_switch */
+			OMAP3_CORE1_IOPAD(0x2168, PIN_INPUT | MUX_MODE4) /* mmc2_dat6.gpio5_10 (gpio_138) nintswitch */
+		>;
+	};
+
+	emac_pins: pinmux_emac_pins {
+		pinctrl-single,pins = <
+		        0x1d2 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd0.rmii_rxd0           */
+		        0x1d4 (PIN_INPUT | MUX_MODE0)           /* rmii_rxd1.rmii_rxd1           */
+		        0x1d6 (PIN_INPUT | MUX_MODE0)           /* rmii_crs_dv.rmii_crs_dv       */
+		        0x1d8 (PIN_INPUT | MUX_MODE0)           /* rmii_rxer.rmii_rxer           */
+		        0x1da (PIN_OUTPUT_PULLUP | MUX_MODE0)   /* rmii_txd0.rmii_txd0           */
+		        0x1dc (PIN_INPUT | MUX_MODE0)           /* rmii_txd1.rmii_txd1           */
+		        0x1de (PIN_INPUT | MUX_MODE0)           /* rmii_txen.rmii_txen           */
+		        0x1e0 (PIN_INPUT | MUX_MODE0)           /* rmii_50mhz_clk.rmii_50mhz_clk */
+		>;
+	};
+
+	gpio_bitbang_mdio_pins: pinmux_gpio_bitbang_mdio_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+		        0x1ce (PIN_INPUT_PULLUP  | MUX_MODE4)  /* rmii_mdio_data.gpio4_11 (gpio107) */
+		        0x1d0 (PIN_OUTPUT_PULLUP | MUX_MODE4)   /* rmii_mdio_clk.gpio4_12 (gpio108)   */
+		>;
+	};
+
+	gpio_bitbang_mdio_sleep_pins: pinmux_gpio_bitbang_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+		        0x1ce (PIN_INPUT_PULLUP   | MUX_MODE4)  /* rmii_mdio_data.rmii_mdio_data */
+		        0x1d0 (PIN_INPUT_PULLDOWN | MUX_MODE4)   /* rmii_mdio_clk.rmii_mdio_clk   */
+		>;
+	};
+
+	/* For all pins: offset is 0x48002030 */
+	mmc1_pins: pinmux_mmc1_pins {
+		pinctrl-single,pins = <
+			0x114 (PIN_INPUT_PULLUP | MUX_MODE0)	/* sdmmc1_clk.sdmmc1_clk */
+			0x116 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_cmd.sdmmc1_cmd */
+			0x118 (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat0.sdmmc1_dat0 */
+			0x11a (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat1.sdmmc1_dat1 */
+			0x11c (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat2.sdmmc1_dat2 */
+			0x11e (PIN_INPUT | MUX_MODE0)	/* sdmmc1_dat3.sdmmc1_dat3 */
+
+			0x10c (PIN_INPUT  | MUX_MODE4)   /* mcbsp2_fsx.gpio4_20 - SD-MMC1-CD (gpio_116) */
+			0x10e (PIN_OUTPUT | MUX_MODE4)   /* mcbsp2_clkx.gpio4_21 - SD-MMC1-EN (gpio_117) */
+			/* this macro makes it easier:
+			 * e.g. mcbsp2_dr.gpio4_22 - SD-MMC1-WP (gpio_118):
+			 * OMAP3_CORE1_IOPAD(0x2140, PIN_INPUT | MUX_MODE4)
+			 */
+			0x110 (PIN_INPUT | MUX_MODE4)    /* mcbsp2_dr.gpio4_22 - SD-MMC1-WP (gpio_118) */
+			0x13a (PIN_OUTPUT | MUX_MODE4)   /* mmc2_dat7.gpio5_11 - SD-MMC1-RW (gpio_139) */
+		>;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins {
+		pinctrl-single,pins = <
+			0x04a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a1.gpmc_a1 */
+			0x04c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a2.gpmc_a2 */
+			0x04e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a3.gpmc_a3 */
+			0x050 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a4.gpmc_a4 */
+			0x052 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a5.gpmc_a5 */
+			0x054 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a6.gpmc_a6 */
+			0x056 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a7.gpmc_a7 */
+			0x058 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a8.gpmc_a8 */
+			0x05a (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a9.gpmc_a9 */
+			0x05c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_a10.gpmc_a10 */
+
+			0x06c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d8.gpmc_d8 */
+			0x06e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d9.gpmc_d9 */
+			0x070 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d10.gpmc_d10 */
+			0x072 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d11.gpmc_d11 */
+			0x074 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d12.gpmc_d12 */
+			0x076 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d13.gpmc_d13 */
+			0x078 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d14.gpmc_d14 */
+			0x07a (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_d15.gpmc_d15 */
+
+			0x07e (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs0.gpmc_ncs0 */
+			0x080 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs1.gpmc_ncs1 */
+			0x082 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_ncs2.gpmc_ncs2 */
+			0x08c (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_clk.gpmc_clk */
+
+			0x090 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nadv_ale.gpmc_nadv_ale */
+			0x092 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_noe.gpmc_noe */
+			0x094 (PIN_OUTPUT | MUX_MODE0)	/* gpmc_nwe */
+
+			0x096 (PIN_OUTPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe0_cle.gpmc_nbe0_cle */
+
+			0x098 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_nbe1.gpmc_nbe1 */
+			0x09a (PIN_INPUT | MUX_MODE0)	/* gpmc_nwp.gpmc_nwp */
+
+			0x09c (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */
+			0x09e (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait1.gpmc_wait1 */
+			0x0a0 (PIN_INPUT_PULLUP | MUX_MODE4)	/* gpmc_wait2.gpio_64 */
+			//0x0a2 (PIN_INPUT_PULLUP | MUX_MODE0)	/* gpmc_wait3.gpmc_wait3 */
+		>;
+	};
+
+	watchdog_pins: pinmux_watchdog_pins {
+		pinctrl-single,pins = <
+			OMAP3_CORE1_IOPAD(0x219a, PIN_OUTPUT | MUX_MODE4) /* uart3_cts_rctx.gpio6_3, nWDG_EN_GPIO163 */
+		        OMAP3_CORE1_IOPAD(0x219c, PIN_OUTPUT | MUX_MODE4) /* uart3_rts_sd.gpio6_4, WDG_TRG_GPIO164 */
+		>;
+	};
+};
+
+&bitbang_mdio0 {
+       pinctrl-names = "default", "sleep";
+       pinctrl-0 = <&gpio_bitbang_mdio_pins>;
+       pinctrl-1 = <&gpio_bitbang_mdio_sleep_pins>;
+       gpios = <&gpio4 12 0	/* 0: mdc  */
+		&gpio4 11 0>;   /* 1: mdio */
+
+       phy1: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+       };
+
+       phy2: ethernet-phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <2>;
+       };
+};
+
+&davinci_emac {
+	     status = "okay";
+	     fixed-link {
+		     speed = <100>;
+		     full-duplex;
+	     };
+};
+
+&uart1 {
+	status = "disabled";
+};
+
+&uart2 { /* KBUS Firmware download */
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart2_pins>;
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+
+        rtc_r2221t {
+                compatible = "ricoh,r2221tl";
+                reg = <0x32>;
+
+		interrupt-parent = <&gpio1>;
+		interrupts = <1 IRQ_TYPE_LEVEL_LOW>;
+        };
+
+	24c512@54 {
+		compatible = "24c512";
+		reg = <0x54>;
+
+		pagesize = <128>;
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+	clock-frequency = <400000>;
+};
+
+&mmc1 {
+        status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&vmmc_fixed>;
+	bus-width = <4>;
+	cd-gpios = <&gpio4 20 GPIO_ACTIVE_HIGH>;
+	wp-gpios = <&gpio4 22 GPIO_ACTIVE_HIGH>;
+};
+
+&mmc2 {
+      status = "disabled";
+};
+
+&mmc3 {
+      status = "disabled";
+};
+
+&mcspi1 {
+        status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mcspi1_pins>;
+	spi-rt;
+	spi-rt-prio = <81>;
+
+	kbus0: kbus@0 {	/* KBUS on cs0 */
+		compatible = "wago,spi-kbus";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&kbus_pins>;
+		reg = <0>;
+		spi-max-frequency = <10000000>; /* FIXME */
+		kbus,dma-boost; /* this enables dma boosting */
+		kbus,dma-boost-prio   = <85>;
+		kbus,dma-boost-irq-thread = "irq/29-omap-dma";
+		kbus,dma-default-prio = <50>;
+
+		kbus,reset-on-boot;
+
+		/*
+		 * announce used tty-device in /sys/class/wago/system.
+		 * is needed to link this device to /dev/ttyKbus
+		 */
+		kbus,tty-device = "ttyO1"; /* corresponds to &uart2*/
+
+
+		/* some should be active low, keep all to high for compatibility reasons */
+		kbus,gpio-nrst   = <&gpio4  9 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nsync  = <&gpio4 10 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-cmdsel = <&gpio4  7 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nirq   = <&gpio4  1 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nerr   = <&gpio4  6 GPIO_ACTIVE_HIGH>;
+
+		kbus,gpio-errst  = <&gpio4  2 GPIO_ACTIVE_HIGH    /* 0..2 */
+				    &gpio4  3 GPIO_ACTIVE_HIGH
+				    &gpio4  4 GPIO_ACTIVE_HIGH>; /* On pfc200 we have one more:
+								  * &gpio4  4 GPIO_ACTIVE_HIGH
+								  * but keep it in sync with pfc100
+								  */
+
+		kbus,gpio-nrdy   = <&gpio4  8 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&gpmc {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+	num-cs = <3>;
+	num-waitpins = <4>;
+	ranges = <
+		0 0 0x00000000 0x01000000	/* CS0: NAND, 16M */
+		1 0 0x01000000 0x01000000	/* CS1: FB/DPC31, 16M */
+		2 0 0x02000000 0x01000000	/* CS2: NVRAM, 16M */
+	>;
+
+	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <36>;
+		gpmc,cs-wr-off-ns = <36>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <24>;
+		gpmc,adv-wr-off-ns = <36>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <30>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <48>;
+		gpmc,access-ns = <54>;
+		gpmc,rd-cycle-ns = <72>;
+		gpmc,wr-cycle-ns = <72>;
+
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+
+		gpmc,wr-access-ns = <30>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+        nvram: nor@2,0 { /* NVRAM Device 128k */
+		reg = <2 0 0x1000000>;
+
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+
+		gpmc,cs-on-ns = <12>;
+		gpmc,cs-rd-off-ns = <54>;
+		gpmc,cs-wr-off-ns = <30>;
+
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <54>;
+		gpmc,adv-wr-off-ns = <30>;
+
+		gpmc,oe-on-ns = <12>;
+		gpmc,oe-off-ns = <54>;
+
+		gpmc,we-on-ns = <12>;
+		gpmc,we-off-ns = <30>;
+
+		gpmc,rd-cycle-ns = <54>;
+		gpmc,wr-cycle-ns = <30>;
+
+		gpmc,access-ns = <48>;
+
+		gpmc,wr-access-ns = <18>;
+		gpmc,wr-data-mux-bus-ns = <12>;
+
+		gpmc,time-para-granularity;
+		gpmc,mux-add-data = <2>; /* address-data multiplexing mode */
+
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wait-on-read = "false";
+		gpmc,wait-on-write = "false";
+
+		gpmc,cycle2cycle-delay-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&usbhshost {
+	status = "disabled";
+};
+
+&aes {
+	status = "disabled";
+};
+
+&sham {
+	status = "disabled";
+};
+
+&gpio3 {
+	ti,no-reset-on-init;
+};
+
+/include/ "pxc-nandparts.dtsi"
diff --git a/arch/arm/boot/dts/wago-pfc200v2-dcan.dtsi b/arch/arm/boot/dts/wago-pfc200v2-dcan.dtsi
new file mode 100644
index 0000000..b478a507
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200v2-dcan.dtsi
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+&am33xx_pinmux {
+	dcan0_pins: pinmux_dcan0_pins {
+		pinctrl-single,pins = <
+			0x11c (PIN_OUTPUT_PULLDOWN	| MUX_MODE1)	/* mii1_txd3.dcan0_tx (gpio0_16) */    //j18
+			0x120 (PIN_INPUT_PULLDOWN	| MUX_MODE1)	/* mii1_txd2.dcan0_rx (gpio0_17) */    //k15
+		>;
+	};
+};
+
+&dcan0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&dcan0_pins>;
+};
diff --git a/arch/arm/boot/dts/wago-pfc200v2-netx.dtsi b/arch/arm/boot/dts/wago-pfc200v2-netx.dtsi
new file mode 100644
index 0000000..367c270
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200v2-netx.dtsi
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/ {
+	uio_netx_dma_fb_asic@8000000 {
+		compatible = "uio_pdrv_genirq";
+		pinctrl-names = "default";
+		pinctrl-0 = <&netx_pins>;
+		status = "okay";
+
+		reg = <0x04000000 0x40000>; /* 256k (min: 64k, max: 256k) */
+
+		/* gpio0_19: DMA-FB-ASIC  */
+		interrupt-parent = <&gpio0>;
+		interrupts = <19 IRQ_TYPE_EDGE_FALLING>; /* IRQ_TYPE_EDGE_RISING? */
+	};
+};
+
+&am33xx_pinmux {
+	netx_pins: pinmux_netx_pins {
+		pinctrl-single,pins = <
+			0x078 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE2)	/* gpmc_ben1.gpmc_csn6 (gpio1_28) */		//u18
+			0x138 (PIN_OUTPUT_PULLDOWN 	| MUX_MODE1)   	/* mii1_rxd2.uart3_txd (gpio2_19), syncro-mode */   //l16
+			0x134 (PIN_INPUT_PULLDOWN	| MUX_MODE1)	/* mii1_rxd3.uart3_rxd (gpio2_18), dpsync      */   //l17
+			0x1b0 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* xdma_event_intr0.gpio0_19, DMA-FB-ASIC      */   //a15
+			0x0d8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7)   	/* lcd_data14.gpio0_10 (gpio0_10), nRST-FB   */   //v4
+		>;
+	};
+};
+
+&wsysinit {
+	dp,reset;
+	dp,gpio-rst = <&gpio0 10 GPIO_ACTIVE_LOW>; /* nRST-FB */
+};
+
+&gpmc {
+        netX51: nor@6,0 {	/* FIXME: Timings are to be updated!!! */
+		reg = <6 0 0x40000>; /* 256k (min: 64k, max: 256k) */
+		bank-width = <2>;    /* 16bit Device (2 Bytes) */
+
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <150>;
+		gpmc,cs-wr-off-ns = <70>;
+
+		gpmc,adv-on-ns = <0>;
+		gpmc,adv-rd-off-ns = <0>;
+		gpmc,adv-wr-off-ns = <0>;
+
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <150>;
+
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <70>;
+
+		gpmc,rd-cycle-ns = <150>;
+		gpmc,wr-cycle-ns = <70>;
+
+		gpmc,access-ns = <130>;
+		gpmc,wr-access-ns = <50>;
+
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		gpmc,cycle2cycle-delay-ns = <20>;
+		gpmc,cycle2cycle-samecsen;
+		gpmc,cycle2cycle-diffcsen;
+
+		/* gpmc,time-para-granularity; */
+		gpmc,mux-add-data = <0>; 		/* non-multiplexing mode */
+
+		gpmc,clk-activation-ns = <0>;	/* First rising edge of GPMC_CLK at start access time */
+		gpmc,wait-monitoring-ns = <0>; 	/* =1, WAIT pin is monitored one GPMC_CLK cycle before valid data */
+
+		gpmc,wait-pin = <0>;			/* WAIT input pin is WAIT0 */
+		gpmc,wait-on-read = "false";		/* =true */
+		gpmc,wait-on-write = "false";
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
diff --git a/arch/arm/boot/dts/wago-pfc200v2-setupfw.dts b/arch/arm/boot/dts/wago-pfc200v2-setupfw.dts
new file mode 100644
index 0000000..afaee78
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200v2-setupfw.dts
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "wago-pfc200v2.dtsi"
+#include "wago-pfc100-uart1.dtsi"
+#include "wago-pfc200v2-netx.dtsi"
+#include "wago-pfc200v2-dcan.dtsi"
+
+/*
+ *
+ *   DEVCONF: 0x004E
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  |  x  x  |  |  |  x
+ *                                    |        |  |  CAN
+ *                                    |        |  RS232_485
+ *                                    |        ETHERNET_IP
+ *                                    PROFIBUS_DPM
+ *
+ */
+
+/*
+ * The devconf variable is a 16bit value.
+ * Data is stored in little endian format.
+ *
+ * 0x1fe |---------------------------------------|
+ *       |          DEVCONF Byte 0 (Low Byte)    |
+ *       | ------------------------------------- |
+ *       |          DEVCONF Byte 1 (High Byte)   |
+ * 0x200 |---------------------------------------|
+ *
+ *   15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
+ *    |   |   |   |   |   |  |  |  |  |  |  |  |  |  |  |
+ *    x   x   x   x   x   x  x  x  x  |  |  |  |  |  |  PROFIBUS_SL
+ *                                    |  |  |  |  |  CAN
+ *                                    |  |  |  |  RS232_485
+ *                                    |  |  |  ETHERNET_IP
+ *                                    |  |  3G_MODEM
+ *				      |	 DIP_SWITCH
+ *                                    PROFIBUS_DPM
+ *
+ *   x: reserved for future use
+ *
+ */
+
+/ {
+	target_info {
+		/*
+		 * maybe we should change the drivers name
+		 * to something like "wago,information" ??
+		*/
+		compatible = "wago,testenv";
+
+		board_info {
+			model = "pfc200v2";
+			id = "750-82xx";
+		};
+
+		led_info {
+			/* conforms to led order on device, see node "pca9552@60".
+			 * we assume, that every led has to colors (red, green).
+			 * so we only allow the colors red,green,orange
+			 */
+			led_array_red = "u1:u2:u3:u4:dia:bf:sys:run:io:ms:ns:can";
+		};
+	};
+};
+
+&uart1 {
+	/* uart1 disabled for cmtest gpio test */
+	status = "disabled";
+};
+
+&oms {
+	/* disable oms driver for cmtest gpio test */
+	status = "disabled";
+};
diff --git a/arch/arm/boot/dts/wago-pfc200v2.dtsi b/arch/arm/boot/dts/wago-pfc200v2.dtsi
new file mode 100644
index 0000000..54b1483
--- /dev/null
+++ b/arch/arm/boot/dts/wago-pfc200v2.dtsi
@@ -0,0 +1,927 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <dt-bindings/interrupt-controller/irq.h>
+#include "am33xx.dtsi"
+
+/* Varianten beim PFC100
+ *
+ * 750-8101: 2ETH, DIP
+ * 750-8102: 2ETH, RS232/485
+ *
+ */
+
+
+/ {
+	model = "WAGO PFC200 DPM";
+	compatible = "wago,pfc200", "ti,am33xx";
+
+	cpus {
+		cpu@0 {
+			cpu0-supply = <&dcdc4_reg>;
+
+			/*
+			 * To consider voltage drop between PMIC and SoC,
+			 * tolerance value is reduced to 2% from 4% and
+			 * voltage value is increased as a precaution.
+			 */
+			operating-points = <
+				/* kHz    uV */
+				1000000  1325000
+				 800000  1260000
+				 720000  1200000
+				 600000  1100000
+				 300000  950000
+			>;
+		};
+	};
+
+	aliases {
+		mdio-gpio0 = &bitbang_mdio0;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x10000000>; /* 256 MB */
+	};
+
+
+	vxe164_reg: fixedregulator@0 {	/* XE164 +3V3  System voltage */
+		compatible = "regulator-fixed";
+		regulator-name = "vxe164";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dcdc4_reg>;
+	};
+
+	vsd_reg: fixedregulator@1 {		/* SD Card +3V3 Systemvoltage over power switch */
+		compatible = "regulator-fixed";
+		regulator-name = "v_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+                vin-supply = <&dcdc4_reg>;
+	};
+
+	ksz8863 {
+		compatible = "micrel,ksz8863";
+		pinctrl-names = "default";
+		pinctrl-0 = <&ksz8863_pins>;
+		status = "okay";
+
+		ksz,reset-switch;
+		ksz,gpio-reset = <&gpio3 10 GPIO_ACTIVE_LOW>;
+		ksz,disable-internal-ldo;
+		ksz,mii-bus = <&bitbang_mdio0>;
+	};
+
+	UIO_NVRAM@0x1000000 {
+		compatible = "uio_pdrv_genirq";
+		reg = <0x1000000 0x20000>;  /* 128k 16bit NVRAM */
+	};
+
+        wsysinit: wsysinit_init {
+		compatible = "wago,sysinit";
+		add-sysfs-entries;
+
+		tty,service   = "ttyO0";
+		tty,rs232-485 = "ttyO1";
+
+		board,variant = "pfc200v2";
+
+		/* sysclock adjustments,
+		   empirical values */
+		adjtimex,tick = <10000>;
+		adjtimex,frequency = <2000000>;
+	};
+
+	/*
+	   this name of the gpio-keys device is a
+	   historical heritage from 3.6.11 kernel.
+	   the device-name is checked in omsd. So we
+	   need to adapt this configuration
+	*/
+	oms: PAC-Operating-Mode-Switch {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+
+		run {
+			label = "RUN";
+			gpios = <&gpio3 18 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 114 */
+			linux,code = <1>;
+			linux,input-type = <5>;  /* EV_SW */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		stop {
+			label = "STOP";
+			gpios = <&gpio3 17 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 113 */
+			linux,code = <2>;
+			linux,input-type = <5>;  /* EV_SW */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		reset {
+			label = "RESET";
+			gpios = <&gpio3 16 GPIO_ACTIVE_LOW>; /* BAS_RUN GPIO 112 */
+			linux,code = <3>;
+			linux,input-type = <1>;  /* EV_KEY */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+		reset_all {
+			label = "RESET_ALL";
+			gpios = <&gpio3 15 GPIO_ACTIVE_HIGH>; /* BAS_RUN GPIO 111 */
+			linux,code = <4>;
+			linux,input-type = <1>;  /* EV_KEY */
+			debounce-interval = <1>; /* debounce ticks interval in msecs */
+		};
+
+	};
+
+	dsa@0 {
+		compatible = "marvell,dsa";
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* interrupts = <10>; --> not supported from the driver! */
+
+		/* master netdevice (eth0) */
+		dsa,ethernet = <&mac>; /* TODO: should we use 'cpsw_emac1' instead? */
+		dsa,mii-bus = <&bitbang_mdio0>;
+
+		switch@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <16 0>;	/* MDIO address 16, switch 0 in tree */
+
+			port@0 {
+				reg = <2>;        /* phys are twisted on hw */
+				label = "ethX1";
+				phy-handle = <&phy2>;
+				phy-pwrdown;
+			};
+
+			port@1 {
+				reg = <1>;
+				label = "ethX2";
+				phy-handle = <&phy1>;
+				phy-pwrdown;
+			};
+
+			port@2 {
+				reg = <3>;
+				label = "cpu";
+			};
+		};
+	};
+
+	watchdog: watchdog {
+		/* XC6124 */
+		compatible = "linux,wdt-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&watchdog_pins>;
+
+		gpio-en = <&gpio3 7 GPIO_ACTIVE_LOW>;
+		gpios = <&gpio3 8 GPIO_ACTIVE_LOW>;
+
+		hw_algo = "toggle";
+		hw_margin_ms = <1600>;
+		status = "okay";
+	};
+};
+
+&uart0 { /* debug interface over JTAG Connector */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&uart1 {
+	status = "disabled";
+};
+
+&uart4 { /* KBUS Firmware download */
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4_pins>;
+	status = "okay";
+};
+
+&elm {
+	status = "okay";
+};
+
+&gpmc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpmc_pins>;
+
+	num-cs = <7>;	/* only two devices */
+	num-waitpins = <3>;
+	status = "okay";
+	ranges = <
+		0 0 0x00000000 0x01000000	/* CS0: NAND, 16M */
+		1 0 0x01000000 0x01000000	/* CS1: NVRAM, 16M */
+		6 0 0x04000000 0x01000000	/* CS6: NETX/DPC31, 16M */
+	>;
+
+	nand: nand@0,0 {
+		reg = <0 0 0>; /* CS0, offset 0 */
+		nand-bus-width = <8>;
+		ti,nand-ecc-opt = "bch8";
+		gpmc,device-nand = "true";
+		gpmc,device-width = <1>;
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <44>;
+		gpmc,cs-wr-off-ns = <44>;
+		gpmc,adv-on-ns = <6>;
+		gpmc,adv-rd-off-ns = <34>;
+		gpmc,adv-wr-off-ns = <44>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <40>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <54>;
+		gpmc,access-ns = <64>;
+		gpmc,rd-cycle-ns = <82>;
+		gpmc,wr-cycle-ns = <82>;
+		gpmc,wait-pin = <0>;
+		gpmc,wait-on-read = "true";
+		gpmc,wait-on-write = "true";
+		gpmc,bus-turnaround-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <0>;
+		gpmc,clk-activation-ns = <0>;
+		gpmc,wait-monitoring-ns = <0>;
+		gpmc,wr-access-ns = <40>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ti,elm-id = <&elm>;
+	};
+
+        nvram: nor@1,0 { /* NVRAM Device 128k */
+		reg = <1 0 0x1000000>;
+
+		bank-width = <2>; /* 1: 8bit, 2: 16bit */
+		gpmc,sync-clk-ps = <0>;
+		gpmc,cs-on-ns = <0>;
+		gpmc,cs-rd-off-ns = <50>;
+		gpmc,cs-wr-off-ns = <30>;
+		gpmc,adv-on-ns = <0>;
+		gpmc,adv-rd-off-ns = <0>;
+		gpmc,adv-wr-off-ns = <0>;
+		gpmc,oe-on-ns = <0>;
+		gpmc,oe-off-ns = <50>;
+		gpmc,we-on-ns = <0>;
+		gpmc,we-off-ns = <30>;
+		gpmc,rd-cycle-ns = <50>;
+		gpmc,wr-cycle-ns = <30>;
+		gpmc,access-ns = <40>;
+		gpmc,wr-access-ns = <10>;
+		gpmc,wr-data-mux-bus-ns = <0>;
+		gpmc,cycle2cycle-delay-ns = <10>;
+		gpmc,cycle2cycle-samecsen;
+		gpmc,cycle2cycle-diffcsen;
+		gpmc,wait-on-read = "false";
+		gpmc,wait-on-write = "false";
+
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+/* for pin mux offset calc: doc_offset - 0x800h = dts-offset */
+&am33xx_pinmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <
+		&rmii1_reserved_pins
+	>;
+
+	rmii1_reserved_pins: pinmux_XXX_pins {
+		pinctrl-single,pins = <
+			/* reserved, not yet used (RMII1) */
+			0x114 (PIN_OUTPUT_PULLDOWN 	| MUX_MODE1) 	/* mii1_txen.rmii1_txen (gpio3_3)                */   //j16
+			0x128 (PIN_OUTPUT_PULLDOWN 	| MUX_MODE1) 	/* mii1_txd0.rmii1_txd0 (gpio0_28)               */   //k17
+			0x124 (PIN_OUTPUT_PULLDOWN 	| MUX_MODE1) 	/* mii1_txd1.rmii1_txd1 (gpio0_21)               */   //k16
+			0x140 (PIN_INPUT_PULLDOWN 	| MUX_MODE1)	/* mii1_rxd0.rmii1_rxd0 (gpio2_21)               */   //m16
+			0x13c (PIN_INPUT_PULLDOWN 	| MUX_MODE1)	/* mii1_rxd1.rmii1_rxd1 (gpio2_20)               */   //l15
+			0x08C (PIN_OUTPUT_PULLDOWN 	| MUX_MODE7)	/* gpmc_clk.gpio2_1 (gpio2_1), rmii1.en/ETH-RST     */   //v12
+			0x044 (PIN_INPUT_PULLDOWN       | MUX_MODE7)	/* gpmc_a1.gpio1_17 (gpio1_17), rmii1.nint/ETH-INTR */   //v14
+			0x144 (PIN_INPUT          	| MUX_MODE0)	/* rmii1_ref_clk.rmii1_refclk (gpio0_29)         */   //h18
+			0x10c (PIN_INPUT_PULLDOWN	| MUX_MODE1)	/* mii1_crs.rmii1_crs_dv (gpio3_1)         */   //h17
+			0x110 (PIN_INPUT_PULLDOWN 	| MUX_MODE1) 	/* mii1_rxerr.rmii1_rxerr (gpio3_2)        */	//j15
+		>;
+	};
+
+	watchdog_pins: pinmux_watchdog_pins {
+		pinctrl-single,pins = <
+			0x1e4 (PIN_OUTPUT_PULLDOWN 	| MUX_MODE7)	/* emu0.gpio3_7 (gpio3_7), nen-wdg           */   //c14
+			0x1e8 (PIN_OUTPUT_PULLDOWN 	| MUX_MODE7)	/* emu1.gpio3_8 (gpio3_8), trig-wdg          */   //b14
+		>;
+	};
+
+	uart0_pins: pinmux_uart0_pins { /* debug interface over JTAG Connector */
+		pinctrl-single,pins = <
+			0x170 (PIN_INPUT_PULLUP		| MUX_MODE0)  	                /* uart0_rxd.uart0_rxd */ 		//e15
+			0x174 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)  	/* uart0_txd.uart0_txd */		//e16
+		>;
+	};
+
+	uart4_pins: pinmux_uart4_pins { /* KBUS firmware download / handshake */
+		 pinctrl-single,pins = <
+			0x168 (PIN_INPUT_PULLUP		| MUX_MODE1)  	                /* uart0_ctsn.uart4_rxd */ 		//e18
+			0x16c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE1)  	/* uart0_rtsn.uart4_txd */		//e17
+		 >;
+	};
+
+	spi0_pins: pinmux_spi0_pins { /* KBUS data communication */
+		pinctrl-single,pins = <
+			0x150 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_sclk.spio_sclk */ 	//a17
+			0x154 (PIN_INPUT_PULLUP		| MUX_MODE0)	                /* spi0_d0.spi0.d0     */	//b17 miso
+			0x158 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_d1spi0.d1      */	//b16 mosi
+			0x15c (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE0)	/* spi0_cs0.spi0_cs0   */	//a16 cs
+		>;
+	};
+
+	i2c0_pins: pinmux_i2c0_pins { /* PMIC, RTC, LED-GPIO-Expander, EEPROM */
+		pinctrl-single,pins = <
+			0x188 (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_sda.i2c0_sda */		//c17
+			0x18c (PIN_INPUT_PULLUP		| SLEWCTRL_SLOW	| MUX_MODE0)	/* i2c0_scl.i2c0_scl */		//c16
+		>;
+	};
+
+	mmc1_pins: pinmux_mmc1_pins {
+		 pinctrl-single,pins = <
+			0x104 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_cmd.mmc0_cmd   */	//g18
+			0x100 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_clk.mmc0_clk   */	//g17
+			0x0fc (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat0.mmc0_dat0 */	//g16
+			0x0f8 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat1.mmc0_dat1 */	//g15
+			0x0f4 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat2.mmc0_dat2 */	//f18
+			0x0f0 (PIN_INPUT_PULLUP 	| SLEWCTRL_FAST	| MUX_MODE0)    /* mmc0_dat3.mmc0_dat3 */	//f17
+			0x190 (PIN_INPUT_PULLUP 	| MUX_MODE7)  	                /* mcasp0_aclkx.mmc0_sdcd */    //a13
+			0x164 (PIN_INPUT_PULLDOWN 	| MUX_MODE5)	                /* ecap0_in_pwm0_out.mmc0_sdwp (gpio0_7)    */   //c18
+		 >;
+	};
+
+	gpmc_pins: pinmux_gpmc_pins { // 16x data and 19x address and 8x control   // NAND 8-bit on cs0   and NvRAM 16-bit on cs1
+		pinctrl-single,pins = <
+			//data
+			0x000 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad0.gpmc_ad0 */		//u7
+			0x004 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad1.gpmc_ad1 */		//v7
+			0x008 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad2.gpmc_ad2 */		//r8
+			0x00c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad3.gpmc_ad3 */		//t8
+			0x010 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad4.gpmc_ad4 */		//u8
+			0x014 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad5.gpmc_ad5 */		//v8
+			0x018 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad6.gpmc_ad6 */		//r9
+			0x01c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad7.gpmc_ad7 */		//t9
+			0x020 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad8.gpmc_ad8 */		//u10
+			0x024 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad9.gpmc_ad9 */		//t10
+			0x028 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad10.gpmc_ad10 */	//t11
+			0x02c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad11.gpmc_ad11 */	//u12
+			0x030 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad12.gpmc_ad12 */	//t12
+			0x034 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad13.gpmc_ad13 */	//r12
+			0x038 (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad14.gpmc_ad14 */	//v13
+			0x03c (PIN_INPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ad15.gpmc_ad15 */	//u13
+			//address
+			0x0A0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data0.gpmc_a0 */		//r1
+			0x0A4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data1.gpmc_a1 */		//r2
+			0x0A8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data2.gpmc_a2 */		//r3
+			0x0AC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data3.gpmc_a3 */		//r4
+			0x0B0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data4.gpmc_a4 */		//t1
+			0x0B4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data5.gpmc_a5 */		//t2
+			0x0B8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data6.gpmc_a6 */		//t3
+			0x0BC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data7.gpmc_a7 */		//t4
+			0x0E0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_vsync.gpmc_a8 */		//u5
+			0x0E4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_hsync.gpmc_a9 */		//r5
+			0x0E8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_pclk.gpmc_a10 */		//v5
+			0x0EC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_ac_bias_en.gpmc_a11 */   //r6
+			0x0C0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data8.gpmc_a12 */	//u1
+			0x0C4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data9.gpmc_a13 */	//u2
+			0x0C8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data10.gpmc_a14 */	//u3
+			0x0CC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data11.gpmc_a15 */	//u4
+			0x0D0 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data12.gpmc_a16 */	//v2
+			0x0D4 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data13.gpmc_a17 */	//v3
+			//0x0D8 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data14.gpmc_a18 */	//v4
+			0x0DC (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE1)	/* lcd_data15.gpmc_a19 */	//t5
+			//control
+			0x09c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_ben0_cle.gpmc_be0n_cle */	//t6
+			0x090 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_advn_ale.gpmc_advn_ale */	//r7
+			0x094 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_oen_ren.gpmc_oen_ren */		//t7
+			0x098 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE0)	/* gpmc_wen.gpmc_wen */				//u6
+			0x07c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn0.gpmc_csn0 */			//v6
+			0x080 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE0)	/* gpmc_csn1.gpmc_csn1 */			//u9
+			0x084 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE1)	/* gpmc_csn2.gpmc_be1n */			//v9
+			0x070 (PIN_INPUT_PULLUP	 	| MUX_MODE0)	/* gpmc_wait0.gpmc_wait0 */			//t17
+			//0x08C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* gpmc_clk.gpio2_1 */				//v12
+		>;
+	};
+
+	ksz8863_pins: pinmux_ksz8863_pins {
+		pinctrl-single,pins = <
+			0x130 (PIN_OUTPUT_PULLDOWN 	| MUX_MODE7)	/* mii1_rx_clk.gpio3_10  (gpio3_10), rmii2.en/Reset    */   //l18
+			0x160 (PIN_INPUT_PULLDOWN       | MUX_MODE7)    /* spi0_cs1.gpio0_6       (gpio0_6), rmii2.nint/Int    */   //c15
+		>;
+	};
+
+	cpsw_default_pins: pinmux_cpsw_default_pins {// RMII2 Ethernet Switch
+		pinctrl-single,pins = <
+			0x040 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a0.rmii2_txen */		//r13
+            0x050 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a4.rmii2_txd1 */		//r14
+            0x054 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_FAST	| MUX_MODE3) 	/* gpmc_a5.rmii2_txd0 */		//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a10.rmii2_rxd1 */		//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_a11.rmii2_rxd0 */		//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE3)  	/* gpmc_wpn.rmii2_rxer */		//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE1)  	/* mii1_col.rmii2_refclk */		//h16
+            0x088 (PIN_INPUT          	| MUX_MODE2)  	/* gpmc_csn3.rmii2_crs_dv */	//t13
+		>;
+	};
+
+	cpsw_sleep_pins: pinmux_cpsw_sleep_pins {
+		pinctrl-single,pins = <
+			0x040 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a0.gpio1_16 */			//r13
+            0x050 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a4.gpio1_20 */			//r14
+            0x054 (PIN_INPUT_PULLDOWN 	| MUX_MODE7) 	/* gpmc_a5.gpio1_21 */			//v15
+            0x068 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a10.gpio1_26 */			//t16
+            0x06C (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_a11.gpio1_27 */			//v17
+            0x074 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_wpn.gpio0_31 */			//u17
+            0x108 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* mii1_col.gpio3_0 */			//h16
+            0x088 (PIN_INPUT_PULLDOWN 	| MUX_MODE7)  	/* gpmc_csn3.gpio2_0 */			//t13
+		>;
+	};
+
+	gpio_bitbang_mdio_pins: pinmux_gpio_bitbang_mdio_pins {
+		pinctrl-single,pins = <
+			/* MDIO */
+			0x148 (PIN_INPUT_PULLUP | SLEWCTRL_FAST | MUX_MODE7)	/* M17: mdio.gpio0_0 (mdio_data), SLEWCTRL_FAST?? */
+			0x14c (PIN_OUTPUT_PULLUP | MUX_MODE7)			/* M18:  mdc.gpio0_1 (mdio_clk)                   */
+		>;
+	};
+
+	gpio_bitbang_mdio_sleep_pins: pinmux_gpio_bitbang_mdio_sleep_pins {
+		pinctrl-single,pins = <
+			/* MDIO reset value */
+			0x148 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mdio.gpio0_0 */				//m17
+			0x14c (PIN_INPUT_PULLDOWN 	| MUX_MODE7)	/* mdc.gpio0_1   */				//m18
+		>;
+	};
+
+	kbus_pins: pinmux_kbus_pins {
+		pinctrl-single,pins = <
+			0x05C (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7)    /* gpmc_a7.gpio1_23 */		//t15	NIRQ
+			0x064 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a9.gpio1_25 */		//u16	NRST
+			0x060 (PIN_OUTPUT_PULLUP	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a8.gpio1_24 */		//v16	CMDSEL
+			0x1b4 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* xdma_event_intr1.gpio0_20 */	//d14	nRDY
+			0x058 (PIN_INPUT_PULLUP 	| MUX_MODE7) 	                /* gpmc_a6.gpio1_22 */		//u15	NSYNC
+
+			/* Error Pin */
+			0x12c (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mii1_tx_clk.gpio3_9 (gpio3_9), kbus.nerr */   //k18
+
+			/* All Error State Pins were removed! (not used by the driver) */
+		>;
+	};
+
+	gsm_pins: pinmux_gsm_pins {
+		pinctrl-single,pins = <
+			0x04c (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a3.gpio1_19 */			//t14	3G-PWR-KEY
+			0x048 (PIN_OUTPUT_PULLDOWN 	| SLEWCTRL_SLOW	| MUX_MODE7) 	/* gpmc_a2.gpio1_18 */			//u14	3G-Reset
+		>;
+	};
+
+	gpio3_pins: pinmux_gpio3_pins {
+		pinctrl-single,pins = <
+			0x194 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_fsx.gpio3_15    */	//b13  	RESET-ALL-BUT
+			0x198 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_axr0.gpio3_16   */	//d12	nRST-BAS
+			0x19c (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_ahclkr.gpio3_17 */	//c12	nSTOP-BAS
+			0x1A0 (PIN_INPUT		| MUX_MODE7) 	/* mcasp0_aclkr.gpio3_18  */	//b12  	nRUN-BAS
+			0x1A8 (PIN_INPUT_PULLUP 	| MUX_MODE7)	/* mcasp0_axr1.gpio3_20 /  */	//d13	nINT-PMIC
+			0x1Ac (PIN_INPUT_PULLUP 	| MUX_MODE7) 	/* mcasp0_ahclkx.gpio3_21  */	//a14	nINT-RTC
+		>;
+	};
+};
+
+&cppi41dma {
+	status = "okay";
+};
+
+&gpio3 { /* BAS, Button, Interrupt RTC & PMIC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&gpio3_pins>;
+};
+
+&spi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+	spi-rt;
+	spi-rt-prio = <81>;
+
+	kbus0: kbus@0 {	/* KBUS on cs0 */
+		compatible = "wago,spi-kbus";
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&kbus_pins>;
+		reg = <0>;
+		spi-max-frequency = <10000000>; /* FIXME */
+		kbus,dma-boost; /* this enables dma boosting */
+		kbus,dma-boost-prio   = <85>;
+		kbus,dma-boost-irq-thread = "irq/19-edma";
+		kbus,dma-default-prio = <50>;
+
+		/*
+		 * announce used tty-device in /sys/class/wago/system.
+		 * is needed to link this device to /dev/ttyKbus
+		 */
+		kbus,tty-device = "ttyO4"; /* corresponds to &uart4*/
+
+		/* some should be active low, keep all to high for compatibility reasons */
+		kbus,gpio-nrst   = <&gpio1 25 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nsync  = <&gpio1 22 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-cmdsel = <&gpio1 24 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nirq   = <&gpio1 23 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nerr   = <&gpio3  9 GPIO_ACTIVE_HIGH>;
+		kbus,gpio-nrdy   = <&gpio0 20 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&i2c0 {
+        status = "okay";
+        clock-frequency = <400000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&i2c0_pins>;
+
+        pca9552@60 {
+                compatible = "nxp,pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+                reg = <0x60>;
+
+		sys-red@0 {
+		      label = "sys-red";
+		      reg = <0>;
+		      linux,default-trigger = "timer";
+		};
+
+		sys-green@1 {
+		      label = "sys-green";
+		      reg = <1>;
+		      linux,default-trigger = "timer";
+		};
+
+		run-red@2 {
+		      label = "run-red";
+		      reg = <2>;
+		      linux,default-trigger = "none";
+		};
+
+		run-green@3 {
+		      label = "run-green";
+		      reg = <3>;
+		      linux,default-trigger = "none";
+		};
+
+		io-red@4 {
+		      label = "io-red";
+		      reg = <4>;
+		      linux,default-trigger = "none";
+		};
+
+		io-green@5 {
+		      label = "io-green";
+		      reg = <5>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-red@6 {
+		      label = "ms-red";
+		      reg = <6>;
+		      linux,default-trigger = "none";
+		};
+
+		ms-green@7 {
+		      label = "ms-green";
+		      reg = <7>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-red@8 {
+		      label = "ns-red";
+		      reg = <8>;
+		      linux,default-trigger = "none";
+		};
+
+		ns-green@9 {
+		      label = "ns-green";
+		      reg = <9>;
+		      linux,default-trigger = "none";
+		};
+
+		can-red@10 {
+		      label = "can-red";
+		      reg = <10>;
+		      linux,default-trigger = "none";
+		};
+
+		can-green@11 {
+		      label = "can-green";
+		      reg = <11>;
+		      linux,default-trigger = "none";
+		};
+
+		/* this will switch of the sys-red led during startup */
+		sys-over-red@15 {
+		      label = "sys-over-red";
+		      reg = <15>;
+		      linux,default-trigger = "default-on";
+                };
+        };
+
+        pca9552@61 {
+                compatible = "nxp,pca9552";
+		#address-cells = <1>;
+		#size-cells = <0>;
+                reg = <0x61>;
+
+		bf-red@0 {
+		      label = "bf-red";
+		      reg = <0>;
+		      linux,default-trigger = "none";
+		};
+
+		bf-green@1 {
+		      label = "bf-green";
+		      reg = <1>;
+		      linux,default-trigger = "none";
+		};
+
+		dia-red@2 {
+		      label = "dia-red";
+		      reg = <2>;
+		      linux,default-trigger = "none";
+		};
+
+		dia-green@3 {
+		      label = "dia-green";
+		      reg = <3>;
+		      linux,default-trigger = "none";
+		};
+
+		u4-red@4 {
+		      label = "u4-red";
+		      reg = <4>;
+		      linux,default-trigger = "none";
+		};
+
+		u4-green@5 {
+		      label = "u4-green";
+		      reg = <5>;
+		      linux,default-trigger = "none";
+		};
+
+		u3-red@6 {
+		      label = "u3-red";
+		      reg = <6>;
+		      linux,default-trigger = "none";
+		};
+
+		u3-green@7 {
+		      label = "u3-green";
+		      reg = <7>;
+		      linux,default-trigger = "none";
+		};
+
+		u2-red@8 {
+		      label = "u2-red";
+		      reg = <8>;
+		      linux,default-trigger = "none";
+		};
+
+		u2-green@9 {
+		      label = "u2-green";
+		      reg = <9>;
+		      linux,default-trigger = "none";
+		};
+
+		u1-red@10 {
+		      label = "u1-red";
+		      reg = <10>;
+		      linux,default-trigger = "none";
+		};
+
+		u1-green@11 {
+		      label = "u1-green";
+		      reg = <11>;
+		      linux,default-trigger = "none";
+		};
+        };
+
+        at24cs128n {
+                compatible = "atmel,24c512";
+                reg = <0x54>;
+
+		pagesize = <128>;
+        };
+
+        rtc_r2221t {
+                compatible = "ricoh,r2221tl";
+                reg = <0x32>;
+
+		interrupt-parent = <&gpio3>;
+		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;
+        };
+
+        tps: tps65218@24 {
+                compatible = "ti,tps65218";
+                reg = <0x24>;
+        };
+};
+
+&mac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&cpsw_default_pins>;
+	pinctrl-1 = <&cpsw_sleep_pins>;
+	mac_control = <0x18021>; /* force 100MBit full-duplex */
+	active_slave = <1>;
+	status = "okay";
+};
+
+&bitbang_mdio0 {
+       status = "okay";
+       pinctrl-names = "default", "sleep";
+       pinctrl-0 = <&gpio_bitbang_mdio_pins>;
+       pinctrl-1 = <&gpio_bitbang_mdio_sleep_pins>;
+       gpios = <&gpio0 1 0	/* 0: mdc  */
+		&gpio0 0 0>;   	/* 1: mdio */
+
+       phy1: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+       };
+
+       phy2: ethernet-phy@2 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <2>;
+       };
+};
+
+/*
+ * Use a fixed phy for emac1.
+ * that's rgmii2
+ */
+&cpsw_emac1 {
+	phy-mode = "rmii";
+	fixed-link {
+		speed = <100>;
+		full-duplex;
+	};
+};
+
+&phy_sel {
+	rmii-clock-ext;
+};
+
+&tps {
+        interrupts = <47>;
+        interrupt-parent = <&intc>;
+        compatible = "ti,tps65218";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+
+        dcdc1_reg: regulator-dcdc1 {
+                 compatible = "ti,tps65218-dcdc1";
+                /* VDD_CORE +1V1-CORE voltage limits */
+                regulator-name = "vdd_CORE";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc2_reg: regulator-dcdc2 {
+                 compatible = "ti,tps65218-dcdc2";
+                /* VDD_MPU +1V1-MPU voltage limits */
+                regulator-name = "vdd_MPU";
+                regulator-min-microvolt = <1100000>;
+                regulator-max-microvolt = <1100000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc3_reg: regulator-dcdc3 {
+                 compatible = "ti,tps65218-dcdc3";
+                /* VDD_DDR +1V5-DDR voltage limits */
+                regulator-name = "vdd_DDR";
+                regulator-min-microvolt = <1500000>;
+                regulator-max-microvolt = <1500000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+
+        dcdc4_reg: regulator-dcdc4 {
+                 compatible = "ti,tps65218-dcdc4";
+                /* VDD_LOGIC +3V3 voltage limits */
+                regulator-name = "vdd_LOGIC";
+                regulator-min-microvolt = <3300000>;
+                regulator-max-microvolt = <3300000>;
+                regulator-boot-on;
+                regulator-always-on;
+        };
+		/*
+		dcdc1_sw:	dcdcswitch-dcdc1{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_SD +3V3-SD voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-on;
+		*/
+
+		/*
+		dcdc2_sw:	dcdcswitch-dcdc2{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_USB +5V0-USB voltage
+                dcdcswitch-name = "vdd_SD";
+                dcdcswitch-min-microvolt = <4750000>;
+                dcdcswitch-max-microvolt = <5250000>;
+                dcdcswitch-boot-off;
+		*/
+
+		/*
+		dcdc3_sw:	dcdcswitch-dcdc3{
+                 compatible = "ti,tps65218-dcdc4";
+                // VDD_LS +3V3-LS voltage not used in PFC100
+                dcdcswitch-name = "vdd_Last";
+                dcdcswitch-min-microvolt = <3300000>;
+                dcdcswitch-max-microvolt = <3300000>;
+                dcdcswitch-boot-off;
+		*/
+        config2_reg: regulator-config2 {
+                 compatible = "ti,tps65218-config2";
+                /* VDD_Logic current set to 1 Ampere*/
+                regulator-name = "vdd_CONFIG2";
+                regulator-min-microamp = <1000000>;/*TODO*/
+                regulator-max-microamp = <1000000>;/*TODO in drivers/regulator/tps65218-regulator.c */
+                regulator-boot-on;
+                regulator-always-on;
+        };
+        ldo1: regulator-ldo1 {	//VDD-PLL  +1V8
+                compatible = "ti,tps65218-ldo1";
+                regulator-name = "ldo1";
+                regulator-always-on;
+        };
+};
+
+/* do we need this ?? */
+&tscadc {
+	adc {
+		//AIN0 	= +5V0 Local Bus voltage	pmic-in
+		//AIN1	= +3V3  IO system voltage 	dcdc4_reg
+		//AIN2-7	not used
+		ti,adc-channels = <8>;
+	};
+};
+
+&ocmcram {//???
+	 ti,no_idle_on_suspend;
+};
+
+&mmc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins>;
+	vmmc-supply = <&dcdc4_reg>;
+	bus-width = <4>;
+	cd-gpios = <&gpio3 14 GPIO_ACTIVE_HIGH>; /* GPIO 116 */
+};
+
+&usb {
+	status = "okay";
+};
+
+&usb_ctrl_mod {
+	status = "okay";
+};
+
+&usb1_phy {
+	status = "okay";
+};
+
+
+&usb1 { /* usb1 - OTG */
+	status = "okay";
+        dr_mode = "host";
+};
+
+&sham {
+	status = "okay";
+};
+
+&aes {
+	status = "okay";
+};
+
+/include/ "pxc-nandparts.dtsi"
diff --git a/arch/arm/configs/wago_pfc_generic_defconfig b/arch/arm/configs/wago_pfc_generic_defconfig
new file mode 100644
index 0000000..e21ff04
--- /dev/null
+++ b/arch/arm/configs/wago_pfc_generic_defconfig
@@ -0,0 +1,492 @@
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_IRQ_PRIORITY_TABLE=y
+CONFIG_IRQ_DOMAIN_DEBUG=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EXPERT=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_MAC_PARTITION=y
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_MUX_DEBUG=y
+CONFIG_ARCH_OMAP3=y
+CONFIG_ARCH_OMAP4=y
+CONFIG_SOC_AM33XX=y
+CONFIG_WAGO_SYSTEM_BASED_STARTUP=y
+# CONFIG_SOC_OMAP3430 is not set
+# CONFIG_SOC_TI81XX is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_DEVKIT8000 is not set
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP3530_LV_SOM is not set
+# CONFIG_MACH_OMAP3_TORPEDO is not set
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3517EVM is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+# CONFIG_MACH_TOUCHBOOK is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_NOKIA_RX51 is not set
+# CONFIG_MACH_CM_T35 is not set
+# CONFIG_MACH_CM_T3517 is not set
+# CONFIG_MACH_SBC3530 is not set
+CONFIG_ARM_THUMBEE=y
+CONFIG_SWP_EMULATE=y
+CONFIG_ARM_ERRATA_430973=y
+CONFIG_PREEMPT_RT_FULL=y
+# CONFIG_COMPACTION is not set
+CONFIG_UACCESS_WITH_MEMCPY=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_KEXEC=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPU_IDLE=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+CONFIG_PM_DEBUG=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=m
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=m
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_LRO=m
+CONFIG_INET_UDP_DIAG=m
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_GRE=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_NETFILTER=y
+CONFIG_BRIDGE_NETFILTER=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_SNMP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_ESP=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=y
+CONFIG_IP_VS=m
+CONFIG_NF_CONNTRACK_IPV4=y
+# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RPFILTER=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_SECURITY=m
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_BRIDGE_EBT_T_FILTER=y
+CONFIG_BRIDGE_EBT_T_NAT=y
+CONFIG_BRIDGE_EBT_IP=y
+CONFIG_BRIDGE_EBT_LIMIT=y
+CONFIG_BRIDGE_EBT_LOG=y
+CONFIG_L2TP=m
+CONFIG_L2TP_DEBUGFS=m
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_HFSC=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_SCH_TBF=y
+CONFIG_NET_SCH_CODEL=y
+CONFIG_NET_SCH_FQ_CODEL=y
+CONFIG_NET_CLS_BASIC=y
+CONFIG_NET_CLS_TCINDEX=y
+CONFIG_NET_CLS_ROUTE4=y
+CONFIG_NET_CLS_FW=y
+CONFIG_NET_CLS_U32=y
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=y
+CONFIG_NET_CLS_FLOW=y
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=y
+CONFIG_NET_EMATCH_NBYTE=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_NET_EMATCH_META=y
+CONFIG_NET_EMATCH_TEXT=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_NET_ACT_IPT=y
+CONFIG_NET_ACT_NAT=y
+CONFIG_NET_ACT_PEDIT=y
+CONFIG_NET_ACT_SKBEDIT=y
+CONFIG_NET_ACT_CSUM=y
+CONFIG_NET_CLS_IND=y
+CONFIG_NETLINK_DIAG=y
+CONFIG_BPF_JIT=y
+CONFIG_CAN=y
+CONFIG_CAN_GW=m
+CONFIG_CAN_VCAN=y
+CONFIG_CAN_TI_HECC=y
+CONFIG_CAN_C_CAN=y
+CONFIG_CAN_C_CAN_PLATFORM=y
+CONFIG_CAN_EMS_USB=m
+CONFIG_CAN_ESD_USB2=m
+CONFIG_CAN_PEAK_USB=m
+CONFIG_CAN_DEBUG_DEVICES=y
+# CONFIG_WIRELESS is not set
+CONFIG_RFKILL_REGULATOR=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_OMAP_OCP2SCP=y
+# CONFIG_WRLB is not set
+CONFIG_CONNECTOR=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_ECC_BCH=y
+CONFIG_MTD_NAND_OMAP2=y
+CONFIG_MTD_NAND_OMAP_BCH=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_FASTMAP=y
+CONFIG_BLK_DEV_LOOP=m
+# CONFIG_HWLAT_DETECTOR is not set
+CONFIG_TI_SN74LV165A=y
+CONFIG_EEPROM_AT24=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+CONFIG_NET_DSA_KSZ8863=y
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_KSZ8863=y
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_TI_DAVINCI_EMAC=y
+CONFIG_TI_CPSW=y
+CONFIG_TI_CPTS=y
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_SWCONFIG=y
+CONFIG_MICREL_PHY=y
+CONFIG_MICREL_KSZ8863_PHY=y
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_GPIO=y
+CONFIG_SWCFG_KSZ8863=y
+CONFIG_PPP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_CDC_NCM is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_USB_NET_QMI_WWAN=y
+# CONFIG_WLAN is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_OMAP=y
+CONFIG_SERIAL_OMAP_RTU=y
+CONFIG_SERIAL_OMAP_CONSOLE=y
+CONFIG_HW_RANDOM=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA9541=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_SPI=y
+CONFIG_SPI_OMAP24XX=y
+CONFIG_SPI_SC18IS602=m
+CONFIG_SPI_XCOMM=m
+CONFIG_SPI_SPIDEV=y
+CONFIG_SPI_KBUS=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_PCF857X=y
+CONFIG_GPIO_TWL4030=y
+CONFIG_W1=y
+CONFIG_W1_MASTER_GPIO=y
+CONFIG_HDQ_MASTER_OMAP=m
+CONFIG_W1_SLAVE_THERM=y
+CONFIG_W1_SLAVE_SMEM=y
+CONFIG_W1_SLAVE_DS2408=m
+CONFIG_W1_SLAVE_DS2423=m
+CONFIG_W1_SLAVE_DS2431=m
+CONFIG_W1_SLAVE_DS2433=m
+CONFIG_W1_SLAVE_DS2433_CRC=y
+CONFIG_W1_SLAVE_DS2760=m
+CONFIG_W1_SLAVE_DS2780=m
+CONFIG_W1_SLAVE_DS2781=m
+CONFIG_W1_SLAVE_DS28E04=m
+CONFIG_W1_SLAVE_BQ27000=m
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_GPIO_WATCHDOG=y
+CONFIG_OMAP_WATCHDOG=y
+CONFIG_MFD_TI_AM335X_TSCADC=y
+CONFIG_MFD_TPS65218=y
+CONFIG_MFD_TPS65910=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_TPS65218=y
+CONFIG_REGULATOR_TPS65910=y
+# CONFIG_HID_GENERIC is not set
+# CONFIG_USB_HID is not set
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_OTG=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_HOST=y
+CONFIG_USB_MUSB_AM35X=y
+CONFIG_USB_MUSB_DSPS=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_QUALCOMM=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_AM335X_PHY_USB=y
+CONFIG_USB_GPIO_VBUS=m
+CONFIG_USB_ULPI=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_G_MULTI=m
+CONFIG_MMC=y
+CONFIG_SDIO_UART=m
+CONFIG_MMC_OMAP_HS=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PCA955X=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_TRANSIENT=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_RS5C372=y
+CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT=y
+CONFIG_RTC_DRV_ISL1208=y
+CONFIG_DMADEVICES=y
+CONFIG_TI_EDMA=y
+CONFIG_DMA_OMAP=y
+CONFIG_TI_CPPI41=y
+CONFIG_ASYNC_TX_DMA=y
+CONFIG_DMATEST=m
+CONFIG_UIO=y
+CONFIG_UIO_PDRV_GENIRQ=y
+CONFIG_STAGING=y
+CONFIG_IIO_PERIODIC_RTC_TRIGGER=y
+CONFIG_HWSPINLOCK_OMAP=m
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER_CB=y
+CONFIG_TI_AM335X_ADC=y
+CONFIG_IIO_SYSFS_TRIGGER=y
+CONFIG_PWM=y
+CONFIG_PWM_TIECAP=y
+CONFIG_PWM_TIEHRPWM=y
+CONFIG_OMAP_USB2=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FANOTIFY=y
+CONFIG_QUOTA=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_QFMT_V2=y
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=m
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_SWAP=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_DEBUG_LL=y
+CONFIG_DEBUG_AM33XXUART1=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_SHA1_ARM=y
+CONFIG_CRYPTO_AES_ARM=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_SERPENT=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_DEV_OMAP_SHAM=y
+CONFIG_CRYPTO_DEV_OMAP_AES=y
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
diff --git a/arch/arm/plat-omap/counter_32k.c b/arch/arm/plat-omap/counter_32k.c
index 2438b96..e5a6be0 100644
--- a/arch/arm/plat-omap/counter_32k.c
+++ b/arch/arm/plat-omap/counter_32k.c
@@ -19,6 +19,7 @@
 #include <linux/io.h>
 #include <linux/clocksource.h>
 #include <linux/sched_clock.h>
+#include <linux/of.h>
 
 #include <asm/mach/time.h>
 
@@ -70,6 +71,8 @@ static void omap_read_persistent_clock64(struct timespec64 *ts)
 	*ts = persistent_ts;
 }
 
+#define OMAP2_32KSYNCNT_FREQ       32768
+
 /**
  * omap_init_clocksource_32k - setup and register counter 32k as a
  * kernel clocksource
@@ -82,6 +85,18 @@ static void omap_read_persistent_clock64(struct timespec64 *ts)
 int __init omap_init_clocksource_32k(void __iomem *vbase)
 {
 	int ret;
+        int omap2_32ksyncnt = OMAP2_32KSYNCNT_FREQ;
+
+        /*
+         * We use internal 32k generation which is based on sys_xtal 26Mhz external
+         * clock which is divided by 800 to provide a 32k like clock.
+         * The theoretical value is 26000000/800 = 32500.
+         * Empirical value is 32498.50669 ~ rounded integer would be 32499.
+         * We use that one. This should give us a drifting of appr. 14 ppm ~ 7.5 min/year.
+         *
+         */
+	if (of_machine_is_compatible("wago,pfc200"))
+		omap2_32ksyncnt = 32499;
 
 	/*
 	 * 32k sync Counter IP register offsets vary between the
@@ -100,18 +115,18 @@ int __init omap_init_clocksource_32k(void __iomem *vbase)
 	 * __clocksource_update_freq_scale.
 	 */
 	clocks_calc_mult_shift(&persistent_mult, &persistent_shift,
-			32768, NSEC_PER_SEC, 120000);
+			omap2_32ksyncnt, NSEC_PER_SEC, 120000);
 
-	ret = clocksource_mmio_init(sync32k_cnt_reg, "32k_counter", 32768,
+        ret = clocksource_mmio_init(sync32k_cnt_reg, "32k_counter", omap2_32ksyncnt,
 				250, 32, clocksource_mmio_readl_up);
 	if (ret) {
 		pr_err("32k_counter: can't register clocksource\n");
 		return ret;
 	}
 
-	sched_clock_register(omap_32k_read_sched_clock, 32, 32768);
+	sched_clock_register(omap_32k_read_sched_clock, 32, omap2_32ksyncnt);
 	register_persistent_clock(NULL, omap_read_persistent_clock64);
-	pr_info("OMAP clocksource: 32k_counter at 32768 Hz\n");
+	pr_info("OMAP clocksource: 32k_counter at %d Hz\n", omap2_32ksyncnt);
 
 	return 0;
 }
diff --git a/arch/arm/plat-omap/include/plat/omap-serial.h b/arch/arm/plat-omap/include/plat/omap-serial.h
new file mode 100644
index 0000000..b51465d
--- /dev/null
+++ b/arch/arm/plat-omap/include/plat/omap-serial.h
@@ -0,0 +1,214 @@
+/*
+ * Driver for OMAP-UART controller.
+ * Based on drivers/serial/8250.c
+ *
+ * Copyright (C) 2010 Texas Instruments.
+ *
+ * Authors:
+ *	Govindraj R	<govindraj.raja@ti.com>
+ *	Thara Gopinath	<thara@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __OMAP_SERIAL_H__
+#define __OMAP_SERIAL_H__
+
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/pm_qos.h>
+
+#include <plat/mux.h>
+#include <plat/pfc-modbus-rtu.h>
+
+#define DRIVER_NAME	"omap_uart"
+
+/*
+ * Use tty device name as ttyO, [O -> OMAP]
+ * in bootargs we specify as console=ttyO0 if uart1
+ * is used as console uart.
+ */
+#define OMAP_SERIAL_NAME	"ttyO"
+
+#define OMAP_MODE13X_SPEED	230400
+
+/* WER = 0x7F
+ * Enable module level wakeup in WER reg
+ */
+#define OMAP_UART_WER_MOD_WKUP	0X7F
+
+#define OMAP_UART_SYSC_RESET	0X07
+#define OMAP_UART_FIFO_CLR	0X06
+
+#define OMAP_UART_DMA_CH_FREE	-1
+
+#define MSR_SAVE_FLAGS		UART_MSR_ANY_DELTA
+
+#define UART_ERRATA_i202_MDR1_ACCESS	BIT(0)
+#define UART_ERRATA_i291_DMA_FORCEIDLE	BIT(1)
+
+#define OMAP_MAX_HSUART_PORTS	6
+
+#define UART_BUILD_REVISION(x, y)	(((x) << 8) | (y))
+
+#define OMAP_UART_REV_42 0x0402
+#define OMAP_UART_REV_46 0x0406
+#define OMAP_UART_REV_52 0x0502
+#define OMAP_UART_REV_63 0x0603
+
+#define UART_ERRATA_i202_MDR1_ACCESS	BIT(0)
+#define UART_ERRATA_i291_DMA_FORCEIDLE	BIT(1)
+
+#define DEFAULT_CLK_SPEED 48000000 /* 48Mhz*/
+
+/* SCR register bitmasks */
+#define OMAP_UART_SCR_RX_TRIG_GRANU1_MASK		(1 << 7)
+#define OMAP_UART_SCR_TX_TRIG_GRANU1_MASK		(1 << 6)
+#define OMAP_UART_SCR_TX_EMPTY			(1 << 3)
+
+/* FCR register bitmasks */
+#define OMAP_UART_FCR_RX_FIFO_TRIG_MASK			(0x3 << 6)
+#define OMAP_UART_FCR_TX_FIFO_TRIG_MASK			(0x3 << 4)
+
+/* MVR register bitmasks */
+#define OMAP_UART_MVR_SCHEME_SHIFT	30
+
+#define OMAP_UART_LEGACY_MVR_MAJ_MASK	0xf0
+#define OMAP_UART_LEGACY_MVR_MAJ_SHIFT	4
+#define OMAP_UART_LEGACY_MVR_MIN_MASK	0x0f
+
+#define OMAP_UART_MVR_MAJ_MASK		0x700
+#define OMAP_UART_MVR_MAJ_SHIFT		8
+#define OMAP_UART_MVR_MIN_MASK		0x3f
+
+#define OMAP_UART_DMA_CH_FREE	-1
+
+#define MSR_SAVE_FLAGS		UART_MSR_ANY_DELTA
+#define OMAP_MODE13X_SPEED	230400
+
+/* WER = 0x7F
+ * Enable module level wakeup in WER reg
+ */
+#define OMAP_UART_WER_MOD_WKUP	0X7F
+
+/* Enable XON/XOFF flow control on output */
+#define OMAP_UART_SW_TX		0x08
+
+/* Enable XON/XOFF flow control on input */
+#define OMAP_UART_SW_RX		0x02
+
+#define OMAP_UART_SW_CLR	0xF0
+
+#define OMAP_UART_TCR_TRIG	0x0F
+
+
+struct omap_uart_port_info {
+	bool			dma_enabled;	/* To specify DMA Mode */
+	unsigned int		uartclk;	/* UART clock rate */
+	upf_t			flags;		/* UPF_* flags */
+	unsigned int		dma_rx_buf_size;
+	unsigned int		dma_rx_timeout;
+	unsigned int		autosuspend_timeout;
+	unsigned int		dma_rx_poll_rate;
+	int			DTR_gpio;
+	int			DTR_inverted;
+	int			DTR_present;
+
+	int                     mode_gpio;
+	int                     mode_gpio_enable_rs485;
+	int                     disable_port;
+
+	int (*get_context_loss_count)(struct device *);
+	void (*set_forceidle)(struct device *);
+	void (*set_noidle)(struct device *);
+	void (*enable_wakeup)(struct device *, bool);
+};
+
+struct uart_omap_dma {
+	u8			uart_dma_tx;
+	u8			uart_dma_rx;
+	int			rx_dma_channel;
+	int			tx_dma_channel;
+	dma_addr_t		rx_buf_dma_phys;
+	dma_addr_t		tx_buf_dma_phys;
+	unsigned int		uart_base;
+	/*
+	 * Buffer for rx dma.It is not required for tx because the buffer
+	 * comes from port structure.
+	 */
+	unsigned char		*rx_buf;
+	unsigned int		prev_rx_dma_pos;
+	int			tx_buf_size;
+	int			tx_dma_used;
+	int			rx_dma_used;
+	spinlock_t		tx_lock;
+	spinlock_t		rx_lock;
+	/* timer to poll activity on rx dma */
+	struct timer_list	rx_timer;
+	unsigned int		rx_buf_size;
+	unsigned int		rx_poll_rate;
+	unsigned int		rx_timeout;
+};
+
+struct uart_omap_port {
+	struct uart_port	port;
+	struct uart_omap_dma	uart_dma;
+	struct device		*dev;
+
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+	struct modbus_port	mb_port;
+#endif
+
+	unsigned char		ier;
+	unsigned char		lcr;
+	unsigned char		mcr;
+	unsigned char		fcr;
+	unsigned char		efr;
+	unsigned char		dll;
+	unsigned char		dlh;
+	unsigned char		mdr1;
+	unsigned char		scr;
+
+	int			use_dma;
+	/*
+	 * Some bits in registers are cleared on a read, so they must
+	 * be saved whenever the register is read but the bits will not
+	 * be immediately processed.
+	 */
+	unsigned int		lsr_break_flag;
+	unsigned char		msr_saved_flags;
+	char			name[20];
+	unsigned long		port_activity;
+
+	struct serial_rs485     rs485;
+	unsigned int            tx_in_progress:1, tx_wait_end:1;
+
+	int			context_loss_cnt;
+	u32			errata;
+	u8			wakeups_enabled;
+
+	int			DTR_gpio;
+	int			DTR_inverted;
+	int			DTR_active;
+
+	struct pm_qos_request	pm_qos_request;
+	u32			latency;
+	u32			calc_latency;
+	struct work_struct	qos_work;
+	struct pinctrl		*pins;
+};
+
+unsigned int serial_in(struct uart_omap_port *up, int offset);
+void serial_out(struct uart_omap_port *up, int offset, int value);
+void transmit_chars(struct uart_omap_port *up, unsigned int lsr);
+irqreturn_t serial_omap_irq(int irq, void *dev_id);
+void serial_omap_stop_tx(struct uart_port *port);
+void serial_omap_start_tx(struct uart_port *port);
+void serial_omap_disable_ier_thri(struct uart_omap_port *up);
+int serial_omap_end_tx(struct uart_omap_port *up);
+
+
+#endif /* __OMAP_SERIAL_H__ */
diff --git a/arch/arm/plat-omap/io-cnt.c b/arch/arm/plat-omap/io-cnt.c
new file mode 100644
index 0000000..93531f8
--- /dev/null
+++ b/arch/arm/plat-omap/io-cnt.c
@@ -0,0 +1,279 @@
+/*
+ *    Copyright (c) 2014 Joachim Eastwood <manabian@gmail.com>
+ *    Copyright (c) 2012 NeilBrown <neilb@suse.de>
+ *    Heavily based on earlier code which is:
+ *    Copyright (c) 2010 Grant Erickson <marathon96@gmail.com>
+ *
+ *    Also based on pwm-samsung.c
+ *
+ *    This program is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU General Public License
+ *    version 2 as published by the Free Software Foundation.
+ *
+ *    Description:
+ *      This file is the core OMAP support for the generic, Linux
+ *      PWM driver / controller, using the OMAP's dual-mode timers.
+ *
+ */
+#define DEBUG
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+
+#include <linux/kdev_t.h>
+
+/* boa .. this is uggly, but we see no other option here */
+#include <../arch/arm/plat-omap/include/plat/dmtimer.h>
+#include <../arch/arm/mach-omap2/omap_hwmod.h>
+
+/* 
+ * Some hints concerning the 'tclkin' INPUT.
+ * https://github.com/ddrown/pps-gmtimer/blob/master/pps-gmtimer.c
+ *
+ * It is stated that:
+ * "if tclkin has no clock, writes to the timer registers will stall and you will get a message like:
+ * Unhandled fault: external abort on non-linefetch (0x1028) at 0xfa044048"
+ * 
+ */
+
+extern struct class* wsysinit_sysfs_class;
+struct device* omap_iocnt_sysdev = NULL;
+
+#define DM_TIMER_LOAD_MIN		0xFFFFFFFE
+
+struct omap_chip {
+	struct omap_dm_timer	*dm_timer;
+	struct omap_hwmod       *oh;
+	struct mutex		mutex;
+};
+
+static inline u32 omap_dm_timer_read_reg(struct omap_dm_timer *timer, u32 reg)
+{
+	WARN_ON((reg & 0xff) < _OMAP_TIMER_WAKEUP_EN_OFFSET);
+	return __omap_dm_timer_read(timer, reg, timer->posted);
+}
+
+static void omap_dm_timer_write_reg(struct omap_dm_timer *timer, u32 reg,
+						u32 value)
+{
+	WARN_ON((reg & 0xff) < _OMAP_TIMER_WAKEUP_EN_OFFSET);
+	__omap_dm_timer_write(timer, reg, value, timer->posted);
+}
+
+static void omap_iocnt_start(struct omap_chip *omap)
+{
+	pr_debug("io-cnt: turn on hwmod <%s>\n", omap->oh->name);
+
+	omap_hwmod_enable(omap->oh);
+
+	/*
+	 * Set load reg to DM_TIMER_LOAD_MIN
+	 */
+	omap_dm_timer_write_reg(omap->dm_timer, OMAP_TIMER_LOAD_REG, DM_TIMER_LOAD_MIN);
+
+	/*
+	 * Reset the counter to zero
+	 */
+	omap_dm_timer_write_reg(omap->dm_timer, OMAP_TIMER_COUNTER_REG, 0);
+
+	pr_debug("io-cnt: start the timer now!\n");
+
+	/*
+	 * set AR and ST bits
+	 *
+	 * now timer beginns to count based on the sys clk
+	 * 
+	 */
+	omap_dm_timer_write_reg(omap->dm_timer, OMAP_TIMER_CTRL_REG, 3);
+
+	pr_debug("io-cnt: set clk to external.\n");
+
+	/*
+	 * configure the external clock source (TCLKIN).
+	 *
+	 * At this moment counter cannot be resetted and
+	 * will continue counting clk edges coming from the external clock.
+	 */
+	omap_dm_timer_set_source(omap->dm_timer, OMAP_TIMER_SRC_EXT_CLK);
+}
+
+ssize_t omap_iocnt_sysfs_counter_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct omap_chip *omap = dev_get_drvdata(dev);
+	u32 cnt_val;
+
+	cnt_val = omap_dm_timer_read_reg(omap->dm_timer, OMAP_TIMER_COUNTER_REG);
+
+	sprintf(buf, "%u\n", cnt_val);
+
+	return strlen(buf);
+}
+
+ssize_t omap_iocnt_sysfs_cnt_debug_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	u32 reg[2];
+	struct omap_chip *omap = dev_get_drvdata(dev);
+
+	reg[0] = omap_dm_timer_read_reg(omap->dm_timer, OMAP_TIMER_CTRL_REG);
+	reg[1] = omap_dm_timer_read_reg(omap->dm_timer, OMAP_TIMER_LOAD_REG);
+	reg[2] = omap_dm_timer_read_reg(omap->dm_timer, OMAP_TIMER_COUNTER_REG);
+
+	sprintf(buf,
+		"WP_TCLR: %u [0x%.8x]\n"
+		"WP_TLDR: %u [0x%.8x]\n"
+		"WP_TCRR: %u [0x%.8x]\n",
+		reg[0], reg[0],
+		reg[1], reg[1],
+		reg[2], reg[2]
+		);
+
+	return strlen(buf);
+}
+
+ssize_t omap_iocnt_sysfs_cnt_debug_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t count)
+{
+	struct omap_chip *omap = dev_get_drvdata(dev);
+
+	if (!strcmp(buf, "disable")) {
+		pr_debug("io-cnt: disable hwmod <%s>\n", omap->oh->name);
+		omap_hwmod_idle(omap->oh);
+	} else if (!strcmp(buf, "sysclk")) {
+		pr_debug("io-cnt: set clk to sys_clk.\n");
+		omap_dm_timer_set_source(omap->dm_timer, OMAP_TIMER_SRC_SYS_CLK);
+	} else if (!strcmp(buf, "extclk")) {
+		pr_debug("io-cnt: set clk to external.\n");
+		omap_dm_timer_set_source(omap->dm_timer, OMAP_TIMER_SRC_EXT_CLK);
+	} else if (!strcmp(buf, "enable")) {
+		pr_debug("io-cnt: turn on hwmod <%s>\n", omap->oh->name);
+
+		omap_hwmod_enable(omap->oh);
+
+		pr_debug("io-cnt: start the timer now!\n");
+		omap_dm_timer_write_reg(omap->dm_timer, OMAP_TIMER_LOAD_REG, DM_TIMER_LOAD_MIN);
+		omap_dm_timer_write_reg(omap->dm_timer, OMAP_TIMER_COUNTER_REG, 0);
+		omap_dm_timer_write_reg(omap->dm_timer, OMAP_TIMER_CTRL_REG, 3);
+	}
+
+	return count;
+}
+
+DEVICE_ATTR (counter, 0444, omap_iocnt_sysfs_counter_show, NULL);
+DEVICE_ATTR (debug, 0600, omap_iocnt_sysfs_cnt_debug_show, omap_iocnt_sysfs_cnt_debug_store);
+
+int omap_iocnt_init_sysfs(struct omap_chip *omap)
+{
+	if (!omap)
+		return -1;
+
+	omap_iocnt_sysdev = device_create(wsysinit_sysfs_class, NULL,
+					  MKDEV(0, 0), NULL, "iocnt");
+
+	device_create_file(omap_iocnt_sysdev, &dev_attr_counter);
+	device_create_file(omap_iocnt_sysdev, &dev_attr_debug);
+
+	dev_set_drvdata(omap_iocnt_sysdev, omap);
+
+	return 0;
+}
+
+static int omap_iocnt_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct omap_dm_timer *dm_timer;
+	struct device_node *timer;
+	struct omap_chip *omap;
+	const char *oh_name = NULL;
+	struct omap_hwmod *oh;
+
+	timer = of_parse_phandle(np, "ti,timers", 0);
+	if (!timer)
+		return -ENODEV;
+
+	/* get the hwmod directly */
+	of_property_read_string_index(timer, "ti,hwmods", 0, &oh_name);
+	if (!oh_name)
+		return -ENODEV;
+
+	oh = omap_hwmod_lookup(oh_name);
+	if (!oh)
+		return -ENODEV;
+
+	dm_timer = omap_dm_timer_request_by_node(timer);
+	if (!dm_timer)
+		return -EPROBE_DEFER;
+
+	omap = devm_kzalloc(&pdev->dev, sizeof(*omap), GFP_KERNEL);
+	if (omap == NULL)
+		return -ENOMEM;
+
+	omap->oh = oh;
+	omap->dm_timer = dm_timer;
+	mutex_init(&omap->mutex);
+
+	/*
+	 * use the sysclk for
+	 * initial configuration
+	 */
+	omap_dm_timer_set_source(omap->dm_timer, OMAP_TIMER_SRC_SYS_CLK);
+
+	platform_set_drvdata(pdev, omap);
+
+	omap_iocnt_init_sysfs(omap);
+
+	/*
+	 * Start the timer now and
+	 * set the external clock
+	 */
+	omap_iocnt_start(omap);
+
+	dev_info(&pdev->dev, "driver probed.\n");
+
+	return 0;
+}
+
+static int omap_iocnt_remove(struct platform_device *pdev)
+{
+	struct omap_chip *omap = platform_get_drvdata(pdev);
+
+	omap_dm_timer_free(omap->dm_timer);
+	mutex_destroy(&omap->mutex);
+
+	return 0;
+}
+
+static const struct of_device_id omap_iocnt_of_match[] = {
+	{.compatible = "ti,omap-iocnt"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, omap_iocnt_of_match);
+
+static struct platform_driver omap_iocnt_driver = {
+	.driver = {
+		.name	= "omap_iocnt",
+		.owner	= THIS_MODULE,
+		.of_match_table = omap_iocnt_of_match,
+	},
+	.probe		= omap_iocnt_probe,
+	.remove		= omap_iocnt_remove,
+};
+module_platform_driver(omap_iocnt_driver);
+
+MODULE_AUTHOR("Heinrich Toews <heinrich.toews@wago.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("2016-29-06");
+MODULE_DESCRIPTION("OMAP DMTimer based I/O Counter driver");
diff --git a/drivers/bus/omap_l3_smx.c b/drivers/bus/omap_l3_smx.c
index 360a5c0..6a55573 100644
--- a/drivers/bus/omap_l3_smx.c
+++ b/drivers/bus/omap_l3_smx.c
@@ -159,6 +159,12 @@ static irqreturn_t omap3_l3_block_irq(struct omap3_l3 *l3,
 	u8 multi = error & L3_ERROR_LOG_MULTI;
 	u32 address = omap3_l3_decode_addr(error_addr);
 
+	// WAT15957: suppressing warning message on boot
+	if ((OMAP_L3_CODE_IN_BAND_ERR == code) &&
+	    (OMAP_L3_USBOTG == initid))
+	{
+		return IRQ_HANDLED;
+	}
 	pr_err("%s seen by %s %s at address %x\n",
 			omap3_l3_code_string(code),
 			omap3_l3_initiator_string(initid),
diff --git a/drivers/iio/pwm-omap.c b/drivers/iio/pwm-omap.c
new file mode 100644
index 0000000..1ad45f8
--- /dev/null
+++ b/drivers/iio/pwm-omap.c
@@ -0,0 +1,273 @@
+/*
+ *    Copyright (c) 2014 Joachim Eastwood <manabian@gmail.com>
+ *    Copyright (c) 2012 NeilBrown <neilb@suse.de>
+ *    Heavily based on earlier code which is:
+ *    Copyright (c) 2010 Grant Erickson <marathon96@gmail.com>
+ *
+ *    Also based on pwm-samsung.c
+ *
+ *    This program is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU General Public License
+ *    version 2 as published by the Free Software Foundation.
+ *
+ *    Description:
+ *      This file is the core OMAP support for the generic, Linux
+ *      PWM driver / controller, using the OMAP's dual-mode timers.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+
+#include <../arch/arm/plat-omap/include/plat/dmtimer.h>
+
+#define DM_TIMER_LOAD_MIN		0xFFFFFFFE
+
+struct omap_chip {
+	struct omap_dm_timer	*dm_timer;
+	unsigned int		duty_ns, period_ns;
+	struct mutex		mutex;
+	struct pwm_chip		chip;
+};
+
+#define to_omap_chip(chip)	container_of(chip, struct omap_chip, chip)
+
+static int omap_pwm_calc_value(unsigned long clk_rate, int ns)
+{
+	u64 c;
+
+	c = (u64)clk_rate * ns;
+	do_div(c, NSEC_PER_SEC);
+
+	return DM_TIMER_LOAD_MIN - c;
+}
+
+static void omap_pwm_start(struct omap_chip *omap)
+{
+	/*
+	 * According to OMAP 4 TRM section 22.2.4.10 the counter should be
+	 * started at 0xFFFFFFFE when overflow and match is used to ensure
+	 * that the PWM line is toggled on the first event.
+	 *
+	 * Note that omap_dm_timer_enable/disable is for register access and
+	 * not the timer counter itself.
+	 */
+	omap_dm_timer_enable(omap->dm_timer);
+	omap_dm_timer_write_counter(omap->dm_timer, DM_TIMER_LOAD_MIN);
+	omap_dm_timer_disable(omap->dm_timer);
+
+	omap_dm_timer_start(omap->dm_timer);
+}
+
+static int omap_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct omap_chip *omap = to_omap_chip(chip);
+
+	mutex_lock(&omap->mutex);
+	omap_pwm_start(omap);
+	mutex_unlock(&omap->mutex);
+
+	return 0;
+}
+
+static void omap_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct omap_chip *omap = to_omap_chip(chip);
+
+	mutex_lock(&omap->mutex);
+	omap_dm_timer_stop(omap->dm_timer);
+	mutex_unlock(&omap->mutex);
+}
+
+static int omap_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
+			   int duty_ns, int period_ns)
+{
+	struct omap_chip *omap = to_omap_chip(chip);
+	int load_value, match_value;
+	unsigned long clk_rate;
+	bool timer_active;
+
+	dev_dbg(chip->dev, "duty cycle: %d, period %d\n", duty_ns, period_ns);
+
+	mutex_lock(&omap->mutex);
+	if (omap->duty_ns == duty_ns &&
+	    omap->period_ns == period_ns) {
+		/* No change - don't cause any transients. */
+		mutex_unlock(&omap->mutex);
+		return 0;
+	}
+
+	clk_rate = clk_get_rate(omap_dm_timer_get_fclk(omap->dm_timer));
+
+	/*
+	 * Calculate the appropriate load and match values based on the
+	 * specified period and duty cycle. The load value determines the
+	 * cycle time and the match value determines the duty cycle.
+	 */
+	load_value = omap_pwm_calc_value(clk_rate, period_ns);
+	match_value = omap_pwm_calc_value(clk_rate, period_ns - duty_ns);
+
+	/*
+	 * We MUST stop the associated dual-mode timer before attempting to
+	 * write its registers, but calls to omap_dm_timer_start/stop must
+	 * be balanced so check if timer is active before calling timer_stop.
+	 */
+	timer_active = pm_runtime_active(&omap->dm_timer->pdev->dev);
+	if (timer_active)
+		omap_dm_timer_stop(omap->dm_timer);
+
+	omap_dm_timer_set_load(omap->dm_timer, true, load_value);
+	omap_dm_timer_set_match(omap->dm_timer, true, match_value);
+
+	dev_dbg(chip->dev, "load value: %#08x (%d), match value: %#08x (%d)\n",
+		load_value, load_value,	match_value, match_value);
+
+	omap_dm_timer_set_pwm(omap->dm_timer,
+			      pwm->polarity == PWM_POLARITY_INVERSED,
+			      true,
+			      OMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE);
+
+	/* If config was called while timer was running it must be reenabled. */
+	if (timer_active)
+		omap_pwm_start(omap);
+
+	omap->duty_ns = duty_ns;
+	omap->period_ns = period_ns;
+	mutex_unlock(&omap->mutex);
+
+	return 0;
+}
+
+static int omap_pwm_set_polarity(struct pwm_chip *chip, struct pwm_device *pwm,
+				 enum pwm_polarity polarity)
+{
+	struct omap_chip *omap = to_omap_chip(chip);
+
+	/*
+	 * PWM core will not call set_polarity while PWM is enabled so it's
+	 * safe to reconfigure the timer here without stopping it first.
+	 */
+	mutex_lock(&omap->mutex);
+	omap_dm_timer_set_pwm(omap->dm_timer,
+			      polarity == PWM_POLARITY_INVERSED,
+			      true,
+			      OMAP_TIMER_TRIGGER_OVERFLOW_AND_COMPARE);
+	mutex_unlock(&omap->mutex);
+
+	return 0;
+}
+
+static struct pwm_ops omap_pwm_ops = {
+	.enable		= omap_pwm_enable,
+	.disable	= omap_pwm_disable,
+	.config		= omap_pwm_config,
+	.set_polarity	= omap_pwm_set_polarity,
+	.owner		= THIS_MODULE,
+};
+
+static int omap_pwm_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct omap_dm_timer *dm_timer;
+	struct device_node *timer;
+	struct omap_chip *omap;
+	int status;
+
+	timer = of_parse_phandle(np, "ti,timers", 0);
+	if (!timer)
+		return -ENODEV;
+
+	dm_timer = omap_dm_timer_request_by_node(timer);
+	if (!dm_timer)
+		return -EPROBE_DEFER;
+
+	if (!(dm_timer->capability & OMAP_TIMER_HAS_PWM)) {
+		dev_err(&pdev->dev, "timer has no PWM capability\n");
+		return -ENODEV;
+	}
+
+	omap = devm_kzalloc(&pdev->dev, sizeof(*omap), GFP_KERNEL);
+	if (omap == NULL)
+		return -ENOMEM;
+
+	omap->dm_timer = dm_timer;
+	omap_dm_timer_set_source(omap->dm_timer, OMAP_TIMER_SRC_SYS_CLK);
+
+	omap->chip.dev = &pdev->dev;
+	omap->chip.ops = &omap_pwm_ops;
+	omap->chip.base = -1;
+	omap->chip.npwm = 1;
+	omap->chip.of_xlate = of_pwm_xlate_with_flags;
+	omap->chip.of_pwm_n_cells = 3;
+
+	mutex_init(&omap->mutex);
+
+	/*
+	 * Ensure that the timer is stopped before we allow PWM core to call
+	 * pwm_enable.
+	 */
+	if (pm_runtime_active(&omap->dm_timer->pdev->dev))
+		omap_dm_timer_stop(omap->dm_timer);
+
+	status = pwmchip_add(&omap->chip);
+	if (status < 0) {
+		dev_err(&pdev->dev, "failed to register PWM\n");
+		omap_dm_timer_free(omap->dm_timer);
+		return status;
+	}
+
+	platform_set_drvdata(pdev, omap);
+
+	return 0;
+}
+
+static int omap_pwm_remove(struct platform_device *pdev)
+{
+	struct omap_chip *omap = platform_get_drvdata(pdev);
+	int status;
+
+	status = pwmchip_remove(&omap->chip);
+	if (status < 0)
+		return status;
+
+	if (pm_runtime_active(&omap->dm_timer->pdev->dev))
+		omap_dm_timer_stop(omap->dm_timer);
+
+	omap_dm_timer_free(omap->dm_timer);
+
+	mutex_destroy(&omap->mutex);
+
+	return 0;
+}
+
+static const struct of_device_id omap_pwm_of_match[] = {
+	{.compatible = "ti,omap-pwm"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, omap_pwm_of_match);
+
+static struct platform_driver omap_pwm_driver = {
+	.driver = {
+		.name	= "omap-pwm",
+		.owner	= THIS_MODULE,
+		.of_match_table = omap_pwm_of_match,
+	},
+	.probe		= omap_pwm_probe,
+	.remove		= omap_pwm_remove,
+};
+module_platform_driver(omap_pwm_driver);
+
+MODULE_AUTHOR("Grant Erickson <marathon96@gmail.com>");
+MODULE_AUTHOR("NeilBrown <neilb@suse.de>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("2014-20-04");
+MODULE_DESCRIPTION("OMAP PWM Driver using Dual-mode Timers");
diff --git a/drivers/leds/leds-pca955x.c b/drivers/leds/leds-pca955x.c
index f672648..433c88ee 100644
--- a/drivers/leds/leds-pca955x.c
+++ b/drivers/leds/leds-pca955x.c
@@ -240,6 +240,67 @@ static int pca955x_led_set(struct led_classdev *led_cdev,
 	return 0;
 }
 
+#if IS_ENABLED(CONFIG_OF)
+static struct led_platform_data *
+pca955x_dt_init(struct i2c_client *client, struct pca955x_chipdef *chip)
+{
+	struct device_node *np = client->dev.of_node, *child;
+	struct led_platform_data *pdata;
+	struct led_info *pca955x_leds;
+	int count;
+
+	/* get amount of childs in that node */
+	count = of_get_child_count(np);
+	if (!count || count > chip->bits)
+		return ERR_PTR(-ENODEV);
+
+	/* allocate memory for led_info objects */
+	pca955x_leds = devm_kzalloc(&client->dev,
+			sizeof(struct led_info) * chip->bits, GFP_KERNEL);
+	if (!pca955x_leds)
+		return ERR_PTR(-ENOMEM);
+
+	/* run through childs and fill led_info objects */
+	for_each_child_of_node(np, child) {
+		struct led_info led;
+		u32 reg;
+		int res;
+
+		res = of_property_read_u32(child, "reg", &reg);
+		if ((res != 0) || (reg >= chip->bits))
+			continue;
+		led.name =
+			of_get_property(child, "label", NULL) ? : child->name;
+		led.default_trigger =
+			of_get_property(child, "linux,default-trigger", NULL);
+		pca955x_leds[reg] = led;
+	}
+	pdata = devm_kzalloc(&client->dev,
+			     sizeof(struct led_platform_data), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->leds = pca955x_leds;
+	pdata->num_leds = chip->bits;
+
+	return pdata;
+}
+
+static const struct of_device_id of_pca955x_match[] = {
+	{ .compatible = "nxp,pca9550", },
+	{ .compatible = "nxp,pca9551", },
+	{ .compatible = "nxp,pca9552", },
+	{ .compatible = "nxp,pca9553", },
+	{},
+};
+#else
+static struct led_platform_data *
+pca955x_dt_init(struct i2c_client *client, struct pca955x_chipdef *chip)
+{
+	return ERR_PTR(-ENODEV);
+}
+#endif
+
 static int pca955x_probe(struct i2c_client *client,
 					const struct i2c_device_id *id)
 {
@@ -254,6 +315,16 @@ static int pca955x_probe(struct i2c_client *client,
 	adapter = to_i2c_adapter(client->dev.parent);
 	pdata = dev_get_platdata(&client->dev);
 
+	pr_debug("%s: id->driver_data = 0x%x.\n", __func__, (u32)id->driver_data);
+
+	if (!pdata) {
+		pdata = pca955x_dt_init(client, chip);
+		if (IS_ERR(pdata)) {
+			dev_warn(&client->dev, "could not parse configuration\n");
+			pdata = NULL;
+		}
+	}
+
 	/* Make sure the slave address / chip type combo given is possible */
 	if ((client->addr & ~((1 << chip->slv_addr_shift) - 1)) !=
 	    chip->slv_addr) {
@@ -293,6 +364,20 @@ static int pca955x_probe(struct i2c_client *client,
 	pca955x->client = client;
 	pca955x->chipdef = chip;
 
+	/* Turn off LEDs */
+	for (i = 0; i < pca95xx_num_led_regs(chip->bits); i++)
+		pca955x_write_ls(client, i, 0x55);
+
+	/* PWM0 is used for half brightness or 50% duty cycle */
+	pca955x_write_pwm(client, 0, 255-LED_HALF);
+
+	/* PWM1 is used for variable brightness, default to OFF */
+	pca955x_write_pwm(client, 1, 0);
+
+	/* Set to fast frequency so we do not see flashing */
+	pca955x_write_psc(client, 0, 0);
+	pca955x_write_psc(client, 1, 0);
+
 	for (i = 0; i < chip->bits; i++) {
 		pca955x_led = &pca955x->leds[i];
 		pca955x_led->led_num = i;
@@ -302,7 +387,7 @@ static int pca955x_probe(struct i2c_client *client,
 		if (pdata) {
 			if (pdata->leds[i].name)
 				snprintf(pca955x_led->name,
-					sizeof(pca955x_led->name), "pca955x:%s",
+					sizeof(pca955x_led->name), "%s",
 					pdata->leds[i].name);
 			if (pdata->leds[i].default_trigger)
 				pca955x_led->led_cdev.default_trigger =
@@ -315,25 +400,16 @@ static int pca955x_probe(struct i2c_client *client,
 		pca955x_led->led_cdev.name = pca955x_led->name;
 		pca955x_led->led_cdev.brightness_set_blocking = pca955x_led_set;
 
-		err = led_classdev_register(&client->dev,
-					&pca955x_led->led_cdev);
-		if (err < 0)
-			goto exit;
-	}
-
-	/* Turn off LEDs */
-	for (i = 0; i < pca95xx_num_led_regs(chip->bits); i++)
-		pca955x_write_ls(client, i, 0x55);
-
-	/* PWM0 is used for half brightness or 50% duty cycle */
-	pca955x_write_pwm(client, 0, 255-LED_HALF);
-
-	/* PWM1 is used for variable brightness, default to OFF */
-	pca955x_write_pwm(client, 1, 0);
+		pr_debug("%s: pca955x_led->led_cdev.name = <%s>, dev.name = <%s>\n",
+			 __func__, pca955x_led->led_cdev.name, dev_name(&client->dev));
 
-	/* Set to fast frequency so we do not see flashing */
-	pca955x_write_psc(client, 0, 0);
-	pca955x_write_psc(client, 1, 0);
+		if (pdata->leds[i].name) {
+			err = led_classdev_register(&client->dev,
+						    &pca955x_led->led_cdev);
+			if (err < 0)
+				goto exit;
+		}
+	}
 
 	return 0;
 
@@ -362,6 +438,7 @@ static struct i2c_driver pca955x_driver = {
 	.probe	= pca955x_probe,
 	.remove	= pca955x_remove,
 	.id_table = pca955x_id,
+	.of_match_table = of_match_ptr(of_pca955x_match),
 };
 
 module_i2c_driver(pca955x_driver);
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 215e91e..a6c4f5f 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -775,6 +775,17 @@ config PANEL_BOOT_MESSAGE
 	  An empty message will only clear the display at driver init time. Any other
 	  printf()-formatted message is valid with newline and escape codes.
 
+config TI_SN74LV165A
+	tristate "Texas Instruments SN74LV165A"
+	depends on SYSFS && GPIO_OMAP && GPIOLIB && OF_GPIO
+	help
+	  If you say yes here you get support for the Texas Instruments
+	  SN74LV165A 8-bit shift register.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called ti_sn74lv165a.
+
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 2bf79ba..99287e2 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -53,6 +53,7 @@ obj-$(CONFIG_ECHO)		+= echo/
 obj-$(CONFIG_VEXPRESS_SYSCFG)	+= vexpress-syscfg.o
 obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_PANEL)             += panel.o
+obj-$(CONFIG_TI_SN74LV165A)     += ti_sn74lv165a.o
 
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_core.o
 lkdtm-$(CONFIG_LKDTM)		+= lkdtm_bugs.o
diff --git a/drivers/misc/ti_sn74lv165a.c b/drivers/misc/ti_sn74lv165a.c
new file mode 100644
index 0000000..70dfd4d
--- /dev/null
+++ b/drivers/misc/ti_sn74lv165a.c
@@ -0,0 +1,296 @@
+/*
+ * Linux kernel driver for Texas Instruments SN74LV165A
+ * 8-bit-shift-register on gpio lines
+ *
+ * Copyright (C) 2015 WAGO Automation
+ *
+ * Author: Oleg Karfich
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+//#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+
+#define DEFAULT_PERIOD	4 /* milliseconds */
+#define NUM_BITS	8
+
+struct sn74_gpio {
+	unsigned int num;
+	bool active_low;
+};
+
+struct sn74_gpio_info {
+	struct sn74_gpio clk;
+	struct sn74_gpio load;
+	struct sn74_gpio input;
+};
+
+struct sn74_platform_data {
+	struct sn74_gpio_info *ctrl_gpios;
+	unsigned long period;
+	unsigned int bits;
+};
+
+static int sn74_get_input(struct sn74_gpio *gpio)
+{
+	return (gpio_get_value(gpio->num) ^ gpio->active_low);
+}
+
+static void sn74_set_ctrl_gpio(struct sn74_gpio *gpio, int what)
+{
+	gpio_set_value(gpio->num, what ^ gpio->active_low);
+}
+
+static ssize_t sn74_input_value_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct sn74_platform_data *pdata;
+	struct sn74_gpio_info *ctrl_gpios;
+	unsigned long half_period;
+	int i, value = 0;
+
+	pr_debug("## %s:%d\n", __func__, __LINE__);
+
+	pdata = dev_get_drvdata(dev);
+	if (!pdata) {
+		dev_warn(dev, "%s:%d > could not get platform-data\n", __func__, __LINE__);
+		return -1;
+	}
+
+	ctrl_gpios = pdata->ctrl_gpios;
+	half_period = (pdata->period / 2);
+
+	/* load register */
+	sn74_set_ctrl_gpio(&ctrl_gpios->load, 1);
+	ndelay(half_period);
+	sn74_set_ctrl_gpio(&ctrl_gpios->load, 0);
+
+	for (i = 0; i < pdata->bits; i++) {
+
+		value <<= 1;
+		value |= sn74_get_input(&ctrl_gpios->input);
+
+		/* do one clk cycle */
+		sn74_set_ctrl_gpio(&ctrl_gpios->clk, 1);
+		ndelay(half_period);
+		sn74_set_ctrl_gpio(&ctrl_gpios->clk, 0);
+		ndelay(half_period);
+	}
+
+	return sprintf(buf, "0x%02x\n", value);
+}
+
+/*
+ * ATTRIBUTES:
+ *
+ *	/sys/devices/<dts-node-name>/value
+ *
+ */
+static DEVICE_ATTR(value, S_IRUGO, sn74_input_value_show, NULL);
+
+static struct attribute *sn74_attrs[] = {
+	&dev_attr_value.attr,
+	NULL,
+};
+
+static struct attribute_group sn74_attr_group = {
+	.attrs = sn74_attrs,
+};
+
+#ifdef CONFIG_OF
+
+static struct sn74_platform_data *sn74_get_devtree_pdata(struct device *dev)
+{
+	struct device_node *node;
+	struct sn74_platform_data *pdata;
+	struct sn74_gpio_info *ctrl_gpios;
+	enum of_gpio_flags flags;
+	unsigned int gpio, period;
+
+	dev_dbg(dev, "## %s:%d\n", __func__, __LINE__);
+
+	node = dev->of_node;
+	if (!node)
+		return ERR_PTR(-ENODEV);
+
+	/* automatically freed on driver detach */
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	ctrl_gpios = devm_kzalloc(dev, sizeof(*ctrl_gpios), GFP_KERNEL);
+	if (!ctrl_gpios)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->ctrl_gpios = ctrl_gpios;
+
+	if (!of_find_property(node, "gpios", NULL)) {
+		dev_err(dev, "failed to get control gpios\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	gpio = of_get_gpio_flags(node, 0, &flags);
+	if (gpio < 0)
+		return ERR_PTR(-ENODEV);
+
+	pdata->ctrl_gpios->clk.num = gpio;
+	pdata->ctrl_gpios->clk.active_low = flags & OF_GPIO_ACTIVE_LOW;
+
+	dev_dbg(dev, "clk gpio-num : %d, active low : %d\n", pdata->ctrl_gpios->clk.num, pdata->ctrl_gpios->clk.active_low);
+
+	gpio = of_get_gpio_flags(node, 1, &flags);
+	if (gpio < 0)
+		return ERR_PTR(-ENODEV);
+
+	pdata->ctrl_gpios->input.num = gpio;
+	pdata->ctrl_gpios->input.active_low = flags & OF_GPIO_ACTIVE_LOW;
+
+	dev_dbg(dev, "input gpio-num : %d, active low : %d\n", pdata->ctrl_gpios->input.num, pdata->ctrl_gpios->input.active_low);
+
+	gpio = of_get_gpio_flags(node, 2, &flags);
+	if (gpio < 0)
+		return ERR_PTR(-ENODEV);
+
+	pdata->ctrl_gpios->load.num = gpio;
+	pdata->ctrl_gpios->load.active_low = flags & OF_GPIO_ACTIVE_LOW;
+
+	dev_dbg(dev, "load gpio-num : %d, active low : %d\n", pdata->ctrl_gpios->load.num, pdata->ctrl_gpios->load.active_low);
+
+	if (of_property_read_u32(node, "clk,period", &period)) {
+		period = DEFAULT_PERIOD;
+		dev_warn(dev, "not freq value found, using default value: %d\n", period);
+	}
+	pdata->period = (((unsigned long)period) * 1000000); /* convert to nano-seconds for udelay */
+
+	dev_dbg(dev, "clk period : %ld ns\n", pdata->period);
+
+	return pdata;
+}
+
+static const struct of_device_id sn74_of_match[] = {
+	{ .compatible = "ti,sn74lv165a", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sn74_of_match);
+
+#else
+
+static struct sn74_platform_data *sn74_get_devtree_pdata(struct device *dev)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+#endif
+
+static int sn74_request_gpios(struct device *dev)
+{
+	struct sn74_platform_data *pdata;
+	int ret = -1;
+
+	dev_dbg(dev, "## %s:%d\n", __func__, __LINE__);
+
+	pdata = dev_get_drvdata(dev);
+	if (pdata) {
+
+		ret = devm_gpio_request(dev, pdata->ctrl_gpios->clk.num, "sn74_clk");
+		if (ret < 0)
+			return -ENODEV;
+
+		gpio_direction_output(pdata->ctrl_gpios->clk.num, 0);
+
+		ret = devm_gpio_request(dev, pdata->ctrl_gpios->load.num, "sn74_load");
+		if (ret < 0)
+			return -ENODEV;
+
+		gpio_direction_output(pdata->ctrl_gpios->load.num, 1);
+
+		ret = devm_gpio_request(dev, pdata->ctrl_gpios->input.num, "sn74_input");
+		if (ret < 0)
+			return -ENODEV;
+
+		gpio_direction_input(pdata->ctrl_gpios->input.num);
+	}
+	return ret;
+}
+
+static int sn74_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sn74_platform_data *pdata;
+	int ret;
+
+	dev_dbg(dev, "## %s:%d\n", __func__, __LINE__);
+
+	pdata = dev_get_platdata(dev);
+	if (!pdata) {
+		pdata = sn74_get_devtree_pdata(dev);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
+	}
+
+	pdata->bits = NUM_BITS;
+
+	dev_set_drvdata(dev, pdata);
+
+	ret = sn74_request_gpios(dev);
+	if (ret < 0) {
+		dev_err(dev, "could not request gpios\n");
+		return -ENODEV;
+	}
+
+	ret = sysfs_create_group(&dev->kobj, &sn74_attr_group);
+	if (ret)
+		dev_err(dev, "cant export sn74 sysfs group attribute\n");
+
+	return ret;
+}
+
+static int sn74_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	dev_dbg(dev, "## %s:%d\n", __func__, __LINE__);
+
+	sysfs_remove_group(&dev->kobj, &sn74_attr_group);
+
+	return 0;
+}
+
+static struct platform_driver sn74_device_driver = {
+	.probe          = sn74_probe,
+	.remove         = sn74_remove,
+	.driver         = {
+		.name   = "sn74lv165a",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(sn74_of_match),
+	}
+};
+
+static int __init sn74_init(void)
+{
+	return platform_driver_register(&sn74_device_driver);
+}
+
+static void __exit sn74_exit(void)
+{
+	platform_driver_unregister(&sn74_device_driver);
+}
+
+module_init(sn74_init);
+module_exit(sn74_exit);
+
+MODULE_AUTHOR("Oleg Karfich <oleg.karfich@wago.com>");
+MODULE_DESCRIPTION("SN74LV165A 8-bit shift register");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
index 4d01d7b..70c577a 100644
--- a/drivers/net/can/ti_hecc.c
+++ b/drivers/net/can/ti_hecc.c
@@ -37,6 +37,7 @@
  */
 
 #include <linux/module.h>
+#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
@@ -45,13 +46,20 @@
 #include <linux/skbuff.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
 #include <linux/io.h>
 
 #include <linux/can/dev.h>
 #include <linux/can/error.h>
-#include <linux/can/led.h>
 #include <linux/can/platform/ti_hecc.h>
 
+/* tracing */
+#define PXC_CAN_TRACER
+#define CREATE_TRACE_POINTS
+#include <trace/events/pxc.h>
+
 #define DRV_NAME "ti_hecc"
 #define HECC_MODULE_VERSION     "0.7"
 MODULE_VERSION(HECC_MODULE_VERSION);
@@ -81,7 +89,6 @@ MODULE_VERSION(HECC_MODULE_VERSION);
 #define HECC_TX_MB_MASK		(HECC_MAX_TX_MBOX - 1)
 #define HECC_TX_MASK		((HECC_MAX_TX_MBOX - 1) | HECC_TX_PRIO_MASK)
 #define HECC_TX_MBOX_MASK	(~(BIT(HECC_MAX_TX_MBOX) - 1))
-#define HECC_DEF_NAPI_WEIGHT	HECC_MAX_RX_MBOX
 
 /*
  * Important Note: RX mailbox configuration
@@ -100,10 +107,20 @@ MODULE_VERSION(HECC_MODULE_VERSION);
  */
 
 #define HECC_MAX_RX_MBOX	(HECC_MAX_MAILBOXES - HECC_MAX_TX_MBOX)
-#define HECC_RX_BUFFER_MBOX	12 /* as per table above */
+#define HECC_RX_BUFFER_MBOX	28 /* as per table above */
 #define HECC_RX_FIRST_MBOX	(HECC_MAX_MAILBOXES - 1)
 #define HECC_RX_HIGH_MBOX_MASK	(~(BIT(HECC_RX_BUFFER_MBOX) - 1))
 
+/*
+ * The weight field is a measure of the importance of this interface;
+ * the number stored here will turn out to be the same number your driver
+ * finds in the quota field when poll() is called. Gigabit adaptor drivers
+ * tend to set weight to 64; smaller values can be used for slower media.
+ */
+#define HECC_DEF_NAPI_WEIGHT	128
+#define HECC_DEF_NAPI_MAXREAD	28
+
+
 /* TI HECC module registers */
 #define HECC_CANME		0x0	/* Mailbox enable */
 #define HECC_CANMD		0x4	/* Mailbox direction */
@@ -170,6 +187,7 @@ MODULE_VERSION(HECC_MODULE_VERSION);
 #define HECC_CANES_SMA		BIT(5)	/* suspend mode ack */
 #define HECC_CANES_CCE		BIT(4)	/* Change config enabled */
 #define HECC_CANES_PDA		BIT(3)	/* Power down mode ack */
+#define HECC_CANES_RM		BIT(1)	/* Receive Mode bit */
 
 #define HECC_CANBTC_SAM		BIT(7)	/* sample points */
 
@@ -195,6 +213,13 @@ MODULE_VERSION(HECC_MODULE_VERSION);
 #define HECC_CANGIM_DEF_MASK	0x700	/* only busoff/warning/passive */
 #define HECC_CANGIM_SIL		BIT(2)	/* system interrupts to int line 1 */
 
+/*
+ * Receive Mode bit reflects what the CAN protocol kernel (CPK) is
+ * actually doing regardless of mailbox configuration. CPK receive
+ * mode timeout. Tried from 1 - 5us and kept 10 as a safety value.
+ */
+#define RM_TIMEOUT_US		10
+
 /* CAN Bittiming constants as per HECC specs */
 static const struct can_bittiming_const ti_hecc_bittiming_const = {
 	.name = DRV_NAME,
@@ -285,6 +310,15 @@ static inline u32 hecc_get_bit(struct ti_hecc_priv *priv, int reg, u32 bit_mask)
 	return (hecc_read(priv, reg) & bit_mask) ? 1 : 0;
 }
 
+static int ti_hecc_get_state(const struct net_device *ndev,
+	enum can_state *state)
+{
+	struct ti_hecc_priv *priv = netdev_priv(ndev);
+
+	*state = priv->can.state;
+	return 0;
+}
+
 static int ti_hecc_set_btc(struct ti_hecc_priv *priv)
 {
 	struct can_bittiming *bit_timing = &priv->can.bittiming;
@@ -306,7 +340,7 @@ static int ti_hecc_set_btc(struct ti_hecc_priv *priv)
 	/* ERM being set to 0 by default meaning resync at falling edge */
 
 	hecc_write(priv, HECC_CANBTC, can_btc);
-	netdev_info(priv->ndev, "setting CANBTC=%#x\n", can_btc);
+	netdev_dbg(priv->ndev, "setting CANBTC=%#x\n", can_btc);
 
 	return 0;
 }
@@ -517,10 +551,10 @@ static netdev_tx_t ti_hecc_xmit(struct sk_buff *skb, struct net_device *ndev)
 		data = (cf->can_id & CAN_SFF_MASK) << 18;
 	hecc_write_mbx(priv, mbxno, HECC_CANMID, data);
 	hecc_write_mbx(priv, mbxno, HECC_CANMDL,
-		be32_to_cpu(*(__be32 *)(cf->data)));
+		be32_to_cpu(*(u32 *)(cf->data)));
 	if (cf->can_dlc > 4)
 		hecc_write_mbx(priv, mbxno, HECC_CANMDH,
-			be32_to_cpu(*(__be32 *)(cf->data + 4)));
+			be32_to_cpu(*(u32 *)(cf->data + 4)));
 	else
 		*(u32 *)(cf->data + 4) = 0;
 	can_put_echo_skb(skb, ndev, mbxno);
@@ -568,10 +602,12 @@ static int ti_hecc_rx_pkt(struct ti_hecc_priv *priv, int mbxno)
 		cf->can_id |= CAN_RTR_FLAG;
 	cf->can_dlc = get_can_dlc(data & 0xF);
 	data = hecc_read_mbx(priv, mbxno, HECC_CANMDL);
-	*(__be32 *)(cf->data) = cpu_to_be32(data);
+	*(u32 *)(cf->data) = cpu_to_be32(data);
 	if (cf->can_dlc > 4) {
 		data = hecc_read_mbx(priv, mbxno, HECC_CANMDH);
-		*(__be32 *)(cf->data + 4) = cpu_to_be32(data);
+		*(u32 *)(cf->data + 4) = cpu_to_be32(data);
+	} else {
+		*(u32 *)(cf->data + 4) = 0;
 	}
 	spin_lock_irqsave(&priv->mbx_lock, flags);
 	hecc_clear_bit(priv, HECC_CANME, mbx_mask);
@@ -582,7 +618,7 @@ static int ti_hecc_rx_pkt(struct ti_hecc_priv *priv, int mbxno)
 	spin_unlock_irqrestore(&priv->mbx_lock, flags);
 
 	stats->rx_bytes += cf->can_dlc;
-	can_led_event(priv->ndev, CAN_LED_EVENT_RX);
+	trace_pxc_canpkt(cf);  /* trace point A: dump received packet */
 	netif_receive_skb(skb);
 	stats->rx_packets++;
 
@@ -616,10 +652,10 @@ static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)
 	struct ti_hecc_priv *priv = netdev_priv(ndev);
 	u32 num_pkts = 0;
 	u32 mbx_mask;
-	unsigned long pending_pkts, flags;
+	unsigned long pending_pkts, flags, timeout;
 
-	if (!netif_running(ndev))
-		return 0;
+	if (quota > HECC_DEF_NAPI_MAXREAD) /* maximum mailboxes to read */
+	    quota = HECC_DEF_NAPI_MAXREAD;
 
 	while ((pending_pkts = hecc_read(priv, HECC_CANRMP)) &&
 		num_pkts < quota) {
@@ -628,12 +664,18 @@ static int ti_hecc_rx_poll(struct napi_struct *napi, int quota)
 			if (ti_hecc_rx_pkt(priv, priv->rx_next) < 0)
 				return num_pkts;
 			++num_pkts;
-		} else if (priv->rx_next > HECC_RX_BUFFER_MBOX) {
-			break; /* pkt not received yet */
 		}
 		--priv->rx_next;
-		if (priv->rx_next == HECC_RX_BUFFER_MBOX) {
+		if (priv->rx_next == HECC_RX_BUFFER_MBOX - 1) {
 			/* enable high bank mailboxes */
+			timeout = jiffies + usecs_to_jiffies(RM_TIMEOUT_US);
+			while (hecc_get_bit(priv, HECC_CANES, HECC_CANES_RM)) {
+				cpu_relax();
+				if (time_after(jiffies, timeout)) {
+					netdev_warn(ndev, "receiving pkt\n");
+					break;
+				}
+			}
 			spin_lock_irqsave(&priv->mbx_lock, flags);
 			mbx_mask = hecc_read(priv, HECC_CANME);
 			mbx_mask |= HECC_RX_HIGH_MBOX_MASK;
@@ -747,6 +789,7 @@ static int ti_hecc_error(struct net_device *ndev, int int_status,
 		}
 	}
 
+	trace_pxc_canpkt(cf);  /* trace point B: dump generated error packet */
 	stats->rx_packets++;
 	stats->rx_bytes += cf->can_dlc;
 	netif_rx(skb);
@@ -787,7 +830,6 @@ static irqreturn_t ti_hecc_interrupt(int irq, void *dev_id)
 			stats->tx_bytes += hecc_read_mbx(priv, mbxno,
 						HECC_CANMCF) & 0xF;
 			stats->tx_packets++;
-			can_led_event(ndev, CAN_LED_EVENT_TX);
 			can_get_echo_skb(ndev, mbxno);
 			--priv->tx_tail;
 		}
@@ -825,7 +867,7 @@ static int ti_hecc_open(struct net_device *ndev)
 	struct ti_hecc_priv *priv = netdev_priv(ndev);
 	int err;
 
-	err = request_irq(ndev->irq, ti_hecc_interrupt, IRQF_SHARED,
+	err = request_irq(ndev->irq, ti_hecc_interrupt, IRQF_SHARED | IRQF_THREAD_TBL_LOOKUP,
 			ndev->name, ndev);
 	if (err) {
 		netdev_err(ndev, "error requesting interrupt\n");
@@ -843,8 +885,6 @@ static int ti_hecc_open(struct net_device *ndev)
 		return err;
 	}
 
-	can_led_event(ndev, CAN_LED_EVENT_OPEN);
-
 	ti_hecc_start(ndev);
 	napi_enable(&priv->napi);
 	netif_start_queue(ndev);
@@ -863,8 +903,6 @@ static int ti_hecc_close(struct net_device *ndev)
 	close_candev(ndev);
 	ti_hecc_transceiver_switch(priv, 0);
 
-	can_led_event(ndev, CAN_LED_EVENT_STOP);
-
 	return 0;
 }
 
@@ -875,6 +913,56 @@ static const struct net_device_ops ti_hecc_netdev_ops = {
 	.ndo_change_mtu		= can_change_mtu,
 };
 
+struct ti_hecc_platform_data *of_get_can_pdata(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct ti_hecc_platform_data *pdata;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return NULL; /* out of memory */
+
+	if (of_property_read_u32(np, "ti,hecc-scc-hecc-offset", &pdata->scc_hecc_offset)) {
+		dev_info(dev, "property ti,hecc-scc-hecc-offset is missing!\n");
+		goto out_err;
+	}
+
+	if (of_property_read_u32(np, "ti,hecc-scc-ram-offset", &pdata->scc_ram_offset)) {
+		dev_info(dev, "property: ti,hecc-scc-ram-offset is missing!\n");
+		goto out_err;
+	}
+
+	if (of_property_read_u32(np, "ti,hecc-ram-offset", &pdata->hecc_ram_offset)) {
+		dev_info(dev, "property: ti,hecc-ram-offset is missing!\n");
+		goto out_err;
+	}
+
+	if (of_property_read_u32(np, "ti,hecc-mbx-offset", &pdata->mbx_offset)) {
+		dev_info(dev, "property: ti,hecc-mbx-offset is missing!\n");
+		goto out_err;
+	}
+
+	if (of_property_read_u32(np, "ti,hecc-int-line", &pdata->int_line)) {
+		dev_info(dev, "property: ti,hecc-int-line is missing!\n");
+		goto out_err;
+	}
+
+	if (of_property_read_u32(np, "ti,hecc-version", &pdata->version)) {
+		dev_info(dev, "property: ti,hecc-version is missing!\n");
+		goto out_err;
+	}
+
+	dev->platform_data = pdata;
+
+	return pdata;
+
+out_err:
+
+	kfree(pdata);
+
+	return NULL;
+}
+
 static int ti_hecc_probe(struct platform_device *pdev)
 {
 	struct net_device *ndev = (struct net_device *)0;
@@ -884,7 +972,15 @@ static int ti_hecc_probe(struct platform_device *pdev)
 	void __iomem *addr;
 	int err = -ENODEV;
 
-	pdata = dev_get_platdata(&pdev->dev);
+
+	if (pdev->dev.of_node) {
+		pdata = of_get_can_pdata(&pdev->dev);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
+	} else {
+		pdata = dev_get_platdata(&pdev->dev);
+	}
+
 	if (!pdata) {
 		dev_err(&pdev->dev, "No platform data\n");
 		goto probe_exit;
@@ -930,6 +1026,7 @@ static int ti_hecc_probe(struct platform_device *pdev)
 
 	priv->can.bittiming_const = &ti_hecc_bittiming_const;
 	priv->can.do_set_mode = ti_hecc_do_set_mode;
+	priv->can.do_get_state = ti_hecc_get_state;
 	priv->can.do_get_berr_counter = ti_hecc_get_berr_counter;
 	priv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;
 
@@ -962,9 +1059,6 @@ static int ti_hecc_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "register_candev() failed\n");
 		goto probe_exit_clk;
 	}
-
-	devm_can_led_init(ndev);
-
 	dev_info(&pdev->dev, "device registered (reg_base=%p, irq=%u)\n",
 		priv->base, (u32) ndev->irq);
 
@@ -995,6 +1089,7 @@ static int ti_hecc_remove(struct platform_device *pdev)
 	iounmap(priv->base);
 	release_mem_region(res->start, resource_size(res));
 	free_candev(ndev);
+	platform_set_drvdata(pdev, NULL);
 
 	return 0;
 }
@@ -1044,10 +1139,21 @@ static int ti_hecc_resume(struct platform_device *pdev)
 #define ti_hecc_resume NULL
 #endif
 
+#ifdef CONFIG_OF
+static const struct of_device_id ti_hecc_dt_ids[] = {
+	{ .compatible = "ti,hecc", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ti_hecc_dt_ids);
+#endif
+
 /* TI HECC netdevice driver: platform driver structure */
 static struct platform_driver ti_hecc_driver = {
 	.driver = {
 		.name    = DRV_NAME,
+#ifdef CONFIG_OF
+		.of_match_table = ti_hecc_dt_ids,
+#endif
 	},
 	.probe = ti_hecc_probe,
 	.remove = ti_hecc_remove,
diff --git a/drivers/net/ethernet/micrel/Kconfig b/drivers/net/ethernet/micrel/Kconfig
index b7e2f49..29f0ddc6 100644
--- a/drivers/net/ethernet/micrel/Kconfig
+++ b/drivers/net/ethernet/micrel/Kconfig
@@ -61,4 +61,9 @@ config KSZ884X_PCI
 	  To compile this driver as a module, choose M here. The module
 	  will be called ksz884x.
 
+config KSZ8863
+	tristate "Micrel KSZ8863"
+	---help---
+	  This driver adds the KSZ8863 switch driver.
+
 endif # NET_VENDOR_MICREL
diff --git a/drivers/net/ethernet/micrel/Makefile b/drivers/net/ethernet/micrel/Makefile
index c83e4bc..931975d 100644
--- a/drivers/net/ethernet/micrel/Makefile
+++ b/drivers/net/ethernet/micrel/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_KS8842) += ks8842.o
 obj-$(CONFIG_KS8851) += ks8851.o
 obj-$(CONFIG_KS8851_MLL) += ks8851_mll.o
 obj-$(CONFIG_KSZ884X_PCI) += ksz884x.o
+obj-$(CONFIG_KSZ8863) += ksz8863.o
diff --git a/drivers/net/ethernet/micrel/ksz8863.c b/drivers/net/ethernet/micrel/ksz8863.c
new file mode 100644
index 0000000..5f9a235
--- /dev/null
+++ b/drivers/net/ethernet/micrel/ksz8863.c
@@ -0,0 +1,261 @@
+/*
+ * WAGO Rocket Local Bus Tripple Buffer Core driver
+ *
+ * Copyright (C) 2014 Wago Kontakttechnik GmbH
+ *	Santosh Shilimkar <santosh.shilimkar@ti.com>
+ *	Sricharan <r.sricharan@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+#undef DEBUG
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_mdio.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/ksz8863.h>
+
+#define DRIVER_NAME		"ksz8863"
+
+struct ksz8863_info {
+	/* back-link to device */
+	struct device *dev;
+	struct mii_bus *mii_bus;
+	int reset_gpio;
+	bool disable_internal_ldo;
+	bool reset;
+};
+
+struct ksz8863_info *ksz_info = NULL;
+
+struct ksz8863_info *of_get_ksz8863_pdata(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	/* struct ksz8863_info *ksz_info; */
+	struct pinctrl *pinctrl;
+	struct device_node *mdio_node;
+	int ret;
+
+	ksz_info = devm_kzalloc(dev, sizeof(*ksz_info), GFP_KERNEL);
+	if (!ksz_info)
+		return NULL; /* out of memory */
+
+	ksz_info->reset = false;
+	ksz_info->disable_internal_ldo = false;
+	ksz_info->reset_gpio = 0;
+
+	if (np) {
+
+		pinctrl = devm_pinctrl_get_select_default(dev);
+		if (IS_ERR(pinctrl))
+			dev_warn(dev, "pins are not configured from the driver\n");
+
+		if (of_find_property(np, "ksz,disable-internal-ldo", NULL))
+			ksz_info->disable_internal_ldo = true;
+
+		ksz_info->reset_gpio = of_get_named_gpio(np, "ksz,gpio-reset", 0);
+		if (ksz_info->reset_gpio == -EPROBE_DEFER)
+			return ERR_PTR(-EPROBE_DEFER);
+
+		if (ksz_info->reset_gpio < 0) {
+			dev_err(dev, "No gpio reset pin given\n");
+			ksz_info->reset = false;
+			goto skip_reset;
+		}
+
+		if (of_find_property(np, "ksz,reset-switch", NULL))
+			ksz_info->reset = true;
+
+		ret = devm_gpio_request_one(dev, ksz_info->reset_gpio,
+					    GPIOF_OUT_INIT_HIGH | GPIOF_EXPORT_DIR_FIXED,
+					    "GPIO Switch Reset Pin");
+		if (ret < 0) {
+			dev_err(dev, "failed to claim gpio-reset pin\n");
+			return NULL;
+		}
+
+	skip_reset:
+
+		dev_warn(dev, "Switch will %s resetted.\n",
+			 ksz_info->reset ? "be" : "NOT be");
+
+		/* get mdio node */
+		mdio_node = of_parse_phandle(np, "ksz,mii-bus", 0);
+		if (!mdio_node) {
+			dev_err(dev, "can't find node 'ksz,mii-bus'\n");
+			return ERR_PTR(-EINVAL);
+		}
+
+		ksz_info->mii_bus = of_mdio_find_bus(mdio_node);
+		if (!ksz_info->mii_bus) {
+			dev_err(dev, "can't find mii bus device\n");
+			return ERR_PTR(-EPROBE_DEFER);
+		}
+
+		dev_info(dev, "found and using '%s'.\n", ksz_info->mii_bus->name);
+	}
+
+	ksz_info->dev = dev;
+
+	return ksz_info;
+}
+
+static void ksz8863_hw_reset(struct ksz8863_info *ksz_info)
+{
+	dev_info(ksz_info->dev, "Going to reset gpio%d\n", ksz_info->reset_gpio);
+	gpio_set_value(ksz_info->reset_gpio, 0);
+	mdelay(100);
+	gpio_set_value(ksz_info->reset_gpio, 1);
+	dev_info(ksz_info->dev, "KSZ8863 Switch resetted!\n");
+}
+
+/* functions for switch register access over mdio */
+static int ksz8863_smi_nread(u8 reg, u8 *rxbuf, int len)
+{
+	int i;
+	int nreg = (int) reg;
+
+	if (!ksz_info || !ksz_info->mii_bus)
+		return -1;
+
+	nreg |= MII_ADDR_KSZ;
+
+	for (i = 0; i < len; i++) {
+		rxbuf[i] = mdiobus_read(ksz_info->mii_bus, 0, nreg + i) & 0xff;
+		pr_debug("%s:%d: read %d byte(s), reg 0x%x, val 0x%x\n",
+			 __func__, __LINE__, len, reg, rxbuf[i]);
+	}
+
+	return 0;
+}
+
+static int ksz8863_smi_nwrite(u8 reg, u8 *txbuf, int len)
+{
+	int i;
+	int nreg = (int) reg;
+
+	if (!ksz_info || !ksz_info->mii_bus)
+		return -1;
+
+	nreg |= MII_ADDR_KSZ;
+
+	for (i = 0; i < len; i++) {
+		mdiobus_write(ksz_info->mii_bus, 0, nreg + i, txbuf[i]);
+		pr_debug("%s:%d: wrote %d byte(s), reg 0x%x, val 0x%x\n",
+			 __func__, __LINE__, len, reg, txbuf[i]);
+	}
+
+	return 0;
+}
+
+struct ksz8863_fns_t ksz8863_fns_data = {};
+struct ksz8863_fns_t *ksz8863_fns = &ksz8863_fns_data;
+
+static int ksz8863_probe(struct platform_device *pdev)
+{
+	struct ksz8863_info *pdata;
+	u8 v;
+	u8 chipid[2];
+	int ret;
+
+	pr_debug("%s/%d\n", __func__, __LINE__);
+
+	if (pdev->dev.of_node) {
+		pdata = of_get_ksz8863_pdata(&pdev->dev);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
+	}
+
+	if (pdata && pdata->reset)
+		ksz8863_hw_reset(pdata);
+
+	if ((ret = ksz8863_smi_nread(ChipID0, chipid, 2)))
+		return -1;
+
+	if (chipid[0] == KSZ8863_FAMILY_ID &&
+	    (chipid[1] >> 4) == KSZ8863_CHIP_ID)
+		dev_info(&pdev->dev, "Detected Family ID 0x%x, Chip ID 0x%x\n", chipid[0], chipid[1] >> 4);
+
+	if (pdata && pdata->disable_internal_ldo) {
+                if ((ret = ksz8863_smi_nread(Internal1v8ldoControl, &v, 1)))
+                        return -1;
+
+		/* disable internal 1.8V LDO */
+		v |= BIT(6);
+
+		if ((ret = ksz8863_smi_nwrite(Internal1v8ldoControl, &v, 1)))
+			return -1;
+
+		pr_info("%s: 1.8V LDO disabled\n", __func__);
+	}
+
+	pdev->dev.platform_data = pdata;
+
+	ksz8863_fns->nread  = ksz8863_smi_nread;
+	ksz8863_fns->nwrite = ksz8863_smi_nwrite;
+
+	dev_info(&pdev->dev, "KSZ8863 Switch Reset Driver probed\n");
+
+	return 0;
+}
+
+static int ksz8863_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id ksz8863_dt_ids[] = {
+	{ .compatible = "micrel,ksz8863", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ksz8863_dt_ids);
+#endif
+
+static struct platform_driver ksz8863_driver = {
+	.probe  = ksz8863_probe,
+	.remove = ksz8863_remove,
+	.driver = {
+		.name   = DRIVER_NAME,
+		.owner  = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = ksz8863_dt_ids,
+#endif
+	},
+};
+
+module_platform_driver(ksz8863_driver);
+
+MODULE_AUTHOR("Heinrich Toews");
+MODULE_DESCRIPTION("KSZ8863 Switch Reset Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
index 2651c8d..a4fb062 100644
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@ -15,6 +15,16 @@ if PHYLIB
 config SWPHY
 	bool
 
+config SWCONFIG
+	tristate "Switch configuration API"
+	---help---
+	  Switch configuration API using netlink. This allows
+	  you to configure the VLAN features of certain switches.
+
+config SWCONFIG_LEDS
+	bool "Switch LED trigger support"
+	depends on (SWCONFIG && LEDS_TRIGGERS)
+
 comment "MDIO bus device drivers"
 
 config MDIO_BCM_IPROC
@@ -43,6 +53,17 @@ config MDIO_BITBANG
 
 	  If in doubt, say N.
 
+if MDIO_BITBANG
+
+	config MICREL_KSZ8863_EXTENDED_REGS
+	       bool "Enable ksz8863 extended reg access"
+	       default y
+	       help
+		 This config enables special treatment for ksz8863
+		 extended register access
+
+endif
+
 config MDIO_BUS_MUX
 	tristate
 	depends on OF_MDIO
@@ -226,6 +247,11 @@ config DP83867_PHY
 	---help---
 	  Currently supports the DP83867 PHY.
 
+config MICREL_KSZ8863_PHY
+	tristate "Driver for Micrel KSZ8863 PHY"
+	---help---
+	  Supports the KSZ8863 PHY.
+
 config FIXED_PHY
 	tristate "MDIO Bus/PHY emulation with fixed speed/link PHYs"
 	depends on PHYLIB
@@ -326,3 +352,11 @@ endif # PHYLIB
 config MICREL_KS8995MA
 	tristate "Micrel KS8995MA 5-ports 10/100 managed Ethernet switch"
 	depends on SPI
+
+config SWCFG_KSZ8863
+       tristate "KSZ8863 SWCONFIG Configuration Interface via netlink"
+       depends on SWCONFIG
+
+config SWCFG_MV88E6321
+       tristate "MV88E6321 SWCONFIG Configuration Interface via netlink"
+       depends on SWCONFIG
diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
index e58667d..5e7d44f 100644
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_LXT_PHY)		+= lxt.o
 obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
 obj-$(CONFIG_MICREL_PHY)	+= micrel.o
+obj-$(CONFIG_MICREL_KSZ8863_PHY) += ksz8863-phy.o
 obj-$(CONFIG_MICROCHIP_PHY)	+= microchip.o
 obj-$(CONFIG_MICROSEMI_PHY)	+= mscc.o
 obj-$(CONFIG_NATIONAL_PHY)	+= national.o
@@ -53,3 +54,5 @@ obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
+obj-$(CONFIG_SWCONFIG)		+= swconfig.o
+obj-$(CONFIG_SWCFG_KSZ8863)     += ksz8863-cfg.o
diff --git a/drivers/net/phy/ksz8863-cfg.c b/drivers/net/phy/ksz8863-cfg.c
new file mode 100644
index 0000000..f68c49c
--- /dev/null
+++ b/drivers/net/phy/ksz8863-cfg.c
@@ -0,0 +1,1726 @@
+/*
+ * ksz8863-cfg.c
+ *
+ * Copyright (c) 2010 SAGEM Communications
+ *
+ * Author: Karl Beldan <karl.beldan@sagemcom.com>
+ *
+ * Licensed under the GPL version 2
+ */
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+/* #include <linux/smp_lock.h> */
+#include <linux/mutex_rt.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <asm/uaccess.h>
+#if defined(CONFIG_SWCONFIG) || defined(CONFIG_SWCONFIG_MODULE)
+#include <linux/switch.h>
+#endif /* CONFIG_SWCONFIG */
+
+#include <linux/ksz8863.h>
+
+#define KSZ8863_CPU_PORT                2
+#define KSZ8863_NUM_PORTS               3
+#define KSZ8863_NUM_VLANS               16
+
+// Global Control
+#define GC3_VLAN_ENABLE_SHIFT           7
+// Port Control
+#define PC0_TAG_INSERT_SHIFT            2
+#define PC0_TAG_REMOVE_SHIFT            1
+#define PC1_TAG_DOUBLE_SHIFT            4
+#define PC2_IN_PORT_VLAN_FILT_SHIFT     6
+// Indirect Access Control
+#define IAC0_RD_bWR_SHIFT               4
+#define IAC0_TBL_SEL_SHIFT              2
+#define IAC0_TBL_SEL_STATIC_MAC         0
+#define IAC0_TBL_SEL_VLAN               1
+#define IAC0_TBL_SEL_DYN_MAC            2
+#define IAC0_TBL_SEL_MIB_CNT            3
+#define MAX_TBL_ENTRY_LEN               (IndirectDataRegister0 - IndirectDataRegister8 + 1)
+// Indirect Data
+#define ID8_READ_IN_PROGRESS_SHIFT      7
+// Reset
+#define RESET_SOFTWARE_SHIFT            4
+#define RESET_PCS_SHIFT                 0
+
+#define KSZ8863_MAX_STATIC_ENTRIES      20
+
+#define MASK(msb, lsb)          \
+        ( (((u32)1<<((msb)-(lsb)+1))-1) << (lsb) )
+#define GET(v, msb, lsb)        \
+        ( ((u32)(v) & MASK(msb,lsb)) >> (lsb) )
+#define SET(v, f, msb, lsb)     \
+        ( (v) = ((v)&~MASK(msb,lsb)) | (( (u32)(f)<<(lsb) ) & MASK(msb,lsb)) )
+
+#define DFLT_CFG_FLAGS                  KSZ8863_CFG_PWRDOWN_FLAG
+
+static int ksz8863_soft_reset(void)
+{
+        u8 v;
+        int ret;
+        unsigned long time;
+        unsigned rmask = BIT(RESET_SOFTWARE_SHIFT) | BIT(RESET_PCS_SHIFT);
+
+        v = rmask;
+        if ((ret = ksz8863_nwrite(Reset, &v, 1)))
+                return ret;
+
+        time = jiffies + HZ;
+        do {
+                mdelay(10);
+                if ((ret = ksz8863_nread(Reset, &v, 1)))
+                        return ret;
+        } while(v & rmask && time_after(time, jiffies));
+
+        return (v & rmask) ? -1 : 0;
+}
+
+static int ksz8863_setup_dflt_cfg(int flags)
+{
+        u8 reg_val[3];
+        int ret;
+
+        // Reset
+        if ((ret = ksz8863_soft_reset()))
+                return ret;
+
+#ifdef CONFIG_NET_DSA_KSZ8863
+	if (is_dsa_enabled()) {
+        // Tail tagging - enable
+#define GC1_TAIL_TAG_MODE_ENABLE_SHIFT                  6
+                if ((ret = ksz8863_nread(GlobalControl1, reg_val, 1)))
+                        return ret;
+                *reg_val |= 1 << GC1_TAIL_TAG_MODE_ENABLE_SHIFT;
+                if ((ret = ksz8863_nwrite(GlobalControl1, reg_val, 1)))
+                        return ret;
+		/* if dsa configured than by default set ports 1 + 2 into listening state */
+		reg_val[0] = reg_val[1] = 0x1; /* disable address learning */
+		if ((ret = ksz8863_nwrite(Port1Control2, &reg_val[0], 1)))
+			return ret;
+		if ((ret = ksz8863_nwrite(Port2Control2, &reg_val[1], 1)))
+			return ret;
+        }
+#endif
+
+	/* Turn on IGMP Snooping */
+        if ((ret = ksz8863_nread(GlobalControl3, reg_val, 1)))
+                return ret;
+        *reg_val |= BIT(6);
+        if ((ret = ksz8863_nwrite(GlobalControl3, reg_val, 1)))
+                return ret;
+
+#define GC12_UNKNOWN_PACKET_DFLT_PORT_ENABLE_SHIFT      7
+#define GC12_UNKNOWN_PACKET_DFLT_PORT_SHIFT             0
+        if ((ret = ksz8863_nread(GlobalControl12, reg_val, 1)))
+                return ret;
+        *reg_val |= 1 << GC12_UNKNOWN_PACKET_DFLT_PORT_ENABLE_SHIFT;
+
+	// clear default port bits
+	*reg_val &= ~(7 << GC12_UNKNOWN_PACKET_DFLT_PORT_SHIFT);
+	if (is_dsa_enabled())
+		// Unknown MAC @ddress - broadcoast only to cpu port (needed for multicast traffic)
+		*reg_val |= 4 << GC12_UNKNOWN_PACKET_DFLT_PORT_SHIFT;
+	else
+		// Unknown MAC @ddress - broadcoast to every ports
+		*reg_val |= 7 << GC12_UNKNOWN_PACKET_DFLT_PORT_SHIFT;
+
+        if ((ret = ksz8863_nwrite(GlobalControl12, reg_val, 1)))
+                return ret;
+
+#define PC0_BROADCAST_STORM_PROTECT_ENABLE_SHIFT        7
+#ifndef CONFIG_NET_DSA_KSZ8863
+        // Split TXQ in 4 - the datasheet wrongly states it is default
+#define PC0_TXQ_SPLIT_ENABLE_SHIFT                      0
+#define PC0_PORT_PRIO_SHIFT                             3
+        // Queue 3 has highest priority
+#define PC0_PRIO_DIFFSERV_CLASS_SHIFT                   6
+        // Protect against broadcast storms
+        *reg_val = 1 << PC0_TXQ_SPLIT_ENABLE_SHIFT;
+        *reg_val |= 1 << PC0_BROADCAST_STORM_PROTECT_ENABLE_SHIFT;
+#else
+        *reg_val = 1 << PC0_BROADCAST_STORM_PROTECT_ENABLE_SHIFT;
+#endif
+        reg_val[1] = reg_val[2] = *reg_val;
+
+	/* Enable BCAST Protection on Port1 & Port2 */
+        if ((ret = ksz8863_nwrite(Port1Control0, &reg_val[0], 1)))
+                return ret;
+        if ((ret = ksz8863_nwrite(Port2Control0, &reg_val[1], 1)))
+                return ret;
+
+        /* Set Port 1 and 2 LED Modes Bits [5,4]
+         *   00: LED0 -> Link/ACT, LED1 -> Speed
+         *   01: LED0 -> Link    , LED1 -> ACT
+         *   10: LED0 -> Link/ACT, LED1 -> Duplex
+         *   11: LED0 -> Link    , LED1 -> Duplex
+         */
+
+        // LEDs - LED0 -> Link, LED1 -> ACT
+#define PM_LED_MODE_SELECTION_SHIFT                     4
+        if ((ret = ksz8863_nread(PowerManagementLedMode, reg_val, 1)))
+                return ret;
+        *reg_val &= ~(3 << PM_LED_MODE_SELECTION_SHIFT);
+        *reg_val |=   1 << PM_LED_MODE_SELECTION_SHIFT;
+        if ((ret = ksz8863_nwrite(PowerManagementLedMode, reg_val, 1)))
+                return ret;
+
+	/* Put Port 3 (CPU) into MAC Mode */
+        *reg_val = 1 << 7;
+        if ((ret = ksz8863_nwrite(Port3Control5, reg_val, 1)))
+                return ret;
+
+        // Power Down the ports
+        if (flags & KSZ8863_CFG_PWRDOWN_FLAG) {
+		if ((ret = ksz8863_nread(Port1Control13, reg_val, 1)))
+			return ret;
+#define PC1_POWER_DOWN_SHIFT                            3
+		*reg_val |= 1 << PC1_POWER_DOWN_SHIFT;
+		if ((ret = ksz8863_nwrite(Port1Control13, reg_val, 1)))
+			return ret;
+		if ((ret = ksz8863_nwrite(Port2Control13, reg_val, 1)))
+			return ret;
+	}
+
+	if (is_dsa_enabled()) {
+		/* Setup STP Settings */
+		*reg_val = 0x3; 	/* RX Enable, Learning disable */
+		if ((ret = ksz8863_nwrite(Port1Control2, reg_val, 1))) /* X2 */
+			return ret;
+		if ((ret = ksz8863_nwrite(Port2Control2, reg_val, 1))) /* X1 */
+			return ret;
+		*reg_val = 0x5; 	/* RX Enable, Learning disable */
+		if ((ret = ksz8863_nwrite(Port3Control2, reg_val, 1))) /* CPU */
+			return ret;
+	}
+
+        return 0;
+}
+
+#if defined(CONFIG_SWCONFIG) || defined(CONFIG_SWCONFIG_MODULE)
+static char __buf[2048];
+
+
+/**
+ * TABLES
+ */
+static int tbl_nread(unsigned table, u16 addr, u8 *buf, unsigned len)
+{
+        u8 val[2];
+        int ret;
+
+        if (table > IAC0_TBL_SEL_MIB_CNT) {
+                printk(KERN_ERR "%s: invalid table (%d)\n", __func__, table);
+                return -EINVAL;
+        }
+        if (addr & ~((1 << 10) - 1)) {
+                printk(KERN_ERR "%s: invalid address (%d)\n", __func__, addr);
+                return -EINVAL;
+        }
+        if (len > MAX_TBL_ENTRY_LEN || !len) {
+                printk(KERN_ERR "%s: invalid len (%d)\n", __func__, len);
+                return -EINVAL;
+        }
+
+
+        val[0] = 1 << IAC0_RD_bWR_SHIFT;
+        val[0] |= table << IAC0_TBL_SEL_SHIFT;
+        val[0] |= addr >> 8;
+        val[1] = addr & 0xff;
+        if ((ret = ksz8863_nwrite(IndirectAccessControl0, val, 2)))
+                return ret;
+        if (table == IAC0_TBL_SEL_DYN_MAC || table == IAC0_TBL_SEL_MIB_CNT) {
+                unsigned long time = jiffies + HZ;
+                do {
+                        if ((ret = ksz8863_nread(IndirectDataRegister8, val, 1)))
+                                return ret;
+                        mdelay(10);
+                } while(val[0] & BIT(ID8_READ_IN_PROGRESS_SHIFT) && time_after(time, jiffies)); // cpu status read
+                if (val[0] & BIT(ID8_READ_IN_PROGRESS_SHIFT)) {
+                        printk(KERN_ERR "%s: access timed out\n", __func__);
+                        return -1;
+                }
+        }
+        return ksz8863_nread(IndirectDataRegister0 - len + 1, buf, len);
+}
+
+static int tbl_nwrite(unsigned table, u16 addr, u8 *buf, unsigned len)
+{
+        u8 val[2];
+        int ret;
+
+        if (table > IAC0_TBL_SEL_VLAN) {
+                printk(KERN_ERR "%s: invalid table (%d)\n", __func__, table);
+                return -EINVAL;
+        }
+        if (addr & ~((1 << 10) - 1)) {
+                printk(KERN_ERR "%s: invalid address (%d)\n", __func__, addr);
+                return -EINVAL;
+        }
+        if (len > MAX_TBL_ENTRY_LEN || !len) {
+                printk(KERN_ERR "%s: invalid len (%d)\n", __func__, len);
+                return -EINVAL;
+        }
+
+        if ((ret = ksz8863_nwrite(IndirectDataRegister0 - len + 1, buf, len)))
+                return ret;
+
+        val[0] = table << IAC0_TBL_SEL_SHIFT;
+        val[0] |= addr >> 8; // indirect address
+        val[1] = addr & 0xff;
+        return ksz8863_nwrite(IndirectAccessControl0, val, 2);
+}
+
+/**
+ * Dynamic MAC Address Table
+ */
+struct dyn_mac_tbl_e {
+        unsigned long long mac:48;
+        unsigned fid:4;
+        unsigned port:2;
+        unsigned time:2;
+        unsigned valid_nb:10; // global
+        unsigned empty:1;     // global
+        unsigned reserved:4;
+        unsigned nrdy:1;
+} __attribute__((packed));
+
+static int get_dyn_mac_e(unsigned idx, struct dyn_mac_tbl_e *entry)
+{
+        u8 buf[sizeof(struct dyn_mac_tbl_e)];
+        int i;
+
+        if (idx > 1 << 10)
+                return -EINVAL;
+
+        if (tbl_nread(IAC0_TBL_SEL_DYN_MAC, idx, buf, sizeof(struct dyn_mac_tbl_e)))
+                return -EIO;
+
+        for (i = 0; i < sizeof(struct dyn_mac_tbl_e); i++)
+                ((u8 *)entry)[i] = buf[sizeof(struct dyn_mac_tbl_e) - 1 - i];
+
+        return 0;
+}
+
+/**
+ * Static MAC Address Table
+ */
+struct static_mac_tbl_e {
+        unsigned long long mac:48;
+        unsigned forward_ports:3;
+        unsigned valid:1;
+        unsigned override:1;
+        unsigned use_fid:1;
+        unsigned fid:4;
+} __attribute__((packed));
+
+static int get_static_mac_e(unsigned idx, struct static_mac_tbl_e *entry)
+{
+        u8 buf[sizeof(struct static_mac_tbl_e)];
+        int i;
+
+        if (idx > 1 << 10)
+                return -EINVAL;
+
+        if (tbl_nread(IAC0_TBL_SEL_STATIC_MAC, idx, buf, sizeof(struct static_mac_tbl_e)))
+                return -EIO;
+
+        for (i = 0; i < sizeof(struct static_mac_tbl_e); i++)
+                ((u8 *)entry)[i] = buf[sizeof(struct static_mac_tbl_e) - 1 - i];
+
+        return 0;
+}
+
+/**
+ * VLAN table
+ */
+struct vlan_tbl_e {
+        unsigned vid:12;
+        unsigned fid:4;
+        unsigned member:3;
+        unsigned valid:1;
+} __attribute__((packed));
+
+static int get_vlan_tbl_e(unsigned idx, struct vlan_tbl_e *entry)
+{
+        u8 buf[sizeof(struct vlan_tbl_e)];
+        int i;
+
+        if (idx > KSZ8863_NUM_VLANS)
+                return -EINVAL;
+
+        if (tbl_nread(IAC0_TBL_SEL_VLAN, idx, buf, sizeof(struct vlan_tbl_e)))
+                return -EIO;
+
+        for (i = 0; i < sizeof(struct vlan_tbl_e); i++)
+                ((u8 *)entry)[i] = buf[sizeof(struct vlan_tbl_e) - 1 - i];
+
+        return 0;
+};
+
+static int set_vlan_tbl_e(unsigned idx, struct vlan_tbl_e *entry)
+{
+        u8 buf[sizeof(struct vlan_tbl_e)];
+        int i;
+
+        if (idx > KSZ8863_NUM_VLANS)
+                return -EINVAL;
+
+        for (i = 0; i < sizeof(struct vlan_tbl_e); i++)
+                buf[i] = ((u8 *)entry)[sizeof(struct vlan_tbl_e) - 1 - i];
+
+        return tbl_nwrite(IAC0_TBL_SEL_VLAN, idx, buf, sizeof(struct vlan_tbl_e));
+};
+
+
+
+/**
+ *
+ */
+static u8 cur_reg = 0;
+static u8 cur_port = 1;
+
+static int setregbits(u8 reg, u8 val, unsigned msb, unsigned lsb)
+{
+        u8 v;
+        int ret;
+
+        if (msb > 8)
+                return -EINVAL;
+
+        if ((ret = ksz8863_nread(reg, &v, 1)))
+                return ret;
+
+        SET(v, val, msb, lsb);
+
+        return ksz8863_nwrite(reg, &v, 1);
+}
+
+static int getregbits(u8 reg, u8 *val, unsigned msb, unsigned lsb)
+{
+        u8 v;
+        int ret;
+
+        if (msb > 8)
+                return -EINVAL;
+
+        if ((ret = ksz8863_nread(reg, &v, 1)))
+                return ret;
+
+        *val = GET(v, msb, lsb);
+
+        return 0;
+}
+
+
+static int ksz8863_sw_set_sel_reg(struct switch_dev *dev,
+                                  const struct switch_attr *attr,
+                                  struct switch_val *val)
+{
+        cur_reg = val->value.i;
+        return 0;
+}
+
+static int ksz8863_sw_get_sel_reg(struct switch_dev *dev,
+                                  const struct switch_attr *attr,
+                                  struct switch_val *val)
+{
+        val->value.i = cur_reg;
+        return 0;
+}
+
+static int ksz8863_sw_set_reg(struct switch_dev *dev,
+                              const struct switch_attr *attr,
+                              struct switch_val *val)
+{
+        u8 v = val->value.i;
+        return ksz8863_nwrite(cur_reg, &v, 1);
+}
+
+static int ksz8863_sw_get_reg(struct switch_dev *dev,
+                              const struct switch_attr *attr,
+                              struct switch_val *val)
+{
+        u8 v;
+        int ret;
+
+        if ((ret = ksz8863_nread(cur_reg, &v, 1)))
+                return ret;
+        val->value.i = v;
+
+        return 0;
+}
+
+static inline int ksz8863_sw_set_vlan_enable(struct switch_dev *dev,
+                                             const struct switch_attr *attr,
+                                             struct switch_val *val)
+{
+        return setregbits(GlobalControl3, !!val->value.i, GC3_VLAN_ENABLE_SHIFT, GC3_VLAN_ENABLE_SHIFT);
+}
+
+static inline int ksz8863_sw_get_vlan_enable(struct switch_dev *dev,
+                                             const struct switch_attr *attr,
+                                             struct switch_val *val)
+{
+        int ret;
+        u8 v;
+
+        if ((ret = getregbits(GlobalControl3, &v, GC3_VLAN_ENABLE_SHIFT, GC3_VLAN_ENABLE_SHIFT)))
+                return ret;
+        val->value.i = v;
+
+        return 0;
+}
+
+static int ksz8863_sw_set_vlan_table(struct switch_dev *dev,
+                                     const struct switch_attr *attr,
+                                     struct switch_val *val)
+{
+        struct vlan_tbl_e entry;
+        int vid, fid, member, valid;
+
+        if (sscanf(val->value.s, "%d,%d,%d,%d",
+                   &vid,
+                   &fid,
+                   &member,
+                   &valid) != 4)
+                return -EINVAL;
+
+        entry.vid    = vid;
+        entry.fid    = fid;
+        entry.member = member;
+        entry.valid  = valid;
+
+        return set_vlan_tbl_e(val->port_vlan, &entry);
+}
+
+static int ksz8863_sw_get_vlan_table(struct switch_dev *dev,
+                                     const struct switch_attr *attr,
+                                     struct switch_val *val)
+{
+        struct vlan_tbl_e entry;
+        int ret;
+
+        if ((ret = get_vlan_tbl_e(val->port_vlan, &entry)))
+                return ret;
+
+        val->len = snprintf(__buf, sizeof(__buf), "%d,%d,%d,%d",
+                            entry.vid,
+                            entry.fid,
+                            entry.member,
+                            entry.valid);
+        val->value.s = __buf;
+
+        return 0;
+}
+
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+static int ksz8863_sw_get_dynmacs(struct switch_dev *dev,
+                                  const struct switch_attr *attr,
+                                  struct switch_val *val)
+{
+        struct dyn_mac_tbl_e entry;
+        u8 *buf;
+        int count;
+        int i;
+        int ret;
+
+        if ((ret = get_dyn_mac_e(0, &entry)))
+                return ret;
+
+        val->len = 0;
+        __buf[0] = '\0';
+        val->value.s = __buf;
+
+        if (entry.empty)
+                return 0;
+
+        count = entry.valid_nb + 1;
+        for (i = 0; i < count && sizeof(__buf) > val->len + 64; i++) {
+                if ((ret = get_dyn_mac_e(i, &entry)))
+                        return ret;
+                buf = (char *)&entry;
+                val->len += snprintf(__buf + val->len, sizeof(__buf) - val->len,
+                                     MAC_FMT "  %d  %02d  %d\n",
+                                     buf[5], buf[4], buf[3], buf[2], buf[1], buf[0],
+                                     entry.port,
+                                     entry.fid,
+                                     entry.time);
+        }
+
+        if (i < count)
+                printk(KERN_ERR "%s: --- %d MACs not displayed ---\n", __func__, count - i);
+
+        return 0;
+}
+
+static int ksz8863_sw_get_staticmacs(struct switch_dev *dev,
+				     const struct switch_attr *attr,
+				     struct switch_val *val)
+{
+        struct static_mac_tbl_e entry;
+        u8 *buf;
+        int i;
+        int ret;
+
+        if ((ret = get_static_mac_e(0, &entry)))
+                return ret;
+
+        val->len = 0;
+        __buf[0] = '\0';
+        val->value.s = __buf;
+
+	for (i = 1; i < KSZ8863_MAX_STATIC_ENTRIES; i++) {
+
+		  if (!entry.valid)
+			  break;
+
+		  buf = (char *)&entry;
+		  val->len += snprintf(__buf + val->len, sizeof(__buf) - val->len,
+				       MAC_FMT "  0x%x  %02d  %d\n",
+				       buf[5], buf[4], buf[3], buf[2], buf[1], buf[0],
+				       entry.forward_ports & 0x7,
+				       entry.fid,
+				       entry.override);
+
+		  /* get the next entry */
+		  if ((ret = get_static_mac_e(i, &entry)))
+			  return ret;
+        }
+
+        return 0;
+}
+
+static int ksz8863_sw_set_staticmacs(struct switch_dev *dev,
+				     const struct switch_attr *attr,
+				     struct switch_val *val)
+{
+        struct static_mac_tbl_e entry;
+	u8 buf[sizeof(struct static_mac_tbl_e)];
+        u8 *macaddr = (char *)&entry;
+	u16 idx;
+	int values[12], i;
+
+	/* scan data
+	 * command syntax should be <0,00:30:DE:FF:00:C0,0x4,1,1,0,0>2
+	 */
+        if (sscanf(val->value.s, "%d,"MAC_FMT",%x,%d,%d,%d,%d",
+		   &values[11],
+		   &values[5], &values[4], &values[3], &values[2], &values[1], &values[0],
+		   &values[6], &values[7], &values[8], &values[9], &values[10])!= 12)
+		return -EINVAL;
+
+	/* set the mac address */
+	for (i = 0; i < 6; i++)
+		macaddr[i] = (char) values[i];
+
+	entry.forward_ports = (unsigned) values[6] & 0x7;
+	entry.valid = (unsigned) values[7] & 0x1;
+	entry.override = (unsigned) values[8] & 0x1;
+	entry.use_fid = (unsigned) values[9] & 0x1;
+	entry.fid = (unsigned) values[10] & 0xf;
+	idx = (u16) values[11];
+
+	pr_info("%s:%d,"MAC_FMT",0x%x,%d,%d,%d,%d\n", __func__,
+	       idx,
+	       macaddr[5], macaddr[4], macaddr[3], macaddr[2], macaddr[1], macaddr[0],
+	       entry.forward_ports,
+	       entry.valid,
+	       entry.override,
+	       entry.use_fid,
+	       entry.fid);
+
+        for (i = 0; i < sizeof(struct static_mac_tbl_e); i++)
+                buf[i] = ((u8 *)&entry)[sizeof(struct static_mac_tbl_e) - 1 - i];
+
+        return tbl_nwrite(IAC0_TBL_SEL_STATIC_MAC, idx, buf, sizeof(struct static_mac_tbl_e));
+}
+
+static int ksz8863_sw_set_sel_port(struct switch_dev *dev,
+                                   const struct switch_attr *attr,
+                                   struct switch_val *val)
+{
+	if (val->value.i < 1 || val->value.i > 3)
+		return -EINVAL;
+
+        cur_port = val->value.i;
+        return 0;
+}
+
+static int ksz8863_sw_get_sel_port(struct switch_dev *dev,
+                                   const struct switch_attr *attr,
+                                   struct switch_val *val)
+{
+        val->value.i = cur_port;
+        return 0;
+}
+
+struct ksz_tbl_mib_entry {
+	int id;
+	char* str_id;
+	char* str_descr;
+};
+
+struct ksz_tbl_mib_entry ksz_tbl_mib [] = {
+	{  0x0, "RxLoPriorityByte", 	"Rx lo-priority (default) octet count including bad packets" },
+	{  0x1, "RxHiPriorityByte", 	"Rx hi-priority octet count including bad packets" },
+	{  0x2, "RxUndersizePkt", 	"Rx undersize packets w/ good CRC" },
+	{  0x3, "RxFragments", 		"Rx fragment packets w/ bad CRC, symbol errors or alignment errors" },
+	{  0x4, "RxOversize", 		"Rx oversize packets w/ good CRC (max: 1536 or 1522 bytes)" },
+	{  0x5, "RxJabbers", 		"Rx packets longer than 1522 bytes w/ either CRC errors," \
+					"alignment errors, or symbol errors (depends on max packet size setting)" },
+	{  0x6, "RxSymbolError",		"Rx packets w/ invalid data symbol and legal packet size." },
+	{  0x7, "RxCRCError", 		"Rx packets within (64,1522) bytes w/ an integral number of bytes and a bad CRC " \
+					"(upper limit depends on max packet size setting)" },
+	{  0x8, "RxAlignmentError", 	"Rx packets within (64,1522) bytes w/ a non-integral number of bytes and a bad CRC " \
+					"(upper limit depends on max packet size setting)" },
+	{  0x9, "RxControl8808Pkts", 	"Number of MAC control frames received by a port with 88-08h in EtherType field" },
+	{  0xA, "RxPausePkts", 		"Number of PAUSE frames received by a port. PAUSE frame is qualified with EtherType " \
+					"(88-08h), DA, control opcode (00-01), data length (64B min), and a valid CRC" },
+	{  0xB, "RxBroadcast", 		"Rx good broadcast packets (not including error broadcast packets or valid multicast packets)" },
+	{  0xC, "RxMulticast", 		"Rx good multicast packets (not including MAC control frames, " \
+					"error multicast packets or valid broadcast packets)" },
+	{  0xD, "RxUnicast", 		"Rx good unicast packets" },
+	{  0xE, "Rx64Octets", 		"Total Rx packets (bad packets included) that were 64 octets in length" },
+	{  0xF, "Rx65to127Octets", 	"Total Rx packets (bad packets included) that are between 65 and 127 octets in length" },
+	{ 0x10, "Rx128to255Octets", 	"Total Rx packets (bad packets included) that are between 128 and 255 octets in length" },
+	{ 0x11, "Rx256to511Octets", 	"Total Rx packets (bad packets included) that are between 256 and 511 octets in length" },
+	{ 0x12, "Rx512to1023Octets", 	"Total Rx packets (bad packets included) that are between 512 and 1023 octets in length" },
+	{ 0x13, "Rx1024to1522Octets", 	"Total Rx packets (bad packets included) that are between 1024 and 1522 octets in length " \
+					"(upper limit depends on max packet size setting)" },
+	{ 0x14, "TxLoPriorityByte", 	"Tx lo-priority good octet count, including PAUSE packets" },
+	{ 0x15, "TxHiPriorityByte", 	"Tx hi-priority good octet count, including PAUSE packets" },
+	{ 0x16, "TxLateCollision", 	"The number of times a collision is detected later than 512 bit-times into the Tx of a packet" },
+	{ 0x17, "TxPausePkts", 		"Number of PAUSE frames transmitted by a port" },
+	{ 0x18, "TxBroadcastPkts", 	"Tx good broadcast packets (not including error broadcast or valid multicast packets)" },
+	{ 0x19, "TxMulticastPkts", 	"Tx good multicast packets (not including error multicast packets or valid broadcast packets)" },
+	{ 0x1A, "TxUnicastPkts", 	"Tx good unicast packets" },
+	{ 0x1B, "TxDeferred", 		"Tx packets by a port for which the 1st Tx attempt is delayed due to the busy medium" },
+	{ 0x1C, "TxTotalCollision", 	"Tx total collision, half duplex only" },
+	{ 0x1D, "TxExcessiveCollision", "A count of frames for which Tx fails due to excessive collisions" },
+	{ 0x1E, "TxSingleCollision", 	"Successfully Tx frames on a port for which Tx is inhibited by exactly one collision" },
+	{ 0x1F, "TxMultipleCollision", 	"Successfully Tx frames on a port for which Tx is inhibited by more than one collision" },
+	{    0, NULL, NULL },
+};
+
+#define KSZ_TBL_MIB_OFLOW BIT(7)
+#define KSZ_TBL_MIB_VALID BIT(6)
+static int ksz8863_sw_get_statistics(struct switch_dev *dev,
+                                  const struct switch_attr *attr,
+                                  struct switch_val *val)
+{
+        u8 buf[4];
+        int i = 0;
+        int ret = 0;
+	int offset = (cur_port - 1) << 5;
+
+        val->len = 0;
+        __buf[0] = '\0';
+        val->value.s = __buf;
+
+	val->len += snprintf(__buf + val->len, sizeof(__buf) - val->len,
+			     "Statistics for PORT %d (off 0x%x):\n",
+			     cur_port, offset);
+
+	while (ksz_tbl_mib[i].str_id != NULL) {
+		u32 value;
+		u8 oflow;
+
+		if (tbl_nread(IAC0_TBL_SEL_MIB_CNT, ksz_tbl_mib[i].id + offset, buf, sizeof(buf))) {
+	                ret = -EIO;
+			break;
+		}
+
+		if (!(buf[0] & KSZ_TBL_MIB_VALID))
+			continue;
+
+		oflow = (buf[0] & KSZ_TBL_MIB_OFLOW);
+
+		buf[0] &= ~(KSZ_TBL_MIB_OFLOW | KSZ_TBL_MIB_VALID);
+
+		value = (buf[3] <<  0) |
+			(buf[2] <<  8) |
+			(buf[1] << 16) |
+			(buf[0] << 24);
+
+		if (sizeof(__buf) < (val->len + 64)) {
+			pr_err("SWCONFIG: MSG buffer full!\n");
+			ret = -EFAULT;
+			break;
+		}
+
+                val->len += snprintf(__buf + val->len, sizeof(__buf) - val->len,
+                                     "%25s\t%15u\t%s\n",
+                                     ksz_tbl_mib[i].str_id,
+                                     value,
+				     oflow ? "*" : "");
+
+		i++;
+	}
+
+        return ret;
+}
+
+static inline int ksz8863_sw_set_ins_tag(struct switch_dev *dev,
+                                         const struct switch_attr *attr,
+                                         struct switch_val *val)
+{
+        return setregbits(Port1Control0 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                          !!val->value.i, PC0_TAG_INSERT_SHIFT, PC0_TAG_INSERT_SHIFT);
+}
+
+static inline int ksz8863_sw_get_ins_tag(struct switch_dev *dev,
+                                         const struct switch_attr *attr,
+                                         struct switch_val *val)
+{
+        int ret;
+        u8 v;
+
+        if ((ret = getregbits(Port1Control0 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                              &v, PC0_TAG_INSERT_SHIFT, PC0_TAG_INSERT_SHIFT)))
+                return ret;
+        val->value.i = v;
+
+        return 0;
+}
+
+static inline int ksz8863_sw_set_tail_tag(struct switch_dev *dev,
+                                         const struct switch_attr *attr,
+                                         struct switch_val *val)
+{
+        return setregbits(GlobalControl1, !!val->value.i,
+			  GC1_TAIL_TAG_MODE_ENABLE_SHIFT,
+			  GC1_TAIL_TAG_MODE_ENABLE_SHIFT);
+}
+
+static inline int ksz8863_sw_get_tail_tag(struct switch_dev *dev,
+					  const struct switch_attr *attr,
+					  struct switch_val *val)
+{
+        int ret;
+        u8 v;
+
+        if ((ret = getregbits(GlobalControl1, &v,
+			      GC1_TAIL_TAG_MODE_ENABLE_SHIFT,
+			      GC1_TAIL_TAG_MODE_ENABLE_SHIFT)))
+		return ret;
+
+        val->value.i = v;
+
+        return 0;
+}
+
+/* Broadcast Storm Protection
+ *
+ * Register 6 (0x06): Global Control 4
+ * Register 7 (0x07): Global Control 5
+ *
+ * |     GlobalControl4      |     GlobalControl5       |
+ * ------------------------------------------------------
+ * | 7  6  5  4  3  2  1  0  |  7  6  5  4  3  2  1  0  |
+ * | x  x  x  x  x [--------- bcast rate[10:0]--------] |
+ *
+ * "The rate is based on a 67ms interval for 100BT and a 500ms interval for 10BT.
+ * At the beginning of each interval, the counter is cleared to zero, and the
+ * rate limit mechanism starts to count the number of bytes during the interval.
+ * The rate definition is described in register 6 (0x06) and 7 (0x07).
+ * The default setting is 0x63 (99 decimal). This is equal to a rate of 1%, calculated as follows:
+ * 148,800 frames/sec * 67ms/interval * 1% = 99 frames/interval (approx.) = 0x63
+ * Note: 148,800 frames/sec is based on 64-byte block of packets in 100BASE-TX with
+ * 12 bytes of IPG and 8 bytes of preamble between two packets. " (Datasheet, Page 28)
+ *
+ * */
+static inline int ksz8863_sw_set_bcast_protect(struct switch_dev *dev,
+					       const struct switch_attr *attr,
+					       struct switch_val *val)
+{
+	u8 gc4_v, gc5_v, v[2];
+	int ret, rate = val->value.i;
+	bool mode_10bt;
+	int frames_per_sec, ms_per_interval, frames_per_interval, div, num;
+
+        if ((ret = ksz8863_nread(Port1Control0, &v[0], 1)))
+                return ret;
+
+        if ((ret = ksz8863_nread(Port2Control0, &v[1], 1)))
+                return ret;
+
+	if (rate == 0) {
+                /* disable broadcast storm protection */
+		v[0] &= ~BIT(7);
+		if ((ret = ksz8863_nwrite(Port1Control0, &v[0], 1)))
+			return ret;
+
+		v[1] &= ~BIT(7);
+		if ((ret = ksz8863_nwrite(Port2Control0, &v[1], 1)))
+			return ret;
+
+		pr_info("%s: Disabled Broadcast Storm Protection on Port1 and Port2\n", __func__);
+		return 0;
+	}
+
+	/* the maximum rate is aprox 20% (2047 Frames/Interval) */
+	if (rate > 20) {
+		pr_info("%s: Rate (%d%%) is too high. Throttle to max (20%%)\n", __func__, rate);
+		rate = 20;
+	}
+
+        if ((ret = ksz8863_nread(GlobalControl4, &gc4_v, 1)))
+                return ret;
+
+	pr_debug("%s: read: gc4 (0x%x)\n", __func__, (u32) gc4_v);
+
+       /* Check for Interface Mode -- BIT 4: Switch MII 10BT */
+	if (gc4_v & BIT(4)) { /* 10BT */
+		mode_10bt = true;
+		frames_per_sec = 148800 / 10;
+		ms_per_interval = 500;
+	} else { /* 100BT */
+		mode_10bt = false;
+		frames_per_sec = 148800;
+		ms_per_interval = 67;
+	}
+
+	pr_debug("%s: %s Mode (fps %d, mpi %d)\n", __func__, mode_10bt ? "10BT" : "100BT",
+		frames_per_sec, ms_per_interval);
+
+	/* frames_per_interval = ((frames_per_sec * ms_per_interval) / 1000) * (rate / 100); */
+	div = 1000 * 100;
+	num = frames_per_sec * ms_per_interval * rate;
+	frames_per_interval = num / div;
+	if ((num % div) > (div / 2)) {
+		pr_debug("%s: INC frames_per_interval\n", __func__);
+		frames_per_interval++;
+	}
+
+	gc5_v = (frames_per_interval & 0xff);
+	gc4_v &= ~0x7;
+	gc4_v |= (frames_per_interval >> 8) & 0x7;
+
+        if ((ret = ksz8863_nwrite(GlobalControl5, &gc5_v, 1)))
+                return ret;
+
+        if ((ret = ksz8863_nwrite(GlobalControl4, &gc4_v, 1)))
+                return ret;
+
+	pr_debug("%s: written: gc4 (0x%x), gc5 (0x%x)\n", __func__, (u32) gc4_v, (u32) gc5_v);
+
+        /* enable broadcast storm protection */
+	v[0] |= BIT(7);
+	if ((ret = ksz8863_nwrite(Port1Control0, &v[0], 1)))
+		return ret;
+	v[1] |= BIT(7);
+	if ((ret = ksz8863_nwrite(Port2Control0, &v[1], 1)))
+		return ret;
+
+	pr_info("%s: Enabled Broadcast Storm Protection (Port 1 & 2) (%s: Rate %d, %d Frames/Interval)\n",
+		__func__, mode_10bt ? "10BT" : "100BT", rate, frames_per_interval);
+
+        return 0;
+}
+
+static inline int ksz8863_sw_get_bcast_protect(struct switch_dev *dev,
+					       const struct switch_attr *attr,
+					       struct switch_val *val)
+{
+	u8 gc4_v, gc5_v, v[2];
+	int ret, rate;
+	bool mode_10bt, bcast_en;
+	int frames_per_sec, ms_per_interval, frames_per_interval, div, num;
+
+        if ((ret = ksz8863_nread(GlobalControl4, &gc4_v, 1)))
+                return ret;
+
+        if ((ret = ksz8863_nread(GlobalControl5, &gc5_v, 1)))
+                return ret;
+
+       /* Check for Interface Mode -- BIT 4: Switch MII 10BT */
+	if (gc4_v & BIT(4)) { /* 10BT */
+		mode_10bt = true;
+		frames_per_sec = 148800 / 10;
+		ms_per_interval = 500;
+	} else { /* 100BT */
+		mode_10bt = false;
+		frames_per_sec = 148800;
+		ms_per_interval = 67;
+	}
+
+	frames_per_interval = ((gc4_v & 0x7) << 8) | gc5_v;
+
+	div = frames_per_sec * ms_per_interval;
+	num = frames_per_interval * 1000 * 100;
+	rate = num / div;
+	if ((num % div) > (div / 2)) {
+		pr_debug("%s: INC rate\n", __func__);
+		rate++;
+	}
+
+        if ((ret = ksz8863_nread(Port1Control0, &v[0], 1)))
+                return ret;
+
+        if ((ret = ksz8863_nread(Port2Control0, &v[1], 1)))
+                return ret;
+
+	if ((v[0] & BIT(7)) && (v[1] & BIT(7)))
+		bcast_en = true;
+	else
+		bcast_en = false;
+
+	pr_info("%s: Broadcast Storm Protection is %s (on Port1/Port2) (%s: Calc-Rate %d, %d Frames/Interval)\n",
+		__func__, bcast_en ? "enabled" : "disabled", mode_10bt ? "10BT" : "100BT",
+		rate, frames_per_interval);
+
+	/* return a 0-value to indicate that broadcast protection is disabled */
+        val->value.i = bcast_en ? rate : 0;
+
+        return 0;
+}
+
+static int ksz8863_sw_set_ratelimit(struct switch_dev *dev,
+				    const struct switch_attr *attr,
+				    struct switch_val *val)
+{
+	u8 v[4];
+	u8 reg;
+        int rate, ret;
+	int rate_step, rate_start, rate_stop;
+	char *modestr = __buf;
+	bool mode_10bt;
+
+	pr_info("%s: received <%s>\n", __func__, val->value.s);
+
+	if (strlen(val->value.s) > 8) {
+		pr_err("%s: argument <%s> is too long (max 8 chars)!\n", __func__, val->value.s);
+		return -EINVAL;
+	}
+
+	if (strncmp(val->value.s, "off", 3) == 0) {
+		pr_info("%s: turning off rate limiting!\n", __func__);
+		reg = 0;
+		goto limit_off;
+	}
+
+        if (sscanf(val->value.s, "%d.%s",
+                   &rate,
+                   modestr) != 2)
+                return -EINVAL;
+
+	pr_debug("%s: rate %d, modestr <%s>\n", __func__, rate, modestr);
+
+       /* Check for Interface Mode -- BIT 4: Switch MII 10BT */
+        if ((ret = ksz8863_nread(GlobalControl4, v, 1)))
+                return ret;
+	if (v[0] & BIT(4)) /*  10BT */
+		mode_10bt = true;
+	else                /* 100BT */
+		mode_10bt = false;
+
+	if (strncmp(modestr, "mbps", 4) == 0) {
+
+		/* '00' and '0x64'/'0x09' will set full speed */
+		rate_start = 0;
+		rate_stop  = mode_10bt ? 10 : 100;
+
+		if ((rate < rate_start) || (rate > rate_stop))
+			return -EINVAL;
+
+		reg = rate;
+
+	} else if (strncmp(modestr, "kbps", 4) == 0) {
+		/* lookup kbps */
+		rate_step = 64;
+		rate_start = rate_step;
+		rate_stop  = 960;
+
+		if ((rate < rate_start) || (rate > rate_stop)
+		    || ((rate % rate_step) != 0))
+			return -EINVAL;
+
+		reg = 0x64 + (rate / rate_step); /* 0x65..0x73 */
+	} else {
+		return -EINVAL;
+	}
+
+	/* enable rate limiting and rate into all prio queues */
+	reg |= BIT(7);
+
+limit_off:
+	v[0] = v[1] = v[2] = v[3] = reg;
+	pr_info("%s: write: rate reg 0x%x\n", __func__, (u32) reg);
+	if ((ret = ksz8863_nwrite(Port3EgressRateLimitQ0, v, 4)))
+		return ret;
+
+	if (reg)
+		pr_info("%s: %s: rate limit set to <%d.%s>\n",
+			__func__, mode_10bt ? "10BT" : "100BT", rate, modestr);
+
+        return 0;
+}
+
+static int ksz8863_sw_get_ratelimit(struct switch_dev *dev,
+				    const struct switch_attr *attr,
+				    struct switch_val *val)
+{
+	u8 v[4];
+        int rate = -1, ret, i;
+	int rate_reg, rate_stop;
+	char modestr[6];
+	bool disabled = true;
+	bool mode_10bt;
+
+       /* Check for Interface Mode -- BIT 4: Switch MII 10BT */
+        if ((ret = ksz8863_nread(GlobalControl4, v, 1)))
+                return ret;
+	if (v[0] & BIT(4)) /*  10BT */
+		mode_10bt = true;
+	else                /* 100BT */
+		mode_10bt = false;
+
+	if ((ret = ksz8863_nread(Port3EgressRateLimitQ0, v, 4)))
+		return ret;
+
+	strcpy(modestr, "none");
+
+	/* we take just the first queue */
+	val->len = snprintf(__buf, sizeof(__buf), "disabled");
+	val->value.s = __buf;
+
+	for (i = 0; i < 4; i++) {
+		if (v[i] & BIT(7)) {
+
+			disabled = false;
+			rate_reg = v[i] & 0x7f;
+
+			rate_stop = mode_10bt ? 10 : 100;
+			if (rate_reg <= rate_stop) {
+				/* mbps */
+				if ((rate_reg == 0) || (rate_reg == rate_stop))
+					rate = rate_stop;
+				else
+					rate = rate_reg;
+				strcpy(modestr, "mbps");
+			} else if (rate_reg <= 0x73) {
+				/* kbps */
+				rate = 64 * (rate_reg - 0x64);
+				strcpy(modestr, "kbps");
+			}
+		} else
+			disabled = true;
+
+		if (i == 0) {
+			if (!disabled) {
+				/* we take just the first queue */
+				val->len = snprintf(__buf, sizeof(__buf), "%d.%s",
+						    rate,
+						    modestr);
+				val->value.s = __buf;
+			}
+		}
+
+		pr_info("%s: Q%d: rate limiting is %s, %d.%s.\n",
+			__func__, i, disabled ? "disabled" : "enabled", rate, modestr);
+	}
+
+        return 0;
+}
+
+#define KSZ_SNIFF_TX_BIT  BIT(5)
+#define KSZ_SNIFF_RX_BIT  BIT(6)
+#define KSZ_SNIFFER_BIT   BIT(7)
+
+#define KSZ_SNIFFER_MASK (BIT(5) | BIT(6) | BIT(7))
+
+static inline int ksz8863_sw_set_port_mirror(struct switch_dev *dev,
+					     const struct switch_attr *attr,
+					     struct switch_val *val)
+{
+	u8 v[3], gc3_v;
+	int ret, mirror = val->value.i;
+
+	/* enable tx/rx sniff */
+	if ((ret = ksz8863_nread(GlobalControl3, &gc3_v, 1)))
+		return ret;
+        if ((ret = ksz8863_nread(Port1Control1, &v[0], 1)))
+                return ret;
+        if ((ret = ksz8863_nread(Port2Control1, &v[1], 1)))
+                return ret;
+        if ((ret = ksz8863_nread(Port3Control1, &v[2], 1)))
+                return ret;
+
+	/* reset */
+	v[0] &= ~KSZ_SNIFFER_MASK;
+	v[1] &= ~KSZ_SNIFFER_MASK;
+	v[2] &= ~KSZ_SNIFFER_MASK;
+
+	/* X1 = 2, X2 = 1, so we twist it! */
+	switch (mirror) {
+	case 0:
+		gc3_v &= ~BIT(0); /* disable tx/rx sniff */
+		break;
+	case 1:
+		v[1] |= KSZ_SNIFF_RX_BIT | KSZ_SNIFF_TX_BIT;	/* Port2 (X1) is MIRROR (TX+RX-SNIFF) */
+		v[0] |= KSZ_SNIFFER_BIT;			/* Port1 (X2) is SNIFFER              */
+
+		v[2] |= KSZ_SNIFF_RX_BIT | KSZ_SNIFF_TX_BIT; /* Port3 (CPU) is always TX+RX-SNIFF */
+
+		gc3_v |= BIT(0); /* enable tx/rx sniff */
+		break;
+	case 2:
+		v[0] |= KSZ_SNIFF_RX_BIT | KSZ_SNIFF_TX_BIT;	/* Port1 (X2) is MIRROR (TX+RX-SNIFF) */
+		v[1] |= KSZ_SNIFFER_BIT;			/* Port2 (X1) is SNIFFER              */
+
+		v[2] |= KSZ_SNIFF_RX_BIT | KSZ_SNIFF_TX_BIT; /* Port3 (CPU) is always TX+RX-SNIFF */
+
+		gc3_v |= BIT(0); /* enable tx/rx sniff */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if ((ret = ksz8863_nwrite(GlobalControl3, &gc3_v, 1)))
+		return ret;
+	if ((ret = ksz8863_nwrite(Port1Control1, &v[0], 1)))
+		return ret;
+	if ((ret = ksz8863_nwrite(Port2Control1, &v[1], 1)))
+		return ret;
+	if ((ret = ksz8863_nwrite(Port3Control1, &v[2], 1)))
+		return ret;
+
+	if (mirror == 0)
+		pr_info("%s: turn-off port MIRRORING!\n", __func__);
+	else
+		pr_info("%s: X%d is MIRROR-Port (X%d is SNIFFER)\n", __func__, mirror, mirror == 1 ? 2 : 1);
+
+	return 0;
+}
+
+static inline int ksz8863_sw_get_port_mirror(struct switch_dev *dev,
+					     const struct switch_attr *attr,
+					     struct switch_val *val)
+{
+	u8 v[3];
+	int ret, mirror;
+
+	/* enable tx/rx sniff */
+        if ((ret = ksz8863_nread(Port1Control1, &v[0], 1)))
+                return ret;
+        if ((ret = ksz8863_nread(Port2Control1, &v[1], 1)))
+                return ret;
+        if ((ret = ksz8863_nread(Port3Control1, &v[2], 1)))
+                return ret;
+
+	if ((v[2] & BIT(7))) {
+		pr_err("%s: invalid: port 3 is not allowed to be mirror!\n", __func__);
+		return -1;
+	}
+
+	/* X1 = 2, X2 = 1, so we twist it! */
+	if ((v[0] & KSZ_SNIFFER_BIT) && !(v[1] & KSZ_SNIFFER_BIT))
+		mirror = 1;
+	else if ((v[1] & KSZ_SNIFFER_BIT) && !(v[0] & KSZ_SNIFFER_BIT))
+		mirror = 2;
+	else if (!(v[1] & KSZ_SNIFFER_BIT) && !(v[0] & KSZ_SNIFFER_BIT))
+		mirror = 0;
+	else
+		return -1;
+
+        val->value.i = mirror;
+
+	if (mirror)
+		pr_info("%s: mirror-port: X%d\n", __func__, mirror);
+	else
+		pr_info("%s: Port mirrorroring is OFF!\n", __func__);
+
+	return 0;
+}
+
+static inline int ksz8863_sw_set_fast_aging(struct switch_dev *dev,
+					    const struct switch_attr *attr,
+					    struct switch_val *val)
+{
+	u8 gc1_v;
+	int ret, enable = val->value.i;
+
+	if ((ret = ksz8863_nread(GlobalControl1, &gc1_v, 1)))
+		return ret;
+
+	pr_debug("%s: read: gc1_v 0x%x\n", __func__, gc1_v);
+
+	if (enable)
+		gc1_v |= BIT(1); /* enable fast age (800us) */
+	else
+		gc1_v &= ~BIT(1);
+
+	if ((ret = ksz8863_nwrite(GlobalControl1, &gc1_v, 1)))
+		return ret;
+
+	pr_debug("%s: write: gc1_v 0x%x\n", __func__, gc1_v);
+
+	pr_info("%s: fast age %s\n", __func__, enable ? "enabled" : "disabled");
+
+	return 0;
+}
+
+static inline int ksz8863_sw_get_fast_aging(struct switch_dev *dev,
+					    const struct switch_attr *attr,
+					    struct switch_val *val)
+{
+	u8 gc1_v;
+	int ret;
+
+	if ((ret = ksz8863_nread(GlobalControl1, &gc1_v, 1)))
+		return ret;
+
+	pr_debug("%s: read: gc1_v 0x%x\n", __func__, gc1_v);
+
+	if (gc1_v & BIT(1))
+		val->value.i = 1;
+	else
+		val->value.i = 0;
+
+	pr_info("%s: fast age is %s\n", __func__, val->value.i ? "enabled" : "disabled");
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_DSA_KSZ8863
+static inline int ksz8863_sw_set_dsa_enable(struct switch_dev *dev,
+					    const struct switch_attr *attr,
+					    struct switch_val *val)
+{
+	dsa_enable(!!val->value.i);
+
+	ksz8863_setup_dflt_cfg(DFLT_CFG_FLAGS);
+
+	return 0;
+}
+
+static inline int ksz8863_sw_get_dsa_enable(struct switch_dev *dev,
+					    const struct switch_attr *attr,
+					    struct switch_val *val)
+{
+        val->value.i = is_dsa_enabled();
+
+        return 0;
+}
+#endif
+
+static inline int ksz8863_sw_set_rem_tag(struct switch_dev *dev,
+                                         const struct switch_attr *attr,
+                                         struct switch_val *val)
+{
+        return setregbits(Port1Control0 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                          !!val->value.i, PC0_TAG_REMOVE_SHIFT, PC0_TAG_REMOVE_SHIFT);
+}
+
+static inline int ksz8863_sw_get_rem_tag(struct switch_dev *dev,
+                                         const struct switch_attr *attr,
+                                         struct switch_val *val)
+{
+        int ret;
+        u8 v;
+
+        if ((ret = getregbits(Port1Control0 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                              &v, PC0_TAG_REMOVE_SHIFT, PC0_TAG_REMOVE_SHIFT)))
+                return ret;
+        val->value.i = v;
+
+        return 0;
+}
+
+static inline int ksz8863_sw_set_force_tag(struct switch_dev *dev,
+                                           const struct switch_attr *attr,
+                                           struct switch_val *val)
+{
+        return setregbits(Port1Control1 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                          !!val->value.i, PC1_TAG_DOUBLE_SHIFT, PC1_TAG_DOUBLE_SHIFT);
+}
+
+static inline int ksz8863_sw_get_force_tag(struct switch_dev *dev,
+                                           const struct switch_attr *attr,
+                                           struct switch_val *val)
+{
+        int ret;
+        u8 v;
+
+        if ((ret = getregbits(Port1Control1 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                              &v, PC1_TAG_DOUBLE_SHIFT, PC1_TAG_DOUBLE_SHIFT)))
+                return ret;
+        val->value.i = v;
+
+        return 0;
+}
+
+static inline int ksz8863_sw_set_port_memb(struct switch_dev *dev,
+                                           const struct switch_attr *attr,
+                                           struct switch_val *val)
+{
+        return setregbits(Port1Control1 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                          val->value.i, 2, 0);
+}
+
+static inline int ksz8863_sw_get_port_memb(struct switch_dev *dev,
+                                           const struct switch_attr *attr,
+                                           struct switch_val *val)
+{
+        int ret;
+        u8 v;
+
+        if ((ret = getregbits(Port1Control1 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                              &v, 2, 0)))
+                return ret;
+        val->value.i = v;
+
+        return 0;
+}
+
+
+
+static inline int ksz8863_sw_set_eg_pvid(struct switch_dev *dev,
+                                         const struct switch_attr *attr,
+                                         struct switch_val *val)
+{
+        return setregbits(InsertSrcPvid, val->value.i, 5, 0);
+}
+
+static int ksz8863_sw_get_eg_pvid(struct switch_dev *dev,
+                                  const struct switch_attr *attr,
+                                  struct switch_val *val)
+{
+        int ret;
+        u8 v;
+
+        if ((ret = getregbits(InsertSrcPvid, &v, 5, 0)))
+                return ret;
+
+        val->value.i = v;
+
+        return 0;
+}
+
+struct dflt_tag {
+        unsigned vid_11_8:4;
+        unsigned cfi:1;
+        unsigned prio:3;
+        unsigned vid_7_0:8;
+} __attribute__((packed));
+
+static int ksz8863_sw_set_dflt_tag(struct switch_dev *dev,
+                                   const struct switch_attr *attr,
+                                   struct switch_val *val)
+{
+        struct dflt_tag tag;
+        int vid, cfi, prio;
+
+        if (sscanf(val->value.s, "%d,%d,%d",
+                   &vid,
+                   &cfi,
+                   &prio) != 3)
+                return -EINVAL;
+
+        tag.vid_11_8 = (vid >> 8) & MASK(4, 0);
+        tag.cfi = cfi;
+        tag.prio = prio;
+        tag.vid_7_0 = vid & MASK(8, 0);
+
+        return ksz8863_nwrite(Port1Control3 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                              (u8 *)&tag, sizeof(struct dflt_tag));
+}
+
+static int ksz8863_sw_get_dflt_tag(struct switch_dev *dev,
+                                   const struct switch_attr *attr,
+                                   struct switch_val *val)
+{
+        struct dflt_tag tag;
+        int ret;
+
+        if ((ret = ksz8863_nread(Port1Control3 + val->port_vlan * KSZ8863_PORTS_REGS_OFFSET,
+                                 (u8 *)&tag, sizeof(struct dflt_tag))))
+                return ret;
+
+        val->len = snprintf(__buf, sizeof(__buf), "%d,%d,%d",
+                            (tag.vid_11_8 << 8) | tag.vid_7_0,
+                            tag.cfi,
+                            tag.prio);
+        val->value.s = __buf;
+
+        return 0;
+}
+
+
+static inline int ksz8863_sw_reset(struct switch_dev *dev)
+{
+        return ksz8863_soft_reset();
+}
+
+static int ksz8863_sw_setup_dflt_cfg(struct switch_dev *dev,
+                                     const struct switch_attr *attr,
+                                     struct switch_val *val)
+{
+        return ksz8863_setup_dflt_cfg(DFLT_CFG_FLAGS);
+}
+
+
+static struct switch_attr ksz8863_global_attrs[] = {
+        {
+                .type = SWITCH_TYPE_NOVAL,
+                .name = "setup_dflt",
+                .description = "Setup default config",
+                .set = ksz8863_sw_setup_dflt_cfg,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "sel_reg",
+                .description = "Select register for rw operation",
+                .set = ksz8863_sw_set_sel_reg,
+                .get = ksz8863_sw_get_sel_reg,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "reg",
+                .description = "Read/Write selected register",
+                .set = ksz8863_sw_set_reg,
+                .get = ksz8863_sw_get_reg,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "vlan_enable",
+                .description = "Enable VLAN mode",
+                .set = ksz8863_sw_set_vlan_enable,
+                .get = ksz8863_sw_get_vlan_enable,
+        }, {
+                .type = SWITCH_TYPE_STRING,
+                .name = "dynmacs",
+                .description = "Dynamic MAC address table - \'mac, port, fid, aging\'",
+                .get = ksz8863_sw_get_dynmacs,
+        }, {
+                .type = SWITCH_TYPE_STRING,
+                .name = "statmacs",
+                .description = "Static MAC address table"
+		" - read: \'mac, forward ports, fid, override\'"
+		" - write: \'idx,mac,forward ports,valid,override,use_fid,fid\'",
+		.set = ksz8863_sw_set_staticmacs,
+                .get = ksz8863_sw_get_staticmacs,
+        }, {
+                // TODO mv in port attrs
+                .type = SWITCH_TYPE_INT,
+                .name = "eports_pvid",
+                .description = "Ports whose src PVID will be inserted at egress ports - 6 bits - TODO -",
+                .set = ksz8863_sw_set_eg_pvid,
+                .get = ksz8863_sw_get_eg_pvid,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "tail_tag",
+                .description = "Enables or Disables Tail Tag Mode",
+                .set = ksz8863_sw_set_tail_tag,
+                .get = ksz8863_sw_get_tail_tag,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "bcast_protect",
+                .description = "Sets the broadcast storm protection rate limit (0..20%) for Port 1 & 2. '0' will disable protection",
+                .set = ksz8863_sw_set_bcast_protect,
+                .get = ksz8863_sw_get_bcast_protect,
+        }, {
+                .type = SWITCH_TYPE_STRING,
+                .name = "rate_limit",
+                .description = "Enables Rate Limiting on Egress Port3 (CPU-Ingress), format='50.mbps'/'64.kbps'. 'off' will disable rate limiting",
+                .set = ksz8863_sw_set_ratelimit,
+                .get = ksz8863_sw_get_ratelimit,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "port_mirror",
+                .description = "Enables the mirror port  (1=X1, 2=X2, 0=off)",
+                .set = ksz8863_sw_set_port_mirror,
+                .get = ksz8863_sw_get_port_mirror,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "fast_aging",
+                .description = "Enables:1/Disables:0 Fast Aging.",
+                .set = ksz8863_sw_set_fast_aging,
+                .get = ksz8863_sw_get_fast_aging,
+#ifdef CONFIG_NET_DSA_KSZ8863
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "dsa_enable",
+                .description = "Enables or Disables DSA Network-Path",
+                .set = ksz8863_sw_set_dsa_enable,
+                .get = ksz8863_sw_get_dsa_enable,
+#endif
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "sel_port",
+                .description = "Select port for statistics",
+                .set = ksz8863_sw_set_sel_port,
+                .get = ksz8863_sw_get_sel_port,
+        }, {
+                .type = SWITCH_TYPE_STRING,
+                .name = "stats",
+                .description = "Get Switch statistics (*: marks counter overflow bit)",
+                .get = ksz8863_sw_get_statistics,
+        },
+};
+
+static struct switch_attr ksz8863_port_attrs[] = {
+        {
+                .type = SWITCH_TYPE_INT,
+                .name = "ins_tag",
+                .description = "Insert tag",
+                .set = ksz8863_sw_set_ins_tag,
+                .get = ksz8863_sw_get_ins_tag,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "rem_tag",
+                .description = "Remove tag",
+                .set = ksz8863_sw_set_rem_tag,
+                .get = ksz8863_sw_get_rem_tag,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "force_tag",
+                .description = "All packets will be tagged with port default tag of ingress port",
+                .set = ksz8863_sw_set_force_tag,
+                .get = ksz8863_sw_get_force_tag,
+        }, {
+                .type = SWITCH_TYPE_STRING,
+                .name = "default_tag",
+                .description = "Default tag for insertion - \'vid[12],cfi[1],prio[3]\'",
+                .set = ksz8863_sw_set_dflt_tag,
+                .get = ksz8863_sw_get_dflt_tag,
+        }, {
+                .type = SWITCH_TYPE_INT,
+                .name = "port_memb",
+                .description = "The port can only communicate within the membership "
+                        "- \'port3_en[1]port2_en[1]port1_en[1]\'",
+                .set = ksz8863_sw_set_port_memb,
+                .get = ksz8863_sw_get_port_memb,
+        },
+};
+
+static struct switch_attr ksz8863_vlan_attrs[] = {
+        {
+                .type = SWITCH_TYPE_STRING,
+                .name = "vlan_table",
+                .description = "VLAN table entry - \'vid[12],fid[4],membership[3],valid[1]\'",
+                .set = ksz8863_sw_set_vlan_table,
+                .get = ksz8863_sw_get_vlan_table,
+        },
+ };
+
+struct switch_dev_ops ksz8863_switch_dev_ops = {
+	.attr_global = {
+		.attr = ksz8863_global_attrs,
+	        .n_attr = ARRAY_SIZE(ksz8863_global_attrs),
+	},
+        .attr_port = {
+                .attr = ksz8863_port_attrs,
+                .n_attr = ARRAY_SIZE(ksz8863_port_attrs),
+        },
+        .attr_vlan = {
+                .attr = ksz8863_vlan_attrs,
+                .n_attr = ARRAY_SIZE(ksz8863_vlan_attrs),
+        },
+        .reset_switch = ksz8863_sw_reset,
+};
+
+static struct switch_dev ksz8863_switch_dev = {
+        .name = "ksz8863",
+        .devname = "ksz8863",
+	.alias = "switch0",
+        .cpu_port = KSZ8863_CPU_PORT,
+        .ports = KSZ8863_NUM_PORTS,
+        .vlans = KSZ8863_NUM_VLANS,
+	.ops = &ksz8863_switch_dev_ops,
+};
+#endif /* CONFIG_SWCONFIG */
+
+
+static DEFINE_MUTEX(ioctl_mutex);
+
+static long ksz8863_ioctl(struct file *file,
+                          unsigned int cmd, unsigned long arg)
+{
+        void __user *argp;
+        unsigned long size;
+        int ret;
+
+        argp = (void __user *)arg;
+        size = (cmd & IOCSIZE_MASK) >> IOCSIZE_SHIFT;
+        if (cmd & IOC_IN) {
+                if (!access_ok(VERIFY_READ, argp, size))
+                        return -EFAULT;
+        }
+        if (cmd & IOC_OUT) {
+                if (!access_ok(VERIFY_WRITE, argp, size))
+                        return -EFAULT;
+        }
+
+
+        if ((ret = mutex_lock_interruptible(&ioctl_mutex)))
+                return ret;
+
+        switch (cmd) {
+        default:
+                ret = ksz8863_setup_dflt_cfg(DFLT_CFG_FLAGS);
+        }
+
+        mutex_unlock(&ioctl_mutex);
+        return ret;
+}
+
+static long ksz8863_unlocked_ioctl(struct file *file,
+                                   unsigned int cmd, unsigned long arg)
+{
+        int ret;
+
+        ret = ksz8863_ioctl(file, cmd, arg);
+
+        return ret;
+}
+
+static struct file_operations ksz8863_fops = {
+        .owner          = THIS_MODULE,
+        .unlocked_ioctl = ksz8863_unlocked_ioctl,
+};
+
+static struct miscdevice misc_dev = {
+        .minor = MISC_DYNAMIC_MINOR,
+        .name  = KSZ8863_CHRDEV_NAME,
+        .fops  = &ksz8863_fops,
+};
+
+
+static int __init ksz8863_cfg_init(void)
+{
+        int err;
+
+        if ((err = misc_register(&misc_dev))) {
+                printk(KERN_ERR "%s: unable to register misc device\n", __func__);
+                return err;
+        }
+
+#if defined(CONFIG_SWCONFIG) || defined(CONFIG_SWCONFIG_MODULE)
+        if ((err = register_switch(&ksz8863_switch_dev, NULL))) {
+                printk(KERN_ERR "%s: switch registration failed\n", __func__);
+                misc_deregister(&misc_dev);
+                return err;
+        }
+#endif /* CONFIG_SWCONFIG */
+
+        ksz8863_fns->setup_dflt_cfg = ksz8863_setup_dflt_cfg;
+
+        return 0;
+}
+
+
+static void __exit ksz8863_cfg_exit(void)
+{
+#if defined(CONFIG_SWCONFIG) || defined(CONFIG_SWCONFIG_MODULE)
+        unregister_switch(&ksz8863_switch_dev);
+#endif /* CONFIG_SWCONFIG */
+        misc_deregister(&misc_dev);
+}
+
+module_init(ksz8863_cfg_init);
+module_exit(ksz8863_cfg_exit);
+
+MODULE_AUTHOR("karl.beldan@sagemcom.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/phy/ksz8863-phy.c b/drivers/net/phy/ksz8863-phy.c
new file mode 100644
index 0000000..6b0294d
--- /dev/null
+++ b/drivers/net/phy/ksz8863-phy.c
@@ -0,0 +1,136 @@
+/*
+ * drivers/net/phy/phy_device.c
+ *
+ * Copyright (c) 2010 SAGEMCOM
+ *
+ * Author: Karl Beldan <karl.beldan@sagemcom.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/phy.h>
+#include <linux/ksz8863.h>
+
+// genphy_config_init
+static int ksz8863_config_init(struct phy_device *phydev)
+{
+        int val;
+        u32 features;
+
+        features = SUPPORTED_MII;
+
+        /* Do we support autonegotiation? */
+        val = phy_read(phydev, MII_BMSR);
+
+        if (val < 0)
+                return val;
+
+        if (val & BMSR_ANEGCAPABLE)
+                features |= SUPPORTED_Autoneg;
+
+        if (val & BMSR_100FULL)
+                features |= SUPPORTED_100baseT_Full;
+        if (val & BMSR_100HALF)
+                features |= SUPPORTED_100baseT_Half;
+        if (val & BMSR_10FULL)
+                features |= SUPPORTED_10baseT_Full;
+        if (val & BMSR_10HALF)
+                features |= SUPPORTED_10baseT_Half;
+
+        if (val & BMSR_ESTATEN) {
+                val = phy_read(phydev, MII_ESTATUS);
+
+                if (val < 0)
+                        return val;
+
+                if (val & ESTATUS_1000_TFULL)
+                        features |= SUPPORTED_1000baseT_Full;
+                if (val & ESTATUS_1000_THALF)
+                        features |= SUPPORTED_1000baseT_Half;
+        }
+
+        phydev->supported = features;
+        phydev->advertising = features;
+
+        return 0;
+}
+
+static int ksz8863_ack_interrupt(struct phy_device *phydev)
+{
+        u8 val;
+        int ret;
+
+        ret = ksz8863_nread(LinkChangeInterrupt, &val, 1);
+        if (ret < 0)
+                return ret;
+
+        val |= 1 << (phydev->addr - 1);
+
+        return ksz8863_nwrite(LinkChangeInterrupt, &val, 1);
+}
+
+static int ksz8863_config_intr(struct phy_device *phydev)
+{
+        u8 val;
+        int ret;
+
+        ret = ksz8863_nread(InterruptEnable, &val, 1);
+        if (ret < 0)
+                return ret;
+
+        if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+                val |= 1 << (phydev->addr - 1);
+        else
+                val &= ~(1 << (phydev->addr - 1));
+
+        return ksz8863_nwrite(InterruptEnable, &val, 1);
+}
+
+static int ksz8863_did_interrupt(struct phy_device *phydev)
+{
+        u8 val;
+        int ret;
+
+        ret = ksz8863_nread(LinkChangeInterrupt, &val, 1);
+        if (ret < 0)
+                return ret;
+
+        return val & (1 << (phydev->addr - 1));
+}
+
+static struct phy_driver ksz8863_driver = {
+        .phy_id         = (KSZ8863_PHYID1 << 16) | KSZ8863_PHYID2,
+        .phy_id_mask    = ~0x6,
+        .name           = "Micrel KSZ8863",
+        .config_init    = ksz8863_config_init,
+        .features       = PHY_BASIC_FEATURES,
+        .flags          = PHY_HAS_INTERRUPT,
+        .config_aneg    = genphy_config_aneg,
+        .read_status    = genphy_read_status,
+        .ack_interrupt  = ksz8863_ack_interrupt,
+        .config_intr    = ksz8863_config_intr,
+        .did_interrupt  = ksz8863_did_interrupt,
+        .driver         = {.owner = THIS_MODULE, },
+};
+
+static int __init ksz8863_init(void)
+{
+        return phy_driver_register(&ksz8863_driver);
+}
+
+static void __exit ksz8863_exit(void)
+{
+        phy_driver_unregister(&ksz8863_driver);
+}
+
+
+module_init(ksz8863_init);
+module_exit(ksz8863_exit);
+
+MODULE_AUTHOR("karl.beldan@sagemcom.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/phy/mdio-bitbang.c b/drivers/net/phy/mdio-bitbang.c
index 61a543c..af260c6 100644
--- a/drivers/net/phy/mdio-bitbang.c
+++ b/drivers/net/phy/mdio-bitbang.c
@@ -30,6 +30,13 @@
 #define MDIO_C45_READ (MDIO_C45 | 3)
 #define MDIO_C45_WRITE (MDIO_C45 | 1)
 
+#ifdef CONFIG_MICREL_KSZ8863_EXTENDED_REGS
+/* Special treatment for ksz8863 SMI access */
+#define MDIO_KSZ (1<<14)
+#define MDIO_KSZ_WR_BIT (1<<3)
+#define MDIO_KSZ_READ (MDIO_KSZ | 0)
+#define MDIO_KSZ_WRITE (MDIO_KSZ | MDIO_KSZ_WR_BIT)
+#endif
 #define MDIO_SETUP_TIME 10
 #define MDIO_HOLD_TIME 10
 
@@ -124,6 +131,20 @@ static void mdiobb_cmd(struct mdiobb_ctrl *ctrl, int op, u8 phy, u8 reg)
 	mdiobb_send_bit(ctrl, (op >> 1) & 1);
 	mdiobb_send_bit(ctrl, (op >> 0) & 1);
 
+#ifdef CONFIG_MICREL_KSZ8863_EXTENDED_REGS
+	/* Special treatment for ksz8863 SMI access */
+	if (op & MDIO_KSZ) {
+		/* SMI Frame Format:
+		 *       Preamble | SB | OP |  PHY  |  REG  | TA | Data Bits [15:0] | Z
+		 *    R:   32x1   | 01 | 00 | 1xRRR | RRRRR | Z0 | 00000000DDDDDDDD | Z
+		 *    W:   32x1   | 01 | 00 | 0xRRR | RRRRR | 10 | XXXXXXXXDDDDDDDD | Z
+		 */
+		phy = ((reg>>5) & 0x7);
+		if (!(op & MDIO_KSZ_WR_BIT))
+			phy |= (1<<4);
+		reg &= 0x1f;
+	}
+#endif
 	mdiobb_send_num(ctrl, phy, 5);
 	mdiobb_send_num(ctrl, reg, 5);
 }
@@ -160,6 +181,10 @@ static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 	if (reg & MII_ADDR_C45) {
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_READ, phy, reg);
+#ifdef CONFIG_MICREL_KSZ8863_EXTENDED_REGS
+	} else if (reg & MII_ADDR_KSZ) {
+		mdiobb_cmd(ctrl, MDIO_KSZ_READ, phy, reg);
+#endif
 	} else
 		mdiobb_cmd(ctrl, MDIO_READ, phy, reg);
 
@@ -181,6 +206,7 @@ static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 
 	ret = mdiobb_get_num(ctrl, 16);
 	mdiobb_get_bit(ctrl);
+
 	return ret;
 }
 
@@ -191,6 +217,10 @@ static int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
 	if (reg & MII_ADDR_C45) {
 		reg = mdiobb_cmd_addr(ctrl, phy, reg);
 		mdiobb_cmd(ctrl, MDIO_C45_WRITE, phy, reg);
+#ifdef CONFIG_MICREL_KSZ8863_EXTENDED_REGS
+	} else if (reg & MII_ADDR_KSZ) {
+		mdiobb_cmd(ctrl, MDIO_KSZ_WRITE, phy, reg);
+#endif
 	} else
 		mdiobb_cmd(ctrl, MDIO_WRITE, phy, reg);
 
diff --git a/drivers/net/phy/swconfig.c b/drivers/net/phy/swconfig.c
new file mode 100644
index 0000000..99cdc1d
--- /dev/null
+++ b/drivers/net/phy/swconfig.c
@@ -0,0 +1,1121 @@
+/*
+ * swconfig.c: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/capability.h>
+#include <linux/skbuff.h>
+#include <linux/switch.h>
+#include <linux/of.h>
+
+//#define DEBUG 1
+#ifdef DEBUG
+#define DPRINTF(format, ...) printk("%s: " format, __func__, ##__VA_ARGS__)
+#else
+#define DPRINTF(...) do {} while(0)
+#endif
+
+#define SWCONFIG_DEVNAME	"switch%d"
+
+#include "swconfig_leds.c"
+
+MODULE_AUTHOR("Felix Fietkau <nbd@openwrt.org>");
+MODULE_LICENSE("GPL");
+
+static int swdev_id = 0;
+static struct list_head swdevs;
+static DEFINE_SPINLOCK(swdevs_lock);
+struct swconfig_callback;
+
+struct swconfig_callback
+{
+	struct sk_buff *msg;
+	struct genlmsghdr *hdr;
+	struct genl_info *info;
+	int cmd;
+
+	/* callback for filling in the message data */
+	int (*fill)(struct swconfig_callback *cb, void *arg);
+
+	/* callback for closing the message before sending it */
+	int (*close)(struct swconfig_callback *cb, void *arg);
+
+	struct nlattr *nest[4];
+	int args[4];
+};
+
+/* defaults */
+
+static int
+swconfig_get_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	int ret;
+	if (val->port_vlan >= dev->vlans)
+		return -EINVAL;
+
+	if (!dev->ops->get_vlan_ports)
+		return -EOPNOTSUPP;
+
+	ret = dev->ops->get_vlan_ports(dev, val);
+	return ret;
+}
+
+static int
+swconfig_set_vlan_ports(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	struct switch_port *ports = val->value.ports;
+	const struct switch_dev_ops *ops = dev->ops;
+	int i;
+
+	if (val->port_vlan >= dev->vlans)
+		return -EINVAL;
+
+	/* validate ports */
+	if (val->len > dev->ports)
+		return -EINVAL;
+
+	if (!ops->set_vlan_ports)
+		return -EOPNOTSUPP;
+
+	for (i = 0; i < val->len; i++) {
+		if (ports[i].id >= dev->ports)
+			return -EINVAL;
+
+		if (ops->set_port_pvid &&
+		    !(ports[i].flags & (1 << SWITCH_PORT_FLAG_TAGGED)))
+			ops->set_port_pvid(dev, ports[i].id, val->port_vlan);
+	}
+
+	return ops->set_vlan_ports(dev, val);
+}
+
+static int
+swconfig_set_pvid(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->set_port_pvid)
+		return -EOPNOTSUPP;
+
+	return dev->ops->set_port_pvid(dev, val->port_vlan, val->value.i);
+}
+
+static int
+swconfig_get_pvid(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->get_port_pvid)
+		return -EOPNOTSUPP;
+
+	return dev->ops->get_port_pvid(dev, val->port_vlan, &val->value.i);
+}
+
+static const char *
+swconfig_speed_str(enum switch_port_speed speed)
+{
+	switch (speed) {
+	case SWITCH_PORT_SPEED_10:
+		return "10baseT";
+	case SWITCH_PORT_SPEED_100:
+		return "100baseT";
+	case SWITCH_PORT_SPEED_1000:
+		return "1000baseT";
+	default:
+		break;
+	}
+
+	return "unknown";
+}
+
+static int
+swconfig_get_link(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	struct switch_port_link link;
+	int len;
+	int ret;
+
+	if (val->port_vlan >= dev->ports)
+		return -EINVAL;
+
+	if (!dev->ops->get_port_link)
+		return -EOPNOTSUPP;
+
+	memset(&link, 0, sizeof(link));
+	ret = dev->ops->get_port_link(dev, val->port_vlan, &link);
+	if (ret)
+		return ret;
+
+	memset(dev->buf, 0, sizeof(dev->buf));
+
+	if (link.link)
+		len = snprintf(dev->buf, sizeof(dev->buf),
+			       "port:%d link:up speed:%s %s-duplex %s%s%s",
+			       val->port_vlan,
+			       swconfig_speed_str(link.speed),
+			       link.duplex ? "full" : "half",
+			       link.tx_flow ? "txflow ": "",
+			       link.rx_flow ?	"rxflow " : "",
+			       link.aneg ? "auto" : "");
+	else
+		len = snprintf(dev->buf, sizeof(dev->buf), "port:%d link:down",
+			       val->port_vlan);
+
+	val->value.s = dev->buf;
+	val->len = len;
+
+	return 0;
+}
+
+static int
+swconfig_apply_config(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	/* don't complain if not supported by the switch driver */
+	if (!dev->ops->apply_config)
+		return 0;
+
+	return dev->ops->apply_config(dev);
+}
+
+static int
+swconfig_reset_switch(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
+{
+	/* don't complain if not supported by the switch driver */
+	if (!dev->ops->reset_switch)
+		return 0;
+
+	return dev->ops->reset_switch(dev);
+}
+
+enum global_defaults {
+	GLOBAL_APPLY,
+	GLOBAL_RESET,
+};
+
+enum vlan_defaults {
+	VLAN_PORTS,
+};
+
+enum port_defaults {
+	PORT_PVID,
+	PORT_LINK,
+};
+
+static struct switch_attr default_global[] = {
+	[GLOBAL_APPLY] = {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "apply",
+		.description = "Activate changes in the hardware",
+		.set = swconfig_apply_config,
+	},
+	[GLOBAL_RESET] = {
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset",
+		.description = "Reset the switch",
+		.set = swconfig_reset_switch,
+	}
+};
+
+static struct switch_attr default_port[] = {
+	[PORT_PVID] = {
+		.type = SWITCH_TYPE_INT,
+		.name = "pvid",
+		.description = "Primary VLAN ID",
+		.set = swconfig_set_pvid,
+		.get = swconfig_get_pvid,
+	},
+	[PORT_LINK] = {
+		.type = SWITCH_TYPE_STRING,
+		.name = "link",
+		.description = "Get port link information",
+		.set = NULL,
+		.get = swconfig_get_link,
+	}
+};
+
+static struct switch_attr default_vlan[] = {
+	[VLAN_PORTS] = {
+		.type = SWITCH_TYPE_PORTS,
+		.name = "ports",
+		.description = "VLAN port mapping",
+		.set = swconfig_set_vlan_ports,
+		.get = swconfig_get_vlan_ports,
+	},
+};
+
+static const struct switch_attr *
+swconfig_find_attr_by_name(const struct switch_attrlist *alist, const char *name)
+{
+	int i;
+
+	for (i = 0; i < alist->n_attr; i++)
+		if (strcmp(name, alist->attr[i].name) == 0)
+			return &alist->attr[i];
+
+	return NULL;
+}
+
+static void swconfig_defaults_init(struct switch_dev *dev)
+{
+	const struct switch_dev_ops *ops = dev->ops;
+
+	dev->def_global = 0;
+	dev->def_vlan = 0;
+	dev->def_port = 0;
+
+	if (ops->get_vlan_ports || ops->set_vlan_ports)
+		set_bit(VLAN_PORTS, &dev->def_vlan);
+
+	if (ops->get_port_pvid || ops->set_port_pvid)
+		set_bit(PORT_PVID, &dev->def_port);
+
+	if (ops->get_port_link &&
+	    !swconfig_find_attr_by_name(&ops->attr_port, "link"))
+		set_bit(PORT_LINK, &dev->def_port);
+
+	/* always present, can be no-op */
+	set_bit(GLOBAL_APPLY, &dev->def_global);
+	set_bit(GLOBAL_RESET, &dev->def_global);
+}
+
+
+static struct genl_family switch_fam = {
+	.id = GENL_ID_GENERATE,
+	.name = "switch",
+	.hdrsize = 0,
+	.version = 1,
+	.maxattr = SWITCH_ATTR_MAX,
+};
+
+static const struct nla_policy switch_policy[SWITCH_ATTR_MAX+1] = {
+	[SWITCH_ATTR_ID] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_ID] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_PORT] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VLAN] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VALUE_INT] = { .type = NLA_U32 },
+	[SWITCH_ATTR_OP_VALUE_STR] = { .type = NLA_NUL_STRING },
+	[SWITCH_ATTR_OP_VALUE_PORTS] = { .type = NLA_NESTED },
+	[SWITCH_ATTR_TYPE] = { .type = NLA_U32 },
+};
+
+static const struct nla_policy port_policy[SWITCH_PORT_ATTR_MAX+1] = {
+	[SWITCH_PORT_ID] = { .type = NLA_U32 },
+	[SWITCH_PORT_FLAG_TAGGED] = { .type = NLA_FLAG },
+};
+
+static inline void
+swconfig_lock(void)
+{
+	spin_lock(&swdevs_lock);
+}
+
+static inline void
+swconfig_unlock(void)
+{
+	spin_unlock(&swdevs_lock);
+}
+
+static struct switch_dev *
+swconfig_get_dev(struct genl_info *info)
+{
+	struct switch_dev *dev = NULL;
+	struct switch_dev *p;
+	int id;
+
+	if (!info->attrs[SWITCH_ATTR_ID])
+		goto done;
+
+	id = nla_get_u32(info->attrs[SWITCH_ATTR_ID]);
+	swconfig_lock();
+	list_for_each_entry(p, &swdevs, dev_list) {
+		if (id != p->id)
+			continue;
+
+		dev = p;
+		break;
+	}
+	if (dev)
+		mutex_lock(&dev->sw_mutex);
+	else
+		DPRINTF("device %d not found\n", id);
+	swconfig_unlock();
+done:
+	return dev;
+}
+
+static inline void
+swconfig_put_dev(struct switch_dev *dev)
+{
+	mutex_unlock(&dev->sw_mutex);
+}
+
+static int
+swconfig_dump_attr(struct swconfig_callback *cb, void *arg)
+{
+	struct switch_attr *op = arg;
+	struct genl_info *info = cb->info;
+	struct sk_buff *msg = cb->msg;
+	int id = cb->args[0];
+	void *hdr;
+
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &switch_fam,
+			NLM_F_MULTI, SWITCH_CMD_NEW_ATTR);
+	if (IS_ERR(hdr))
+		return -1;
+
+	if (nla_put_u32(msg, SWITCH_ATTR_OP_ID, id))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_OP_TYPE, op->type))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_OP_NAME, op->name))
+		goto nla_put_failure;
+	if (op->description)
+		if (nla_put_string(msg, SWITCH_ATTR_OP_DESCRIPTION,
+			op->description))
+			goto nla_put_failure;
+
+	return genlmsg_end(msg, hdr);
+nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	return -EMSGSIZE;
+}
+
+/* spread multipart messages across multiple message buffers */
+static int
+swconfig_send_multipart(struct swconfig_callback *cb, void *arg)
+{
+	struct genl_info *info = cb->info;
+	int restart = 0;
+	int err;
+
+	do {
+		if (!cb->msg) {
+			cb->msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+			if (cb->msg == NULL)
+				goto error;
+		}
+
+		if (!(cb->fill(cb, arg) < 0))
+			break;
+
+		/* fill failed, check if this was already the second attempt */
+		if (restart)
+			goto error;
+
+		/* try again in a new message, send the current one */
+		restart = 1;
+		if (cb->close) {
+			if (cb->close(cb, arg) < 0)
+				goto error;
+		}
+		err = genlmsg_reply(cb->msg, info);
+		cb->msg = NULL;
+		if (err < 0)
+			goto error;
+
+	} while (restart);
+
+	return 0;
+
+error:
+	if (cb->msg)
+		nlmsg_free(cb->msg);
+	return -1;
+}
+
+static int
+swconfig_list_attrs(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attrlist *alist;
+	struct switch_dev *dev;
+	struct swconfig_callback cb;
+	int err = -EINVAL;
+	int i;
+
+	/* defaults */
+	struct switch_attr *def_list;
+	unsigned long *def_active;
+	int n_def;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	switch(hdr->cmd) {
+	case SWITCH_CMD_LIST_GLOBAL:
+		alist = &dev->ops->attr_global;
+		def_list = default_global;
+		def_active = &dev->def_global;
+		n_def = ARRAY_SIZE(default_global);
+		break;
+	case SWITCH_CMD_LIST_VLAN:
+		alist = &dev->ops->attr_vlan;
+		def_list = default_vlan;
+		def_active = &dev->def_vlan;
+		n_def = ARRAY_SIZE(default_vlan);
+		break;
+	case SWITCH_CMD_LIST_PORT:
+		alist = &dev->ops->attr_port;
+		def_list = default_port;
+		def_active = &dev->def_port;
+		n_def = ARRAY_SIZE(default_port);
+		break;
+	default:
+		WARN_ON(1);
+		goto out;
+	}
+
+	memset(&cb, 0, sizeof(cb));
+	cb.info = info;
+	cb.fill = swconfig_dump_attr;
+	for (i = 0; i < alist->n_attr; i++) {
+		if (alist->attr[i].disabled)
+			continue;
+		cb.args[0] = i;
+		err = swconfig_send_multipart(&cb, (void *) &alist->attr[i]);
+		if (err < 0)
+			goto error;
+	}
+
+	/* defaults */
+	for (i = 0; i < n_def; i++) {
+		if (!test_bit(i, def_active))
+			continue;
+		cb.args[0] = SWITCH_ATTR_DEFAULTS_OFFSET + i;
+		err = swconfig_send_multipart(&cb, (void *) &def_list[i]);
+		if (err < 0)
+			goto error;
+	}
+	swconfig_put_dev(dev);
+
+	if (!cb.msg)
+		return 0;
+
+	return genlmsg_reply(cb.msg, info);
+
+error:
+	if (cb.msg)
+		nlmsg_free(cb.msg);
+out:
+	swconfig_put_dev(dev);
+	return err;
+}
+
+static const struct switch_attr *
+swconfig_lookup_attr(struct switch_dev *dev, struct genl_info *info,
+		struct switch_val *val)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attrlist *alist;
+	const struct switch_attr *attr = NULL;
+	int attr_id;
+
+	/* defaults */
+	struct switch_attr *def_list;
+	unsigned long *def_active;
+	int n_def;
+
+	if (!info->attrs[SWITCH_ATTR_OP_ID])
+		goto done;
+
+	switch(hdr->cmd) {
+	case SWITCH_CMD_SET_GLOBAL:
+	case SWITCH_CMD_GET_GLOBAL:
+		alist = &dev->ops->attr_global;
+		def_list = default_global;
+		def_active = &dev->def_global;
+		n_def = ARRAY_SIZE(default_global);
+		break;
+	case SWITCH_CMD_SET_VLAN:
+	case SWITCH_CMD_GET_VLAN:
+		alist = &dev->ops->attr_vlan;
+		def_list = default_vlan;
+		def_active = &dev->def_vlan;
+		n_def = ARRAY_SIZE(default_vlan);
+		if (!info->attrs[SWITCH_ATTR_OP_VLAN])
+			goto done;
+		val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_VLAN]);
+		if (val->port_vlan >= dev->vlans)
+			goto done;
+		break;
+	case SWITCH_CMD_SET_PORT:
+	case SWITCH_CMD_GET_PORT:
+		alist = &dev->ops->attr_port;
+		def_list = default_port;
+		def_active = &dev->def_port;
+		n_def = ARRAY_SIZE(default_port);
+		if (!info->attrs[SWITCH_ATTR_OP_PORT])
+			goto done;
+		val->port_vlan = nla_get_u32(info->attrs[SWITCH_ATTR_OP_PORT]);
+		if (val->port_vlan >= dev->ports)
+			goto done;
+		break;
+	default:
+		WARN_ON(1);
+		goto done;
+	}
+
+	if (!alist)
+		goto done;
+
+	attr_id = nla_get_u32(info->attrs[SWITCH_ATTR_OP_ID]);
+	if (attr_id >= SWITCH_ATTR_DEFAULTS_OFFSET) {
+		attr_id -= SWITCH_ATTR_DEFAULTS_OFFSET;
+		if (attr_id >= n_def)
+			goto done;
+		if (!test_bit(attr_id, def_active))
+			goto done;
+		attr = &def_list[attr_id];
+	} else {
+		if (attr_id >= alist->n_attr)
+			goto done;
+		attr = &alist->attr[attr_id];
+	}
+
+	if (attr->disabled)
+		attr = NULL;
+
+done:
+	if (!attr)
+		DPRINTF("attribute lookup failed\n");
+	val->attr = attr;
+	return attr;
+}
+
+static int
+swconfig_parse_ports(struct sk_buff *msg, struct nlattr *head,
+		struct switch_val *val, int max)
+{
+	struct nlattr *nla;
+	int rem;
+
+	val->len = 0;
+	nla_for_each_nested(nla, head, rem) {
+		struct nlattr *tb[SWITCH_PORT_ATTR_MAX+1];
+		struct switch_port *port = &val->value.ports[val->len];
+
+		if (val->len >= max)
+			return -EINVAL;
+
+		if (nla_parse_nested(tb, SWITCH_PORT_ATTR_MAX, nla,
+				port_policy))
+			return -EINVAL;
+
+		if (!tb[SWITCH_PORT_ID])
+			return -EINVAL;
+
+		port->id = nla_get_u32(tb[SWITCH_PORT_ID]);
+		if (tb[SWITCH_PORT_FLAG_TAGGED])
+			port->flags |= (1 << SWITCH_PORT_FLAG_TAGGED);
+		val->len++;
+	}
+
+	return 0;
+}
+
+static int
+swconfig_set_attr(struct sk_buff *skb, struct genl_info *info)
+{
+	const struct switch_attr *attr;
+	struct switch_dev *dev;
+	struct switch_val val;
+	int err = -EINVAL;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	memset(&val, 0, sizeof(val));
+	attr = swconfig_lookup_attr(dev, info, &val);
+	if (!attr || !attr->set)
+		goto error;
+
+	val.attr = attr;
+	switch(attr->type) {
+	case SWITCH_TYPE_NOVAL:
+		break;
+	case SWITCH_TYPE_INT:
+		if (!info->attrs[SWITCH_ATTR_OP_VALUE_INT])
+			goto error;
+		val.value.i =
+			nla_get_u32(info->attrs[SWITCH_ATTR_OP_VALUE_INT]);
+		break;
+	case SWITCH_TYPE_STRING:
+		if (!info->attrs[SWITCH_ATTR_OP_VALUE_STR])
+			goto error;
+		val.value.s =
+			nla_data(info->attrs[SWITCH_ATTR_OP_VALUE_STR]);
+		break;
+	case SWITCH_TYPE_PORTS:
+		val.value.ports = dev->portbuf;
+		memset(dev->portbuf, 0,
+			sizeof(struct switch_port) * dev->ports);
+
+		/* TODO: implement multipart? */
+		if (info->attrs[SWITCH_ATTR_OP_VALUE_PORTS]) {
+			err = swconfig_parse_ports(skb,
+				info->attrs[SWITCH_ATTR_OP_VALUE_PORTS], &val, dev->ports);
+			if (err < 0)
+				goto error;
+		} else {
+			val.len = 0;
+			err = 0;
+		}
+		break;
+	default:
+		goto error;
+	}
+
+	err = attr->set(dev, attr, &val);
+error:
+	swconfig_put_dev(dev);
+	return err;
+}
+
+static int
+swconfig_close_portlist(struct swconfig_callback *cb, void *arg)
+{
+	if (cb->nest[0])
+		nla_nest_end(cb->msg, cb->nest[0]);
+	return 0;
+}
+
+static int
+swconfig_send_port(struct swconfig_callback *cb, void *arg)
+{
+	const struct switch_port *port = arg;
+	struct nlattr *p = NULL;
+
+	if (!cb->nest[0]) {
+		cb->nest[0] = nla_nest_start(cb->msg, cb->cmd);
+		if (!cb->nest[0])
+			return -1;
+	}
+
+	p = nla_nest_start(cb->msg, SWITCH_ATTR_PORT);
+	if (!p)
+		goto error;
+
+	if (nla_put_u32(cb->msg, SWITCH_PORT_ID, port->id))
+		goto nla_put_failure;
+	if (port->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
+		if (nla_put_flag(cb->msg, SWITCH_PORT_FLAG_TAGGED))
+			goto nla_put_failure;
+	}
+
+	nla_nest_end(cb->msg, p);
+	return 0;
+
+nla_put_failure:
+		nla_nest_cancel(cb->msg, p);
+error:
+	nla_nest_cancel(cb->msg, cb->nest[0]);
+	return -1;
+}
+
+static int
+swconfig_send_ports(struct sk_buff **msg, struct genl_info *info, int attr,
+		const struct switch_val *val)
+{
+	struct swconfig_callback cb;
+	int err = 0;
+	int i;
+
+	if (!val->value.ports)
+		return -EINVAL;
+
+	memset(&cb, 0, sizeof(cb));
+	cb.cmd = attr;
+	cb.msg = *msg;
+	cb.info = info;
+	cb.fill = swconfig_send_port;
+	cb.close = swconfig_close_portlist;
+
+	cb.nest[0] = nla_nest_start(cb.msg, cb.cmd);
+	for (i = 0; i < val->len; i++) {
+		err = swconfig_send_multipart(&cb, &val->value.ports[i]);
+		if (err)
+			goto done;
+	}
+	err = val->len;
+	swconfig_close_portlist(&cb, NULL);
+	*msg = cb.msg;
+
+done:
+	return err;
+}
+
+static int
+swconfig_get_attr(struct sk_buff *skb, struct genl_info *info)
+{
+	struct genlmsghdr *hdr = nlmsg_data(info->nlhdr);
+	const struct switch_attr *attr;
+	struct switch_dev *dev;
+	struct sk_buff *msg = NULL;
+	struct switch_val val;
+	int err = -EINVAL;
+	int cmd = hdr->cmd;
+
+	dev = swconfig_get_dev(info);
+	if (!dev)
+		return -EINVAL;
+
+	memset(&val, 0, sizeof(val));
+	attr = swconfig_lookup_attr(dev, info, &val);
+	if (!attr || !attr->get)
+		goto error;
+
+	if (attr->type == SWITCH_TYPE_PORTS) {
+		val.value.ports = dev->portbuf;
+		memset(dev->portbuf, 0,
+			sizeof(struct switch_port) * dev->ports);
+	}
+
+	err = attr->get(dev, attr, &val);
+	if (err)
+		goto error;
+
+	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!msg)
+		goto error;
+
+	hdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &switch_fam,
+			0, cmd);
+	if (IS_ERR(hdr))
+		goto nla_put_failure;
+
+	switch(attr->type) {
+	case SWITCH_TYPE_INT:
+		if (nla_put_u32(msg, SWITCH_ATTR_OP_VALUE_INT, val.value.i))
+			goto nla_put_failure;
+		break;
+	case SWITCH_TYPE_STRING:
+		if (nla_put_string(msg, SWITCH_ATTR_OP_VALUE_STR, val.value.s))
+			goto nla_put_failure;
+		break;
+	case SWITCH_TYPE_PORTS:
+		err = swconfig_send_ports(&msg, info,
+				SWITCH_ATTR_OP_VALUE_PORTS, &val);
+		if (err < 0)
+			goto nla_put_failure;
+		break;
+	default:
+		DPRINTF("invalid type in attribute\n");
+		err = -EINVAL;
+		goto error;
+	}
+	err = genlmsg_end(msg, hdr);
+	if (err < 0)
+		goto nla_put_failure;
+
+	swconfig_put_dev(dev);
+	return genlmsg_reply(msg, info);
+
+nla_put_failure:
+	if (msg)
+		nlmsg_free(msg);
+error:
+	swconfig_put_dev(dev);
+	if (!err)
+		err = -ENOMEM;
+	return err;
+}
+
+static int
+swconfig_send_switch(struct sk_buff *msg, u32 pid, u32 seq, int flags,
+		const struct switch_dev *dev)
+{
+	struct nlattr *p = NULL, *m = NULL;
+	void *hdr;
+	int i;
+
+	hdr = genlmsg_put(msg, pid, seq, &switch_fam, flags,
+			SWITCH_CMD_NEW_ATTR);
+	if (IS_ERR(hdr))
+		return -1;
+
+	if (nla_put_u32(msg, SWITCH_ATTR_ID, dev->id))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_DEV_NAME, dev->devname))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_ALIAS, dev->alias))
+		goto nla_put_failure;
+	if (nla_put_string(msg, SWITCH_ATTR_NAME, dev->name))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_VLANS, dev->vlans))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_PORTS, dev->ports))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, SWITCH_ATTR_CPU_PORT, dev->cpu_port))
+		goto nla_put_failure;
+
+	m = nla_nest_start(msg, SWITCH_ATTR_PORTMAP);
+	if (!m)
+		goto nla_put_failure;
+	for (i = 0; i < dev->ports; i++) {
+		p = nla_nest_start(msg, SWITCH_ATTR_PORTS);
+		if (!p)
+			continue;
+		if (dev->portmap[i].s) {
+			if (nla_put_string(msg, SWITCH_PORTMAP_SEGMENT, dev->portmap[i].s))
+				goto nla_put_failure;
+			if (nla_put_u32(msg, SWITCH_PORTMAP_VIRT, dev->portmap[i].virt))
+				goto nla_put_failure;
+		}
+		nla_nest_end(msg, p);
+	}
+	nla_nest_end(msg, m);
+	return genlmsg_end(msg, hdr);
+nla_put_failure:
+	genlmsg_cancel(msg, hdr);
+	return -EMSGSIZE;
+}
+
+static int swconfig_dump_switches(struct sk_buff *skb,
+		struct netlink_callback *cb)
+{
+	struct switch_dev *dev;
+	int start = cb->args[0];
+	int idx = 0;
+
+	swconfig_lock();
+	list_for_each_entry(dev, &swdevs, dev_list) {
+		if (++idx <= start)
+			continue;
+		if (swconfig_send_switch(skb, NETLINK_CB(cb->skb).portid,
+				cb->nlh->nlmsg_seq, NLM_F_MULTI,
+				dev) < 0)
+			break;
+	}
+	swconfig_unlock();
+	cb->args[0] = idx;
+
+	return skb->len;
+}
+
+static int
+swconfig_done(struct netlink_callback *cb)
+{
+	return 0;
+}
+
+static struct genl_ops swconfig_ops[] = {
+	{
+		.cmd = SWITCH_CMD_LIST_GLOBAL,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_LIST_VLAN,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_LIST_PORT,
+		.doit = swconfig_list_attrs,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_GLOBAL,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_VLAN,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_PORT,
+		.doit = swconfig_get_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_GLOBAL,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_VLAN,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_SET_PORT,
+		.doit = swconfig_set_attr,
+		.policy = switch_policy,
+	},
+	{
+		.cmd = SWITCH_CMD_GET_SWITCH,
+		.dumpit = swconfig_dump_switches,
+		.policy = switch_policy,
+		.done = swconfig_done,
+	}
+};
+
+#ifdef CONFIG_OF
+void
+of_switch_load_portmap(struct switch_dev *dev)
+{
+	struct device_node *port;
+
+	if (!dev->of_node)
+		return;
+
+	for_each_child_of_node(dev->of_node, port) {
+		const __be32 *prop;
+		const char *segment;
+		int size, phys;
+
+		if (of_device_is_compatible(port, "swconfig,port"))
+			continue;
+
+		if (of_property_read_string(port, "swconfig,segment", &segment))
+			continue;
+
+		prop = of_get_property(port, "swconfig,portmap", &size);
+		if (!prop)
+			continue;
+
+		if (size != (2 * sizeof(*prop))) {
+			pr_err("%s: failed to parse port mapping\n", port->name);
+			continue;
+		}
+
+		phys = be32_to_cpup(prop++);
+		if ((phys < 0) | (phys >= dev->ports)) {
+			pr_err("%s: physical port index out of range\n", port->name);
+			continue;
+		}
+
+		dev->portmap[phys].s = kstrdup(segment, GFP_KERNEL);
+		dev->portmap[phys].virt = be32_to_cpup(prop);
+		pr_debug("Found port: %s, physical: %d, virtual: %d\n",
+			segment, phys, dev->portmap[phys].virt);
+	}
+}
+#endif
+
+int
+register_switch(struct switch_dev *dev, struct net_device *netdev)
+{
+	struct switch_dev *sdev;
+	const int max_switches = 8 * sizeof(unsigned long);
+	unsigned long in_use = 0;
+	int err;
+	int i;
+
+	INIT_LIST_HEAD(&dev->dev_list);
+	if (netdev) {
+		dev->netdev = netdev;
+		if (!dev->alias)
+			dev->alias = netdev->name;
+	}
+	BUG_ON(!dev->alias);
+
+	if (dev->ports > 0) {
+		dev->portbuf = kzalloc(sizeof(struct switch_port) * dev->ports,
+				GFP_KERNEL);
+		if (!dev->portbuf)
+			return -ENOMEM;
+		dev->portmap = kzalloc(sizeof(struct switch_portmap) * dev->ports,
+				GFP_KERNEL);
+		if (!dev->portmap) {
+			kfree(dev->portbuf);
+			return -ENOMEM;
+		}
+	}
+	swconfig_defaults_init(dev);
+	mutex_init(&dev->sw_mutex);
+	swconfig_lock();
+	dev->id = ++swdev_id;
+
+	list_for_each_entry(sdev, &swdevs, dev_list) {
+		if (!sscanf(sdev->devname, SWCONFIG_DEVNAME, &i))
+			continue;
+		if (i < 0 || i > max_switches)
+			continue;
+
+		set_bit(i, &in_use);
+	}
+	i = find_first_zero_bit(&in_use, max_switches);
+
+	if (i == max_switches) {
+		swconfig_unlock();
+		return -ENFILE;
+	}
+
+#ifdef CONFIG_OF
+	if (dev->ports)
+		of_switch_load_portmap(dev);
+#endif
+
+	/* fill device name */
+	snprintf(dev->devname, IFNAMSIZ, SWCONFIG_DEVNAME, i);
+
+	list_add(&dev->dev_list, &swdevs);
+	swconfig_unlock();
+
+	err = swconfig_create_led_trigger(dev);
+	if (err)
+		return err;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_switch);
+
+void
+unregister_switch(struct switch_dev *dev)
+{
+	swconfig_destroy_led_trigger(dev);
+	kfree(dev->portbuf);
+	mutex_lock(&dev->sw_mutex);
+	swconfig_lock();
+	list_del(&dev->dev_list);
+	swconfig_unlock();
+	mutex_unlock(&dev->sw_mutex);
+}
+EXPORT_SYMBOL_GPL(unregister_switch);
+
+
+static int __init
+swconfig_init(void)
+{
+	int err;
+
+	INIT_LIST_HEAD(&swdevs);
+	err = genl_register_family_with_ops(&switch_fam, swconfig_ops);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static void __exit
+swconfig_exit(void)
+{
+	genl_unregister_family(&switch_fam);
+}
+
+module_init(swconfig_init);
+module_exit(swconfig_exit);
diff --git a/drivers/net/phy/swconfig_leds.c b/drivers/net/phy/swconfig_leds.c
new file mode 100644
index 0000000..2fc5d55
--- /dev/null
+++ b/drivers/net/phy/swconfig_leds.c
@@ -0,0 +1,354 @@
+/*
+ * swconfig_led.c: LED trigger support for the switch configuration API
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ */
+
+#ifdef CONFIG_SWCONFIG_LEDS
+
+#include <linux/leds.h>
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+
+#define SWCONFIG_LED_TIMER_INTERVAL	(HZ / 10)
+#define SWCONFIG_LED_NUM_PORTS		32
+
+struct switch_led_trigger {
+	struct led_trigger trig;
+	struct switch_dev *swdev;
+
+	struct delayed_work sw_led_work;
+	u32 port_mask;
+	u32 port_link;
+	unsigned long port_traffic[SWCONFIG_LED_NUM_PORTS];
+};
+
+struct swconfig_trig_data {
+	struct led_classdev *led_cdev;
+	struct switch_dev *swdev;
+
+	rwlock_t lock;
+	u32 port_mask;
+
+	bool prev_link;
+	unsigned long prev_traffic;
+	enum led_brightness prev_brightness;
+};
+
+static void
+swconfig_trig_set_brightness(struct swconfig_trig_data *trig_data,
+			     enum led_brightness brightness)
+{
+	led_set_brightness(trig_data->led_cdev, brightness);
+	trig_data->prev_brightness = brightness;
+}
+
+static void
+swconfig_trig_update_port_mask(struct led_trigger *trigger)
+{
+	struct list_head *entry;
+	struct switch_led_trigger *sw_trig;
+	u32 port_mask;
+
+	if (!trigger)
+		return;
+
+	sw_trig = (void *) trigger;
+
+	port_mask = 0;
+	read_lock(&trigger->leddev_list_lock);
+	list_for_each(entry, &trigger->led_cdevs) {
+		struct led_classdev *led_cdev;
+		struct swconfig_trig_data *trig_data;
+
+		led_cdev = list_entry(entry, struct led_classdev, trig_list);
+		trig_data = led_cdev->trigger_data;
+		if (trig_data) {
+			read_lock(&trig_data->lock);
+			port_mask |= trig_data->port_mask;
+			read_unlock(&trig_data->lock);
+		}
+	}
+	read_unlock(&trigger->leddev_list_lock);
+
+	sw_trig->port_mask = port_mask;
+
+	if (port_mask)
+		schedule_delayed_work(&sw_trig->sw_led_work,
+				      SWCONFIG_LED_TIMER_INTERVAL);
+	else
+		cancel_delayed_work_sync(&sw_trig->sw_led_work);
+}
+
+static ssize_t
+swconfig_trig_port_mask_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
+	unsigned long port_mask;
+	ssize_t ret = -EINVAL;
+	char *after;
+	size_t count;
+
+	port_mask = simple_strtoul(buf, &after, 16);
+	count =	after - buf;
+
+	if (*after && isspace(*after))
+		count++;
+
+	if (count == size) {
+		bool changed;
+
+		write_lock(&trig_data->lock);
+
+		changed = (trig_data->port_mask != port_mask);
+		if (changed) {
+			trig_data->port_mask = port_mask;
+			if (port_mask == 0)
+				swconfig_trig_set_brightness(trig_data, LED_OFF);
+		}
+
+		write_unlock(&trig_data->lock);
+
+		if (changed)
+			swconfig_trig_update_port_mask(led_cdev->trigger);
+
+		ret = count;
+	}
+
+	return ret;
+}
+
+static ssize_t
+swconfig_trig_port_mask_show(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct swconfig_trig_data *trig_data = led_cdev->trigger_data;
+
+	read_lock(&trig_data->lock);
+	sprintf(buf, "%#x\n", trig_data->port_mask);
+	read_unlock(&trig_data->lock);
+
+	return strlen(buf) + 1;
+}
+
+static DEVICE_ATTR(port_mask, 0644, swconfig_trig_port_mask_show,
+		   swconfig_trig_port_mask_store);
+
+static void
+swconfig_trig_activate(struct led_classdev *led_cdev)
+{
+	struct switch_led_trigger *sw_trig;
+	struct swconfig_trig_data *trig_data;
+	int err;
+
+	if (led_cdev->trigger->activate != swconfig_trig_activate)
+		return;
+
+	trig_data = kzalloc(sizeof(struct swconfig_trig_data), GFP_KERNEL);
+	if (!trig_data)
+		return;
+
+	sw_trig = (void *) led_cdev->trigger;
+
+	rwlock_init(&trig_data->lock);
+	trig_data->led_cdev = led_cdev;
+	trig_data->swdev = sw_trig->swdev;
+	led_cdev->trigger_data = trig_data;
+
+	err = device_create_file(led_cdev->dev, &dev_attr_port_mask);
+	if (err)
+		goto err_free;
+
+	return;
+
+err_free:
+	led_cdev->trigger_data = NULL;
+	kfree(trig_data);
+}
+
+static void
+swconfig_trig_deactivate(struct led_classdev *led_cdev)
+{
+	struct swconfig_trig_data *trig_data;
+
+	swconfig_trig_update_port_mask(led_cdev->trigger);
+
+	trig_data = (void *) led_cdev->trigger_data;
+	if (trig_data) {
+		device_remove_file(led_cdev->dev, &dev_attr_port_mask);
+		kfree(trig_data);
+	}
+}
+
+static void
+swconfig_trig_led_event(struct switch_led_trigger *sw_trig,
+			struct led_classdev *led_cdev)
+{
+	struct swconfig_trig_data *trig_data;
+	u32 port_mask;
+	bool link;
+
+	trig_data = led_cdev->trigger_data;
+	if (!trig_data)
+		return;
+
+	read_lock(&trig_data->lock);
+	port_mask = trig_data->port_mask;
+	read_unlock(&trig_data->lock);
+
+	link = !!(sw_trig->port_link & port_mask);
+	if (!link) {
+		if (link != trig_data->prev_link)
+			led_set_brightness(trig_data->led_cdev, LED_OFF);
+	} else {
+		unsigned long traffic;
+		int i;
+
+		traffic = 0;
+		for (i = 0; i < SWCONFIG_LED_NUM_PORTS; i++) {
+			if (port_mask & (1 << i))
+				traffic += sw_trig->port_traffic[i];
+		}
+
+		if (trig_data->prev_brightness != LED_FULL)
+			swconfig_trig_set_brightness(trig_data, LED_FULL);
+		else if (traffic != trig_data->prev_traffic)
+			swconfig_trig_set_brightness(trig_data, LED_OFF);
+
+		trig_data->prev_traffic = traffic;
+	}
+
+	trig_data->prev_link = link;
+}
+
+static void
+swconfig_trig_update_leds(struct switch_led_trigger *sw_trig)
+{
+	struct list_head *entry;
+	struct led_trigger *trigger;
+
+	trigger = &sw_trig->trig;
+	read_lock(&trigger->leddev_list_lock);
+	list_for_each(entry, &trigger->led_cdevs) {
+		struct led_classdev *led_cdev;
+
+		led_cdev = list_entry(entry, struct led_classdev, trig_list);
+		swconfig_trig_led_event(sw_trig, led_cdev);
+	}
+	read_unlock(&trigger->leddev_list_lock);
+}
+
+static void
+swconfig_led_work_func(struct work_struct *work)
+{
+	struct switch_led_trigger *sw_trig;
+	struct switch_dev *swdev;
+	u32 port_mask;
+	u32 link;
+	int i;
+
+	sw_trig = container_of(work, struct switch_led_trigger,
+			       sw_led_work.work);
+
+	port_mask = sw_trig->port_mask;
+	swdev = sw_trig->swdev;
+
+	link = 0;
+	for (i = 0; i < SWCONFIG_LED_NUM_PORTS; i++) {
+		u32 port_bit;
+
+		port_bit = BIT(i);
+		if ((port_mask & port_bit) == 0)
+			continue;
+
+		if (swdev->ops->get_port_link) {
+			struct switch_port_link port_link;
+
+			memset(&port_link, '\0', sizeof(port_link));
+			swdev->ops->get_port_link(swdev, i, &port_link);
+
+			if (port_link.link)
+				link |= port_bit;
+		}
+
+		if (swdev->ops->get_port_stats) {
+			struct switch_port_stats port_stats;
+
+			memset(&port_stats, '\0', sizeof(port_stats));
+			swdev->ops->get_port_stats(swdev, i, &port_stats);
+			sw_trig->port_traffic[i] = port_stats.tx_bytes +
+						   port_stats.rx_bytes;
+		}
+	}
+
+	sw_trig->port_link = link;
+
+	swconfig_trig_update_leds(sw_trig);
+
+	schedule_delayed_work(&sw_trig->sw_led_work,
+			      SWCONFIG_LED_TIMER_INTERVAL);
+}
+
+static int
+swconfig_create_led_trigger(struct switch_dev *swdev)
+{
+	struct switch_led_trigger *sw_trig;
+	int err;
+
+	if (!swdev->ops->get_port_link)
+		return 0;
+
+	sw_trig = kzalloc(sizeof(struct switch_led_trigger), GFP_KERNEL);
+	if (!sw_trig)
+		return -ENOMEM;
+
+	sw_trig->swdev = swdev;
+	sw_trig->trig.name = swdev->devname;
+	sw_trig->trig.activate = swconfig_trig_activate;
+	sw_trig->trig.deactivate = swconfig_trig_deactivate;
+
+	INIT_DELAYED_WORK(&sw_trig->sw_led_work, swconfig_led_work_func);
+
+	err = led_trigger_register(&sw_trig->trig);
+	if (err)
+		goto err_free;
+
+	swdev->led_trigger = sw_trig;
+
+	return 0;
+
+err_free:
+	kfree(sw_trig);
+	return err;
+}
+
+static void
+swconfig_destroy_led_trigger(struct switch_dev *swdev)
+{
+	struct switch_led_trigger *sw_trig;
+
+	sw_trig = swdev->led_trigger;
+	if (sw_trig) {
+		cancel_delayed_work_sync(&sw_trig->sw_led_work);
+		led_trigger_unregister(&sw_trig->trig);
+		kfree(sw_trig);
+	}
+}
+
+#else /* SWCONFIG_LEDS */
+static inline int
+swconfig_create_led_trigger(struct switch_dev *swdev) { return 0; }
+
+static inline void
+swconfig_destroy_led_trigger(struct switch_dev *swdev) { }
+#endif /* CONFIG_SWCONFIG_LEDS */
diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig
index 3a72862..0716fe5 100644
--- a/drivers/net/usb/Kconfig
+++ b/drivers/net/usb/Kconfig
@@ -533,6 +533,12 @@ config USB_NET_QMI_WWAN
 	  To compile this driver as a module, choose M here: the
 	  module will be called qmi_wwan.
 
+config QMI_WWAN_QUECTEL_UC20_INIT
+	bool "Enable UC20 Autoconnect Init"
+	depends on USB_NET_QMI_WWAN
+	help
+	  Enable Quectel UC20 Autoconnect Init
+
 config USB_HSO
 	tristate "Option USB High Speed Mobile Devices"
 	depends on USB && RFKILL && TTY
diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
index 2b728cc..63720ef 100644
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -689,6 +689,7 @@ static const struct usb_device_id products[] = {
 	{QMI_FIXED_INTF(0x05c6, 0x8001, 6)},
 	{QMI_FIXED_INTF(0x05c6, 0x9000, 4)},
 	{QMI_FIXED_INTF(0x05c6, 0x9003, 4)},
+	{QMI_FIXED_INTF(0x05c6, 0x9215, 4)},
 	{QMI_FIXED_INTF(0x05c6, 0x9005, 2)},
 	{QMI_FIXED_INTF(0x05c6, 0x900a, 4)},
 	{QMI_FIXED_INTF(0x05c6, 0x900b, 2)},
@@ -1032,6 +1033,118 @@ static bool quectel_ec20_detected(struct usb_interface *intf)
 	return false;
 }
 
+#ifdef CONFIG_QMI_WWAN_QUECTEL_UC20_INIT
+u8 get_blkoutep(struct usb_interface *intf)
+{
+	int num_endpoints;
+	int ep_index;
+	struct usb_host_endpoint *ep = NULL;
+	unsigned intf_num;
+	unsigned blk_out_ep = 0;
+
+	intf_num = intf->cur_altsetting->desc.bInterfaceNumber;
+
+	/* scan endpoints */
+	num_endpoints = intf->cur_altsetting->desc.bNumEndpoints;
+	for (ep_index = 0; ep_index < num_endpoints; ep_index++)
+	{
+		ep = intf->cur_altsetting->endpoint + ep_index;
+		if (ep == NULL)
+		{
+			dev_err(&intf->dev, "invalid endpoint %u\n", ep_index);
+			return 0;
+		}
+
+		if (usb_endpoint_dir_in(&ep->desc) == false
+		    &&  usb_endpoint_xfer_int(&ep->desc) == false)
+		{
+			blk_out_ep = ep->desc.bEndpointAddress;
+		}
+	}
+
+	if (blk_out_ep == 0)
+	{
+		dev_err(&intf->dev, "failed to get BLKOUT Endpoint!\n");
+		return 0;
+	}
+
+	dev_dbg(&intf->dev, "intf %u, blk out 0x%02x\n", intf_num, blk_out_ep);
+
+	return blk_out_ep;
+}
+
+static int qmi_autoconnect_setup(struct usb_interface *intf,
+				 struct usbnet *usbdev, int enable)
+{
+	int result;
+	unsigned intf_num;
+
+	intf_num = intf->cur_altsetting->desc.bInterfaceNumber;
+
+	result = usb_control_msg(usbdev->udev,
+				 usb_sndctrlpipe(usbdev->udev, 0 ),
+				 0x22,
+				 0x21,
+				 enable ? 1 : 0, // DTR present
+				 intf_num,
+				 NULL,
+				 0,
+				 100);
+	if (result < 0)
+	{
+		dev_err(&intf->dev, "Bad SetControlLineState status %d\n", result);
+		return result;
+	}
+
+	return 0;
+}
+
+static int qmi_quectel_uc20_init(struct usb_interface *intf, struct usb_device_id *id)
+{
+	unsigned blk_out_ep;
+	struct usbnet *usbnet_dev;
+	int pipe;
+
+	/* check for Quectel UC20 device */
+	if (id->idVendor != 0x05c6 || (id->idProduct != 0x9003 && id->idProduct != 0x9215))
+		return -ENODEV;
+	else
+		dev_info(&intf->dev, "Detected Quectel UC20\n");
+
+	blk_out_ep = get_blkoutep(intf);
+
+	intf->needs_remote_wakeup = 1;
+	usbnet_dev = usb_get_intfdata(intf);
+	if (usbnet_dev == NULL || usbnet_dev->net == NULL)
+	{
+		dev_err(&intf->dev, "failed to get netdevice!\n");
+		usbnet_disconnect(intf);
+		return -ENXIO;
+	}
+
+	if ((blk_out_ep > 0) && usbnet_dev && usbnet_dev->net) {
+		dev_info(&intf->dev, "bring the device out of low power (airplane) mode.\n");
+
+		/*
+		 * Clearing endpoint halt is a magic handshake that brings
+		 * the device out of low power (airplane) mode
+		 * NOTE: FCC verification should be done before this, if required
+		 */
+		pipe = usb_sndbulkpipe(usbnet_dev->udev, blk_out_ep);
+		usb_clear_halt(usbnet_dev->udev, pipe);
+	} else {
+		dev_err(&intf->dev, "failed to get BLKOUT Endpoint!\n");
+	}
+
+	if (qmi_autoconnect_setup(intf, usbnet_dev, 1)) {
+		dev_err(&intf->dev, "uc20 autoconnent setup failed!\n");
+		return -ENOLINK;
+	}
+
+	return 0;
+}
+#endif
+
 static int qmi_wwan_probe(struct usb_interface *intf,
 			  const struct usb_device_id *prod)
 {
@@ -1066,7 +1179,19 @@ static int qmi_wwan_probe(struct usb_interface *intf,
 		return -ENODEV;
 	}
 
+#ifdef CONFIG_QMI_WWAN_QUECTEL_UC20_INIT
+	{
+		int ret;
+
+		ret = usbnet_probe(intf, id);
+		if (qmi_quectel_uc20_init(intf, id) == 0)
+			dev_info(&intf->dev, "Quectel UC20 Init successful!\n");
+
+		return ret;
+	}
+#else
 	return usbnet_probe(intf, id);
+#endif
 }
 
 static struct usb_driver qmi_wwan_driver = {
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 0723c97..820658f 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -370,6 +370,14 @@ config RTC_DRV_RS5C372
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-rs5c372.
 
+config RTC_DRV_RS5C372_IRQ_SUPPORT
+	bool "Enable R2221 1-HZ-RTC IRQ Support"
+	depends on RTC_DRV_RS5C372
+	default n
+	help
+	  This feature enables the 1Hz-irq of the RTC R2221 and creates a sysfs entry
+	  to make it possible to disable or enable this feature. This is for testing purposes.
+
 config RTC_DRV_ISL1208
 	tristate "Intersil ISL1208"
 	help
diff --git a/drivers/rtc/rtc-rs5c372.c b/drivers/rtc/rtc-rs5c372.c
index c8c7574..cf093a3 100644
--- a/drivers/rtc/rtc-rs5c372.c
+++ b/drivers/rtc/rtc-rs5c372.c
@@ -10,6 +10,7 @@
  * published by the Free Software Foundation.
  */
 
+#undef DEBUG
 #include <linux/i2c.h>
 #include <linux/rtc.h>
 #include <linux/bcd.h>
@@ -119,7 +120,7 @@ static int rs5c_get_regs(struct rs5c372 *rs5c)
 	 * least 80219 chips; this works around that bug.
 	 *
 	 * The third method on the other hand doesn't work for the SMBus-only
-	 * configurations, so we use the the first method there, stripping off
+	 * configurations, so we use the first method there, stripping off
 	 * the extra register in the process.
 	 */
 	if (rs5c->smbus) {
@@ -273,6 +274,43 @@ static int rs5c372_get_trim(struct i2c_client *client, int *osc, int *trim)
 
 	return 0;
 }
+
+/*
+ * dev_bit: Bit DEV
+ * dec: bit F6 (a '1' will cause an increment of 1-second time count)
+ * trim: bits F5..F0 (adjustment factor)
+ * */
+static int rs5c372_set_trim(struct i2c_client *client, u8 dev_bit, u8 dec, int trim)
+{
+	struct rs5c372 *rs5c372 = i2c_get_clientdata(client);
+	unsigned char	buf[1];
+	int		addr;
+	int             tmp = 0;
+
+	dev_dbg(&client->dev, "%s: set trim to %d (0x%x).\n",
+		__func__, (trim & 0x3f), (trim & 0x3f));
+
+	if (dev_bit)
+		tmp |= 0x80;	/* set DEV Bit */
+
+	if (dec)
+		tmp |= 0x40;	/* set F6 Bit */
+
+	tmp |= (trim & 0x3f);
+
+	addr   = RS5C_ADDR(RS5C372_REG_TRIM);
+/* 	buf[0] = bin2bcd(tmp); */
+	buf[0] = tmp;
+
+	if (i2c_smbus_write_i2c_block_data(client, addr, sizeof(buf), buf) < 0) {
+		dev_err(&client->dev, "%s: write error\n", __func__);
+		return -EIO;
+	}
+
+	rs5c_get_regs(rs5c372);
+
+	return 0;
+}
 #endif
 
 static int rs5c372_rtc_read_time(struct device *dev, struct rtc_time *tm)
@@ -357,10 +395,10 @@ static int rs5c_set_alarm(struct device *dev, struct rtc_wkalrm *t)
 	unsigned char		buf[3];
 
 	/* only handle up to 24 hours in the future, like RTC_ALM_SET */
-	if (t->time.tm_mday != -1
-			|| t->time.tm_mon != -1
-			|| t->time.tm_year != -1)
-		return -EINVAL;
+/* 	if (t->time.tm_mday != -1 */
+/* 			|| t->time.tm_mon != -1 */
+/* 			|| t->time.tm_year != -1) */
+/* 		return -EINVAL; */
 
 	/* REVISIT: round up tm_sec */
 
@@ -433,6 +471,97 @@ static const struct rtc_class_ops rs5c372_rtc_ops = {
 };
 
 #if IS_ENABLED(CONFIG_RTC_INTF_SYSFS)
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+
+static int rs5c372_enable_periodic_intr(struct i2c_client *client, int enable)
+{
+	struct rs5c372 *rs5c372 = i2c_get_clientdata(client);
+	u8 ctrl1;
+	int addr;
+
+	rs5c_get_regs(rs5c372);
+	ctrl1 = rs5c372->regs[RS5C_REG_CTRL1];
+
+	/* clear alarm irq flags */
+	ctrl1 &= ~(RS5C_CTRL1_AALE | RS5C_CTRL1_BALE);
+
+	switch (enable) {
+	case 1:
+		ctrl1 &= ~RS5C_CTRL1_CT_MASK;
+		ctrl1 |= RS5C_CTRL1_CT4;
+		break;
+	case 0:
+		ctrl1 &= ~RS5C_CTRL1_CT_MASK;
+		break;
+	default:
+		dev_err(&client->dev, "%s: unexpected value (%d)\n", __func__, enable);
+	}
+
+	addr = RS5C_ADDR(RS5C_REG_CTRL1);
+	if (i2c_smbus_write_byte_data(client, addr, ctrl1) < 0) {
+		pr_debug("%s: can't %s periodic interrupt!\n",
+			 rs5c372->rtc->name,
+			 enable ? "enable" : "disable");
+		return -EIO;
+	}
+	rs5c372->regs[RS5C_REG_CTRL1] = ctrl1;
+
+	pr_debug("%s: periodic interrupt %s.\n",
+		 rs5c372->rtc->name,
+		 enable ? "enabled" : "disabled");
+
+	return 0;
+}
+
+/**
+ * rs5c372_sysfs_store_periodic_intr - enable a periodic 1-second interrupt
+ * @dev: device pointer
+ * @attr: device attribute pointer
+ * @buf: buffer to scan for periodic intr enable value
+ * @count: number of bytes in @buf
+ *
+ *	The relevant values are:
+ *
+ *	 1: Start periodic intr
+ *	 0: Stop periodic intr
+ *
+ **/
+static ssize_t rs5c372_sysfs_periodic_intr_store(struct device *dev,
+						 struct device_attribute *attr,
+						 const char *buf, size_t count)
+{
+	struct i2c_client	*client = to_i2c_client(dev);
+	int enable = simple_strtol(buf, NULL, 10);
+	int ret;
+
+	ret = rs5c372_enable_periodic_intr(client, enable);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t rs5c372_sysfs_periodic_intr_show(struct device *dev,
+						struct device_attribute *attr, char *buf)
+{
+	struct i2c_client	*client = to_i2c_client(dev);
+	struct rs5c372          *rs5c372 = i2c_get_clientdata(client);
+	u8 ctrl1;
+	u8 enabled;
+
+	rs5c_get_regs(rs5c372);
+
+	ctrl1 = rs5c372->regs[RS5C_REG_CTRL1];
+	enabled = (ctrl1 & RS5C_CTRL1_CT_MASK) == RS5C_CTRL1_CT4;
+
+	pr_debug("%s: periodic interrupt is %s.\n",
+		 rs5c372->rtc->name,
+		 enabled ? "enabled" : "disabled");
+
+	return sprintf(buf, "%d\n", enabled);
+}
+static DEVICE_ATTR(enable_periodic_int, 0644, rs5c372_sysfs_periodic_intr_show, rs5c372_sysfs_periodic_intr_store);
+#endif	/* CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT */
 
 static ssize_t rs5c372_sysfs_show_trim(struct device *dev,
 				struct device_attribute *attr, char *buf)
@@ -460,6 +589,33 @@ static ssize_t rs5c372_sysfs_show_osc(struct device *dev,
 }
 static DEVICE_ATTR(osc, S_IRUGO, rs5c372_sysfs_show_osc, NULL);
 
+static ssize_t rs5c372_sysfs_show_intmode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int addr = RS5C_ADDR(RS5C_REG_CTRL1);
+	u8 intmode = i2c_smbus_read_byte_data(to_i2c_client(dev), addr) &
+				RS5C_CTRL1_CT_MASK;
+	return sprintf(buf, "%d\n", intmode);
+}
+
+static ssize_t rs5c372_sysfs_store_intmode(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int addr = RS5C_ADDR(RS5C_REG_CTRL1);
+	u8 intmode = (u8)buf[0] - '0';
+
+	if ((buf[1] == 0 || buf[1] == '\n') && intmode < 8) {
+		u8 ctrl1 = i2c_smbus_read_byte_data(client, addr);
+		ctrl1 = (ctrl1 & ~RS5C_CTRL1_CT_MASK) | intmode;
+		if (i2c_smbus_write_byte_data(client, addr, ctrl1)) count = -EIO;
+	} else count = -EINVAL;
+	return count;
+}
+static DEVICE_ATTR(intmode, 0644, rs5c372_sysfs_show_intmode,
+				rs5c372_sysfs_store_intmode);
+
 static int rs5c_sysfs_register(struct device *dev)
 {
 	int err;
@@ -468,8 +624,23 @@ static int rs5c_sysfs_register(struct device *dev)
 	if (err)
 		return err;
 	err = device_create_file(dev, &dev_attr_osc);
-	if (err)
+	if (err) {
 		device_remove_file(dev, &dev_attr_trim);
+		return err;
+	}
+	err = device_create_file(dev, &dev_attr_intmode);
+	if (err) {
+		device_remove_file(dev, &dev_attr_trim);
+		device_remove_file(dev, &dev_attr_osc);
+	}
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+	err = device_create_file(dev, &dev_attr_enable_periodic_int);
+	if (err) {
+		device_remove_file(dev, &dev_attr_trim);
+		device_remove_file(dev, &dev_attr_osc);
+		device_remove_file(dev, &dev_attr_intmode);
+	}
+#endif
 
 	return err;
 }
@@ -478,6 +649,10 @@ static void rs5c_sysfs_unregister(struct device *dev)
 {
 	device_remove_file(dev, &dev_attr_trim);
 	device_remove_file(dev, &dev_attr_osc);
+	device_remove_file(dev, &dev_attr_intmode);
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+	device_remove_file(dev, &dev_attr_enable_periodic_int);
+#endif
 }
 
 #else
@@ -545,6 +720,42 @@ static int rs5c_oscillator_setup(struct rs5c372 *rs5c372)
 	return 0;
 }
 
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+static int rs5c372_clear_ctfg_bit(struct i2c_client *client)
+{
+	struct rs5c372 *rs5c372 = i2c_get_clientdata(client);
+	u8 ctrl2;
+	int addr;
+
+	rs5c_get_regs(rs5c372);
+	ctrl2 = rs5c372->regs[RS5C_REG_CTRL2];
+
+	/* clear alarm irq flags */
+	ctrl2 &= ~RS5C_CTRL2_CTFG;
+
+	addr = RS5C_ADDR(RS5C_REG_CTRL2);
+	if (i2c_smbus_write_byte_data(client, addr, ctrl2) < 0) {
+		pr_debug("%s: can't clear ctfg bit!\n", __func__);
+		return -EIO;
+	}
+	rs5c372->regs[RS5C_REG_CTRL2] = ctrl2;
+
+	return 0;
+}
+
+static irqreturn_t rs5c372_irq(int irq, void *handle)
+{
+	struct i2c_client *client = (struct i2c_client *) handle;
+
+	/* schedule_delayed_work(&kpad->work, kpad->delay); */
+	trace_printk("%s: Incoming IRQ %d. Reset CTFG Flag.\n", __func__, irq);
+
+	rs5c372_clear_ctfg_bit(client);
+
+	return IRQ_HANDLED;
+}
+#endif	/* CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT */
+
 static int rs5c372_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
@@ -628,8 +839,26 @@ static int rs5c372_probe(struct i2c_client *client,
 		goto exit;
 	}
 
-	if (rs5c372_get_datetime(client, &tm) < 0)
-		dev_warn(&client->dev, "clock needs to be set\n");
+	if (rs5c372_get_datetime(client, &tm) < 0) {
+		dev_warn(&client->dev, "clock needs to be set and will be set to 2012-01-01.\n");
+		tm.tm_mday = 1;
+		/* tm->tm_mon is zero-based */
+		tm.tm_mon = 0;
+		/* year is 1900 + tm->tm_year */
+		tm.tm_year = 112;
+		rs5c372_set_datetime(client, &tm);
+	}
+
+#ifdef	NEED_TRIM
+	pr_debug("%s: set osc adjustment to %s", __func__, "0x0d (13)");
+	rs5c372_set_trim(client, 0, 0, 13); /* Calculation is based on an empirical drift value of +32.47 ppm.
+					     * Set trim value to (32768.00 * 32.47 ppm * 10) + 1 = 11.6398 ~ 12.
+					     * Measurements provide better values for an adjustment value of 13
+					     * which results in a drift value of -1.41 ppm. Also Hardware measurements
+					     * of osc frequency indicate the need of a higher value. So we set 13 here.
+					     * See documentation of r2221 on page 34.
+					     */
+#endif
 
 	dev_info(&client->dev, "%s found, %s\n",
 			({ char *s; switch (rs5c372->type) {
@@ -645,21 +874,45 @@ static int rs5c372_probe(struct i2c_client *client,
 			);
 
 	/* REVISIT use client->irq to register alarm irq ... */
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+	pr_debug("%s: irq is %d", __func__, client->irq);
+	rs5c372->has_irq = 1;
+	err = request_irq(client->irq, rs5c372_irq,
+			  IRQF_TRIGGER_FALLING, /*  | IRQF_TRIGGER_RISING */
+			  "RTC R2221 IRQ", client); /* client->dev.driver->name */
+	if (err) {
+		dev_err(&client->dev, "irq %d busy?\n", client->irq);
+		goto exit;
+	}
+#endif
 	rs5c372->rtc = devm_rtc_device_register(&client->dev,
 					rs5c372_driver.driver.name,
 					&rs5c372_rtc_ops, THIS_MODULE);
 
 	if (IS_ERR(rs5c372->rtc)) {
 		err = PTR_ERR(rs5c372->rtc);
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+		goto exit_free_irq;
+#else
 		goto exit;
+#endif
 	}
 
 	err = rs5c_sysfs_register(&client->dev);
 	if (err)
 		goto exit;
 
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+	/* disable periodic intr at startup */
+	rs5c372_enable_periodic_intr(client, 0);
+#endif
+
 	return 0;
 
+#ifdef CONFIG_RTC_DRV_RS5C372_IRQ_SUPPORT
+exit_free_irq:
+	free_irq(client->irq, client);
+#endif
 exit:
 	return err;
 }
diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c
index 904fc9c..3745858 100644
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@ -811,7 +811,8 @@ static void process_echoes(struct tty_struct *tty)
 	echoed = __process_echoes(tty);
 	mutex_unlock(&ldata->output_lock);
 
-	if (echoed && tty->ops->flush_chars)
+	if (echoed && tty->ops->flush_chars
+	    && !test_bit(TTY_IGNORE_FLUSH, &tty->flags))
 		tty->ops->flush_chars(tty);
 }
 
@@ -1224,10 +1225,13 @@ static void n_tty_receive_parity_error(struct tty_struct *tty, unsigned char c)
 {
 	struct n_tty_data *ldata = tty->disc_data;
 
+	n_tty_trace("%d: char 0x%x\n", __LINE__, c);
+
 	if (I_INPCK(tty)) {
 		if (I_IGNPAR(tty))
 			return;
 		if (I_PARMRK(tty)) {
+			n_tty_trace("%d: I_PARMRK: char 0x%x\n", __LINE__, c);
 			put_tty_queue('\377', ldata);
 			put_tty_queue('\0', ldata);
 			put_tty_queue(c, ldata);
@@ -1646,7 +1650,8 @@ static void __receive_buf(struct tty_struct *tty, const unsigned char *cp,
 			n_tty_receive_buf_standard(tty, cp, fp, count);
 
 		flush_echoes(tty);
-		if (tty->ops->flush_chars)
+		if (tty->ops->flush_chars
+		    && !test_bit(TTY_IGNORE_FLUSH, &tty->flags))
 			tty->ops->flush_chars(tty);
 	}
 
@@ -1852,6 +1857,7 @@ static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)
 		clear_bit(__DISABLED_CHAR, ldata->char_map);
 		ldata->raw = 0;
 		ldata->real_raw = 0;
+                n_tty_trace("%d: real_raw = 0\n", __LINE__);
 	} else {
 		ldata->raw = 1;
 		if ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&
@@ -2346,7 +2352,8 @@ static ssize_t n_tty_write(struct tty_struct *tty, struct file *file,
 					break;
 				b++; nr--;
 			}
-			if (tty->ops->flush_chars)
+			if (tty->ops->flush_chars
+			    && !test_bit(TTY_IGNORE_FLUSH, &tty->flags))
 				tty->ops->flush_chars(tty);
 		} else {
 			struct n_tty_data *ldata = tty->disc_data;
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 25c1d7b..cabefbc0 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1128,6 +1128,16 @@ config SERIAL_OMAP
 	  with the omap-serial driver. DMA support can be enabled from platform
 	  data.
 
+config SERIAL_OMAP_RTU
+	tristate "OMAP serial port support (RTU)"
+	depends on ARCH_OMAP2PLUS
+	select SERIAL_CORE
+	help
+         This driver is actually the SERIAL_OMAP driver from kernel 3.6.11
+         which was enhanced by RS485 and Modbus RTU functionallity.
+         Because this driver was tested and is stable this one is used for
+         fieldbus communication.
+
 config SERIAL_OMAP_CONSOLE
 	bool "Console on OMAP serial port"
 	depends on SERIAL_OMAP=y
@@ -1143,6 +1153,13 @@ config SERIAL_OMAP_CONSOLE
 	  your boot loader about how to pass options to the kernel at
 	  boot time.)
 
+config SERIAL_OMAP_MODBUS
+        bool "Modbus RTU support for OMAP"
+        default y
+        help
+          Select this option to enable Modbus RTU support.
+          This will allow a timing-based frame determination and address-based frame filtering.
+
 config SERIAL_LANTIQ
 	bool "Lantiq serial driver"
 	depends on LANTIQ
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 1278d37..db42e74 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -65,6 +65,8 @@ obj-$(CONFIG_SERIAL_NETX) += netx-serial.o
 obj-$(CONFIG_SERIAL_KGDB_NMI) += kgdb_nmi.o
 obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_SERIAL_OMAP) += omap-serial.o
+obj-$(CONFIG_SERIAL_OMAP_MODBUS) += pfc-modbus-rtu.o
+obj-$(CONFIG_SERIAL_OMAP_RTU) += omap-serial-rtu.o
 obj-$(CONFIG_SERIAL_ALTERA_UART) += altera_uart.o
 obj-$(CONFIG_SERIAL_ST_ASC) += st-asc.o
 obj-$(CONFIG_SERIAL_TILEGX) += tilegx.o
diff --git a/drivers/tty/serial/omap-serial-rtu.c b/drivers/tty/serial/omap-serial-rtu.c
new file mode 100644
index 0000000..631e62b
--- /dev/null
+++ b/drivers/tty/serial/omap-serial-rtu.c
@@ -0,0 +1,2111 @@
+/*
+ * Driver for OMAP-UART controller.
+ * Based on drivers/serial/8250.c
+ *
+ * Copyright (C) 2010 Texas Instruments.
+ *
+ * Authors:
+ *	Govindraj R	<govindraj.raja@ti.com>
+ *	Thara Gopinath	<thara@ti.com>
+ *
+ * RS485 support is based on
+ * http://code.google.com/p/meta-igep/source/browse/recipes-kernel/linux/
+ * linux-3.2/rs485/0010-omap-serial-add-RS-485-standard-support.patch
+ * by Javier Martinez Canillas
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Note: This driver is made separate from 8250 driver as we cannot
+ * over load 8250 driver with omap platform specific configuration for
+ * features like DMA, it makes easier to implement features like DMA and
+ * hardware flow control and software flow control configuration with
+ * this driver as required for the omap-platform.
+ */
+#undef DEBUG
+
+#if defined(CONFIG_SERIAL_OMAP_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/console.h>
+//#include <uapi/linux/serial_reg.h>
+#include "serial_reg_rtu.h"
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/serial_core.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+
+//#include <linux/platform_data/serial-omap.h>
+#include <linux/platform_data/pfc-modbus-rtu.h>
+#include "omap-serial-rtu.h"
+
+/* #include <plat/omap-serial.h> */
+/* #include <plat/pfc-modbus-rtu.h> */
+
+#include <linux/wsysinit-boot-table.h>
+
+#define to_uart_omap_port(p)	((container_of((p), struct uart_omap_port, port)))
+
+static struct uart_omap_port *ui[OMAP_MAX_HSUART_PORTS];
+
+/* Forward declaration of functions */
+static void serial_omap_mdr1_errataset(struct uart_omap_port *up, u8 mdr1);
+static inline void serial_omap_enable_ier_thri(struct uart_omap_port *up);
+
+static inline void serial_omap_irq_enable(struct uart_omap_port * up);
+static inline void serial_omap_irq_disable(struct uart_omap_port *up);
+
+static struct workqueue_struct *serial_omap_uart_wq;
+
+extern int __wsysinit_boot_id;
+
+inline void serial_omap_irq_disable(struct uart_omap_port * up)
+{
+	if(up->port.irq != -1)
+		disable_irq(up->port.irq);
+}
+
+inline void serial_omap_irq_enable(struct uart_omap_port * up)
+{
+	if(up->port.irq != -1)
+		enable_irq(up->port.irq);
+
+}
+
+inline unsigned int serial_in_rtu(struct uart_omap_port *up, int offset)
+{
+	offset <<= up->port.regshift;
+	return readw(up->port.membase + offset);
+}
+
+inline void serial_out_rtu(struct uart_omap_port *up, int offset, int value)
+{
+	pr_debug("%s: %s: offset = 0x%08x, value 0x%08x\n",
+		 up->name, __func__, offset, value);
+
+	offset <<= up->port.regshift;
+	writew(value, up->port.membase + offset);
+}
+
+static inline void serial_omap_clear_fifos(struct uart_omap_port *up)
+{
+	serial_out_rtu(up, UART_FCR, UART_FCR_ENABLE_FIFO);
+	serial_out_rtu(up, UART_FCR, UART_FCR_ENABLE_FIFO |
+		       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+	serial_out_rtu(up, UART_FCR, 0);
+}
+
+static int serial_omap_get_context_loss_count(struct uart_omap_port *up)
+{
+	struct omap_uart_port_info *pdata = up->dev->platform_data;
+
+	if (!pdata || !pdata->get_context_loss_count)
+		return 0;
+
+	return pdata->get_context_loss_count(up->dev);
+}
+
+static void serial_omap_set_forceidle(struct uart_omap_port *up)
+{
+	struct omap_uart_port_info *pdata = up->dev->platform_data;
+
+	if (!pdata || !pdata->set_forceidle)
+		return;
+
+	pdata->set_forceidle(up->dev);
+}
+
+static void serial_omap_set_noidle(struct uart_omap_port *up)
+{
+	struct omap_uart_port_info *pdata = up->dev->platform_data;
+
+	if (!pdata || !pdata->set_noidle)
+		return;
+
+	pdata->set_noidle(up->dev);
+}
+
+static void serial_omap_enable_wakeup(struct uart_omap_port *up, bool enable)
+{
+	struct omap_uart_port_info *pdata = up->dev->platform_data;
+
+	if (!pdata || !pdata->enable_wakeup)
+		return;
+
+	pdata->enable_wakeup(up->dev, enable);
+}
+
+/*
+ * serial_omap_baud_is_mode16 - check if baud rate is MODE16X
+ * @port: uart port info
+ * @baud: baudrate for which mode needs to be determined
+ *
+ * Returns true if baud rate is MODE16X and false if MODE13X
+ * Original table in OMAP TRM named "UART Mode Baud Rates, Divisor Values,
+ * and Error Rates" determines modes not for all common baud rates.
+ * E.g. for 1000000 baud rate mode must be 16x, but according to that
+ * table it's determined as 13x.
+ */
+static bool
+serial_omap_baud_is_mode16(struct uart_port *port, unsigned int baud)
+{
+	unsigned int n13 = port->uartclk / (13 * baud);
+	unsigned int n16 = port->uartclk / (16 * baud);
+	int baudAbsDiff13 = baud - (port->uartclk / (13 * n13));
+	int baudAbsDiff16 = baud - (port->uartclk / (16 * n16));
+	if(baudAbsDiff13 < 0)
+		baudAbsDiff13 = -baudAbsDiff13;
+	if(baudAbsDiff16 < 0)
+		baudAbsDiff16 = -baudAbsDiff16;
+
+	return (baudAbsDiff13 > baudAbsDiff16);
+}
+
+#ifdef CONFIG_SERIAL_OMAP_RS485
+static inline int rts_on_send(struct uart_omap_port *up)
+{
+	return up->rs485.flags & SER_RS485_RTS_ON_SEND;
+}
+
+inline void serial_omap_disable_ier_thri(struct uart_omap_port *up)
+{
+	up->ier &= ~UART_IER_THRI;
+	serial_out_rtu(up, UART_IER, up->ier);
+}
+
+/*
++ * Switch transmit interrupt mode (to transmit last data chunk before
++ * end of transmit)
++ */
+static inline void serial_omap_thri_mode(struct uart_omap_port *up)
+{
+	unsigned char scr = serial_in_rtu(up, UART_OMAP_SCR);
+
+	if(up->tx_wait_end)
+                /* wait for remaining data to be sent: interrupt when FIFO empty */
+		scr |= UART_OMAP_SCR_TX_EMPTY_CTL_IT;
+	else
+		/*
+		 * default IRQ mode: interrupt when FIFO not full (reset by filling
+		 * it again)
+		 */
+		scr &= ~UART_OMAP_SCR_TX_EMPTY_CTL_IT;
+
+	serial_out_rtu(up, UART_OMAP_SCR, scr);
+}
+
+/*
+ *  Toggle RTS pin according to configuration settings (RTS high/low on send?)
+ */
+static inline void serial_omap_update_rts(struct uart_omap_port *up)
+{
+	pr_debug("%s: %s: enter\n", up->name, __func__);
+
+	if(up->rs485.flags & SER_RS485_ENABLED) {
+
+		if(up->tx_in_progress) {
+			pr_debug("%s: %s: deassert RTS (~UART_MCR_RTS)\n", up->name, __func__);
+			/* See AM35x docs 14.6.2.10 MCR_REG: 0x0 -> RTS high, 0x1 -> RTS low */
+			up->mcr &= ~UART_MCR_RTS;
+		} else {
+			pr_debug("%s: %s: assert RTS (UART_MCR_RTS)\n", up->name, __func__);
+			up->mcr |= UART_MCR_RTS;
+		}
+
+		serial_out_rtu(up, UART_MCR, up->mcr);
+	}
+}
+
+static void serial_omap_config_rs485(struct uart_omap_port *up, struct serial_rs485 *rs485conf)
+{
+	if (gpio_is_valid(up->rs485en_gpio)) {
+                bool rs485_is_enabled = (up->rs485.flags & SER_RS485_ENABLED);
+		int val;
+
+		/* way from uart_port to tty_port: ugly :( */
+		struct tty_struct *tty = up->port.state->port.tty;
+
+		up->rs485 = *rs485conf;
+
+		val = up->rs485.flags & SER_RS485_ENABLED;
+
+		/*
+		 * WAGO: PARMRK is set by CODESYS when parity is enabled.
+		 * 		This way CODESYS libraries are notified about parity errors.
+		 * 		N_TTY line discipline disables raw connection mode with PARMRK
+		 * 		active and triggers a flush_chars() on each RX operation.
+		 * 		flush_chars() activates TX during a running RX operation, leading
+		 * 		to framing and parity errors (RS485 is half-duplex!)
+		 * 		That's why we deactivate flush_chars() for RS485 mode
+		 */
+
+
+		if(val) { /* Enable RS485 */
+                        if(!rs485_is_enabled)
+                                set_bit(TTY_IGNORE_FLUSH, &tty->flags);
+		} else { /* Enable RS232 */
+			up->tx_in_progress = 0;
+			up->tx_wait_end = 0;
+
+                        if(rs485_is_enabled)
+                                clear_bit(TTY_IGNORE_FLUSH, &tty->flags);
+		}
+
+		gpio_set_value(up->rs485en_gpio, up->rs485en_alow ? !val : val);
+
+		pr_info("%s: %s mode enabled\n", __func__, val ? "rs485" : "rs232");
+	}
+}
+
+#endif
+
+/*
+ * serial_omap_get_divisor - calculate divisor value
+ * @port: uart port info
+ * @baud: baudrate for which divisor needs to be calculated.
+ */
+static unsigned int
+serial_omap_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	unsigned int divisor;
+
+	if (!serial_omap_baud_is_mode16(port, baud))
+		divisor = 13;
+	else
+		divisor = 16;
+	return port->uartclk/(baud * divisor);
+}
+
+static void serial_omap_enable_ms(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	dev_dbg(up->port.dev, "serial_omap_enable_ms+%d\n", up->port.line);
+
+	pm_runtime_get_sync(up->dev);
+	up->ier |= UART_IER_MSI;
+	serial_out_rtu(up, UART_IER, up->ier);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+void serial_omap_stop_tx(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	pm_runtime_get_sync(up->dev);
+
+#ifdef CONFIG_SERIAL_OMAP_RS485
+	if(up->rs485.flags & SER_RS485_ENABLED){
+		up->tx_in_progress = 0;
+		up->tx_wait_end = 1;
+		serial_omap_thri_mode(up);
+		serial_omap_enable_ier_thri(up);
+	} else
+#endif
+	serial_omap_disable_ier_thri(up);
+
+	serial_omap_set_forceidle(up);
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static void serial_omap_stop_rx(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	pm_runtime_get_sync(up->dev);
+	up->ier &= ~UART_IER_RLSI;
+	up->port.read_status_mask &= ~UART_LSR_DR;
+	serial_out_rtu(up, UART_IER, up->ier);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static inline unsigned int __serial_omap_tx_empty(struct uart_omap_port *up){
+	return serial_in_rtu(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+}
+
+#ifdef CONFIG_SERIAL_OMAP_RS485
+// TCe: new
+inline int serial_omap_end_tx(struct uart_omap_port *up)
+{
+	if((up->rs485.flags & SER_RS485_ENABLED) && up->tx_wait_end &&
+	   __serial_omap_tx_empty(up)){
+
+		up->tx_wait_end = 0;
+		up->tx_in_progress = 0;
+
+		if(rts_on_send(up))
+			serial_omap_update_rts(up);
+
+		/* rts change causes a break condition, just remove it */
+		serial_in_rtu(up, UART_RX);
+
+		/* Enable RX interrupt */
+		up->ier = UART_IER_RLSI | UART_IER_RDI;
+		up->port.read_status_mask |= UART_LSR_DR;
+		serial_out_rtu(up, UART_IER, up->ier);
+
+		serial_out_rtu(up, UART_OMAP_SCR, up->scr);
+
+		return 1;
+	}
+
+	return 0;
+}
+#endif
+
+void transmit_chars_rtu(struct uart_omap_port *up, unsigned int lsr)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	int count;
+
+#ifdef CONFIG_SERIAL_OMAP_RS485
+	if(up->rs485.flags & SER_RS485_ENABLED){
+		if(!up->tx_in_progress){
+			up->tx_in_progress = 1;
+
+                        /* Clear LSR (error/status bits, especially Data Ready bit) */
+                        serial_in_rtu(up, UART_LSR);
+
+                        /* Disable RX */
+                        up->ier &= ~(UART_IER_RLSI | UART_IER_RDI);
+                        up->port.read_status_mask &= ~UART_LSR_DR;
+	                serial_out_rtu(up, UART_IER, up->ier);
+
+			if(rts_on_send(up))
+				serial_omap_update_rts(up);
+		}
+
+		if(up->tx_wait_end) {
+			up->tx_wait_end = 0;
+			serial_omap_thri_mode(up);
+			serial_omap_disable_ier_thri(up); /* it gets reenabled below */
+		}
+	}
+#endif
+
+	if (up->port.x_char) {
+		serial_out_rtu(up, UART_TX, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
+		serial_omap_stop_tx(&up->port);
+		return;
+	}
+	count = up->port.fifosize / 4;
+
+	do {
+		serial_out_rtu(up, UART_TX, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		spin_unlock(&up->port.lock);
+		uart_write_wakeup(&up->port);
+		spin_lock(&up->port.lock);
+	}
+
+	if (uart_circ_empty(xmit))
+		serial_omap_stop_tx(&up->port);
+	else
+		serial_omap_start_tx(&up->port);
+}
+
+static inline void serial_omap_enable_ier_thri(struct uart_omap_port *up)
+{
+	if (!(up->ier & UART_IER_THRI)) {
+		up->ier |= UART_IER_THRI;
+		serial_out_rtu(up, UART_IER, up->ier);
+	}
+}
+
+void serial_omap_start_tx(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	pm_runtime_get_sync(up->dev);
+	serial_omap_enable_ier_thri(up);
+	serial_omap_set_noidle(up);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static void serial_omap_throttle(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned long flags;
+
+	pm_runtime_get_sync(up->dev);
+	serial_omap_irq_disable(up);
+	spin_lock_irqsave(&up->port.lock, flags);
+	up->ier &= ~(UART_IER_RLSI | UART_IER_RDI);
+	serial_out_rtu(up, UART_IER, up->ier);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	serial_omap_irq_enable(up);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static void serial_omap_unthrottle(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned long flags;
+
+	pm_runtime_get_sync(up->dev);
+	serial_omap_irq_disable(up);
+	spin_lock_irqsave(&up->port.lock, flags);
+	up->ier |= UART_IER_RLSI | UART_IER_RDI;
+	serial_out_rtu(up, UART_IER, up->ier);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	serial_omap_irq_enable(up);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static unsigned int check_modem_status(struct uart_omap_port *up)
+{
+	unsigned int status;
+
+	status = serial_in_rtu(up, UART_MSR);
+	status |= up->msr_saved_flags;
+	up->msr_saved_flags = 0;
+	if ((status & UART_MSR_ANY_DELTA) == 0)
+		return status;
+
+	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
+	    up->port.state != NULL) {
+		if (status & UART_MSR_TERI)
+			up->port.icount.rng++;
+		if (status & UART_MSR_DDSR)
+			up->port.icount.dsr++;
+		if (status & UART_MSR_DDCD)
+			uart_handle_dcd_change
+				(&up->port, status & UART_MSR_DCD);
+		if (status & UART_MSR_DCTS)
+			uart_handle_cts_change
+				(&up->port, status & UART_MSR_CTS);
+		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+	}
+
+	return status;
+}
+
+#define SET_LSR(val, lsr) ((val) |= ((lsr) << 8))
+#define GET_LSR(val) ((val) >> 8)
+
+#define SET_CH(val, ch) ((val) |= (ch))
+#define GET_CH(val) ((val) & 0xff)
+
+void inline static serial_omap_do_rx(struct uart_omap_port *up, unsigned char ch, unsigned int lsr)
+{
+	unsigned int flag = TTY_NORMAL;
+
+	up->port.icount.rx++;
+
+	if (uart_handle_sysrq_char(&up->port, ch))
+		return;
+
+	uart_insert_char(&up->port, lsr, UART_LSR_OE, ch, flag);
+}
+
+static void serial_omap_rlsi(struct uart_omap_port *up, unsigned int lsr)
+{
+	uint16_t val = 0;
+	unsigned char ch = 0;
+
+	/* clear byte in rx fifo */
+	if (likely(lsr & UART_LSR_DR))
+		ch = serial_in_rtu(up, UART_RX);
+
+	SET_LSR(val, lsr);
+	/* error happened -> ignore ch */
+	kfifo_put(&up->rx_fifo, val);
+	tasklet_hi_schedule(&up->rx_tsklt);
+}
+
+// serial_omap_rlsi() bottom half
+void inline static serial_omap_rx_handle_errors(struct uart_omap_port *up, unsigned int lsr)
+{
+	unsigned int flag = TTY_NORMAL;
+
+	up->port.icount.rx++;
+
+	if (lsr & UART_LSR_BI) {
+		flag = TTY_BREAK;
+		lsr &= ~(UART_LSR_FE | UART_LSR_PE);
+		up->port.icount.brk++;
+		/*
+		 * We do the SysRQ and SAK checking
+		 * here because otherwise the break
+		 * may get masked by ignore_status_mask
+		 * or read_status_mask.
+		 */
+		if (uart_handle_break(&up->port))
+			return;
+
+	}
+
+	if (lsr & UART_LSR_PE) {
+		flag = TTY_PARITY;
+		up->port.icount.parity++;
+	}
+
+	if (lsr & UART_LSR_FE) {
+		flag = TTY_FRAME;
+		up->port.icount.frame++;
+	}
+
+	if (lsr & UART_LSR_OE)
+		up->port.icount.overrun++;
+
+#ifdef CONFIG_SERIAL_OMAP_CONSOLE
+	if (up->port.line == up->port.cons->index) {
+		/* Recover the break flag from console xmit */
+		lsr |= up->lsr_break_flag;
+	}
+#endif
+	uart_insert_char(&up->port, lsr, UART_LSR_OE, 0, flag);
+}
+
+static void serial_omap_rdi(struct uart_omap_port *up, unsigned int lsr)
+{
+	uint16_t val = 0;
+
+	if (!(lsr & UART_LSR_DR))
+		return;
+
+	SET_CH(val, serial_in_rtu(up, UART_RX));
+	SET_LSR(val, lsr);
+
+	kfifo_put(&up->rx_fifo, val);
+
+	tasklet_hi_schedule(&up->rx_tsklt);
+}
+
+/* BUGME: version for PSV was lacking pm calls here! */
+void serial_omap_modem_status_bh(unsigned long dev_id)
+{
+	struct uart_omap_port *up = (void*) dev_id;
+
+	pm_runtime_get_sync(up->dev);
+
+	spin_lock_bh(&up->port.lock);
+	check_modem_status(up);
+	spin_unlock_bh(&up->port.lock);
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+
+}
+
+
+/*
+ * Wrapper to load off transmit_chars into a tasklet. Identical to modbus_omap_transmit()
+ */
+void serial_omap_transmit_bh(unsigned long dev_id)
+{
+	struct uart_omap_port *up = (void*) dev_id;
+
+	pm_runtime_get_sync(up->dev);
+
+	spin_lock(&up->port.lock);
+	transmit_chars_rtu(up, serial_in_rtu(up, UART_LSR));
+	spin_unlock(&up->port.lock);
+
+	serial_omap_set_noidle(up);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+#define UART_LSR_ERROR_MASK (UART_LSR_BI | UART_LSR_FE | UART_LSR_PE |UART_LSR_OE)
+
+void serial_omap_receive_bh(unsigned long dev_id)
+{
+	struct uart_omap_port *up = (void*) dev_id;
+	uint16_t val = 0;
+	unsigned char ch = 0;
+	unsigned int lsr, nr_processed;
+
+	pm_runtime_get_sync(up->dev);
+	spin_lock_bh(&up->port.lock);
+
+	while(!kfifo_is_empty(&up->rx_fifo)) {
+
+		nr_processed = kfifo_get(&up->rx_fifo, &val);
+
+		if((lsr = GET_LSR(val)) & UART_LSR_ERROR_MASK)
+			serial_omap_rx_handle_errors(up, lsr);
+		else
+		{
+			ch = GET_CH(val);
+			/* regular rx; should be last statement in while (because of handle_sysrq) */
+			serial_omap_do_rx(up, ch, lsr);
+		}
+	}
+
+	spin_unlock_bh(&up->port.lock);
+
+	/* stuff from vanilla irq handler that may hold port.lock */
+	tty_flip_buffer_push(&up->port.state->port);
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+/**
+ * serial_omap_irq_rtu() - This handles the interrupt from one port
+ * @irq: uart port irq number
+ * @dev_id: uart port info
+ */
+irqreturn_t serial_omap_irq_rtu(int irq, void *dev_id)
+{
+	struct uart_omap_port *up = dev_id;
+	unsigned int iir, lsr;
+	unsigned int type;
+	irqreturn_t ret = IRQ_NONE;
+	int max_count = 256;
+
+	do {
+		iir = serial_in_rtu(up, UART_IIR);
+		if (iir & UART_IIR_NO_INT)
+			break;
+
+		ret = IRQ_HANDLED;
+		lsr = serial_in_rtu(up, UART_LSR);
+
+		/* extract IRQ type from IIR register */
+		type = iir & 0x3e;
+
+		switch (type) {
+		case UART_IIR_MSI:
+			/*
+			 * This should be safe towards process context functions because
+			 * we don't clear any existing bits, only adding new ones.
+			 */
+			up->msr_saved_flags |= serial_in_rtu(up, UART_MSR);
+			tasklet_hi_schedule(&up->mdm_status_tsklt);
+			break;
+		case UART_IIR_THRI:
+			/*
+			 * THR irq is cleared by writing to TX FIFO in tasklet
+			 * It gets reenabled there
+			 */
+			serial_omap_disable_ier_thri(up);
+
+#ifdef CONFIG_SERIAL_OMAP_RS485
+			if(!serial_omap_end_tx(up))
+				tasklet_hi_schedule(&up->tx_tsklt);
+#else
+			tasklet_hi_schedule(&up->tx_tsklt);
+#endif
+			break;
+		case UART_IIR_RX_TIMEOUT:
+			/* FALLTHROUGH */
+		case UART_IIR_RDI:
+			serial_omap_rdi(up, lsr);
+			break;
+		case UART_IIR_RLSI:
+			serial_omap_rlsi(up, lsr);
+			break;
+		case UART_IIR_CTS_RTS_DSR:
+			/* simply try again */
+			break;
+		case UART_IIR_XOFF:
+			/* FALLTHROUGH */
+		default:
+			break;
+		}
+	} while (!(iir & UART_IIR_NO_INT) && max_count--);
+
+	up->port_activity = jiffies;
+
+	return ret;
+}
+
+static unsigned int serial_omap_tx_empty(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned long flags = 0;
+	unsigned int ret = 0;
+
+	pm_runtime_get_sync(up->dev);
+	dev_dbg(up->port.dev, "serial_omap_tx_empty+%d\n", up->port.line);
+
+	serial_omap_irq_disable(up);
+	spin_lock_irqsave(&up->port.lock, flags);
+	//FIXME: use __serial_omap_tx_empty instead?
+	ret = serial_in_rtu(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	serial_omap_irq_enable(up);
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+	return ret;
+}
+
+static unsigned int serial_omap_get_mctrl(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned int status;
+	unsigned int ret = 0;
+
+	pm_runtime_get_sync(up->dev);
+	status = check_modem_status(up);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+
+	dev_dbg(up->port.dev, "serial_omap_get_mctrl+%d\n", up->port.line);
+
+	if (status & UART_MSR_DCD)
+		ret |= TIOCM_CAR;
+	if (status & UART_MSR_RI)
+		ret |= TIOCM_RNG;
+	if (status & UART_MSR_DSR)
+		ret |= TIOCM_DSR;
+	if (status & UART_MSR_CTS)
+		ret |= TIOCM_CTS;
+	return ret;
+}
+
+static void serial_omap_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned char mcr = 0, old_mcr;
+
+	dev_dbg(up->port.dev, "serial_omap_set_mctrl+%d\n", up->port.line);
+	if (mctrl & TIOCM_RTS)
+		mcr |= UART_MCR_RTS;
+	if (mctrl & TIOCM_DTR)
+		mcr |= UART_MCR_DTR;
+	if (mctrl & TIOCM_OUT1)
+		mcr |= UART_MCR_OUT1;
+	if (mctrl & TIOCM_OUT2)
+		mcr |= UART_MCR_OUT2;
+	if (mctrl & TIOCM_LOOP)
+		mcr |= UART_MCR_LOOP;
+
+	pm_runtime_get_sync(up->dev);
+	old_mcr = serial_in_rtu(up, UART_MCR);
+	old_mcr &= ~(UART_MCR_LOOP | UART_MCR_OUT2 | UART_MCR_OUT1 |
+		     UART_MCR_DTR | UART_MCR_RTS);
+	up->mcr = old_mcr | mcr;
+#ifdef CONFIG_SERIAL_OMAP_RS485
+	if(up->rs485.flags & SER_RS485_ENABLED && rts_on_send(up))
+		serial_omap_update_rts(up);
+#endif
+	serial_out_rtu(up, UART_MCR, up->mcr);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+
+}
+
+static void serial_omap_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned long flags = 0;
+
+	dev_dbg(up->port.dev, "serial_omap_break_ctl+%d\n", up->port.line);
+	pm_runtime_get_sync(up->dev);
+	serial_omap_irq_disable(up);
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (break_state == -1)
+		up->lcr |= UART_LCR_SBC;
+	else
+		up->lcr &= ~UART_LCR_SBC;
+	serial_out_rtu(up, UART_LCR, up->lcr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	serial_omap_irq_enable(up);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static int serial_omap_startup(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned long flags = 0;
+	int retval;
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(up->port.irq, serial_omap_irq_rtu, up->port.irqflags | IRQF_NO_THREAD,
+				up->name, up);
+	if (retval)
+		return retval;
+
+	dev_dbg(up->port.dev, "serial_omap_startup+%d\n", up->port.line);
+
+	pm_runtime_get_sync(up->dev);
+	/*
+	 * Clear the FIFO buffers and disable them.
+	 * (they will be reenabled in set_termios())
+	 */
+	serial_omap_clear_fifos(up);
+	/* For Hardware flow control */
+	serial_out_rtu(up, UART_MCR, UART_MCR_RTS);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) serial_in_rtu(up, UART_LSR);
+	if (serial_in_rtu(up, UART_LSR) & UART_LSR_DR)
+		(void) serial_in_rtu(up, UART_RX);
+	(void) serial_in_rtu(up, UART_IIR);
+	(void) serial_in_rtu(up, UART_MSR);
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_out_rtu(up, UART_LCR, UART_LCR_WLEN8);
+	serial_omap_irq_disable(up);
+	spin_lock_irqsave(&up->port.lock, flags);
+	/*
+	 * Most PC uarts need OUT2 raised to enable interrupts.
+	 */
+	up->port.mctrl |= TIOCM_OUT2;
+	serial_omap_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	serial_omap_irq_enable(up);
+
+	up->msr_saved_flags = 0;
+
+	retval = kfifo_alloc(&up->rx_fifo, 128, 0);
+
+	if(retval) {
+		dev_err(up->dev, "Unable to allocate memory (%d)\n", retval);
+		return retval;
+	}
+
+	tasklet_init(&up->tx_tsklt, serial_omap_transmit_bh, (unsigned long)up);
+	tasklet_init(&up->rx_tsklt, serial_omap_receive_bh, (unsigned long)up);
+	tasklet_init(&up->mdm_status_tsklt, serial_omap_modem_status_bh, (unsigned long)up);
+
+	/*
+	 * Finally, enable interrupts. Note: Modem status interrupts
+	 * are set via set_termios(), which will be occurring imminently
+	 * anyway, so we don't enable them here.
+	 */
+	up->ier = UART_IER_RLSI | UART_IER_RDI;
+	serial_out_rtu(up, UART_IER, up->ier);
+
+	/* Enable module level wake up */
+	serial_out_rtu(up, UART_OMAP_WER, OMAP_UART_WER_MOD_WKUP);
+
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+	modbus_omap_startup(up);
+#endif
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+	up->port_activity = jiffies;
+
+	return 0;
+}
+
+static void serial_omap_shutdown(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned long flags = 0;
+
+	dev_dbg(up->port.dev, "serial_omap_shutdown+%d\n", up->port.line);
+
+	pm_runtime_get_sync(up->dev);
+
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+	modbus_omap_shutdown(up);
+#endif
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	up->ier = 0;
+	serial_out_rtu(up, UART_IER, 0);
+
+	serial_omap_irq_disable(up);
+	spin_lock_irqsave(&up->port.lock, flags);
+	up->port.mctrl &= ~TIOCM_OUT2;
+	serial_omap_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+	serial_omap_irq_enable(up);
+
+	/*
+	 * Disable break condition and FIFOs
+	 */
+	serial_out_rtu(up, UART_LCR, serial_in_rtu(up, UART_LCR) & ~UART_LCR_SBC);
+	serial_omap_clear_fifos(up);
+
+	/*
+	 * Read data port to reset things, and then free the irq
+	 */
+	if (serial_in_rtu(up, UART_LSR) & UART_LSR_DR)
+		(void) serial_in_rtu(up, UART_RX);
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+	free_irq(up->port.irq, up);
+
+	up->tx_in_progress = 0;
+	up->tx_wait_end = 0;
+
+	tasklet_kill(&up->tx_tsklt);
+	tasklet_kill(&up->rx_tsklt);
+	tasklet_kill(&up->mdm_status_tsklt);
+	kfifo_free(&up->rx_fifo);
+}
+
+static void serial_omap_uart_qos_work(struct work_struct *work)
+{
+	struct uart_omap_port *up = container_of(work, struct uart_omap_port,
+						qos_work);
+
+	pm_qos_update_request(&up->pm_qos_request, up->latency);
+}
+
+static void
+serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
+			struct ktermios *old)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned char cval = 0;
+	unsigned int baud, quot;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		cval = UART_LCR_WLEN5;
+		break;
+	case CS6:
+		cval = UART_LCR_WLEN6;
+		break;
+	case CS7:
+		cval = UART_LCR_WLEN7;
+		break;
+	default:
+	case CS8:
+		cval = UART_LCR_WLEN8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		cval |= UART_LCR_STOP;
+	if (termios->c_cflag & PARENB)
+		cval |= UART_LCR_PARITY;
+	if (!(termios->c_cflag & PARODD))
+		cval |= UART_LCR_EPAR;
+	if (termios->c_cflag & CMSPAR)
+		cval |= UART_LCR_SPAR;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/13);
+	quot = serial_omap_get_divisor(port, baud);
+
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+	modbus_omap_calc_to(up, baud);
+#endif
+
+	/* calculate wakeup latency constraint */
+	up->calc_latency = (USEC_PER_SEC * up->port.fifosize) / (baud / 8);
+	up->latency = up->calc_latency;
+	schedule_work(&up->qos_work);
+
+	up->dll = quot & 0xff;
+	up->dlh = quot >> 8;
+	up->mdr1 = UART_OMAP_MDR1_DISABLE;
+
+	up->fcr = UART_FCR_R_TRIG_01 | UART_FCR_T_TRIG_01 |
+			UART_FCR_ENABLE_FIFO;
+
+	/*
+	 * Ok, we're now changing the port state. Do it with
+	 * interrupts disabled.
+	 */
+	pm_runtime_get_sync(up->dev);
+	serial_omap_irq_disable(up);
+	spin_lock(&up->port.lock);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	up->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= UART_LSR_BI;
+
+	/*
+	 * Characters to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= UART_LSR_OE;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= UART_LSR_DR;
+
+	/*
+	 * Modem status interrupts
+	 */
+	up->ier &= ~UART_IER_MSI;
+	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
+		up->ier |= UART_IER_MSI;
+	serial_out_rtu(up, UART_IER, up->ier);
+	serial_out_rtu(up, UART_LCR, cval);		/* reset DLAB */
+	up->lcr = cval;
+	up->scr = 0;
+
+	/* FIFOs and DMA Settings */
+
+	/* FCR can be changed only when the
+	 * baud clock is not running
+	 * DLL_REG and DLH_REG set to 0.
+	 */
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_A);
+	serial_out_rtu(up, UART_DLL, 0);
+	serial_out_rtu(up, UART_DLM, 0);
+	serial_out_rtu(up, UART_LCR, 0);
+
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+
+	up->efr = serial_in_rtu(up, UART_EFR) & ~UART_EFR_ECB;
+	up->efr &= ~UART_EFR_SCD;
+	serial_out_rtu(up, UART_EFR, up->efr | UART_EFR_ECB);
+
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_A);
+	up->mcr = serial_in_rtu(up, UART_MCR) & ~UART_MCR_TCRTLR;
+	serial_out_rtu(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);
+	/* FIFO ENABLE, DMA MODE */
+
+	up->scr |= OMAP_UART_SCR_RX_TRIG_GRANU1_MASK;
+	/*
+	 * NOTE: Setting OMAP_UART_SCR_RX_TRIG_GRANU1_MASK
+	 * sets Enables the granularity of 1 for TRIGGER RX
+	 * level. Along with setting RX FIFO trigger level
+	 * to 1 (as noted below, 16 characters) and TLR[3:0]
+	 * to zero this will result RX FIFO threshold level
+	 * to 1 character, instead of 16 as noted in comment
+	 * below.
+	 */
+
+	/* Set receive FIFO threshold to 16 characters and
+	 * transmit FIFO threshold to 16 spaces
+	 */
+	up->fcr &= ~OMAP_UART_FCR_RX_FIFO_TRIG_MASK;
+	up->fcr &= ~OMAP_UART_FCR_TX_FIFO_TRIG_MASK;
+	up->fcr |= UART_FCR6_R_TRIGGER_16 | UART_FCR6_T_TRIGGER_24 |
+		UART_FCR_ENABLE_FIFO;
+
+	serial_out_rtu(up, UART_FCR, up->fcr);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+
+	serial_out_rtu(up, UART_OMAP_SCR, up->scr);
+
+	/* Reset UART_MCR00CRTLR: this must be done with the EFR_ECB bit set */
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_A);
+	serial_out_rtu(up, UART_MCR, up->mcr);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+	serial_out_rtu(up, UART_EFR, up->efr);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_A);
+
+	/* Protocol, Baud Rate, and Interrupt Settings */
+
+	if (up->errata & UART_ERRATA_i202_MDR1_ACCESS)
+		serial_omap_mdr1_errataset(up, up->mdr1);
+	else
+		serial_out_rtu(up, UART_OMAP_MDR1, up->mdr1);
+
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+	serial_out_rtu(up, UART_EFR, up->efr | UART_EFR_ECB);
+
+	serial_out_rtu(up, UART_LCR, 0);
+	serial_out_rtu(up, UART_IER, 0);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+
+	serial_out_rtu(up, UART_DLL, up->dll);	/* LS of divisor */
+	serial_out_rtu(up, UART_DLM, up->dlh);	/* MS of divisor */
+
+	serial_out_rtu(up, UART_LCR, 0);
+	serial_out_rtu(up, UART_IER, up->ier);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+
+	serial_out_rtu(up, UART_EFR, up->efr);
+	serial_out_rtu(up, UART_LCR, cval);
+
+	if (!serial_omap_baud_is_mode16(port, baud))
+		up->mdr1 = UART_OMAP_MDR1_13X_MODE;
+	else
+		up->mdr1 = UART_OMAP_MDR1_16X_MODE;
+
+	if (up->errata & UART_ERRATA_i202_MDR1_ACCESS)
+		serial_omap_mdr1_errataset(up, up->mdr1);
+	else
+		serial_out_rtu(up, UART_OMAP_MDR1, up->mdr1);
+
+	/* Configure flow control */
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+
+	/* XON1/XOFF1 accessible mode B, TCRTLR=0, ECB=0 */
+	serial_out_rtu(up, UART_XON1, termios->c_cc[VSTART]);
+	serial_out_rtu(up, UART_XOFF1, termios->c_cc[VSTOP]);
+
+	/* Enable access to TCR/TLR */
+	serial_out_rtu(up, UART_EFR, up->efr | UART_EFR_ECB);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_A);
+	serial_out_rtu(up, UART_MCR, up->mcr | UART_MCR_TCRTLR);
+
+	serial_out_rtu(up, UART_TI752_TCR, OMAP_UART_TCR_TRIG);
+
+	if (termios->c_cflag & CRTSCTS && up->port.flags & UPF_HARD_FLOW) {
+		/* Enable AUTORTS and AUTOCTS */
+		up->efr |= UART_EFR_CTS | UART_EFR_RTS;
+
+		/* Ensure MCR RTS is asserted */
+		up->mcr |= UART_MCR_RTS;
+	} else {
+		/* Disable AUTORTS and AUTOCTS */
+		up->efr &= ~(UART_EFR_CTS | UART_EFR_RTS);
+	}
+
+	if (up->port.flags & UPF_SOFT_FLOW) {
+		/* clear SW control mode bits */
+		up->efr &= OMAP_UART_SW_CLR;
+
+		/*
+		 * IXON Flag:
+		 * Enable XON/XOFF flow control on input.
+		 * Receiver compares XON1, XOFF1.
+		 */
+		if (termios->c_iflag & IXON)
+			up->efr |= OMAP_UART_SW_RX;
+
+		/*
+		 * IXOFF Flag:
+		 * Enable XON/XOFF flow control on output.
+		 * Transmit XON1, XOFF1
+		 */
+		if (termios->c_iflag & IXOFF)
+			up->efr |= OMAP_UART_SW_TX;
+
+		/*
+		 * IXANY Flag:
+		 * Enable any character to restart output.
+		 * Operation resumes after receiving any
+		 * character after recognition of the XOFF character
+		 */
+		if (termios->c_iflag & IXANY)
+			up->mcr |= UART_MCR_XONANY;
+		else
+			up->mcr &= ~UART_MCR_XONANY;
+	}
+	serial_out_rtu(up, UART_MCR, up->mcr);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+	serial_out_rtu(up, UART_EFR, up->efr);
+	serial_out_rtu(up, UART_LCR, up->lcr);
+
+	serial_omap_set_mctrl(&up->port, up->port.mctrl);
+
+	spin_unlock(&up->port.lock);
+	serial_omap_irq_enable(up);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+	dev_dbg(up->port.dev, "serial_omap_set_termios+%d\n", up->port.line);
+}
+
+/* static int serial_omap_set_wake(struct uart_port *port, unsigned int state) */
+/* { */
+/* 	struct uart_omap_port *up = to_uart_omap_port(port); */
+
+/* 	serial_omap_enable_wakeup(up, state); */
+
+/* 	return 0; */
+/* } */
+
+static void
+serial_omap_pm(struct uart_port *port, unsigned int state,
+	       unsigned int oldstate)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned char efr;
+
+	dev_dbg(up->port.dev, "serial_omap_pm+%d\n", up->port.line);
+
+	pm_runtime_get_sync(up->dev);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+	efr = serial_in_rtu(up, UART_EFR);
+	serial_out_rtu(up, UART_EFR, efr | UART_EFR_ECB);
+	serial_out_rtu(up, UART_LCR, 0);
+
+	serial_out_rtu(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B);
+	serial_out_rtu(up, UART_EFR, efr);
+	serial_out_rtu(up, UART_LCR, 0);
+
+	if (!device_may_wakeup(up->dev)) {
+		if (!state)
+			pm_runtime_forbid(up->dev);
+		else
+			pm_runtime_allow(up->dev);
+	}
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static void serial_omap_release_port(struct uart_port *port)
+{
+	dev_dbg(port->dev, "serial_omap_release_port+\n");
+}
+
+static int serial_omap_request_port(struct uart_port *port)
+{
+	dev_dbg(port->dev, "serial_omap_request_port+\n");
+	return 0;
+}
+
+static void serial_omap_config_port(struct uart_port *port, int flags)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	dev_dbg(up->port.dev, "serial_omap_config_port+%d\n",
+							up->port.line);
+	up->port.type = PORT_OMAP;
+	up->port.flags |= UPF_SOFT_FLOW | UPF_HARD_FLOW;
+}
+
+static int
+serial_omap_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	/* we don't want the core code to modify any port params */
+	dev_dbg(port->dev, "serial_omap_verify_port+\n");
+	return -EINVAL;
+}
+
+static const char *
+serial_omap_type(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	dev_dbg(up->port.dev, "serial_omap_type+%d\n", up->port.line);
+	return up->name;
+}
+
+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
+
+static inline void wait_for_xmitr(struct uart_omap_port *up)
+{
+	unsigned int status, tmout = 10000;
+
+	/* Wait up to 10ms for the character(s) to be sent. */
+	do {
+		status = serial_in_rtu(up, UART_LSR);
+
+		if (status & UART_LSR_BI)
+			up->lsr_break_flag = UART_LSR_BI;
+
+		if (--tmout == 0)
+			break;
+		udelay(1);
+	} while ((status & BOTH_EMPTY) != BOTH_EMPTY);
+
+	/* Wait up to 1s for flow control if necessary */
+	if (up->port.flags & UPF_CONS_FLOW) {
+		tmout = 1000000;
+		for (tmout = 1000000; tmout; tmout--) {
+			unsigned int msr = serial_in_rtu(up, UART_MSR);
+
+			up->msr_saved_flags |= msr & MSR_SAVE_FLAGS;
+			if (msr & UART_MSR_CTS)
+				break;
+
+			udelay(1);
+		}
+	}
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+
+static void serial_omap_poll_put_char(struct uart_port *port, unsigned char ch)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	pm_runtime_get_sync(up->dev);
+	wait_for_xmitr(up);
+	serial_out_rtu(up, UART_TX, ch);
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+static int serial_omap_poll_get_char(struct uart_port *port)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+	unsigned int status;
+
+	pm_runtime_get_sync(up->dev);
+	status = serial_in_rtu(up, UART_LSR);
+	if (!(status & UART_LSR_DR)) {
+		status = NO_POLL_CHAR;
+		goto out;
+	}
+
+	status = serial_in_rtu(up, UART_RX);
+
+out:
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+
+	return status;
+}
+
+#endif /* CONFIG_CONSOLE_POLL */
+
+#ifdef CONFIG_SERIAL_OMAP_CONSOLE
+
+static struct uart_omap_port *serial_omap_console_ports[OMAP_MAX_HSUART_PORTS];
+
+static struct uart_driver serial_omap_reg;
+
+static void serial_omap_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_omap_port *up = to_uart_omap_port(port);
+
+	wait_for_xmitr(up);
+	serial_out_rtu(up, UART_TX, ch);
+}
+
+static void
+serial_omap_console_write(struct console *co, const char *s,
+		unsigned int count)
+{
+	struct uart_omap_port *up = serial_omap_console_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+	int locked = 1;
+
+	pm_runtime_get_sync(up->dev);
+
+	serial_omap_irq_disable(up);
+	if (up->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock_irqsave(&up->port.lock, flags);
+	else
+		spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * First save the IER then disable the interrupts
+	 */
+	ier = serial_in_rtu(up, UART_IER);
+	serial_out_rtu(up, UART_IER, 0);
+
+	uart_console_write(&up->port, s, count, serial_omap_console_putchar);
+
+	/*
+	 * Finally, wait for transmitter to become empty
+	 * and restore the IER
+	 */
+	wait_for_xmitr(up);
+	serial_out_rtu(up, UART_IER, ier);
+	/*
+	 * The receive handling will happen properly because the
+	 * receive ready bit will still be set; it is not cleared
+	 * on read.  However, modem control will not, we must
+	 * call it if we have saved something in the saved flags
+	 * while processing with interrupts off.
+	 */
+	if (up->msr_saved_flags)
+		check_modem_status(up);
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+	if (locked)
+		spin_unlock_irqrestore(&up->port.lock, flags);
+
+	serial_omap_irq_enable(up);
+}
+
+#ifdef CONFIG_SERIAL_OMAP_RS485
+static int
+serial_omap_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *) port;
+	struct serial_rs485 rs485conf;
+	unsigned long flags;
+
+	switch(cmd) {
+	case TIOCSRS485:
+		if(copy_from_user(&rs485conf, (struct serial_rs485*) arg, sizeof(rs485conf)))
+			return -EFAULT;
+
+		serial_omap_irq_disable(up);
+		spin_lock_irqsave(&up->port.lock, flags);
+
+		serial_omap_config_rs485(up, &rs485conf);
+
+		if(rts_on_send(up))
+			serial_omap_update_rts(up);
+		serial_omap_thri_mode(up);
+
+		spin_unlock_irqrestore(&up->port.lock, flags);
+		serial_omap_irq_enable(up);
+
+		break;
+
+	case TIOCGRS485:
+		if(copy_to_user((struct serial_rs485 *) arg, &(up->rs485), sizeof(rs485conf)))
+			return -EFAULT;
+		break;
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+	case TIOCSMBRTU:
+		switch(arg)
+		{
+		case 0:
+			modbus_omap_disable(up);
+			break;
+		case 1:
+			modbus_omap_enable(up);
+			break;
+		default: break;
+		}
+		break;
+	case TIOCSMBRTUADDR:
+		dev_info(up->dev, "Setting slave ID to %lu", arg);
+		up->mb_port.slave_id = arg;
+		break;
+	case TIOCSMBRTUIFT:
+		dev_info(up->dev, "Setting interframe timeout to %luns %s",
+		         arg, arg ? "" : "(auto)");
+		up->mb_port.to_35_override = arg;
+		break;
+	case TIOCSMBRTUICT:
+		dev_info(up->dev, "Setting intercharacter timeout to %luns %s",
+		         arg, arg ? "" : "(auto)");
+		up->mb_port.to_15_override = arg;
+		break;
+	case TIOCSMBRTUTS:
+		switch(arg)
+		{
+		case 0:
+			modbus_omap_timestamp_disable(up);
+			break;
+		case 1:
+			modbus_omap_timestamp_enable(up);
+			break;
+		default: break;
+		}
+	break;
+#endif
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+#endif
+
+static int __init
+serial_omap_console_setup(struct console *co, char *options)
+{
+	struct uart_omap_port *up;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (serial_omap_console_ports[co->index] == NULL)
+		return -ENODEV;
+	up = serial_omap_console_ports[co->index];
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&up->port, co, baud, parity, bits, flow);
+}
+
+static struct console serial_omap_console = {
+	.name		= OMAP_SERIAL_NAME,
+	.write		= serial_omap_console_write,
+	.device		= uart_console_device,
+	.setup		= serial_omap_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &serial_omap_reg,
+};
+
+static void serial_omap_add_console_port(struct uart_omap_port *up)
+{
+	serial_omap_console_ports[up->port.line] = up;
+}
+
+#define OMAP_CONSOLE	(&serial_omap_console)
+
+#else
+
+#define OMAP_CONSOLE	NULL
+
+static inline void serial_omap_add_console_port(struct uart_omap_port *up)
+{}
+
+#endif
+
+static struct uart_ops serial_omap_pops = {
+	.tx_empty	= serial_omap_tx_empty,
+	.set_mctrl	= serial_omap_set_mctrl,
+	.get_mctrl	= serial_omap_get_mctrl,
+	.stop_tx	= serial_omap_stop_tx,
+	.start_tx	= serial_omap_start_tx,
+	.throttle	= serial_omap_throttle,
+	.unthrottle	= serial_omap_unthrottle,
+	.stop_rx	= serial_omap_stop_rx,
+	.enable_ms	= serial_omap_enable_ms,
+	.break_ctl	= serial_omap_break_ctl,
+	.startup	= serial_omap_startup,
+	.shutdown	= serial_omap_shutdown,
+	.set_termios	= serial_omap_set_termios,
+	.pm		= serial_omap_pm,
+	//	.set_wake	= serial_omap_set_wake,
+	.type		= serial_omap_type,
+	.release_port	= serial_omap_release_port,
+	.request_port	= serial_omap_request_port,
+	.config_port	= serial_omap_config_port,
+	.verify_port	= serial_omap_verify_port,
+#ifdef CONFIG_SERIAL_OMAP_RS485
+	.ioctl = serial_omap_ioctl,
+#endif
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_put_char  = serial_omap_poll_put_char,
+	.poll_get_char  = serial_omap_poll_get_char,
+#endif
+};
+
+static struct uart_driver serial_omap_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "OMAP-SERIAL-RTU",
+	.dev_name	= OMAP_SERIAL_NAME,
+	.nr		= OMAP_MAX_HSUART_PORTS,
+	.cons		= OMAP_CONSOLE,
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int serial_omap_suspend(struct device *dev)
+{
+	struct uart_omap_port *up = dev_get_drvdata(dev);
+
+	uart_suspend_port(&serial_omap_reg, &up->port);
+	flush_work(&up->qos_work);
+
+	return 0;
+}
+
+static int serial_omap_resume(struct device *dev)
+{
+	struct uart_omap_port *up = dev_get_drvdata(dev);
+
+	uart_resume_port(&serial_omap_reg, &up->port);
+
+	return 0;
+}
+#endif
+
+static void omap_serial_fill_features_erratas(struct uart_omap_port *up)
+{
+	u32 mvr, scheme;
+	u16 revision, major, minor;
+
+	mvr = serial_in_rtu(up, UART_OMAP_MVER);
+
+	/* Check revision register scheme */
+	scheme = mvr >> OMAP_UART_MVR_SCHEME_SHIFT;
+
+	switch (scheme) {
+	case 0: /* Legacy Scheme: OMAP2/3 */
+		/* MINOR_REV[0:4], MAJOR_REV[4:7] */
+		major = (mvr & OMAP_UART_LEGACY_MVR_MAJ_MASK) >>
+					OMAP_UART_LEGACY_MVR_MAJ_SHIFT;
+		minor = (mvr & OMAP_UART_LEGACY_MVR_MIN_MASK);
+		break;
+	case 1:
+		/* New Scheme: OMAP4+ */
+		/* MINOR_REV[0:5], MAJOR_REV[8:10] */
+		major = (mvr & OMAP_UART_MVR_MAJ_MASK) >>
+					OMAP_UART_MVR_MAJ_SHIFT;
+		minor = (mvr & OMAP_UART_MVR_MIN_MASK);
+		break;
+	default:
+		dev_warn(up->dev,
+			"Unknown %s revision, defaulting to highest\n",
+			up->name);
+		/* highest possible revision */
+		major = 0xff;
+		minor = 0xff;
+	}
+
+	/* normalize revision for the driver */
+	revision = UART_BUILD_REVISION(major, minor);
+
+	switch (revision) {
+	case OMAP_UART_REV_46:
+		up->errata |= (UART_ERRATA_i202_MDR1_ACCESS |
+				UART_ERRATA_i291_DMA_FORCEIDLE);
+		break;
+	case OMAP_UART_REV_52:
+		up->errata |= (UART_ERRATA_i202_MDR1_ACCESS |
+				UART_ERRATA_i291_DMA_FORCEIDLE);
+		break;
+	case OMAP_UART_REV_63:
+		up->errata |= UART_ERRATA_i202_MDR1_ACCESS;
+		break;
+	default:
+		break;
+	}
+}
+
+static struct omap_uart_port_info *of_get_uart_port_info(struct device *dev)
+{
+	struct omap_uart_port_info *omap_up_info;
+
+	omap_up_info = devm_kzalloc(dev, sizeof(*omap_up_info), GFP_KERNEL);
+	if (!omap_up_info)
+		return NULL; /* out of memory */
+
+	of_property_read_u32(dev->of_node, "clock-frequency",
+					 &omap_up_info->uartclk);
+	return omap_up_info;
+}
+
+static int of_probe_rs485(struct uart_omap_port *up,
+			  struct device_node *np)
+{
+	struct serial_rs485 *rs485conf = &up->rs485;
+	u32 rs485_delay[2];
+	enum of_gpio_flags flags;
+	int ret;
+
+	rs485conf->flags = 0;
+	up->rts_gpio = -EINVAL;
+
+	if (!np)
+		return 0;
+
+	if (of_property_read_bool(np, "rs485-rts-active-high"))
+		rs485conf->flags |= SER_RS485_RTS_ON_SEND;
+	else
+		rs485conf->flags |= SER_RS485_RTS_AFTER_SEND;
+
+#if 0				/* we have no rts_gpio, we toggle rts by register */
+	/* check for tx enable gpio */
+	up->rts_gpio = of_get_named_gpio_flags(np, "rts-gpio", 0, &flags);
+	if (gpio_is_valid(up->rts_gpio)) {
+		ret = devm_gpio_request(up->dev, up->rts_gpio, "omap-serial-rtu");
+		if (ret < 0)
+			return ret;
+		ret = gpio_direction_output(up->rts_gpio,
+				rs485conf->flags & SER_RS485_RTS_AFTER_SEND);
+		if (ret < 0)
+			return ret;
+	} else if (up->rts_gpio == -EPROBE_DEFER) {
+		return -EPROBE_DEFER;
+	} else {
+		up->rts_gpio = -EINVAL;
+	}
+#endif
+
+	/* check for tx enable gpio */
+	up->rs485en_gpio = of_get_named_gpio_flags(np, "rs485en-gpio", 0, &flags);
+	if (gpio_is_valid(up->rs485en_gpio)) {
+		ret = gpio_request(up->rs485en_gpio, "omap-serial-rtu-rs485en");
+		if (ret < 0)
+			return ret;
+	} else if (up->rs485en_gpio == -EPROBE_DEFER) {
+#if 0
+		devm_gpio_free(up->dev, up->rts_gpio);
+#endif
+		return -EPROBE_DEFER;
+	} else {
+		up->rs485en_gpio = -EINVAL;
+	}
+
+	/*
+	 * This is only used in newer omap-serial driver
+	 * but keep it here ...
+	 */
+	if (of_property_read_u32_array(np, "rs485-rts-delay",
+				rs485_delay, 2) == 0) {
+		rs485conf->delay_rts_before_send = rs485_delay[0];
+		rs485conf->delay_rts_after_send = rs485_delay[1];
+	}
+
+	if (of_property_read_bool(np, "rs485-rx-during-tx"))
+		rs485conf->flags |= SER_RS485_RX_DURING_TX;
+
+	if (of_property_read_bool(np, "linux,rs485-enabled-at-boot-time") || (!(__wsysinit_boot_id & WSYSINIT_BOOT_UART)
+				&& !(__wsysinit_boot_id & WSYSINIT_BOOT_OVERWRITE)))
+		rs485conf->flags |= SER_RS485_ENABLED;
+
+	if (gpio_is_valid(up->rs485en_gpio)) {
+		int val = rs485conf->flags & SER_RS485_ENABLED;
+
+		up->rs485en_alow = flags & OF_GPIO_ACTIVE_LOW;
+
+		pr_info("%s: rs485en-gpio is %s\n", __func__,
+				up->rs485en_alow ? "active_low" : "active_high");
+
+		/* turn on or off rs485 hw path */
+		ret = gpio_direction_output(up->rs485en_gpio, up->rs485en_alow ? !val : val);
+		if (ret < 0)
+			return ret;
+
+		pr_info("%s: %s mode enabled\n", __func__, val ? "rs485" : "rs232");
+	}
+
+	return 0;
+}
+
+static int serial_omap_probe(struct platform_device *pdev)
+{
+	struct uart_omap_port	*up;
+	struct resource		*mem;
+	struct omap_uart_port_info *omap_up_info = pdev->dev.platform_data;
+	int uartirq = 0;
+	int ret;
+
+	if (pdev->dev.of_node) {
+		uartirq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+		if (!uartirq)
+			return -EPROBE_DEFER;
+
+		omap_up_info = of_get_uart_port_info(&pdev->dev);
+	} else {
+		uartirq = platform_get_irq(pdev, 0);
+		if (uartirq < 0)
+			return -EPROBE_DEFER;
+	}
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -ENODEV;
+	}
+
+	if (!devm_request_mem_region(&pdev->dev, mem->start, resource_size(mem),
+				pdev->dev.driver->name)) {
+		dev_err(&pdev->dev, "memory region already claimed\n");
+		return -EBUSY;
+	}
+
+	up = devm_kzalloc(&pdev->dev, sizeof(*up), GFP_KERNEL);
+	if (!up)
+		return -ENOMEM;
+
+	if (pdev->dev.of_node) {
+		ret = of_probe_rs485(up, pdev->dev.of_node);
+		if (ret == -EPROBE_DEFER) {
+			devm_kfree(&pdev->dev, up);
+			return -EPROBE_DEFER;
+		}
+	}
+
+	up->dev = &pdev->dev;
+	up->port.dev = &pdev->dev;
+	up->port.type = PORT_OMAP;
+	up->port.iotype = UPIO_MEM;
+	up->port.irq = uartirq;
+
+	up->port.regshift = 2;
+	up->port.fifosize = 64;
+	up->port.ops = &serial_omap_pops;
+
+	if (pdev->dev.of_node)
+		up->port.line = of_alias_get_id(pdev->dev.of_node, "serial");
+	else
+		up->port.line = pdev->id;
+
+	if (up->port.line < 0) {
+		dev_err(&pdev->dev, "failed to get alias/pdev id, errno %d\n",
+								up->port.line);
+		ret = -ENODEV;
+		goto err_port_line;
+	}
+
+	up->pins = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(up->pins)) {
+		dev_warn(&pdev->dev, "did not get pins for uart%i error: %li\n",
+			 up->port.line, PTR_ERR(up->pins));
+		up->pins = NULL;
+	}
+
+	sprintf(up->name, "OMAP UART%d HWIRQ", up->port.line);
+	up->port.mapbase = mem->start;
+	up->port.membase = devm_ioremap(&pdev->dev, mem->start,
+						resource_size(mem));
+	if (!up->port.membase) {
+		dev_err(&pdev->dev, "can't ioremap UART\n");
+		ret = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	up->port.flags = omap_up_info->flags;
+	up->port.uartclk = omap_up_info->uartclk;
+	if (!up->port.uartclk) {
+		up->port.uartclk = DEFAULT_CLK_SPEED;
+		dev_warn(&pdev->dev, "No clock speed specified: using default:"
+						"%d\n", DEFAULT_CLK_SPEED);
+	}
+
+	up->latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;
+	up->calc_latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;
+	pm_qos_add_request(&up->pm_qos_request,
+		PM_QOS_CPU_DMA_LATENCY, up->latency);
+	serial_omap_uart_wq = create_singlethread_workqueue(up->name);
+	INIT_WORK(&up->qos_work, serial_omap_uart_qos_work);
+
+	platform_set_drvdata(pdev, up);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev,
+			omap_up_info->autosuspend_timeout);
+
+	pm_runtime_irq_safe(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+
+	omap_serial_fill_features_erratas(up);
+
+	ui[up->port.line] = up;
+	serial_omap_add_console_port(up);
+
+	ret = uart_add_one_port(&serial_omap_reg, &up->port);
+	if (ret != 0)
+		goto err_add_port;
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+
+	return 0;
+
+err_add_port:
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+err_ioremap:
+err_port_line:
+	dev_err(&pdev->dev, "[UART%d]: failure [%s]: %d\n",
+				pdev->id, __func__, ret);
+	return ret;
+}
+
+static int serial_omap_remove(struct platform_device *dev)
+{
+	struct uart_omap_port *up = platform_get_drvdata(dev);
+
+	pm_runtime_put_sync(up->dev);
+	pm_runtime_disable(up->dev);
+	uart_remove_one_port(&serial_omap_reg, &up->port);
+	pm_qos_remove_request(&up->pm_qos_request);
+
+	return 0;
+}
+
+/*
+ * Work Around for Errata i202 (2430, 3430, 3630, 4430 and 4460)
+ * The access to uart register after MDR1 Access
+ * causes UART to corrupt data.
+ *
+ * Need a delay =
+ * 5 L4 clock cycles + 5 UART functional clock cycle (@48MHz = ~0.2uS)
+ * give 10 times as much
+ */
+static void serial_omap_mdr1_errataset(struct uart_omap_port *up, u8 mdr1)
+{
+	u8 timeout = 255;
+
+	serial_out_rtu(up, UART_OMAP_MDR1, mdr1);
+	udelay(2);
+	serial_out_rtu(up, UART_FCR, up->fcr | UART_FCR_CLEAR_XMIT |
+			UART_FCR_CLEAR_RCVR);
+	/*
+	 * Wait for FIFO to empty: when empty, RX_FIFO_E bit is 0 and
+	 * TX_FIFO_E bit is 1.
+	 */
+	while (UART_LSR_THRE != (serial_in_rtu(up, UART_LSR) &
+				(UART_LSR_THRE | UART_LSR_DR))) {
+		timeout--;
+		if (!timeout) {
+			/* Should *never* happen. we warn and carry on */
+			dev_crit(up->dev, "Errata i202: timedout %x\n",
+						serial_in_rtu(up, UART_LSR));
+			break;
+		}
+		udelay(1);
+	}
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static void serial_omap_restore_context(struct uart_omap_port *up)
+{
+	if (up->errata & UART_ERRATA_i202_MDR1_ACCESS)
+		serial_omap_mdr1_errataset(up, UART_OMAP_MDR1_DISABLE);
+	else
+		serial_out_rtu(up, UART_OMAP_MDR1, UART_OMAP_MDR1_DISABLE);
+
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B); /* Config B mode */
+	serial_out_rtu(up, UART_EFR, UART_EFR_ECB);
+	serial_out_rtu(up, UART_LCR, 0x0); /* Operational mode */
+	serial_out_rtu(up, UART_IER, 0x0);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B); /* Config B mode */
+	serial_out_rtu(up, UART_DLL, up->dll);
+	serial_out_rtu(up, UART_DLM, up->dlh);
+	serial_out_rtu(up, UART_LCR, 0x0); /* Operational mode */
+	serial_out_rtu(up, UART_IER, up->ier);
+	serial_out_rtu(up, UART_FCR, up->fcr);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_A);
+	serial_out_rtu(up, UART_MCR, up->mcr);
+	serial_out_rtu(up, UART_LCR, UART_LCR_CONF_MODE_B); /* Config B mode */
+	serial_out_rtu(up, UART_OMAP_SCR, up->scr);
+	serial_out_rtu(up, UART_EFR, up->efr);
+	serial_out_rtu(up, UART_LCR, up->lcr);
+	if (up->errata & UART_ERRATA_i202_MDR1_ACCESS)
+		serial_omap_mdr1_errataset(up, up->mdr1);
+	else
+		serial_out_rtu(up, UART_OMAP_MDR1, up->mdr1);
+}
+
+static int serial_omap_runtime_suspend(struct device *dev)
+{
+	struct uart_omap_port *up = dev_get_drvdata(dev);
+	struct omap_uart_port_info *pdata = dev->platform_data;
+
+	if (!up)
+		return -EINVAL;
+
+	if (!pdata)
+		return 0;
+
+	up->context_loss_cnt = serial_omap_get_context_loss_count(up);
+
+	if (device_may_wakeup(dev)) {
+		if (!up->wakeups_enabled) {
+			serial_omap_enable_wakeup(up, true);
+			up->wakeups_enabled = true;
+		}
+	} else {
+		if (up->wakeups_enabled) {
+			serial_omap_enable_wakeup(up, false);
+			up->wakeups_enabled = false;
+		}
+	}
+
+	up->latency = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE;
+	schedule_work(&up->qos_work);
+
+	return 0;
+}
+
+static int serial_omap_runtime_resume(struct device *dev)
+{
+	struct uart_omap_port *up = dev_get_drvdata(dev);
+
+	int loss_cnt = serial_omap_get_context_loss_count(up);
+
+	if (loss_cnt < 0) {
+		dev_err(dev, "serial_omap_get_context_loss_count failed : %d\n",
+			loss_cnt);
+		serial_omap_restore_context(up);
+	} else if (up->context_loss_cnt != loss_cnt) {
+		serial_omap_restore_context(up);
+	}
+	up->latency = up->calc_latency;
+	schedule_work(&up->qos_work);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops serial_omap_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(serial_omap_suspend, serial_omap_resume)
+	SET_RUNTIME_PM_OPS(serial_omap_runtime_suspend,
+				serial_omap_runtime_resume, NULL)
+};
+
+#if defined(CONFIG_OF)
+static const struct of_device_id omap_serial_of_match[] = {
+	{ .compatible = "ti,omap2-uart-rtu" },
+	{ .compatible = "ti,omap3-uart-rtu" },
+	{ .compatible = "ti,omap4-uart-rtu" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, omap_serial_of_match);
+#endif
+
+static struct platform_driver serial_omap_driver = {
+	.probe          = serial_omap_probe,
+	.remove         = serial_omap_remove,
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.pm	= &serial_omap_dev_pm_ops,
+		.of_match_table = of_match_ptr(omap_serial_of_match),
+	},
+};
+
+static int __init serial_omap_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&serial_omap_reg);
+	if (ret != 0)
+		return ret;
+	ret = platform_driver_register(&serial_omap_driver);
+	if (ret != 0)
+		uart_unregister_driver(&serial_omap_reg);
+	return ret;
+}
+
+static void __exit serial_omap_exit(void)
+{
+	platform_driver_unregister(&serial_omap_driver);
+	uart_unregister_driver(&serial_omap_reg);
+}
+
+module_init(serial_omap_init);
+module_exit(serial_omap_exit);
+
+MODULE_DESCRIPTION("OMAP High Speed UART driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Texas Instruments Inc");
diff --git a/drivers/tty/serial/omap-serial-rtu.h b/drivers/tty/serial/omap-serial-rtu.h
new file mode 100644
index 0000000..741bb5f
--- /dev/null
+++ b/drivers/tty/serial/omap-serial-rtu.h
@@ -0,0 +1,222 @@
+/*
+ * Driver for OMAP-UART controller.
+ * Based on drivers/serial/8250.c
+ *
+ * Copyright (C) 2010 Texas Instruments.
+ *
+ * Authors:
+ *	Govindraj R	<govindraj.raja@ti.com>
+ *	Thara Gopinath	<thara@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __OMAP_SERIAL_H__
+#define __OMAP_SERIAL_H__
+
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/pm_qos.h>
+#include <linux/kfifo.h>
+
+//#include <plat/mux.h>
+//#include <plat/pfc-modbus-rtu.h>
+
+#define DRIVER_NAME	"omap_uart_rtu"
+
+/*
+ * Use tty device name as ttyO, [O -> OMAP]
+ * in bootargs we specify as console=ttyO0 if uart1
+ * is used as console uart.
+ */
+#define OMAP_SERIAL_NAME	"ttyO"
+
+#define OMAP_MODE13X_SPEED	230400
+
+/* WER = 0x7F
+ * Enable module level wakeup in WER reg
+ */
+#define OMAP_UART_WER_MOD_WKUP	0X7F
+
+#define OMAP_UART_SYSC_RESET	0X07
+#define OMAP_UART_FIFO_CLR	0X06
+
+#define OMAP_UART_DMA_CH_FREE	-1
+
+#define MSR_SAVE_FLAGS		UART_MSR_ANY_DELTA
+
+#define UART_ERRATA_i202_MDR1_ACCESS	BIT(0)
+#define UART_ERRATA_i291_DMA_FORCEIDLE	BIT(1)
+
+#define OMAP_MAX_HSUART_PORTS	6
+
+#define UART_BUILD_REVISION(x, y)	(((x) << 8) | (y))
+
+#define OMAP_UART_REV_42 0x0402
+#define OMAP_UART_REV_46 0x0406
+#define OMAP_UART_REV_52 0x0502
+#define OMAP_UART_REV_63 0x0603
+
+#define UART_ERRATA_i202_MDR1_ACCESS	BIT(0)
+#define UART_ERRATA_i291_DMA_FORCEIDLE	BIT(1)
+
+#define DEFAULT_CLK_SPEED 48000000 /* 48Mhz*/
+
+/* SCR register bitmasks */
+#define OMAP_UART_SCR_RX_TRIG_GRANU1_MASK		(1 << 7)
+#define OMAP_UART_SCR_TX_TRIG_GRANU1_MASK		(1 << 6)
+#define OMAP_UART_SCR_TX_EMPTY			(1 << 3)
+
+/* FCR register bitmasks */
+#define OMAP_UART_FCR_RX_FIFO_TRIG_MASK			(0x3 << 6)
+#define OMAP_UART_FCR_TX_FIFO_TRIG_MASK			(0x3 << 4)
+
+/* MVR register bitmasks */
+#define OMAP_UART_MVR_SCHEME_SHIFT	30
+
+#define OMAP_UART_LEGACY_MVR_MAJ_MASK	0xf0
+#define OMAP_UART_LEGACY_MVR_MAJ_SHIFT	4
+#define OMAP_UART_LEGACY_MVR_MIN_MASK	0x0f
+
+#define OMAP_UART_MVR_MAJ_MASK		0x700
+#define OMAP_UART_MVR_MAJ_SHIFT		8
+#define OMAP_UART_MVR_MIN_MASK		0x3f
+
+#define OMAP_UART_DMA_CH_FREE	-1
+
+#define MSR_SAVE_FLAGS		UART_MSR_ANY_DELTA
+#define OMAP_MODE13X_SPEED	230400
+
+/* WER = 0x7F
+ * Enable module level wakeup in WER reg
+ */
+#define OMAP_UART_WER_MOD_WKUP	0X7F
+
+/* Enable XON/XOFF flow control on output */
+#define OMAP_UART_SW_TX		0x08
+
+/* Enable XON/XOFF flow control on input */
+#define OMAP_UART_SW_RX		0x02
+
+#define OMAP_UART_SW_CLR	0xF0
+
+#define OMAP_UART_TCR_TRIG	0x0F
+
+
+struct omap_uart_port_info {
+	bool			dma_enabled;	/* To specify DMA Mode */
+	unsigned int		uartclk;	/* UART clock rate */
+	upf_t			flags;		/* UPF_* flags */
+	unsigned int		dma_rx_buf_size;
+	unsigned int		dma_rx_timeout;
+	unsigned int		autosuspend_timeout;
+	unsigned int		dma_rx_poll_rate;
+	int			DTR_gpio;
+	int			DTR_inverted;
+	int			DTR_present;
+
+  //	int                     disable_port;
+
+	int (*get_context_loss_count)(struct device *);
+	void (*set_forceidle)(struct device *);
+	void (*set_noidle)(struct device *);
+	void (*enable_wakeup)(struct device *, bool);
+};
+
+struct uart_omap_dma {
+	u8			uart_dma_tx;
+	u8			uart_dma_rx;
+	int			rx_dma_channel;
+	int			tx_dma_channel;
+	dma_addr_t		rx_buf_dma_phys;
+	dma_addr_t		tx_buf_dma_phys;
+	unsigned int		uart_base;
+	/*
+	 * Buffer for rx dma.It is not required for tx because the buffer
+	 * comes from port structure.
+	 */
+	unsigned char		*rx_buf;
+	unsigned int		prev_rx_dma_pos;
+	int			tx_buf_size;
+	int			tx_dma_used;
+	int			rx_dma_used;
+	spinlock_t		tx_lock;
+	spinlock_t		rx_lock;
+	/* timer to poll activity on rx dma */
+	struct timer_list	rx_timer;
+	unsigned int		rx_buf_size;
+	unsigned int		rx_poll_rate;
+	unsigned int		rx_timeout;
+};
+
+struct uart_omap_port {
+	struct uart_port	port;
+	struct uart_omap_dma	uart_dma;
+	struct device		*dev;
+
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+	struct modbus_port	mb_port;
+#endif
+
+	unsigned char		ier;
+	unsigned char		lcr;
+	unsigned char		mcr;
+	unsigned char		fcr;
+	unsigned char		efr;
+	unsigned char		dll;
+	unsigned char		dlh;
+	unsigned char		mdr1;
+	unsigned char		scr;
+
+	int			use_dma;
+	/*
+	 * Some bits in registers are cleared on a read, so they must
+	 * be saved whenever the register is read but the bits will not
+	 * be immediately processed.
+	 */
+	unsigned int		lsr_break_flag;
+	unsigned char		msr_saved_flags;
+	char			name[20];
+	unsigned long		port_activity;
+
+	struct serial_rs485     rs485;
+	unsigned int            tx_in_progress:1, tx_wait_end:1;
+	int			rts_gpio;
+	int 			rs485en_gpio;
+	u8 			rs485en_alow;
+
+	int			context_loss_cnt;
+	u32			errata;
+	u8			wakeups_enabled;
+
+	int			DTR_gpio;
+	int			DTR_inverted;
+	int			DTR_active;
+
+	struct pm_qos_request	pm_qos_request;
+	u32			latency;
+	u32			calc_latency;
+	struct work_struct	qos_work;
+	struct pinctrl		*pins;
+
+       struct tasklet_struct   tx_tsklt;
+       struct tasklet_struct   rx_tsklt;
+       struct tasklet_struct   mdm_status_tsklt;
+       DECLARE_KFIFO_PTR(rx_fifo, uint16_t);
+};
+
+unsigned int serial_in(struct uart_omap_port *up, int offset);
+void serial_out(struct uart_omap_port *up, int offset, int value);
+void transmit_chars(struct uart_omap_port *up, unsigned int lsr);
+irqreturn_t serial_omap_irq(int irq, void *dev_id);
+void serial_omap_stop_tx(struct uart_port *port);
+void serial_omap_start_tx(struct uart_port *port);
+void serial_omap_disable_ier_thri(struct uart_omap_port *up);
+int serial_omap_end_tx(struct uart_omap_port *up);
+
+#define CONFIG_SERIAL_OMAP_RS485
+
+#endif /* __OMAP_SERIAL_H__ */
diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c
index e654cb4..c38620d 100644
--- a/drivers/tty/serial/omap-serial.c
+++ b/drivers/tty/serial/omap-serial.c
@@ -1567,7 +1567,7 @@ static int serial_omap_probe_rs485(struct uart_omap_port *up,
 		if (ret < 0)
 			return ret;
 		ret = gpio_direction_output(up->rts_gpio,
-					    flags & SER_RS485_RTS_AFTER_SEND);
+					    rs485conf->flags & SER_RS485_RTS_AFTER_SEND);
 		if (ret < 0)
 			return ret;
 	} else if (up->rts_gpio == -EPROBE_DEFER) {
diff --git a/drivers/tty/serial/pfc-modbus-rtu.c b/drivers/tty/serial/pfc-modbus-rtu.c
new file mode 100644
index 0000000..8218dc8
--- /dev/null
+++ b/drivers/tty/serial/pfc-modbus-rtu.c
@@ -0,0 +1,484 @@
+/*------------------------------------------------------------------------------
+ * Copyright (c) WAGO Kontakttechnik GmbH & Co. KG
+ *
+ * PROPRIETARY RIGHTS are involved in the subject matter of this material. All
+ * manufacturing, reproduction, use and sales rights pertaining to this
+ * subject matter are governed by the license agreement. The recipient of this
+ * software implicitly accepts the terms of the license.
+ *------------------------------------------------------------------------------
+ *------------------------------------------------------------------------------
+ *   \file     pfc-modbus-rtu.c
+ *
+ *   \version  0.1
+ *
+ *   \brief    <short description of the file contents>
+ *
+ *   \author   Timur Celik : WAGO Kontakttechnik GmbH & Co. KG
+ *------------------------------------------------------------------------------
+ */
+#undef DEBUG
+
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+
+//#include <linux/platform_data/serial-omap.h>
+#include <linux/platform_data/pfc-modbus-rtu.h>
+#include "omap-serial-rtu.h"
+
+#include <uapi/linux/serial_reg.h>
+#include <linux/pm_runtime.h>
+#include <linux/tty_flip.h>
+
+static struct kfifo valid_frame;
+
+extern unsigned int serial_in_rtu(struct uart_omap_port *up, int offset);
+extern void serial_out_rtu(struct uart_omap_port *up, int offset, int value);
+
+extern void transmit_chars_rtu(struct uart_omap_port *up, unsigned int lsr);
+extern irqreturn_t serial_omap_irq_rtu(int irq, void *dev_id);
+
+/* extern void serial_omap_enable_ier_thri(struct uart_omap_port *up); */
+/* extern void serial_omap_disable_ier_thri(struct uart_omap_port *up); */
+
+static irqreturn_t modbus_omap_irq(int irq, void *dev_id)
+{
+	struct uart_omap_port *up = dev_id;
+	unsigned int iir, lsr;
+	unsigned int type;
+	irqreturn_t ret = IRQ_NONE;
+	int max_count = 256;
+
+	raw_spin_lock(&up->port.lock);
+
+	do {
+		iir = serial_in_rtu(up, UART_IIR);
+		if (iir & UART_IIR_NO_INT)
+			break;
+
+		ret = IRQ_HANDLED;
+		lsr = serial_in_rtu(up, UART_LSR);
+
+		/* extract IRQ type from IIR register */
+		type = iir & 0x3e;
+
+		switch (type) {
+		case UART_IIR_MSI:
+			up->mb_port.modem_status = serial_in_rtu(up, UART_MSR);
+			tasklet_hi_schedule(&up->mb_port.mdr_tsklt);
+			break;
+		case UART_IIR_THRI:
+			serial_omap_disable_ier_thri(up);
+			if(!serial_omap_end_tx(up)) {
+				tasklet_hi_schedule(&up->mb_port.tx_tsklt);
+			}
+			break;
+		case UART_IIR_RLSI:
+			modbus_omap_rlsi_handler(up, lsr);
+			break;
+		case UART_IIR_RX_TIMEOUT:
+			/* FALLTHROUGH */
+		case UART_IIR_RDI:
+			modbus_omap_rhr_handler(up);
+			break;
+		case UART_IIR_CTS_RTS_DSR:
+			/* simply try again */
+			break;
+		case UART_IIR_XOFF:
+			/* FALLTHROUGH */
+		default:
+			break;
+		}
+	} while (!(iir & UART_IIR_NO_INT) && max_count--);
+
+	raw_spin_unlock(&up->port.lock);
+
+	up->port_activity = jiffies;
+
+	return ret;
+}
+
+static void modbus_check_modem_status(unsigned long dev_id)
+{
+	struct uart_omap_port *up = (void*) dev_id;
+	unsigned int status;
+
+	status = up->mb_port.modem_status;
+	status |= up->msr_saved_flags;
+	up->msr_saved_flags = 0;
+	if ((status & UART_MSR_ANY_DELTA) == 0)
+		return;
+
+	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
+	    up->port.state != NULL) {
+		if (status & UART_MSR_TERI)
+			up->port.icount.rng++;
+		if (status & UART_MSR_DDSR)
+			up->port.icount.dsr++;
+		if (status & UART_MSR_DDCD)
+			uart_handle_dcd_change
+				(&up->port, status & UART_MSR_DCD);
+		if (status & UART_MSR_DCTS)
+			uart_handle_cts_change
+				(&up->port, status & UART_MSR_CTS);
+		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+	}
+}
+
+static void modbus_omap_transmit(unsigned long dev_id)
+{
+	struct uart_omap_port *up = (void*) dev_id;
+
+	spin_lock(&up->port.lock);
+	transmit_chars_rtu(up, serial_in_rtu(up, UART_LSR));
+	spin_unlock(&up->port.lock);
+}
+
+void modbus_omap_process_frame(struct uart_omap_port *up)
+{
+	unsigned char ch, is_valid;
+	unsigned int cnt;
+	int frame_len = 0;
+
+	spin_lock(&up->port.lock);
+start:
+	is_valid = true;
+	if(!kfifo_get(&up->mb_port.length, &frame_len)) {
+		goto exit;
+	}
+	while((frame_len > 0) && (kfifo_get(&up->mb_port.frame, &ch))) {
+		frame_len--;
+		up->port.icount.rx++;
+		if(!kfifo_put(&valid_frame, ch)) {
+			dev_dbg(up->dev, "Buffer overrun\n");
+			is_valid = false;
+		}
+	}
+
+	atomic_dec(&up->mb_port.frame_cnt);
+
+	if(!is_valid)
+		goto exit;
+
+	cnt = kfifo_len(&valid_frame);
+	if(up->mb_port.timestamp_enabled) {
+		cnt -= MB_TIMESTAMP_LENGTH;
+	}
+	if(cnt<MB_FRAME_MIN || cnt>MB_FRAME_MAX) {
+		dev_dbg(up->dev, "Frame length invalid\n");
+		up->port.icount.frame++;
+		goto exit;
+	}
+
+	dev_dbg(up->dev, "Frame of %u bytes received\n", cnt);
+
+	if(kfifo_peek(&valid_frame, &ch) &&
+	   ch != up->mb_port.slave_id && up->mb_port.slave_id && ch) {
+		dev_dbg(up->dev, "Dropping frame with slave id=%d\n", ch);
+		goto exit;
+	}
+
+	// push frame to the uart layer
+	while(kfifo_get(&valid_frame, &ch))
+		uart_insert_char(&up->port, 0, UART_LSR_OE, ch, TTY_NORMAL);
+
+exit:
+	kfifo_reset(&valid_frame);
+	if(atomic_read(&up->mb_port.frame_cnt) > 0) {
+		dev_dbg(up->dev, "Processing another frame\n");
+		goto start;
+	}
+
+	spin_unlock(&up->port.lock);
+}
+
+static void modbus_omap_finish_frame(unsigned long dev_id)
+{
+	struct uart_omap_port *up = (void*) dev_id;
+
+	pm_runtime_get_sync(up->dev);
+
+	modbus_omap_process_frame(up);
+
+	if(up->port.state->port.tty)
+		tty_flip_buffer_push(&up->port.state->port);
+
+	pm_runtime_mark_last_busy(up->dev);
+	pm_runtime_put_autosuspend(up->dev);
+}
+
+enum hrtimer_restart modbus_omap_to_handler(struct hrtimer* hrt)
+{
+	enum hrtimer_restart ret = HRTIMER_NORESTART;
+	struct modbus_port *mp = container_of(hrt, struct modbus_port, timer);
+	struct uart_omap_port *up =
+			container_of(mp, struct uart_omap_port, mb_port);
+	int frame_len = 0;
+	u64 to_35 = mp->to_35_override ? mp->to_35_override : mp->to_35;
+	u64 to_15 = mp->to_15_override ? mp->to_15_override : mp->to_15;
+
+	switch(mp->state) {
+		case ERR:
+			dev_dbg(up->dev, "Timeout at 3.5 char\n");
+
+			if(up->mb_port.timestamp_enabled) {
+				struct timespec ts;
+				ktime_get_ts(&ts);
+				// push timestamp after frame
+				kfifo_put(&up->mb_port.frame, (ts.tv_sec >> 24) & 0xFF);
+				kfifo_put(&up->mb_port.frame, (ts.tv_sec >> 16) & 0xFF);
+				kfifo_put(&up->mb_port.frame, (ts.tv_sec >> 8) & 0xFF);
+				kfifo_put(&up->mb_port.frame, ts.tv_sec & 0xFF);
+				kfifo_put(&up->mb_port.frame, (ts.tv_nsec >> 24) & 0xFF);
+				kfifo_put(&up->mb_port.frame, (ts.tv_nsec >> 16) & 0xFF);
+				kfifo_put(&up->mb_port.frame, (ts.tv_nsec >> 8) & 0xFF);
+				kfifo_put(&up->mb_port.frame, ts.tv_nsec & 0xFF);
+				frame_len = MB_TIMESTAMP_LENGTH;
+			}
+			// push frame length including 8 bytes for timestamp if activated
+			frame_len += atomic_read(&up->mb_port.ch_cnt);
+			kfifo_put(&up->mb_port.length, frame_len);
+			atomic_set(&up->mb_port.ch_cnt, 0);
+			atomic_inc(&up->mb_port.frame_cnt);
+			tasklet_hi_schedule(&up->mb_port.rx_tsklt);
+
+			mp->state = IF;
+			break;
+		case IC:
+			mp->state = ERR;
+			hrtimer_forward(hrt, hrtimer_get_expires(hrt),
+			                ns_to_ktime(to_35-to_15));
+			ret = HRTIMER_RESTART;
+			dev_dbg(up->dev, "Timeout at 1.5 char\n");
+			break;
+		case IF: break;
+		default: break;
+	}
+
+	return ret;
+}
+
+int modbus_omap_rhr_handler(struct uart_omap_port *up)
+{
+	unsigned int ch;
+	int err = false;
+	struct modbus_port *mp = &up->mb_port;
+	u64 to_15 = mp->to_15_override ? mp->to_15_override : mp->to_15;
+	err = hrtimer_start(&mp->timer, ns_to_ktime(to_15), HRTIMER_MODE_REL);
+
+	ch = serial_in_rtu(up, UART_RX);
+
+	if(kfifo_put(&up->mb_port.frame, ch) != 0)
+		atomic_inc(&up->mb_port.ch_cnt);
+
+	switch(mp->state) {
+		case ERR:
+			dev_dbg(up->dev, "Protocol timing incorrect\n");
+			atomic_set(&up->mb_port.ch_cnt, 0);
+			kfifo_reset(&up->mb_port.frame);
+			up->port.icount.frame++;
+			mp->state = IC;
+			err = true;
+			break;
+		case IC: break;
+		case IF:
+			mp->state = IC;
+			break;
+		default: break;
+	}
+
+	return err;
+};
+
+int modbus_omap_rlsi_handler(struct uart_omap_port *up, unsigned int lsr)
+{
+	int err = false;
+	struct modbus_port *mp = &up->mb_port;
+	u64 to_15 = mp->to_15_override ? mp->to_15_override : mp->to_15;
+
+	if((lsr & (UART_LSR_BI | UART_LSR_PE | UART_LSR_FE | UART_LSR_OE)) == 0)
+		return modbus_omap_rhr_handler(up);
+
+	err = hrtimer_start(&mp->timer, ns_to_ktime(to_15), HRTIMER_MODE_REL);
+
+	dev_dbg(up->dev, "Line status error\n");
+	serial_in_rtu(up, UART_RX);
+	// TODO: kfifo_reset(&mp->frame);
+
+	raw_spin_lock(&up->port.lock);
+	if (lsr & UART_LSR_BI)
+		up->port.icount.brk++;
+
+	if (lsr & UART_LSR_PE)
+		up->port.icount.parity++;
+
+	if (lsr & UART_LSR_FE)
+		up->port.icount.frame++;
+
+	if (lsr & UART_LSR_OE)
+		up->port.icount.overrun++;
+	raw_spin_unlock(&up->port.lock);
+
+	return err;
+};
+
+void modbus_omap_calc_to(struct uart_omap_port *up, unsigned int baud)
+{
+	struct modbus_port *mp = &up->mb_port;
+
+	u8 char_bits = 11; /* TODO: get the actual value from the uart */
+	u64 char_duration = USEC_PER_SEC * char_bits / baud;
+	char_duration *= 1000; /* workaround for bug in gcc */
+
+	/*
+	 * When calculating the timeouts, always add one char_duration. The IRQ
+	 * measures the time between rx_end and rx_end, but the time from rx_end
+	 * to rx_start is needed.
+	 */
+	if(baud <= 19000) {
+		mp->to_15 = char_duration * 5/2;
+		mp->to_35 = char_duration * 9/2;
+	} else {
+		mp->to_15 = char_duration + 750000UL;
+		mp->to_35 = char_duration + 1750000UL;
+	}
+
+	dev_info(up->dev, "Baudrate = %u, TO_15 = %lluns, TO_35 = %lluns\n",
+	         baud, mp->to_15, mp->to_35);
+};
+
+void modbus_omap_timestamp_enable(struct uart_omap_port *up)
+{
+	dev_info(up->dev, "Enabling Modbus timestamp\n");
+	up->mb_port.timestamp_enabled = true;
+}
+
+void modbus_omap_timestamp_disable(struct uart_omap_port *up)
+{
+	dev_info(up->dev, "Disabling Modbus timestamp\n");
+	up->mb_port.timestamp_enabled = false;
+}
+
+int modbus_omap_enable(struct uart_omap_port *up)
+{
+	int err;
+	u64 to_35;
+	struct modbus_port *mp = &up->mb_port;
+	struct hrtimer* hrt = &mp->timer;
+
+	if(mp->activated) {
+		err = modbus_omap_disable(up);
+		if(err) return err;
+	}
+
+	dev_info(up->dev, "Enabling Modbus mode\n");
+
+	atomic_set(&mp->ch_cnt, 0);
+	atomic_set(&mp->frame_cnt, 0);
+
+	err = kfifo_alloc(&mp->frame, 640, 0);
+	if(err) {
+		dev_err(up->dev, "Unable to allocate memory (%d)\n", err);
+		return err;
+	}
+	err = kfifo_alloc(&mp->length, 64, 0);
+	if(err) {
+		dev_err(up->dev, "Unable to allocate memory (%d)\n", err);
+		return err;
+	}
+	err = kfifo_alloc(&valid_frame, 512, 0);
+	if(err) {
+		dev_err(up->dev, "Unable to allocate memory (%d)\n", err);
+		return err;
+	}
+
+	hrtimer_init(hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hrt->function = modbus_omap_to_handler;
+	hrt->irqsafe = 1; /* use hw interrupt context */
+
+	if(!hrtimer_is_hres_active(hrt))
+		dev_warn(up->dev, "No hi-res timer available\n");
+
+	/* init a timer which measures the time in between two chars */
+	to_35 = mp->to_35_override ? mp->to_35_override : mp->to_35;
+	err = hrtimer_start(hrt, ns_to_ktime(to_35), HRTIMER_MODE_REL);
+
+	/* create a tasklet for stuff that wants to sleep */
+	tasklet_init(&mp->rx_tsklt, modbus_omap_finish_frame, (unsigned long)up);
+	tasklet_init(&mp->tx_tsklt, modbus_omap_transmit, (unsigned long)up);
+	tasklet_init(&mp->mdr_tsklt, modbus_check_modem_status, (unsigned long)up);
+
+	/* set the new ISR to not threaded */
+	free_irq(up->port.irq, up);
+	err = request_irq(up->port.irq, modbus_omap_irq, IRQF_NO_THREAD,
+	                  up->name, up);
+	if(err) {
+		dev_err(up->dev, "irq-%d could not claim: err %d\n",
+		        up->port.irq, err);
+		return -1;
+	}
+
+	mp->activated = true;
+
+	return 0;
+};
+
+int modbus_omap_disable(struct uart_omap_port *up)
+{
+	int err;
+	struct modbus_port *mp = &up->mb_port;
+
+	if(!mp->activated)
+		return -1;
+
+	dev_info(up->dev, "Disabling Modbus mode\n");
+
+	tasklet_kill(&mp->rx_tsklt);
+	tasklet_kill(&mp->tx_tsklt);
+	tasklet_kill(&mp->mdr_tsklt);
+
+	hrtimer_cancel(&mp->timer);
+
+	/* restore old isr */
+	free_irq(up->port.irq, up);
+	err = request_irq(up->port.irq, serial_omap_irq_rtu, up->port.irqflags | IRQF_NO_THREAD,
+			  up->name, up);
+	if(err) {
+		dev_err(up->dev, "irq-%d could not claim: err %d\n",
+		        up->port.irq, err);
+		return -1;
+	}
+
+	kfifo_free(&mp->frame);
+	kfifo_free(&mp->length);
+	kfifo_free(&valid_frame);
+
+	mp->activated = false;
+
+	return 0;
+};
+
+int modbus_omap_startup(struct uart_omap_port *up)
+{
+	struct modbus_port *mp = &up->mb_port;
+	mp->activated = false;
+	mp->state = ERR;
+	mp->to_15 = ULLONG_MAX;
+	mp->to_35 = ULLONG_MAX;
+	mp->to_15_override = 0;
+	mp->to_35_override = 0;
+	mp->slave_id = 0;
+	mp->modem_status = 0;
+
+	dev_info(up->dev, "Initializing Modbus driver\n");
+	dev_dbg(up->dev,
+	        "IOCTLs are TIOCSMBRTU (%u), TIOCSMBRTUADDR (%u), "
+	        "TIOCSMBRTUIFT (%u) and TIOCSMBRTUICT (%u)\n",
+	        TIOCSMBRTU, TIOCSMBRTUADDR, TIOCSMBRTUIFT, TIOCSMBRTUICT);
+
+	return 0;
+};
+
+void modbus_omap_shutdown(struct uart_omap_port *up)
+{
+};
+
+#endif
diff --git a/drivers/tty/serial/serial_reg_rtu.h b/drivers/tty/serial/serial_reg_rtu.h
new file mode 100644
index 0000000..3e6ca53
--- /dev/null
+++ b/drivers/tty/serial/serial_reg_rtu.h
@@ -0,0 +1,390 @@
+/*
+ * include/linux/serial_reg.h
+ *
+ * Copyright (C) 1992, 1994 by Theodore Ts'o.
+ * 
+ * Redistribution of this file is permitted under the terms of the GNU 
+ * Public License (GPL)
+ * 
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
+
+#ifndef _LINUX_SERIAL_REG_H
+#define _LINUX_SERIAL_REG_H
+
+/*
+ * DLAB=0
+ */
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
+
+#define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
+#define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
+#define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
+#define UART_IER_RDI		0x01 /* Enable receiver data interrupt */
+/*
+ * Sleep mode for ST16650 and TI16750.  For the ST16650, EFR[4]=1
+ */
+#define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
+
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_IIR_NO_INT		0x01 /* No interrupts pending */
+#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
+#define UART_IIR_MSI		0x00 /* Modem status interrupt */
+#define UART_IIR_THRI		0x02 /* Transmitter holding register empty */
+#define UART_IIR_RDI		0x04 /* Receiver data interrupt */
+#define UART_IIR_RLSI		0x06 /* Receiver line status interrupt */
+
+#define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
+#define UART_IIR_RX_TIMEOUT	0x0c /* OMAP RX Timeout interrupt */
+#define UART_IIR_XOFF		0x10 /* OMAP XOFF/Special Character */
+#define UART_IIR_CTS_RTS_DSR	0x20 /* OMAP CTS/RTS/DSR Change */
+
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
+#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
+#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
+/*
+ * Note: The FIFO trigger levels are chip specific:
+ *	RX:76 = 00  01  10  11	TX:54 = 00  01  10  11
+ * PC16550D:	 1   4   8  14		xx  xx  xx  xx
+ * TI16C550A:	 1   4   8  14          xx  xx  xx  xx
+ * TI16C550C:	 1   4   8  14          xx  xx  xx  xx
+ * ST16C550:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C650:	 8  16  24  28		16   8  24  30	PORT_16650V2
+ * NS16C552:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C654:	 8  16  56  60		 8  16  32  56	PORT_16654
+ * TI16C750:	 1  16  32  56		xx  xx  xx  xx	PORT_16750
+ * TI16C752:	 8  16  56  60		 8  16  32  56
+ * Tegra:	 1   4   8  14		16   8   4   1	PORT_TEGRA
+ */
+#define UART_FCR_R_TRIG_00	0x00
+#define UART_FCR_R_TRIG_01	0x40
+#define UART_FCR_R_TRIG_10	0x80
+#define UART_FCR_R_TRIG_11	0xc0
+#define UART_FCR_T_TRIG_00	0x00
+#define UART_FCR_T_TRIG_01	0x10
+#define UART_FCR_T_TRIG_10	0x20
+#define UART_FCR_T_TRIG_11	0x30
+
+#define UART_FCR_TRIGGER_MASK	0xC0 /* Mask for the FIFO trigger range */
+#define UART_FCR_TRIGGER_1	0x00 /* Mask for trigger set at 1 */
+#define UART_FCR_TRIGGER_4	0x40 /* Mask for trigger set at 4 */
+#define UART_FCR_TRIGGER_8	0x80 /* Mask for trigger set at 8 */
+#define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
+/* 16650 definitions */
+#define UART_FCR6_R_TRIGGER_8	0x00 /* Mask for receive trigger set at 1 */
+#define UART_FCR6_R_TRIGGER_16	0x40 /* Mask for receive trigger set at 4 */
+#define UART_FCR6_R_TRIGGER_24  0x80 /* Mask for receive trigger set at 8 */
+#define UART_FCR6_R_TRIGGER_28	0xC0 /* Mask for receive trigger set at 14 */
+#define UART_FCR6_T_TRIGGER_16	0x00 /* Mask for transmit trigger set at 16 */
+#define UART_FCR6_T_TRIGGER_8	0x10 /* Mask for transmit trigger set at 8 */
+#define UART_FCR6_T_TRIGGER_24  0x20 /* Mask for transmit trigger set at 24 */
+#define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
+#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
+
+#define UART_LCR	3	/* Out: Line Control Register */
+/*
+ * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
+ * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
+ */
+#define UART_LCR_DLAB		0x80 /* Divisor latch access bit */
+#define UART_LCR_SBC		0x40 /* Set break control */
+#define UART_LCR_SPAR		0x20 /* Stick parity (?) */
+#define UART_LCR_EPAR		0x10 /* Even parity select */
+#define UART_LCR_PARITY		0x08 /* Parity Enable */
+#define UART_LCR_STOP		0x04 /* Stop bits: 0=1 bit, 1=2 bits */
+#define UART_LCR_WLEN5		0x00 /* Wordlength: 5 bits */
+#define UART_LCR_WLEN6		0x01 /* Wordlength: 6 bits */
+#define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
+#define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
+
+/*
+ * Access to some registers depends on register access / configuration
+ * mode.
+ */
+#define UART_LCR_CONF_MODE_A	UART_LCR_DLAB	/* Configutation mode A */
+#define UART_LCR_CONF_MODE_B	0xBF		/* Configutation mode B */
+
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
+#define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
+#define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
+#define UART_MCR_AFE		0x20 /* Enable auto-RTS/CTS (TI16C550C/TI16C750) */
+#define UART_MCR_LOOP		0x10 /* Enable loopback test mode */
+#define UART_MCR_OUT2		0x08 /* Out2 complement */
+#define UART_MCR_OUT1		0x04 /* Out1 complement */
+#define UART_MCR_RTS		0x02 /* RTS complement */
+#define UART_MCR_DTR		0x01 /* DTR complement */
+
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_FIFOE		0x80 /* Fifo error */
+#define UART_LSR_TEMT		0x40 /* Transmitter empty */
+#define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
+#define UART_LSR_BI		0x10 /* Break interrupt indicator */
+#define UART_LSR_FE		0x08 /* Frame error indicator */
+#define UART_LSR_PE		0x04 /* Parity error indicator */
+#define UART_LSR_OE		0x02 /* Overrun error indicator */
+#define UART_LSR_DR		0x01 /* Receiver data ready */
+#define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
+
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_MSR_DCD		0x80 /* Data Carrier Detect */
+#define UART_MSR_RI		0x40 /* Ring Indicator */
+#define UART_MSR_DSR		0x20 /* Data Set Ready */
+#define UART_MSR_CTS		0x10 /* Clear to Send */
+#define UART_MSR_DDCD		0x08 /* Delta DCD */
+#define UART_MSR_TERI		0x04 /* Trailing edge ring indicator */
+#define UART_MSR_DDSR		0x02 /* Delta DSR */
+#define UART_MSR_DCTS		0x01 /* Delta CTS */
+#define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
+
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+/*
+ * DLAB=1
+ */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_DLM	1	/* Out: Divisor Latch High */
+
+/*
+ * LCR=0xBF (or DLAB=1 for 16C660)
+ */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_XR_EFR	9	/* I/O: Extended Features Register (XR17D15x) */
+#define UART_EFR_CTS		0x80 /* CTS flow control */
+#define UART_EFR_RTS		0x40 /* RTS flow control */
+#define UART_EFR_SCD		0x20 /* Special character detect */
+#define UART_EFR_ECB		0x10 /* Enhanced control bit */
+/*
+ * the low four bits control software flow control
+ */
+
+/*
+ * LCR=0xBF, TI16C752, ST16650, ST16650A, ST16654
+ */
+#define UART_XON1	4	/* I/O: Xon character 1 */
+#define UART_XON2	5	/* I/O: Xon character 2 */
+#define UART_XOFF1	6	/* I/O: Xoff character 1 */
+#define UART_XOFF2	7	/* I/O: Xoff character 2 */
+
+/*
+ * EFR[4]=1 MCR[6]=1, TI16C752
+ */
+#define UART_TI752_TCR	6	/* I/O: transmission control register */
+#define UART_TI752_TLR	7	/* I/O: trigger level register */
+
+/*
+ * LCR=0xBF, XR16C85x
+ */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
+/*
+ * These are the definitions for the Programmable Trigger Register
+ */
+#define UART_TRG_1		0x01
+#define UART_TRG_4		0x04
+#define UART_TRG_8		0x08
+#define UART_TRG_16		0x10
+#define UART_TRG_32		0x20
+#define UART_TRG_64		0x40
+#define UART_TRG_96		0x60
+#define UART_TRG_120		0x78
+#define UART_TRG_128		0x80
+
+#define UART_FCTR	1	/* Feature Control Register */
+#define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
+#define UART_FCTR_RTS_4DELAY	0x01
+#define UART_FCTR_RTS_6DELAY	0x02
+#define UART_FCTR_RTS_8DELAY	0x03
+#define UART_FCTR_IRDA		0x04  /* IrDa data encode select */
+#define UART_FCTR_TX_INT	0x08  /* Tx interrupt type select */
+#define UART_FCTR_TRGA		0x00  /* Tx/Rx 550 trigger table select */
+#define UART_FCTR_TRGB		0x10  /* Tx/Rx 650 trigger table select */
+#define UART_FCTR_TRGC		0x20  /* Tx/Rx 654 trigger table select */
+#define UART_FCTR_TRGD		0x30  /* Tx/Rx 850 programmable trigger select */
+#define UART_FCTR_SCR_SWAP	0x40  /* Scratch pad register swap */
+#define UART_FCTR_RX		0x00  /* Programmable trigger mode select */
+#define UART_FCTR_TX		0x80  /* Programmable trigger mode select */
+
+/*
+ * LCR=0xBF, FCTR[6]=1
+ */
+#define UART_EMSR	7	/* Extended Mode Select Register */
+#define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
+#define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
+
+/*
+ * The Intel XScale on-chip UARTs define these bits
+ */
+#define UART_IER_DMAE	0x80	/* DMA Requests Enable */
+#define UART_IER_UUE	0x40	/* UART Unit Enable */
+#define UART_IER_NRZE	0x20	/* NRZ coding Enable */
+#define UART_IER_RTOIE	0x10	/* Receiver Time Out Interrupt Enable */
+
+#define UART_IIR_TOD	0x08	/* Character Timeout Indication Detected */
+
+#define UART_FCR_PXAR1	0x00	/* receive FIFO threshold = 1 */
+#define UART_FCR_PXAR8	0x40	/* receive FIFO threshold = 8 */
+#define UART_FCR_PXAR16	0x80	/* receive FIFO threshold = 16 */
+#define UART_FCR_PXAR32	0xc0	/* receive FIFO threshold = 32 */
+
+/*
+ * Intel MID on-chip HSU (High Speed UART) defined bits
+ */
+#define UART_FCR_HSU_64_1B	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_HSU_64_16B	0x40	/* receive FIFO treshold = 16 */
+#define UART_FCR_HSU_64_32B	0x80	/* receive FIFO treshold = 32 */
+#define UART_FCR_HSU_64_56B	0xc0	/* receive FIFO treshold = 56 */
+
+#define UART_FCR_HSU_16_1B	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_HSU_16_4B	0x40	/* receive FIFO treshold = 4 */
+#define UART_FCR_HSU_16_8B	0x80	/* receive FIFO treshold = 8 */
+#define UART_FCR_HSU_16_14B	0xc0	/* receive FIFO treshold = 14 */
+
+#define UART_FCR_HSU_64B_FIFO	0x20	/* chose 64 bytes FIFO */
+#define UART_FCR_HSU_16B_FIFO	0x00	/* chose 16 bytes FIFO */
+
+#define UART_FCR_HALF_EMPT_TXI	0x00	/* trigger TX_EMPT IRQ for half empty */
+#define UART_FCR_FULL_EMPT_TXI	0x08	/* trigger TX_EMPT IRQ for full empty */
+
+/*
+ * These register definitions are for the 16C950
+ */
+#define UART_ASR	0x01	/* Additional Status Register */
+#define UART_RFL	0x03	/* Receiver FIFO level */
+#define UART_TFL 	0x04	/* Transmitter FIFO level */
+#define UART_ICR	0x05	/* Index Control Register */
+
+/* The 16950 ICR registers */
+#define UART_ACR	0x00	/* Additional Control Register */
+#define UART_CPR	0x01	/* Clock Prescalar Register */
+#define UART_TCR	0x02	/* Times Clock Register */
+#define UART_CKS	0x03	/* Clock Select Register */
+#define UART_TTL	0x04	/* Transmitter Interrupt Trigger Level */
+#define UART_RTL	0x05	/* Receiver Interrupt Trigger Level */
+#define UART_FCL	0x06	/* Flow Control Level Lower */
+#define UART_FCH	0x07	/* Flow Control Level Higher */
+#define UART_ID1	0x08	/* ID #1 */
+#define UART_ID2	0x09	/* ID #2 */
+#define UART_ID3	0x0A	/* ID #3 */
+#define UART_REV	0x0B	/* Revision */
+#define UART_CSR	0x0C	/* Channel Software Reset */
+#define UART_NMR	0x0D	/* Nine-bit Mode Register */
+#define UART_CTR	0xFF
+
+/*
+ * The 16C950 Additional Control Register
+ */
+#define UART_ACR_RXDIS	0x01	/* Receiver disable */
+#define UART_ACR_TXDIS	0x02	/* Transmitter disable */
+#define UART_ACR_DSRFC	0x04	/* DSR Flow Control */
+#define UART_ACR_TLENB	0x20	/* 950 trigger levels enable */
+#define UART_ACR_ICRRD	0x40	/* ICR Read enable */
+#define UART_ACR_ASREN	0x80	/* Additional status enable */
+
+
+
+/*
+ * These definitions are for the RSA-DV II/S card, from
+ *
+ * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
+ */
+
+#define UART_RSA_BASE (-8)
+
+#define UART_RSA_MSR ((UART_RSA_BASE) + 0) /* I/O: Mode Select Register */
+
+#define UART_RSA_MSR_SWAP (1 << 0) /* Swap low/high 8 bytes in I/O port addr */
+#define UART_RSA_MSR_FIFO (1 << 2) /* Enable the external FIFO */
+#define UART_RSA_MSR_FLOW (1 << 3) /* Enable the auto RTS/CTS flow control */
+#define UART_RSA_MSR_ITYP (1 << 4) /* Level (1) / Edge triger (0) */
+
+#define UART_RSA_IER ((UART_RSA_BASE) + 1) /* I/O: Interrupt Enable Register */
+
+#define UART_RSA_IER_Rx_FIFO_H (1 << 0) /* Enable Rx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_H (1 << 1) /* Enable Tx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_E (1 << 2) /* Enable Tx FIFO empty int. */
+#define UART_RSA_IER_Rx_TOUT (1 << 3) /* Enable char receive timeout int */
+#define UART_RSA_IER_TIMER (1 << 4) /* Enable timer interrupt */
+
+#define UART_RSA_SRR ((UART_RSA_BASE) + 2) /* IN: Status Read Register */
+
+#define UART_RSA_SRR_Tx_FIFO_NEMP (1 << 0) /* Tx FIFO is not empty (1) */
+#define UART_RSA_SRR_Tx_FIFO_NHFL (1 << 1) /* Tx FIFO is not half full (1) */
+#define UART_RSA_SRR_Tx_FIFO_NFUL (1 << 2) /* Tx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NEMP (1 << 3) /* Rx FIFO is not empty (1) */
+#define UART_RSA_SRR_Rx_FIFO_NHFL (1 << 4) /* Rx FIFO is not half full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NFUL (1 << 5) /* Rx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_TOUT (1 << 6) /* Character reception timeout occurred (1) */
+#define UART_RSA_SRR_TIMER (1 << 7) /* Timer interrupt occurred */
+
+#define UART_RSA_FRR ((UART_RSA_BASE) + 2) /* OUT: FIFO Reset Register */
+
+#define UART_RSA_TIVSR ((UART_RSA_BASE) + 3) /* I/O: Timer Interval Value Set Register */
+
+#define UART_RSA_TCR ((UART_RSA_BASE) + 4) /* OUT: Timer Control Register */
+
+#define UART_RSA_TCR_SWITCH (1 << 0) /* Timer on */
+
+/*
+ * The RSA DSV/II board has two fixed clock frequencies.  One is the
+ * standard rate, and the other is 8 times faster.
+ */
+#define SERIAL_RSA_BAUD_BASE (921600)
+#define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
+
+/*
+ * Extra serial register definitions for the internal UARTs
+ * in TI OMAP processors.
+ */
+#define UART_OMAP_MDR1		0x08	/* Mode definition register */
+#define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
+#define UART_OMAP_SCR		0x10	/* Supplementary control register */
+#define UART_OMAP_SSR		0x11	/* Supplementary status register */
+#define UART_OMAP_EBLR		0x12	/* BOF length register */
+#define UART_OMAP_OSC_12M_SEL	0x13	/* OMAP1510 12MHz osc select */
+#define UART_OMAP_MVER		0x14	/* Module version register */
+#define UART_OMAP_SYSC		0x15	/* System configuration register */
+#define UART_OMAP_SYSS		0x16	/* System status register */
+#define UART_OMAP_WER		0x17	/* Wake-up enable register */
+
+/*
+ * These are the definitions for the MDR1 register
+ */
+#define UART_OMAP_MDR1_16X_MODE		0x00	/* UART 16x mode */
+#define UART_OMAP_MDR1_SIR_MODE		0x01	/* SIR mode */
+#define UART_OMAP_MDR1_16X_ABAUD_MODE	0x02	/* UART 16x auto-baud */
+#define UART_OMAP_MDR1_13X_MODE		0x03	/* UART 13x mode */
+#define UART_OMAP_MDR1_MIR_MODE		0x04	/* MIR mode */
+#define UART_OMAP_MDR1_FIR_MODE		0x05	/* FIR mode */
+#define UART_OMAP_MDR1_CIR_MODE		0x06	/* CIR mode */
+#define UART_OMAP_MDR1_DISABLE		0x07	/* Disable (default state) */
+
+/*
+ * These are definitions for the Exar XR17V35X and XR17(C|D)15X
+ */
+#define UART_EXAR_8XMODE	0x88	/* 8X sampling rate select */
+#define UART_EXAR_SLEEP		0x8b	/* Sleep mode */
+#define UART_EXAR_DVID		0x8d	/* Device identification */
+
+#define UART_EXAR_FCTR		0x08	/* Feature Control Register */
+#define UART_FCTR_EXAR_IRDA	0x08	/* IrDa data encode select */
+#define UART_FCTR_EXAR_485	0x10	/* Auto 485 half duplex dir ctl */
+#define UART_FCTR_EXAR_TRGA	0x00	/* FIFO trigger table A */
+#define UART_FCTR_EXAR_TRGB	0x60	/* FIFO trigger table B */
+#define UART_FCTR_EXAR_TRGC	0x80	/* FIFO trigger table C */
+#define UART_FCTR_EXAR_TRGD	0xc0	/* FIFO trigger table D programmable */
+
+#define UART_EXAR_TXTRG		0x0a	/* Tx FIFO trigger level write-only */
+#define UART_EXAR_RXTRG		0x0b	/* Rx FIFO trigger level write-only */
+
+#define UART_OMAP_SCR_TX_EMPTY_CTL_IT 0x08 /* TX Empty IRQ mode */
+
+#endif /* _LINUX_SERIAL_REG_H */
+
diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c
index 11bb9a5..2702dab 100644
--- a/drivers/tty/tty_ioctl.c
+++ b/drivers/tty/tty_ioctl.c
@@ -627,7 +627,7 @@ static int set_termios(struct tty_struct *tty, void __user *arg, int opt)
 	}
 
 	if (opt & TERMIOS_WAIT) {
-		tty_wait_until_sent(tty, 0);
+		tty_wait_until_sent(tty, 5 * HZ); /* Wait 5 seconds in jiffies */
 		if (signal_pending(current))
 			return -ERESTARTSYS;
 	}
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index e6b2071..77ceda1 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -862,7 +862,7 @@ int __uio_register_device(struct module *owner,
 		 * freed until they are released.
 		 */
 		ret = request_irq(info->irq, uio_interrupt,
-				  info->irq_flags, info->name, idev);
+				  info->irq_flags | IRQF_THREAD_TBL_LOOKUP, info->name, idev);
 		if (ret) {
 			info->uio_dev = NULL;
 			goto err_request_irq;
diff --git a/drivers/uio/uio_dmem_genirq.c b/drivers/uio/uio_dmem_genirq.c
index e1134a4..66ce4f7 100644
--- a/drivers/uio/uio_dmem_genirq.c
+++ b/drivers/uio/uio_dmem_genirq.c
@@ -147,6 +147,7 @@ static int uio_dmem_genirq_irqcontrol(struct uio_info *dev_info, s32 irq_on)
 static int uio_dmem_genirq_probe(struct platform_device *pdev)
 {
 	struct uio_dmem_genirq_pdata *pdata = dev_get_platdata(&pdev->dev);
+	struct uio_dmem_genirq_pdata *temp_pdata = 0;
 	struct uio_info *uioinfo = &pdata->uioinfo;
 	struct uio_dmem_genirq_platdata *priv;
 	struct uio_mem *uiomem;
@@ -172,6 +173,40 @@ static int uio_dmem_genirq_probe(struct platform_device *pdev)
 			uioinfo->irq = UIO_IRQ_NONE;
 		else
 			uioinfo->irq = irq;
+
+		/* Allocate a temporary pdata structure into which we can
+		 * read dynamic memory region info from the device tree
+		 * (based on method used in Analog Devices' version of
+		 * this driver) but only if no dynamic memory regions
+		 * already declared.  Make sure the temporary structure
+		 * and its dynamically allocated content is freed
+		 * before this function returns.
+		 */
+		if( !pdata || !pdata->num_dynamic_regions ) {
+			temp_pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+			if (!temp_pdata) {
+				ret = -ENOMEM;
+				dev_err(&pdev->dev, "unable to kmalloc\n");
+				goto bad0;
+			}
+			pdata = temp_pdata;
+			pdata->num_dynamic_regions = 0;
+			of_property_read_u32(pdev->dev.of_node,
+				"uio,number-of-dynamic-regions",
+				&pdata->num_dynamic_regions);
+			pdata->dynamic_region_sizes =
+				kzalloc(sizeof(*pdata->dynamic_region_sizes) *
+					pdata->num_dynamic_regions, GFP_KERNEL);
+			if (!pdata->dynamic_region_sizes) {
+				ret = -ENOMEM;
+				dev_err(&pdev->dev, "unable to kmalloc\n");
+				goto bad0;
+			}
+			of_property_read_u32_array(pdev->dev.of_node,
+				"uio,dynamic-regions-sizes",
+				pdata->dynamic_region_sizes,
+				pdata->num_dynamic_regions);
+		}
 	}
 
 	if (!uioinfo || !uioinfo->name || !uioinfo->version) {
@@ -200,16 +235,28 @@ static int uio_dmem_genirq_probe(struct platform_device *pdev)
 	priv->pdev = pdev;
 	mutex_init(&priv->alloc_lock);
 
+	/* Multiple IRQs are not supported */
 	if (!uioinfo->irq) {
 		ret = platform_get_irq(pdev, 0);
-		if (ret < 0) {
+		uioinfo->irq = ret;
+		if (ret == -ENXIO && pdev->dev.of_node)
+			uioinfo->irq = UIO_IRQ_NONE;
+		else if (ret < 0) {
 			dev_err(&pdev->dev, "failed to get IRQ\n");
 			goto bad1;
 		}
-		uioinfo->irq = ret;
 	}
+
 	uiomem = &uioinfo->mem[0];
 
+	/* dmem_region_start is not necessarily the same as
+	 * num_resources as the resources may include objects
+	 * that are not memory, eg, interrupts, so set
+	 * dmem_region_start to zero here and increment as
+	 * and when we advance uiomem in the following loop
+	 */
+	priv->dmem_region_start = 0;
+
 	for (i = 0; i < pdev->num_resources; ++i) {
 		struct resource *r = &pdev->resource[i];
 
@@ -284,9 +331,16 @@ static int uio_dmem_genirq_probe(struct platform_device *pdev)
  bad1:
 	kfree(priv);
  bad0:
-	/* kfree uioinfo for OF */
-	if (pdev->dev.of_node)
+	/* kfree uioinfo and temp_pdata for OF */
+	if (pdev->dev.of_node) {
+		if (temp_pdata) {
+			if (temp_pdata->dynamic_region_sizes) {
+				kfree(temp_pdata->dynamic_region_sizes);
+			}
+			kfree(temp_pdata);
+		}
 		kfree(uioinfo);
+	}
  bad2:
 	return ret;
 }
@@ -332,10 +386,13 @@ static const struct dev_pm_ops uio_dmem_genirq_dev_pm_ops = {
 };
 
 #ifdef CONFIG_OF
-static const struct of_device_id uio_of_genirq_match[] = {
-	{ /* empty for now */ },
+static struct of_device_id uio_of_genirq_match[] = {
+	{ .compatible = "uio_dmem_genirq" },
+	{ /* end of list */ },
 };
 MODULE_DEVICE_TABLE(of, uio_of_genirq_match);
+module_param_string(of_id, uio_of_genirq_match[0].compatible, 128, 0);
+MODULE_PARM_DESC(of_id, "Openfirmware id of the device to be handled by uio");
 #endif
 
 static struct platform_driver uio_dmem_genirq = {
diff --git a/drivers/uio/uio_pdrv_genirq.c b/drivers/uio/uio_pdrv_genirq.c
index f598ecd..bc6fc21 100644
--- a/drivers/uio/uio_pdrv_genirq.c
+++ b/drivers/uio/uio_pdrv_genirq.c
@@ -148,7 +148,8 @@ static int uio_pdrv_genirq_probe(struct platform_device *pdev)
 	if (!uioinfo->irq) {
 		ret = platform_get_irq(pdev, 0);
 		uioinfo->irq = ret;
-		if (ret == -ENXIO && pdev->dev.of_node)
+		/* -EINVAL is returned if device node attribute is not defined */
+		if ((ret == -ENXIO || ret == -EINVAL) && pdev->dev.of_node)
 			uioinfo->irq = UIO_IRQ_NONE;
 		else if (ret < 0) {
 			dev_err(&pdev->dev, "failed to get IRQ\n");
@@ -178,6 +179,7 @@ static int uio_pdrv_genirq_probe(struct platform_device *pdev)
 		++uiomem;
 	}
 
+	/* htoews: Herr Gleixner empfiehlt diese Zeilen zu loeschen!!! */
 	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
 		uiomem->size = 0;
 		++uiomem;
@@ -253,11 +255,12 @@ static const struct dev_pm_ops uio_pdrv_genirq_dev_pm_ops = {
 
 #ifdef CONFIG_OF
 static struct of_device_id uio_of_genirq_match[] = {
+	{ .compatible = "uio_pdrv_genirq", },
 	{ /* This is filled with module_parm */ },
 	{ /* Sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, uio_of_genirq_match);
-module_param_string(of_id, uio_of_genirq_match[0].compatible, 128, 0);
+module_param_string(of_id, uio_of_genirq_match[1].compatible, 128, 0);
 MODULE_PARM_DESC(of_id, "Openfirmware id of the device to be handled by uio");
 #endif
 
diff --git a/drivers/usb/gadget/legacy/mass_storage.c b/drivers/usb/gadget/legacy/mass_storage.c
index fcba597..cf8526c 100644
--- a/drivers/usb/gadget/legacy/mass_storage.c
+++ b/drivers/usb/gadget/legacy/mass_storage.c
@@ -244,7 +244,7 @@ static int __init msg_init(void)
 {
 	return usb_composite_probe(&msg_driver);
 }
-module_init(msg_init);
+//module_init(msg_init);
 
 static void __exit msg_cleanup(void)
 {
diff --git a/drivers/usb/musb/am35x.c b/drivers/usb/musb/am35x.c
index 50ca805..32d4704 100644
--- a/drivers/usb/musb/am35x.c
+++ b/drivers/usb/musb/am35x.c
@@ -35,6 +35,8 @@
 #include <linux/dma-mapping.h>
 #include <linux/usb/usb_phy_generic.h>
 #include <linux/platform_data/usb-omap.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
 
 #include "musb_core.h"
 
@@ -154,8 +156,10 @@ static void otg_timer(unsigned long _musb)
 	spin_lock_irqsave(&musb->lock, flags);
 	switch (musb->xceiv->otg->state) {
 	case OTG_STATE_A_WAIT_BCON:
-		devctl &= ~MUSB_DEVCTL_SESSION;
-		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+		if (musb->port_mode != MUSB_PORT_MODE_HOST) {
+			devctl &= ~MUSB_DEVCTL_SESSION;
+			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+		}
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 		if (devctl & MUSB_DEVCTL_BDEVICE) {
@@ -462,6 +466,40 @@ static const struct platform_device_info am35x_dev_info = {
 	.dma_mask	= DMA_BIT_MASK(32),
 };
 
+static int of_am35x_probe(struct device_node *np,
+			  struct musb_hdrc_platform_data *pdata)
+{
+	struct musb_hdrc_config *config = pdata->config;
+	struct omap_musb_board_data *data = (struct omap_musb_board_data *)pdata->board_data;
+
+	/* we presume that pdata was already prepared in pdata-quirks.c */
+	if (!of_property_read_u32(np, "mode", (u32 *)&pdata->mode))
+		data->mode = pdata->mode;
+	else
+		goto out_inval;
+
+	if(of_property_read_u32(np, "interface-type",
+				(u32 *)&data->interface_type))
+		goto out_inval;
+
+	if(of_property_read_u32(np, "power", (u32 *)&pdata->power))
+		goto out_inval;
+
+	if(of_property_read_u32(np, "num-eps", (u32 *)&config->num_eps))
+		goto out_inval;
+
+	if(of_property_read_u32(np, "ram-bits", (u32 *)&config->ram_bits))
+		goto out_inval;
+
+	config->multipoint = of_property_read_bool(np, "multipoint");
+
+	return 0;
+
+out_inval:
+
+	return -EINVAL;
+}
+
 static int am35x_probe(struct platform_device *pdev)
 {
 	struct musb_hdrc_platform_data	*pdata = dev_get_platdata(&pdev->dev);
@@ -473,18 +511,21 @@ static int am35x_probe(struct platform_device *pdev)
 
 	int				ret = -ENOMEM;
 
+	if (pdev->dev.of_node)
+		of_am35x_probe(pdev->dev.of_node, pdata);
+
 	glue = kzalloc(sizeof(*glue), GFP_KERNEL);
 	if (!glue)
 		goto err0;
 
-	phy_clk = clk_get(&pdev->dev, "fck");
+	phy_clk = clk_get(&pdev->dev, "hsotgusb_fck");
 	if (IS_ERR(phy_clk)) {
 		dev_err(&pdev->dev, "failed to get PHY clock\n");
 		ret = PTR_ERR(phy_clk);
 		goto err3;
 	}
 
-	clk = clk_get(&pdev->dev, "ick");
+	clk = clk_get(&pdev->dev, "hsotgusb_ick");
 	if (IS_ERR(clk)) {
 		dev_err(&pdev->dev, "failed to get clock\n");
 		ret = PTR_ERR(clk);
@@ -615,12 +656,25 @@ static int am35x_resume(struct device *dev)
 
 static SIMPLE_DEV_PM_OPS(am35x_pm_ops, am35x_suspend, am35x_resume);
 
+#ifdef CONFIG_OF
+static const struct of_device_id am35x_id_table[] = {
+	{
+		.compatible = "ti,musb-am35x"
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, am35x_id_table);
+#endif
+
 static struct platform_driver am35x_driver = {
 	.probe		= am35x_probe,
 	.remove		= am35x_remove,
 	.driver		= {
 		.name	= "musb-am35x",
 		.pm	= &am35x_pm_ops,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(am35x_id_table),
+#endif
 	},
 };
 
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index f1219f6..c1f4896 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -553,16 +553,30 @@ void musb_g_tx(struct musb *musb, u8 epnum)
  */
 static void rxstate(struct musb *musb, struct musb_request *req)
 {
-	const u8		epnum = req->epnum;
-	struct usb_request	*request = &req->request;
+	struct usb_request	*request;
 	struct musb_ep		*musb_ep;
-	void __iomem		*epio = musb->endpoints[epnum].regs;
+	void __iomem		*epio;
 	unsigned		len = 0;
-	u16			fifo_count;
-	u16			csr = musb_readw(epio, MUSB_RXCSR);
-	struct musb_hw_ep	*hw_ep = &musb->endpoints[epnum];
+	u16			fifo_count = 0;
+	u16			csr;
+	struct musb_hw_ep	*hw_ep;
 	u8			use_mode_1;
 
+	if (!musb || !req)
+		return;
+
+	request = &req->request;
+	if (req->epnum >= MUSB_C_NUM_EPS) {
+		return;
+	}
+
+	hw_ep = &musb->endpoints[req->epnum];
+	if (!hw_ep->regs)
+		return;
+
+	epio = hw_ep->regs;
+	csr = musb_readw(epio, MUSB_RXCSR);
+
 	if (hw_ep->is_shared_fifo)
 		musb_ep = &hw_ep->ep_in;
 	else
@@ -589,7 +603,7 @@ static void rxstate(struct musb *musb, struct musb_request *req)
 		return;
 	}
 
-	if (is_cppi_enabled(musb) && is_buffer_mapped(req)) {
+	if (is_cppi_enabled(musb) && is_buffer_mapped(req) && musb->dma_controller) {
 		struct dma_controller	*c = musb->dma_controller;
 		struct dma_channel	*channel = musb_ep->dma;
 
@@ -631,7 +645,7 @@ static void rxstate(struct musb *musb, struct musb_request *req)
 			use_mode_1 = 0;
 
 		if (request->actual < request->length) {
-			if (!is_buffer_mapped(req))
+			if (!(is_buffer_mapped(req) && musb->dma_controller))
 				goto buffer_aint_mapped;
 
 			if (musb_dma_inventra(musb)) {
@@ -766,7 +780,7 @@ static void rxstate(struct musb *musb, struct musb_request *req)
 
 			fifo_count = min_t(unsigned, len, fifo_count);
 
-			if (tusb_dma_omap(musb)) {
+			if (tusb_dma_omap(musb) && musb->dma_controller) {
 				struct dma_controller *c = musb->dma_controller;
 				struct dma_channel *channel = musb_ep->dma;
 				u32 dma_addr = request->dma + request->actual;
@@ -825,11 +839,18 @@ void musb_g_rx(struct musb *musb, u8 epnum)
 	u16			csr;
 	struct musb_request	*req;
 	struct usb_request	*request;
-	void __iomem		*mbase = musb->mregs;
+	void __iomem		*mbase;
 	struct musb_ep		*musb_ep;
-	void __iomem		*epio = musb->endpoints[epnum].regs;
+	void __iomem		*epio;
 	struct dma_channel	*dma;
-	struct musb_hw_ep	*hw_ep = &musb->endpoints[epnum];
+	struct musb_hw_ep	*hw_ep;
+
+	if (!musb || (epnum >= MUSB_C_NUM_EPS))
+		return;
+
+	mbase = musb->mregs;
+	epio = musb->endpoints[epnum].regs;
+	hw_ep = &musb->endpoints[epnum];
 
 	if (hw_ep->is_shared_fifo)
 		musb_ep = &hw_ep->ep_in;
@@ -886,7 +907,7 @@ void musb_g_rx(struct musb *musb, u8 epnum)
 		musb_writew(epio, MUSB_RXCSR,
 			MUSB_RXCSR_P_WZC_BITS | csr);
 
-		request->actual += musb_ep->dma->actual_len;
+		request->actual += dma->actual_len;
 
 #if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_TUSB_OMAP_DMA) || \
 	defined(CONFIG_USB_UX500_DMA)
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 2b81939..b8c83a3 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -78,6 +78,11 @@ static void option_instat_callback(struct urb *urb);
 #define OPTION_PRODUCT_ETNA_KOI_MODEM		0x7100
 #define OPTION_PRODUCT_GTM380_MODEM		0x7201
 
+/* added by wago */
+#define QUECTEL_VENDOR_ID			0x05c6
+#define QUECTEL_PRODUCT_UC20			0x9003
+#define QUECTEL_PRODUCT_EC20			0x9215
+
 #define HUAWEI_VENDOR_ID			0x12D1
 #define HUAWEI_PRODUCT_E173			0x140C
 #define HUAWEI_PRODUCT_E1750			0x1406
@@ -566,6 +571,8 @@ static void option_instat_callback(struct urb *urb);
 
 
 static const struct usb_device_id option_ids[] = {
+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_UC20) },
+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC20) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA_LIGHT) },
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index fb6dc16..81c8708 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -117,6 +117,8 @@ static const struct usb_device_id id_table[] = {
 	{USB_DEVICE(0x05c6, 0x9205)},	/* Gobi 2000 Modem device */
 
 	/* Gobi 3000 devices */
+	{USB_DEVICE(0x05c6, 0x9003)},	/* Gobi 3000 Modem device */
+	{USB_DEVICE(0x05c6, 0x9215)},	/* Gobi 3000 Modem device */
 	{USB_DEVICE(0x03f0, 0x371d)},	/* HP un2430 Gobi 3000 QDL */
 	{USB_DEVICE(0x05c6, 0x920c)},	/* Gobi 3000 QDL */
 	{USB_DEVICE(0x05c6, 0x920d)},	/* Gobi 3000 Composite */
diff --git a/drivers/watchdog/gpio_wdt.c b/drivers/watchdog/gpio_wdt.c
index 93457ca..555f271 100644
--- a/drivers/watchdog/gpio_wdt.c
+++ b/drivers/watchdog/gpio_wdt.c
@@ -27,7 +27,9 @@ enum {
 
 struct gpio_wdt_priv {
 	int			gpio;
+	int			gpio_en;
 	bool			active_low;
+	bool			active_low_en;
 	bool			state;
 	bool			always_running;
 	bool			armed;
@@ -42,9 +44,16 @@ static void gpio_wdt_disable(struct gpio_wdt_priv *priv)
 {
 	gpio_set_value_cansleep(priv->gpio, !priv->active_low);
 
+	pr_info("%s-%d\n", __func__, __LINE__);
 	/* Put GPIO back to tristate */
 	if (priv->hw_algo == HW_ALGO_TOGGLE)
 		gpio_direction_input(priv->gpio);
+
+	/* Turn the WDT off if supported by HW */
+	if (gpio_is_valid(priv->gpio_en)) {
+		gpio_direction_output(priv->gpio_en, priv->active_low_en);
+		pr_info("%s-%d\n", __func__, __LINE__);
+	}
 }
 
 static void gpio_wdt_hwping(unsigned long data)
@@ -52,6 +61,8 @@ static void gpio_wdt_hwping(unsigned long data)
 	struct watchdog_device *wdd = (struct watchdog_device *)data;
 	struct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);
 
+	pr_info("%s-%d\n", __func__, __LINE__);
+
 	if (priv->armed && time_after(jiffies, priv->last_jiffies +
 				      msecs_to_jiffies(wdd->timeout * 1000))) {
 		dev_crit(wdd->parent,
@@ -64,11 +75,13 @@ static void gpio_wdt_hwping(unsigned long data)
 
 	switch (priv->hw_algo) {
 	case HW_ALGO_TOGGLE:
+		pr_info("%s-%d\n", __func__, __LINE__);
 		/* Toggle output pin */
 		priv->state = !priv->state;
 		gpio_set_value_cansleep(priv->gpio, priv->state);
 		break;
 	case HW_ALGO_LEVEL:
+		pr_info("%s-%d\n", __func__, __LINE__);
 		/* Pulse */
 		gpio_set_value_cansleep(priv->gpio, !priv->active_low);
 		udelay(1);
@@ -79,10 +92,18 @@ static void gpio_wdt_hwping(unsigned long data)
 
 static void gpio_wdt_start_impl(struct gpio_wdt_priv *priv)
 {
+	/* Turn the WDT on if supported by HW */
+	if (gpio_is_valid(priv->gpio_en)) {
+		pr_info("%s-%d\n", __func__, __LINE__);
+		gpio_direction_output(priv->gpio_en, !priv->active_low_en);
+	}
+
 	priv->state = priv->active_low;
 	gpio_direction_output(priv->gpio, priv->state);
 	priv->last_jiffies = jiffies;
 	gpio_wdt_hwping((unsigned long)&priv->wdd);
+
++	pr_info("%s-%d\n", __func__, __LINE__);
 }
 
 static int gpio_wdt_start(struct watchdog_device *wdd)
@@ -101,10 +122,11 @@ static int gpio_wdt_stop(struct watchdog_device *wdd)
 
 	priv->armed = false;
 	if (!priv->always_running) {
-		mod_timer(&priv->timer, 0);
+                mod_timer_pending(&priv->timer, 0);
 		gpio_wdt_disable(priv);
 	}
 
++	pr_info("%s-%d\n", __func__, __LINE__);
 	return 0;
 }
 
@@ -112,6 +134,7 @@ static int gpio_wdt_ping(struct watchdog_device *wdd)
 {
 	struct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);
 
+	pr_info("%s-%d\n", __func__, __LINE__);
 	priv->last_jiffies = jiffies;
 
 	return 0;
@@ -119,6 +142,7 @@ static int gpio_wdt_ping(struct watchdog_device *wdd)
 
 static int gpio_wdt_set_timeout(struct watchdog_device *wdd, unsigned int t)
 {
+	pr_info("%s-%d\n", __func__, __LINE__);
 	wdd->timeout = t;
 
 	return gpio_wdt_ping(wdd);
@@ -159,6 +183,13 @@ static int gpio_wdt_probe(struct platform_device *pdev)
 
 	priv->active_low = flags & OF_GPIO_ACTIVE_LOW;
 
+	priv->gpio_en = of_get_named_gpio_flags(pdev->dev.of_node, "gpio-en", 0, &flags);
+	if (!gpio_is_valid(priv->gpio_en)) {
+		dev_err(&pdev->dev, "gpio-en property not found. Assume WDT is already enabled.\n");
+	}
+
+	priv->active_low_en = flags & OF_GPIO_ACTIVE_LOW;
+
 	ret = of_property_read_string(pdev->dev.of_node, "hw_algo", &algo);
 	if (ret)
 		return ret;
@@ -177,6 +208,15 @@ static int gpio_wdt_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
+	/* request WDT EN gpio if provided by HW */
+	if (gpio_is_valid(priv->gpio_en)) {
+		f = priv->active_low_en ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
+		ret = devm_gpio_request_one(&pdev->dev, priv->gpio_en, f,
+					    dev_name(&pdev->dev));
+		if (ret)
+			return ret;
+	}
+
 	ret = of_property_read_u32(pdev->dev.of_node,
 				   "hw_margin_ms", &hw_margin);
 	if (ret)
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index 480972a..003ee89 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -78,6 +78,12 @@
 #define IRQF_COND_SUSPEND	0x00040000
 #define IRQF_NO_SOFTIRQ_CALL	0x00080000
 
+/* PFCxxx Flag to lookup IRQ Thread priority in table
+ * defined in kernel/irq/wsysinit-prio-table.c
+ */
+#define IRQF_THREAD_TBL_LOOKUP	0x00080000
+
+
 #define IRQF_TIMER		(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)
 
 /*
diff --git a/include/linux/ksz8863.h b/include/linux/ksz8863.h
new file mode 100644
index 0000000..b186155
--- /dev/null
+++ b/include/linux/ksz8863.h
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2010 SAGEM Communications.
+ *
+ * Author: Karl Beldan <karl.beldan@sagemcom.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef KSZ8863_H
+#define KSZ8863_H
+
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+#define KSZ8863_FAMILY_ID               0x88
+#define KSZ8863_CHIP_ID                 0x03
+#define KSZ8863_PHYID1                  0x0022
+#define KSZ8863_PHYID2                  0x1430
+#define KSZ8863_PORTS_REGS_OFFSET       16
+
+#define KSZ8863_PHY1_DFLT_ADDR          1
+#define KSZ8863_PHY2_DFLT_ADDR          2
+
+#define KSZ8863_MDIO_MIN                MII_BMCR
+#define KSZ8863_MDIO_MAX                MII_LPA
+
+#define RESET_SOFTWARE_SHIFT            4
+#define RESET_PCS_SHIFT                 0
+
+#ifdef __KERNEL__
+#define ksz8863_nread                   ksz8863_fns->nread
+#define ksz8863_nwrite                  ksz8863_fns->nwrite
+
+#define KSZ8863_CHRDEV_NAME             "swcfg"
+
+#define KSZ8863_CFG_TAIL_TAG_FLAG       (1 << 0)
+#define KSZ8863_CFG_PWRDOWN_FLAG        (1 << 1)
+#define KSZ8863_CFG_DSA_FLAGS           KSZ8863_CFG_TAIL_TAG_FLAG
+
+struct ksz8863_fns_t {
+        int (*nread)(u8 reg, u8 *rxbuf, int len);
+        int (*nwrite)(u8 reg, u8 *txbuf, int len);
+        int (*setup_dflt_cfg)(int flags);
+};
+extern struct ksz8863_fns_t *ksz8863_fns;
+
+
+struct ksz8863_pdata_t {
+        int tail_tag;
+        int intrn_pin;
+	int reset_pin;
+	struct device *mii_bus;
+};
+#endif
+
+/* enum from sources.blackfin.uclinux.org/net/dsa/ksz8893.h with ksz8863 bits */
+enum switch_reg {
+        /* Global Registers: 0-15 */
+        ChipID0 = 0,
+        ChipID1,
+        GlobalControl0,
+        GlobalControl1,
+        GlobalControl2, /* 4 */
+        GlobalControl3,
+        GlobalControl4,
+        GlobalControl5,
+        GlobalControl6, /* 8 */
+        GlobalControl7,
+        GlobalControl8,
+        GlobalControl9,
+        GlobalControl10, /* 12 */
+        GlobalControl11,
+        GlobalControl12,
+        GlobalControl13,
+
+        /* Port Registers: 16-95 */
+        Port1Control0 = 16,
+        Port1Control1,
+        Port1Control2,
+        Port1Control3,
+        Port1Control4, /* 20 */
+        Port1Control5,
+        Port1Control6,
+        Port1Control7,
+        Port1Control8, /* 24 */
+        Port1Control9,
+        Port1Control10,
+        Port1Control11,
+        Port1Control12, /* 28 */
+        Port1Control13,
+        Port1Status0,
+        Port1Status1,
+
+        Port2Control0, /* 32 */
+        Port2Control1,
+        Port2Control2,
+        Port2Control3,
+        Port2Control4, /* 36 */
+        Port2Control5,
+        Port2Control6,
+        Port2Control7,
+        Port2Control8, /* 40 */
+        Port2Control9,
+        Port2Control10,
+        Port2Control11,
+        Port2Control12, /* 44 */
+        Port2Control13,
+        Port2Status0,
+        Port2Status1,
+
+        Port3Control0, /* 48 */
+        Port3Control1,
+        Port3Control2,
+        Port3Control3,
+        Port3Control4, /* 52 */
+        Port3Control5,
+        Port3Control6,
+        Port3Control7,
+        Port3Control8, /* 56 */
+        Port3Control9,
+        Reservednotappliedtoport3, /* 58-62 */
+        Port3Status1 = 63,
+
+        /* ksz8863 specific */
+        Reset = 67,
+
+        TOSPriorityControlRegister0 = 96,
+        TOSPriorityControlRegister1,
+        TOSPriorityControlRegister2,
+        TOSPriorityControlRegister3,
+        TOSPriorityControlRegister4, /* 100 */
+        TOSPriorityControlRegister5,
+        TOSPriorityControlRegister6,
+        TOSPriorityControlRegister7,
+        TOSPriorityControlRegister8, /* 104 */
+        TOSPriorityControlRegister9,
+        TOSPriorityControlRegister10,
+        TOSPriorityControlRegister11,
+        TOSPriorityControlRegister12, /* 108 */
+        TOSPriorityControlRegister13,
+        TOSPriorityControlRegister14,
+        TOSPriorityControlRegister15,
+
+        IndirectAccessControl0 = 121,
+        IndirectAccessControl1,
+        IndirectDataRegister8,
+        IndirectDataRegister7, /* 124 */
+        IndirectDataRegister6,
+        IndirectDataRegister5,
+        IndirectDataRegister4,
+        IndirectDataRegister3, /* 128 */
+        IndirectDataRegister2,
+        IndirectDataRegister1,
+        IndirectDataRegister0,
+
+        Port3EgressRateLimitQ0 = 162,
+        Port3EgressRateLimitQ1,
+        Port3EgressRateLimitQ2,
+        Port3EgressRateLimitQ3,
+
+        Port1TxqSplitForQ0 = 175,
+        Port1TxqSplitForQ1,
+        Port1TxqSplitForQ2,
+        Port1TxqSplitForQ3,
+        Port2TxqSplitForQ0,
+        Port2TxqSplitForQ1, /* 180 */
+        Port2TxqSplitForQ2,
+        Port2TxqSplitForQ3,
+        Port3TxqSplitForQ0,
+        Port3TxqSplitForQ1, /* 184 */
+        Port3TxqSplitForQ2,
+        Port3TxqSplitForQ3,
+
+        InterruptEnable = 187,
+        LinkChangeInterrupt,
+
+	Internal1v8ldoControl = 193,
+        InsertSrcPvid,
+        PowerManagementLedMode,
+
+	ForwardInvalidVIDFrameandHostMode = 198,
+};
+
+#endif /* KSZ8863_H */
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 37dc2de..35862cc 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -2515,7 +2515,11 @@ DECLARE_PER_CPU(int, xmit_recursion);
 
 static inline int dev_recursion_level(void)
 {
+#ifdef CONFIG_PREEMPT_RT_FULL
+	return atomic_read(&current->xmit_recursion);
+#else
 	return this_cpu_read(xmit_recursion);
+#endif
 }
 
 static inline int xmit_rec_read(void)
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 867110c..cfac36d 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -147,6 +147,7 @@ static inline const char *phy_modes(phy_interface_t interface)
 /* Or MII_ADDR_C45 into regnum for read/write on mii_bus to enable the 21 bit
    IEEE 802.3ae clause 45 addressing mode used by 10GIGE phy chips. */
 #define MII_ADDR_C45 (1<<30)
+#define MII_ADDR_KSZ (1<<15)	/* Special Treatment for KSZ8863 3-Port Switch */
 
 struct device;
 struct sk_buff;
diff --git a/include/linux/platform_data/gpio-omap.h b/include/linux/platform_data/gpio-omap.h
index cb26181..ff43e01 100644
--- a/include/linux/platform_data/gpio-omap.h
+++ b/include/linux/platform_data/gpio-omap.h
@@ -198,7 +198,6 @@ struct omap_gpio_platform_data {
 	int bank_width;		/* GPIO bank width */
 	int bank_stride;	/* Only needed for omap1 MPUIO */
 	bool dbck_flag;		/* dbck required or not - True for OMAP3&4 */
-	bool loses_context;	/* whether the bank would ever lose context */
 	bool is_mpuio;		/* whether the bank is of type MPUIO */
 	u32 non_wakeup_gpios;
 
diff --git a/include/linux/platform_data/pfc-modbus-rtu.h b/include/linux/platform_data/pfc-modbus-rtu.h
new file mode 100644
index 0000000..f45e3c7
--- /dev/null
+++ b/include/linux/platform_data/pfc-modbus-rtu.h
@@ -0,0 +1,74 @@
+/*------------------------------------------------------------------------------
+ * Copyright (c) WAGO Kontakttechnik GmbH & Co. KG
+ *
+ * PROPRIETARY RIGHTS are involved in the subject matter of this material. All
+ * manufacturing, reproduction, use and sales rights pertaining to this
+ * subject matter are governed by the license agreement. The recipient of this
+ * software implicitly accepts the terms of the license.
+ *------------------------------------------------------------------------------
+ *------------------------------------------------------------------------------
+ *   \file     pfc-modbus-rtu.h
+ *
+ *   \version  0.1
+ *
+ *   \brief    <short description of the file contents>
+ *
+ *   \author   Timur Celik : WAGO Kontakttechnik GmbH & Co. KG
+ *------------------------------------------------------------------------------
+ */
+
+#ifndef PFC_MODBUS_RTU_H_
+#define PFC_MODBUS_RTU_H_
+#ifdef CONFIG_SERIAL_OMAP_MODBUS
+
+
+#include <asm/atomic.h>
+#include <linux/kfifo.h>
+#include <linux/hrtimer.h>
+#include <linux/interrupt.h>
+
+#define MB_TIMESTAMP_LENGTH	8
+#define MB_FRAME_MAX		256
+#define MB_FRAME_MIN		4
+
+/* State machine definition */
+typedef enum { ERR, IF, IC } MB_STATE;
+
+/* Modbus specific data of the uart port */
+struct modbus_port
+{
+	MB_STATE		state;
+	struct hrtimer		timer;
+	struct kfifo		frame;
+	struct kfifo		length;	  /* contains frame length */
+	atomic_t		ch_cnt;
+	atomic_t		frame_cnt;
+	u8			slave_id; /* if zero all frames are received
+					     (master mode) */
+	u64			to_15;
+	u64			to_35;
+	u64			to_15_override;
+	u64			to_35_override;
+	bool			activated;
+	unsigned int		modem_status;
+	struct tasklet_struct	rx_tsklt;
+	struct tasklet_struct	tx_tsklt;
+	struct tasklet_struct	mdr_tsklt;
+	bool			timestamp_enabled;
+};
+
+struct uart_omap_port;
+
+enum hrtimer_restart modbus_omap_to_handler(struct hrtimer* hrt);
+int modbus_omap_rhr_handler(struct uart_omap_port *up);
+int modbus_omap_rlsi_handler(struct uart_omap_port *up, unsigned int lsr);
+void modbus_omap_calc_to(struct uart_omap_port *up, unsigned int baud);
+int modbus_omap_enable(struct uart_omap_port *up);
+int modbus_omap_disable(struct uart_omap_port *up);
+int modbus_omap_startup(struct uart_omap_port *up);
+void modbus_omap_shutdown(struct uart_omap_port *up);
+void modbus_omap_timestamp_enable(struct uart_omap_port *up);
+void modbus_omap_timestamp_disable(struct uart_omap_port *up);
+
+#endif
+#endif /* PFC_MODBUS_RTU_H_ */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 3c2472c..9f430393 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1422,6 +1422,9 @@ struct sched_rt_entity {
 	/* rq "owned" by this entity/group: */
 	struct rt_rq		*my_q;
 #endif
+#ifdef CONFIG_PREEMPT_RT_FULL
+	atomic_t xmit_recursion;
+#endif
 };
 
 struct sched_dl_entity {
diff --git a/include/linux/switch.h b/include/linux/switch.h
new file mode 100644
index 0000000..258cc6d
--- /dev/null
+++ b/include/linux/switch.h
@@ -0,0 +1,254 @@
+/*
+ * switch.h: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_SWITCH_H
+#define __LINUX_SWITCH_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <linux/genetlink.h>
+#ifndef __KERNEL__
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+#else
+#include <net/genetlink.h>
+#endif
+
+/* main attributes */
+enum {
+	SWITCH_ATTR_UNSPEC,
+	/* global */
+	SWITCH_ATTR_TYPE,
+	/* device */
+	SWITCH_ATTR_ID,
+	SWITCH_ATTR_DEV_NAME,
+	SWITCH_ATTR_ALIAS,
+	SWITCH_ATTR_NAME,
+	SWITCH_ATTR_VLANS,
+	SWITCH_ATTR_PORTS,
+	SWITCH_ATTR_PORTMAP,
+	SWITCH_ATTR_CPU_PORT,
+	/* attributes */
+	SWITCH_ATTR_OP_ID,
+	SWITCH_ATTR_OP_TYPE,
+	SWITCH_ATTR_OP_NAME,
+	SWITCH_ATTR_OP_PORT,
+	SWITCH_ATTR_OP_VLAN,
+	SWITCH_ATTR_OP_VALUE_INT,
+	SWITCH_ATTR_OP_VALUE_STR,
+	SWITCH_ATTR_OP_VALUE_PORTS,
+	SWITCH_ATTR_OP_DESCRIPTION,
+	/* port lists */
+	SWITCH_ATTR_PORT,
+	SWITCH_ATTR_MAX
+};
+
+enum {
+	/* port map */
+	SWITCH_PORTMAP_PORTS,
+	SWITCH_PORTMAP_SEGMENT,
+	SWITCH_PORTMAP_VIRT,
+	SWITCH_PORTMAP_MAX
+};
+
+/* commands */
+enum {
+	SWITCH_CMD_UNSPEC,
+	SWITCH_CMD_GET_SWITCH,
+	SWITCH_CMD_NEW_ATTR,
+	SWITCH_CMD_LIST_GLOBAL,
+	SWITCH_CMD_GET_GLOBAL,
+	SWITCH_CMD_SET_GLOBAL,
+	SWITCH_CMD_LIST_PORT,
+	SWITCH_CMD_GET_PORT,
+	SWITCH_CMD_SET_PORT,
+	SWITCH_CMD_LIST_VLAN,
+	SWITCH_CMD_GET_VLAN,
+	SWITCH_CMD_SET_VLAN
+};
+
+/* data types */
+enum switch_val_type {
+	SWITCH_TYPE_UNSPEC,
+	SWITCH_TYPE_INT,
+	SWITCH_TYPE_STRING,
+	SWITCH_TYPE_PORTS,
+	SWITCH_TYPE_NOVAL,
+};
+
+/* port nested attributes */
+enum {
+	SWITCH_PORT_UNSPEC,
+	SWITCH_PORT_ID,
+	SWITCH_PORT_FLAG_TAGGED,
+	SWITCH_PORT_ATTR_MAX
+};
+
+#define SWITCH_ATTR_DEFAULTS_OFFSET	0x1000
+
+#ifdef __KERNEL__
+
+struct switch_dev;
+struct switch_op;
+struct switch_val;
+struct switch_attr;
+struct switch_attrlist;
+struct switch_led_trigger;
+
+int register_switch(struct switch_dev *dev, struct net_device *netdev);
+void unregister_switch(struct switch_dev *dev);
+
+/**
+ * struct switch_attrlist - attribute list
+ *
+ * @n_attr: number of attributes
+ * @attr: pointer to the attributes array
+ */
+struct switch_attrlist {
+	int n_attr;
+	const struct switch_attr *attr;
+};
+
+enum switch_port_speed {
+	SWITCH_PORT_SPEED_UNKNOWN = 0,
+	SWITCH_PORT_SPEED_10 = 10,
+	SWITCH_PORT_SPEED_100 = 100,
+	SWITCH_PORT_SPEED_1000 = 1000,
+};
+
+struct switch_port_link {
+	bool link;
+	bool duplex;
+	bool aneg;
+	bool tx_flow;
+	bool rx_flow;
+	enum switch_port_speed speed;
+};
+
+struct switch_port_stats {
+	unsigned long tx_bytes;
+	unsigned long rx_bytes;
+};
+
+/**
+ * struct switch_dev_ops - switch driver operations
+ *
+ * @attr_global: global switch attribute list
+ * @attr_port: port attribute list
+ * @attr_vlan: vlan attribute list
+ *
+ * Callbacks:
+ *
+ * @get_vlan_ports: read the port list of a VLAN
+ * @set_vlan_ports: set the port list of a VLAN
+ *
+ * @get_port_pvid: get the primary VLAN ID of a port
+ * @set_port_pvid: set the primary VLAN ID of a port
+ *
+ * @apply_config: apply all changed settings to the switch
+ * @reset_switch: resetting the switch
+ */
+struct switch_dev_ops {
+	struct switch_attrlist attr_global, attr_port, attr_vlan;
+
+	int (*get_vlan_ports)(struct switch_dev *dev, struct switch_val *val);
+	int (*set_vlan_ports)(struct switch_dev *dev, struct switch_val *val);
+
+	int (*get_port_pvid)(struct switch_dev *dev, int port, int *val);
+	int (*set_port_pvid)(struct switch_dev *dev, int port, int val);
+
+	int (*apply_config)(struct switch_dev *dev);
+	int (*reset_switch)(struct switch_dev *dev);
+
+	int (*get_port_link)(struct switch_dev *dev, int port,
+			     struct switch_port_link *link);
+	int (*get_port_stats)(struct switch_dev *dev, int port,
+			      struct switch_port_stats *stats);
+};
+
+struct switch_dev {
+	struct device_node *of_node;
+	const struct switch_dev_ops *ops;
+	/* will be automatically filled */
+	char devname[IFNAMSIZ];
+
+	const char *name;
+	/* NB: either alias or netdev must be set */
+	const char *alias;
+	struct net_device *netdev;
+	struct mii_bus *mii_bus;
+
+	int ports;
+	int vlans;
+	int cpu_port;
+
+	/* the following fields are internal for swconfig */
+	int id;
+	struct list_head dev_list;
+	unsigned long def_global, def_port, def_vlan;
+
+	struct mutex sw_mutex;
+	struct switch_port *portbuf;
+	struct switch_portmap *portmap;
+
+	char buf[128];
+
+#ifdef CONFIG_SWCONFIG_LEDS
+	struct switch_led_trigger *led_trigger;
+#endif
+};
+
+struct switch_port {
+	u32 id;
+	u32 flags;
+};
+
+struct switch_portmap {
+	u32 virt;
+	const char *s;
+};
+
+struct switch_val {
+	const struct switch_attr *attr;
+	int port_vlan;
+	int len;
+	union {
+		const char *s;
+		u32 i;
+		struct switch_port *ports;
+	} value;
+};
+
+struct switch_attr {
+	int disabled;
+	int type;
+	const char *name;
+	const char *description;
+
+	int (*set)(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val);
+	int (*get)(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val);
+
+	/* for driver internal use */
+	int id;
+	int ofs;
+	int max;
+};
+
+#endif
+
+#endif
diff --git a/include/linux/tty.h b/include/linux/tty.h
index fe1b862..1cff37e 100644
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@ -357,6 +357,7 @@ struct tty_file_private {
 #define TTY_HUPPED 		18	/* Post driver->hangup() */
 #define TTY_HUPPING		19	/* Hangup in progress */
 #define TTY_LDISC_HALTED	22	/* Line discipline is halted */
+#define TTY_IGNORE_FLUSH	23	/* flag to prevent flushing of chars */
 
 /* Values for tty->flow_change */
 #define TTY_THROTTLE_SAFE 1
diff --git a/include/misc/wago-tests.h b/include/misc/wago-tests.h
new file mode 100644
index 0000000..a57bc28
--- /dev/null
+++ b/include/misc/wago-tests.h
@@ -0,0 +1,30 @@
+#ifndef _WAGO_TESTS_H_
+#define _WAGO_TESTS_H_
+
+#define WAGO_TEST_DEBUG
+
+#ifdef WAGO_TEST_DEBUG
+#define pac_kdebug(format, arg...)	\
+	printk(KERN_INFO "pac-kdebug: " format , ## arg)
+#else
+#define pac_kdebug(format, arg...)       \
+	({ if (0) printk(KERN_INFO "pac-kdebug: " format , ## arg); 0; })
+#endif
+
+#include <linux/gpio.h>
+#include <linux/time.h>
+
+#define WAGO_TEST__MAX_MEASUREMENTS       20
+#define WAGO_TEST__GPIO                  175  	/* FB-nINT_GPIO175 */
+
+struct wago_trace_data {
+	struct timespec mpoints[WAGO_TEST__MAX_MEASUREMENTS];
+	int mpoint_index;
+};
+
+extern void wago_tests_init(struct wago_trace_data *tdata, u8 gpios_enable);
+extern void wago_tests_deinit(void);
+extern void wago_measure_reset(void);
+extern void wago_mpoint(void);
+
+#endif /* _WAGO_TESTS_H_ */
diff --git a/include/trace/events/dsa.h b/include/trace/events/dsa.h
new file mode 100644
index 0000000..958a9f0
--- /dev/null
+++ b/include/trace/events/dsa.h
@@ -0,0 +1,50 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM dsa
+
+#if !defined(_TRACE_DSA_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_DSA_H
+
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/ip.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(net_dsa_info,
+
+	TP_PROTO(struct sk_buff *skb,
+		 unsigned int skb_len,
+		 struct net_device *dev,
+		 int dsa_port,
+		 const char* func,
+		 char* msg),
+
+        TP_ARGS(skb, skb_len, dev, dsa_port, func, msg),
+
+	TP_STRUCT__entry(
+		__field(	void *,		skbaddr		)
+		__field(	unsigned int,	len		)
+		__field(	int,		dsa_port	)
+		__string(	name,		dev->name	)
+		__string(	funcstr,        func	        )
+		__string(	comment,	msg	        )
+	),
+
+	TP_fast_assign(
+		__entry->skbaddr = skb;
+		__entry->len = skb_len;
+		__entry->dsa_port = dsa_port;
+		__assign_str(name, dev->name);
+		__assign_str(funcstr, func);
+		__assign_str(comment, msg);
+	),
+
+	TP_printk("%s|dsa-port-%d: %s-skb@%p:%u [%s] ",
+		  __get_str(funcstr), __entry->dsa_port,
+		  __get_str(name), __entry->skbaddr,
+		  __entry->len, __get_str(comment))
+);
+
+#endif /* _TRACE_DSA_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/trace/events/pxc.h b/include/trace/events/pxc.h
new file mode 100644
index 0000000..93beebc
--- /dev/null
+++ b/include/trace/events/pxc.h
@@ -0,0 +1,367 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM pxc
+
+#if !defined(_TRACE_PXC_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_PXC_H
+
+#include <linux/tracepoint.h>
+
+#ifdef PFC_CLOCK_TRACER
+TRACE_EVENT(pfc_clock, 	/* trace pfc clock events */
+
+	    TP_PROTO(cycle_t cycle_now, cycle_t cycle_delta, struct timekeeper *tk, s64 nsec, char *msg),
+
+	    TP_ARGS(cycle_now, cycle_delta, tk, nsec, msg),
+
+	TP_STRUCT__entry(
+		__field(cycle_t, cycle_now)
+		__field(cycle_t, cycle_delta)
+		__field(s64, nsec)
+		__field(u32, mult)
+		__field(u32, shift)
+		__field(u64, xtime_nsec)
+		__array(char, msg, 128)
+	),
+
+	TP_fast_assign(
+	        __entry->cycle_now = cycle_now;
+		__entry->cycle_delta = cycle_delta;
+		__entry->nsec = nsec;
+		__entry->mult = tk->mult;
+		__entry->shift = tk->shift;
+		__entry->xtime_nsec = tk->xtime_nsec;
+		strncpy(         __entry->msg, msg,                128);
+	),
+
+	TP_printk("%llu d:%llu->%lli|%u|%u|%llu|%s",
+		  __entry->cycle_now, __entry->cycle_delta, __entry->nsec,
+		  __entry->mult, __entry->shift, __entry->xtime_nsec,
+		  __entry->msg)
+);
+#endif
+
+#if defined(PXC_ETH_EMAC)
+TRACE_EVENT(pxc_eth_emac, 	/* trace davinci_emac events */
+
+	TP_PROTO(struct emac_priv *priv, char *msg),
+
+	TP_ARGS(priv, msg),
+
+	TP_STRUCT__entry(
+		__field(unsigned, link)
+		__field(unsigned, speed)
+		__field(unsigned, duplex)
+		__array(char, phy_id, 32)
+		__array(char, other_phy_id, 32)
+		__array(char, msg, 128)
+		__array(char, devname, 64)
+	),
+
+	TP_fast_assign(
+		__entry->link   = priv->link;
+		__entry->speed  = priv->speed;
+		__entry->duplex = priv->duplex;
+		strncpy(      __entry->phy_id, priv->phy_id,        32);
+		strncpy(__entry->other_phy_id, priv->other_phy_id,  32);
+		strncpy(         __entry->msg, msg,                128);
+		if (priv->ndev)
+			strncpy(__entry->devname, priv->ndev->name, 64);
+	),
+
+	TP_printk("%6s 1-%s 2-%s: %4s|%d/%4s %s", __entry->devname, __entry->phy_id,  __entry->other_phy_id,
+		  __entry->link ? "UP" : "DOWN", __entry->speed, __entry->duplex == 1 ? "Full" : "Half",
+		  __entry->msg)
+);
+
+TRACE_EVENT(pxc_eth_emac_phy,	/* trace phy events */
+
+	TP_PROTO(struct phy_device *phydev, char *msg),
+
+        TP_ARGS(phydev, msg),
+
+	TP_STRUCT__entry(
+		__array(char, msg, 128)
+		__array(char, phyname, 16)
+		__field(int, link)
+		__field(int, speed)
+		__field(int, duplex) /* DUPLEX_HALF=0, DUPLEX_FULL=1 */
+		__field(int, state)
+		__field(int, irq)
+		__array(char, devname, 64)
+		__field(u32, dev_flags)
+	),
+
+	TP_fast_assign(
+		if (phydev->attached_dev)
+			strncpy(__entry->devname, phydev->attached_dev->name, 64);
+		strncpy(__entry->msg, msg, 128);
+		strncpy(__entry->phyname, dev_name(&phydev->dev), 16);
+	        __entry->link = phydev->link;
+		__entry->speed = phydev->speed;
+		__entry->duplex = phydev->duplex;
+		__entry->state = phydev->state;
+		__entry->irq = phydev->irq;
+		__entry->dev_flags = phydev->dev_flags;
+	),
+
+	TP_printk("%6s(%s) %4s|%d/%4s|%d|%d|%u %s", __entry->devname, __entry->phyname,
+		  __entry->link ? "UP" : "DOWN", __entry->speed, __entry->duplex == 1 ? "Full" : "Half",
+		  __entry->state, __entry->irq, __entry->dev_flags, __entry->msg)
+);
+#endif
+
+#if defined(PXC_SPI_TRACER)
+TRACE_EVENT(pxc_spi, 	/* trace mcspi events */
+
+        TP_PROTO(char *msg, const char *func, int data),
+
+	TP_ARGS(msg, func, data),
+
+	TP_STRUCT__entry(
+		__array(char, msg, 128)
+		__array(char, func, 32)
+	        __field(int, data)
+	),
+
+	TP_fast_assign(
+		strncpy(         __entry->msg, msg,                128);
+		strncpy(         __entry->func, func,                32);
+	        __entry->data = data;
+	),
+
+	TP_printk("%s[%d]: %s", __entry->func, __entry->data, __entry->msg)
+);
+
+TRACE_EVENT(pxc_spi_measure_a, 	/* trace mcspi events */
+
+	    TP_PROTO(char *msg, struct wago_trace_data *tdata),
+
+	    TP_ARGS(msg, tdata),
+
+	TP_STRUCT__entry(
+		__array(char, msg, 128)
+	        __field(unsigned int, completion_delay)
+	        __field(unsigned int, completion_delay_work)
+	        __field(unsigned int, async_delay)
+	        __field(unsigned int, enqueue_delay)
+	        __field(unsigned int, work_delay)
+	),
+
+	TP_fast_assign(
+		strncpy(         __entry->msg, msg,                128);
+		if (tdata->mpoint_index > 5) {
+			__entry->completion_delay = tdata->mpoints[5].tv_nsec - tdata->mpoints[1].tv_nsec;
+			__entry->completion_delay_work = tdata->mpoints[4].tv_nsec - tdata->mpoints[2].tv_nsec;
+			__entry->async_delay = tdata->mpoints[1].tv_nsec - tdata->mpoints[0].tv_nsec;
+			__entry->enqueue_delay = tdata->mpoints[2].tv_nsec - tdata->mpoints[1].tv_nsec;
+			__entry->work_delay = tdata->mpoints[3].tv_nsec - tdata->mpoints[2].tv_nsec;
+		}
+	),
+
+	TP_printk("%s: completion_delay=%u, completion_delay_work=%u, async_delay=%u, enqueue_delay=%u, work_delay=%u",
+		  __entry->msg, __entry->completion_delay, __entry->completion_delay_work,
+		  __entry->async_delay, __entry->enqueue_delay, __entry->work_delay)
+);
+
+TRACE_EVENT(pxc_spi_measure_b, 	/* trace mcspi events */
+
+	    TP_PROTO(char *msg, struct wago_trace_data *tdata),
+
+	    TP_ARGS(msg, tdata),
+
+	TP_STRUCT__entry(
+		__array(char, msg, 128)
+	        __field(unsigned int, completion_delay)
+	        __field(unsigned int, completion_delay_work)
+	        __field(unsigned int, async_delay)
+	        __field(unsigned int, enqueue_delay)
+	        __field(unsigned int, work_delay)
+	        __field(unsigned int, delay1)
+	        __field(unsigned int, delay2)
+	),
+
+	TP_fast_assign(
+		strncpy(         __entry->msg, msg,                128);
+		if (tdata->mpoint_index > 8) {
+			__entry->completion_delay = tdata->mpoints[7].tv_nsec - tdata->mpoints[2].tv_nsec;
+			__entry->completion_delay_work = tdata->mpoints[6].tv_nsec - tdata->mpoints[4].tv_nsec;
+			__entry->async_delay = tdata->mpoints[2].tv_nsec - tdata->mpoints[1].tv_nsec;
+			__entry->enqueue_delay = tdata->mpoints[4].tv_nsec - tdata->mpoints[2].tv_nsec;
+			__entry->work_delay = tdata->mpoints[5].tv_nsec - tdata->mpoints[4].tv_nsec;
+			__entry->delay1 = tdata->mpoints[7].tv_nsec - tdata->mpoints[1].tv_nsec;
+			__entry->delay2 = tdata->mpoints[8].tv_nsec - tdata->mpoints[0].tv_nsec;
+		}
+	),
+
+	TP_printk("%s: completion_delay=%u, completion_delay_work=%u, async_delay=%u, enqueue_delay=%u, work_delay=%u, delay1=%u, delay2=%u",
+		  __entry->msg, __entry->completion_delay, __entry->completion_delay_work,
+		  __entry->async_delay, __entry->enqueue_delay, __entry->work_delay, __entry->delay1, __entry->delay2)
+);
+#endif	/* PXC_SPI_TRACER */
+
+#if defined(PXC_SPI_KBUS_TRACER)
+TRACE_EVENT(pxc_kbus, 	/* trace kbus events */
+
+        TP_PROTO(const char *func, char *msg),
+
+	TP_ARGS(func, msg),
+
+	TP_STRUCT__entry(
+		__array(char, msg, 128)
+		__array(char, func, 32)
+	),
+
+	TP_fast_assign(
+		strncpy(         __entry->msg, msg,                128);
+		strncpy(         __entry->func, func,               32);
+	),
+
+        TP_printk("%s:%s", __entry->func, __entry->msg)
+);
+
+TRACE_EVENT(pxc_kbusmsg, 	/* trace kbus events */
+
+	    TP_PROTO(const char *func, struct spi_message *m, char *msg),
+
+	    TP_ARGS(func, m, msg),
+
+	TP_STRUCT__entry(
+		__array(char, msg, 128)
+		__array(char, func, 32)
+	        __field(int, status)
+	),
+
+	TP_fast_assign(
+		strncpy(         __entry->msg, msg,                128);
+		strncpy(         __entry->func, func,               32);
+	        __entry->status = m->status;
+	),
+
+	    TP_printk("%s:%s m->status=%d", __entry->func, __entry->msg, __entry->status)
+);
+
+TRACE_EVENT(pxc_kbusdump, 	/* trace kbus events */
+
+	    TP_PROTO(const char *func, char *msg, int word_len, u16 word),
+
+	    TP_ARGS(func, msg, word_len, word),
+
+	TP_STRUCT__entry(
+		__array(char, func, 32)
+		__array(char, msg, 128)
+	        __field( int, word_len)
+	        __field( u16, word)
+	),
+
+	TP_fast_assign(
+		strncpy(         __entry->func, func,               32);
+		strncpy(         __entry->msg, msg,                128);
+	        __entry->word_len = word_len;
+	        __entry->word = word;
+	),
+
+	    TP_printk("%s:%s-%d 0x%x", __entry->func, __entry->msg, __entry->word_len, __entry->word) /* 0x%04x */
+);
+
+TRACE_EVENT(pxc_buf32,
+
+	TP_PROTO(const char *prefix, char *in_buf, int len, int offs),
+
+        TP_ARGS(prefix, in_buf, len, offs),
+
+	TP_STRUCT__entry(
+		__array(char, prefix, 32)
+	        __field(int, copy_len)
+		__array(char, buf, 32)
+		__field(char *, in_buf_p);
+	),
+
+	TP_fast_assign(
+		strncpy(__entry->prefix, prefix, 32);
+		if (len < 32)
+			memset(__entry->buf, 0, 32);
+		strncpy(__entry->buf, in_buf + offs, len > 32 ? 32 : len);
+		__entry->copy_len = len;
+		__entry->in_buf_p = in_buf;
+	),
+
+	TP_printk("DATADUMP(%s) copylen %4d (in_buf_p %p) "
+		  "[%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"
+		  "-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"
+		  "-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"
+		  "-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x-%.2x]",
+		  __entry->prefix,
+		  __entry->copy_len,
+		  __entry->in_buf_p,
+		  __entry->buf[0],  __entry->buf[1],  __entry->buf[2],  __entry->buf[3],
+		  __entry->buf[4],  __entry->buf[5],  __entry->buf[6],  __entry->buf[7],
+		  __entry->buf[8],  __entry->buf[9],  __entry->buf[10], __entry->buf[11],
+		  __entry->buf[12], __entry->buf[13], __entry->buf[14], __entry->buf[15],
+		  __entry->buf[16], __entry->buf[17], __entry->buf[18], __entry->buf[19],
+		  __entry->buf[20], __entry->buf[21], __entry->buf[22], __entry->buf[23],
+		  __entry->buf[24], __entry->buf[25], __entry->buf[26], __entry->buf[27],
+		  __entry->buf[28], __entry->buf[29], __entry->buf[30], __entry->buf[31])
+);
+
+TRACE_EVENT(pxc_kbus_mdata, 	/* trace kbus measurement events */
+
+        TP_PROTO(const char *func, char *msg, struct wago_trace_data *tdata),
+
+	TP_ARGS(func, msg, tdata),
+
+	TP_STRUCT__entry(
+		__array(char, msg, 128)
+		__array(char, func, 32)
+	        __field(unsigned int, delay1)
+	        __field(unsigned int, delay2)
+	),
+
+	TP_fast_assign(
+		strncpy(         __entry->msg, msg,                128);
+		strncpy(         __entry->func, func,               32);
+		if (tdata->mpoint_index > 3) {
+			__entry->delay1 = tdata->mpoints[3].tv_nsec - tdata->mpoints[0].tv_nsec;
+			__entry->delay2 = tdata->mpoints[2].tv_nsec - tdata->mpoints[1].tv_nsec;
+		}
+	),
+
+	TP_printk("%s:%s delay1=%u delay2=%u", __entry->func, __entry->msg,
+		  __entry->delay1, __entry->delay2)
+);
+#endif	/* PXC_SPI_KBUS_TRACER */
+
+#if defined(PXC_CAN_TRACER)
+TRACE_EVENT(pxc_canpkt,
+
+        TP_PROTO(struct can_frame *canframe),
+
+	TP_ARGS(canframe),
+
+	TP_STRUCT__entry(
+	        __field(struct can_frame *, canframe)
+	),
+
+	TP_fast_assign(
+		__entry->canframe = canframe;
+	),
+
+	TP_printk("%s-0x%x: can_id=0x%x, len=%d, data:%.2x.%.2x.%.2x.%.2x.%.2x.%.2x.%.2x.%.2x",
+		  (__entry->canframe->can_id & CAN_ERR_FLAG) ? " err" : "data",
+		  __entry->canframe->can_id >> CAN_EFF_ID_BITS,
+		  __entry->canframe->can_id & CAN_ERR_MASK,
+		  __entry->canframe->can_dlc,
+		  __entry->canframe->data[0],
+		  __entry->canframe->data[1],
+		  __entry->canframe->data[2],
+		  __entry->canframe->data[3],
+		  __entry->canframe->data[4],
+		  __entry->canframe->data[5],
+		  __entry->canframe->data[6],
+		  __entry->canframe->data[7])
+);
+#endif	/* PXC_CAN_TRACER */
+
+#endif /* if !defined(_TRACE_PXC_H) || defined(TRACE_HEADER_MULTI_READ) */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/include/uapi/asm-generic/ioctls.h b/include/uapi/asm-generic/ioctls.h
index 143dacb..8c594b4 100644
--- a/include/uapi/asm-generic/ioctls.h
+++ b/include/uapi/asm-generic/ioctls.h
@@ -74,6 +74,13 @@
 #define TCSETXW		0x5435
 #define TIOCSIG		_IOW('T', 0x36, int)  /* pty: generate signal */
 #define TIOCVHANGUP	0x5437
+
+#define TIOCSMBRTU     _IOW('T', 0x38, unsigned char) /* Enable/Disable Modbus RTU */
+#define TIOCSMBRTUADDR _IOW('T', 0x39, unsigned char) /* Set Modbus RTU Address */
+#define TIOCSMBRTUIFT  _IOW('T', 0x40, unsigned int) /* Set Modbus RTU interframe timeout */
+#define TIOCSMBRTUICT  _IOW('T', 0x41, unsigned int) /* Set Modbus RTU intercharacter timeout */
+#define TIOCSMBRTUTS   _IOW('T', 0x42, unsigned char) /* Enable/Disable Timestamp */
+
 #define TIOCGPKT	_IOR('T', 0x38, int) /* Get packet mode state */
 #define TIOCGPTLCK	_IOR('T', 0x39, int) /* Get Pty lock state */
 #define TIOCGEXCL	_IOR('T', 0x40, int) /* Get exclusive mode state */
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index cd2be1c..ccdd8d5 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -399,6 +399,7 @@ header-y += stddef.h
 header-y += string.h
 header-y += suspend_ioctls.h
 header-y += swab.h
+header-y += switch.h
 header-y += synclink.h
 header-y += sync_file.h
 header-y += sysctl.h
diff --git a/include/uapi/linux/if_ether.h b/include/uapi/linux/if_ether.h
index 659b163..6b2fc85 100644
--- a/include/uapi/linux/if_ether.h
+++ b/include/uapi/linux/if_ether.h
@@ -130,6 +130,7 @@
 #define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
 #define ETH_P_DSA	0x001B		/* Distributed Switch Arch.	*/
 #define ETH_P_TRAILER	0x001C		/* Trailer switch tagging	*/
+#define ETH_P_TAIL      0x001D          /* Tail Tagging (micrel)        */
 #define ETH_P_PHONET	0x00F5		/* Nokia Phonet frames          */
 #define ETH_P_IEEE802154 0x00F6		/* IEEE802.15.4 frame		*/
 #define ETH_P_CAIF	0x00F7		/* ST-Ericsson CAIF protocol	*/
diff --git a/include/uapi/linux/switch.h b/include/uapi/linux/switch.h
new file mode 100644
index 0000000..a59b239
--- /dev/null
+++ b/include/uapi/linux/switch.h
@@ -0,0 +1,103 @@
+/*
+ * switch.h: Switch configuration API
+ *
+ * Copyright (C) 2008 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_LINUX_SWITCH_H
+#define _UAPI_LINUX_SWITCH_H
+
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <linux/genetlink.h>
+#ifndef __KERNEL__
+#include <netlink/netlink.h>
+#include <netlink/genl/genl.h>
+#include <netlink/genl/ctrl.h>
+#endif
+
+/* main attributes */
+enum {
+	SWITCH_ATTR_UNSPEC,
+	/* global */
+	SWITCH_ATTR_TYPE,
+	/* device */
+	SWITCH_ATTR_ID,
+	SWITCH_ATTR_DEV_NAME,
+	SWITCH_ATTR_ALIAS,
+	SWITCH_ATTR_NAME,
+	SWITCH_ATTR_VLANS,
+	SWITCH_ATTR_PORTS,
+	SWITCH_ATTR_PORTMAP,
+	SWITCH_ATTR_CPU_PORT,
+	/* attributes */
+	SWITCH_ATTR_OP_ID,
+	SWITCH_ATTR_OP_TYPE,
+	SWITCH_ATTR_OP_NAME,
+	SWITCH_ATTR_OP_PORT,
+	SWITCH_ATTR_OP_VLAN,
+	SWITCH_ATTR_OP_VALUE_INT,
+	SWITCH_ATTR_OP_VALUE_STR,
+	SWITCH_ATTR_OP_VALUE_PORTS,
+	SWITCH_ATTR_OP_DESCRIPTION,
+	/* port lists */
+	SWITCH_ATTR_PORT,
+	SWITCH_ATTR_MAX
+};
+
+enum {
+	/* port map */
+	SWITCH_PORTMAP_PORTS,
+	SWITCH_PORTMAP_SEGMENT,
+	SWITCH_PORTMAP_VIRT,
+	SWITCH_PORTMAP_MAX
+};
+
+/* commands */
+enum {
+	SWITCH_CMD_UNSPEC,
+	SWITCH_CMD_GET_SWITCH,
+	SWITCH_CMD_NEW_ATTR,
+	SWITCH_CMD_LIST_GLOBAL,
+	SWITCH_CMD_GET_GLOBAL,
+	SWITCH_CMD_SET_GLOBAL,
+	SWITCH_CMD_LIST_PORT,
+	SWITCH_CMD_GET_PORT,
+	SWITCH_CMD_SET_PORT,
+	SWITCH_CMD_LIST_VLAN,
+	SWITCH_CMD_GET_VLAN,
+	SWITCH_CMD_SET_VLAN
+};
+
+/* data types */
+enum switch_val_type {
+	SWITCH_TYPE_UNSPEC,
+	SWITCH_TYPE_INT,
+	SWITCH_TYPE_STRING,
+	SWITCH_TYPE_PORTS,
+	SWITCH_TYPE_NOVAL,
+};
+
+/* port nested attributes */
+enum {
+	SWITCH_PORT_UNSPEC,
+	SWITCH_PORT_ID,
+	SWITCH_PORT_FLAG_TAGGED,
+	SWITCH_PORT_ATTR_MAX
+};
+
+#define SWITCH_ATTR_DEFAULTS_OFFSET	0x1000
+
+
+#endif /* _UAPI_LINUX_SWITCH_H */
diff --git a/kernel/fork.c b/kernel/fork.c
index bb1bdea..fb14270 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -569,6 +569,10 @@ static struct task_struct *dup_task_struct(struct task_struct *orig, int node)
 	tsk->wake_q.next = NULL;
 	tsk->wake_q_sleeper.next = NULL;
 
+#ifdef CONFIG_PREEMPT_RT_FULL
+	atomic_set(&tsk->xmit_recursion, 0);
+#endif
+
 	account_kernel_stack(tsk, 1);
 
 	kcov_task_init(tsk);
diff --git a/kernel/irq/Kconfig b/kernel/irq/Kconfig
index 3bbfd6a..8d352a8 100644
--- a/kernel/irq/Kconfig
+++ b/kernel/irq/Kconfig
@@ -81,6 +81,13 @@ config GENERIC_MSI_IRQ_DOMAIN
 config HANDLE_DOMAIN_IRQ
 	bool
 
+config IRQ_PRIORITY_TABLE
+        bool "Enable Priority Table Lookup"
+        help
+         By this feature it is possible to assign custom irq thread priorities
+         while they are created (RT_PREEMT). The flag IRQF_THREAD_TBL_LOOKUP
+         trigger a table lookup which may succeed or fail.
+
 config IRQ_DOMAIN_DEBUG
 	bool "Expose hardware/virtual IRQ mapping via debugfs"
 	depends on IRQ_DOMAIN && DEBUG_FS
diff --git a/kernel/irq/Makefile b/kernel/irq/Makefile
index 1d3ee31..629943d 100644
--- a/kernel/irq/Makefile
+++ b/kernel/irq/Makefile
@@ -10,3 +10,4 @@ obj-$(CONFIG_PM_SLEEP) += pm.o
 obj-$(CONFIG_GENERIC_MSI_IRQ) += msi.o
 obj-$(CONFIG_GENERIC_IRQ_IPI) += ipi.o
 obj-$(CONFIG_SMP) += affinity.o
+obj-$(CONFIG_IRQ_PRIORITY_TABLE) += wsysinit-prio-table.o
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 4e0f709..03e6d73 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -19,6 +19,8 @@
 #include <linux/sched/rt.h>
 #include <linux/task_work.h>
 
+#include <linux/wsysinit-prio.h>
+
 #include "internals.h"
 
 #ifdef CONFIG_IRQ_FORCED_THREADING
@@ -1152,6 +1154,20 @@ setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)
 	if (IS_ERR(t))
 		return PTR_ERR(t);
 
+#ifdef CONFIG_IRQ_PRIORITY_TABLE
+                if (new->flags & IRQF_THREAD_TBL_LOOKUP) {
+                        search = wsysinit_tbl_get_prio_by_name(new->name);
+                        if (search > 0) { 	/* found */
+                                param.sched_priority = search;
+                                if (param.sched_priority > MAX_USER_RT_PRIO)
+                                        param.sched_priority = MAX_USER_RT_PRIO - 1;
+
+                                trace_printk("%s: update irq-thread prio to %d\n",
+                                             new->name, param.sched_priority);
+                        }
+                }
+#endif
+
 	sched_setscheduler_nocheck(t, SCHED_FIFO, &param);
 
 	/*
diff --git a/kernel/irq/wsysinit-prio-table.c b/kernel/irq/wsysinit-prio-table.c
new file mode 100644
index 0000000..d87d489
--- /dev/null
+++ b/kernel/irq/wsysinit-prio-table.c
@@ -0,0 +1,187 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/wsysinit-prio.h>
+#include <linux/export.h>
+
+/* sysfs */
+extern struct device* wsysinit_sysfs_device;
+
+static struct wsysinit_irq_prio_tbl_entry *tbl_entry = NULL;
+
+/*
+	The following values were taken out of /etc/specific/known_processes.lst:
+
+	irq/189-RESET_A;f;90
+	irq/188-RESET;f;90
+	irq/187-STOP;f;90
+	irq/186-RUN;f;90
+
+	irq/256-UIO_DPC;f;70
+	irq/257-UIO_DPC;f;70
+	irq/161-UIO_DPC;f;70
+	irq/24-can0;f;84
+	irq/200-kbus;f;82
+*/
+
+/* Don't forget !!!
+ *    You have to set the IRQF_THREAD_TBL_LOOKUP irq flag during
+ *    a request_irq() registration to enable table lookup.
+ */
+struct wsysinit_irq_prio_tbl_entry wsysinit_irq_prio_tbl[] = {
+	{            "can0",  84 },
+	{            "kbus",  82 },
+	{  "UIO_DPC31_XINT",  70 },
+	{  "UIO_DPC31_SYNC",  70 },
+	{ "UIO_DPC31_DXOUT",  70 },
+	{             "RUN",  90 },
+	{            "STOP",  90 },
+	{           "RESET",  90 },
+	{       "RESET_ALL",  90 },
+	{   "uio_alarm_usv",  91 },
+	{ NULL, 0 },
+};
+EXPORT_SYMBOL(wsysinit_irq_prio_tbl);
+
+struct wsysinit_irq_prio_tbl_entry* wsysinit_tbl_get_entry_by_name(const char *name)
+{
+	struct wsysinit_irq_prio_tbl_entry *entry = NULL;
+	int i;
+
+	for (i = 0; wsysinit_irq_prio_tbl[i].name != NULL; i++) {
+		if(!strcmp(name, wsysinit_irq_prio_tbl[i].name)) {
+			entry = &wsysinit_irq_prio_tbl[i];
+			break;
+		}
+	}
+
+	return entry;
+}
+EXPORT_SYMBOL(wsysinit_tbl_get_entry_by_name);
+
+int wsysinit_tbl_get_prio_by_name(const char *name)
+{
+	struct wsysinit_irq_prio_tbl_entry *entry;
+
+	entry = wsysinit_tbl_get_entry_by_name(name);
+	if (entry == NULL)
+		return -1;
+
+	return entry->prio;
+}
+EXPORT_SYMBOL(wsysinit_tbl_get_prio_by_name);
+
+void wsysinit_tbl_dump(void)
+{
+	int i;
+
+	pr_info(">>>> PFCxxx IRQ Thread Priority Table:\n");
+	for (i = 0; wsysinit_irq_prio_tbl[i].name != NULL; i++)
+		pr_info("\t%s\t%d\n", wsysinit_irq_prio_tbl[i].name, wsysinit_irq_prio_tbl[i].prio);
+	pr_info("<<<<\n");
+}
+EXPORT_SYMBOL(wsysinit_tbl_dump);
+
+static ssize_t wsysinit_sysfs_irqprio_show(struct device* dev,
+				      struct device_attribute* attr,
+				      char* buf)
+{
+	if (tbl_entry == NULL)
+		return -1;
+
+	sprintf(buf, "%d\n", tbl_entry->prio);
+	return strlen(buf);
+}
+
+static ssize_t wsysinit_sysfs_can_irqprio_show(struct device* dev,
+					  struct device_attribute* attr,
+					  char* buf)
+{
+	tbl_entry = &wsysinit_irq_prio_tbl[0];
+	return wsysinit_sysfs_irqprio_show(dev, attr, buf);
+}
+
+static ssize_t wsysinit_sysfs_irqprio_set(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t count)
+{
+	u32 new_prio;
+
+	if (tbl_entry == NULL)
+		return -1;
+
+	new_prio = simple_strtoul(buf, NULL, 10);
+
+	/* check if value is valid */
+	if (new_prio < 1 || new_prio > 99)
+		return -EINVAL;
+
+	tbl_entry->prio = (int) new_prio;
+
+	pr_info("%s: prio updated to %d\n",
+		tbl_entry->name, tbl_entry->prio);
+
+	return count;
+}
+
+static ssize_t wsysinit_sysfs_can_irqprio_set(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t count)
+{
+	tbl_entry = &wsysinit_irq_prio_tbl[0];
+	return wsysinit_sysfs_irqprio_set(dev, attr, buf, count);
+}
+
+static ssize_t wsysinit_sysfs_kbus_irqprio_show(struct device* dev,
+					  struct device_attribute* attr,
+					  char* buf)
+{
+	tbl_entry = &wsysinit_irq_prio_tbl[1];
+	return wsysinit_sysfs_irqprio_show(dev, attr, buf);
+}
+
+static ssize_t wsysinit_sysfs_kbus_irqprio_set(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t count)
+{
+	tbl_entry = &wsysinit_irq_prio_tbl[1];
+	return wsysinit_sysfs_irqprio_set(dev, attr, buf, count);
+}
+
+static ssize_t wsysinit_sysfs_tbldump_set(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf,
+				     size_t count)
+{
+	int val = simple_strtoul(buf, NULL, 10);
+
+	if (val == 1)
+		wsysinit_tbl_dump();
+	else
+		return -1;
+
+	return count;
+}
+
+DEVICE_ATTR ( can_irqprio, 0600,  wsysinit_sysfs_can_irqprio_show,  wsysinit_sysfs_can_irqprio_set);
+DEVICE_ATTR (kbus_irqprio, 0600, wsysinit_sysfs_kbus_irqprio_show, wsysinit_sysfs_kbus_irqprio_set);
+DEVICE_ATTR (dump_irqprio, 0200,                        NULL,      wsysinit_sysfs_tbldump_set);
+
+void wsysinit_tbl_sysfs_init(void)
+{
+
+	pr_info("%s: create sysfs entries\n", __func__);
+
+	if (device_create_file(wsysinit_sysfs_device, &dev_attr_can_irqprio))
+		pr_err("%s: can0: failed to create sysfs entry!\n", __func__);
+
+	if (device_create_file(wsysinit_sysfs_device, &dev_attr_kbus_irqprio))
+		pr_err("%s: kbus: failed to create sysfs entry!\n", __func__);
+
+	if (device_create_file(wsysinit_sysfs_device, &dev_attr_dump_irqprio))
+		pr_err("%s: failed to create sysfs entry: 'dump_irqprio'!\n", __func__);
+}
+EXPORT_SYMBOL(wsysinit_tbl_sysfs_init);
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 76018dc..a4e8c91 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -2415,7 +2415,8 @@ void trace_printk_init_buffers(void)
 	if (alloc_percpu_trace_buffer())
 		return;
 
-	/* trace_printk() is for debug use only. Don't use it in production. */
+#if 0
+        /* trace_printk() is for debug use only. Don't use it in production. */
 
 	pr_warn("\n");
 	pr_warn("**********************************************************\n");
@@ -2431,7 +2432,7 @@ void trace_printk_init_buffers(void)
 	pr_warn("**                                                      **\n");
 	pr_warn("**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\n");
 	pr_warn("**********************************************************\n");
-
+#endif
 	/* Expand the buffers to set size */
 	tracing_update_buffers();
 
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index 5f5e28f..bdfa281 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -136,6 +136,15 @@ static int br_dev_open(struct net_device *dev)
 
 static void br_dev_set_multicast_list(struct net_device *dev)
 {
+	struct net_bridge *br = netdev_priv(dev);
+	struct net_bridge_port *p;
+
+	list_for_each_entry(p, &br->port_list, list) {
+		if (!p->dev)
+			continue;
+		dev_mc_sync(p->dev, dev);
+		dev_uc_sync(p->dev, dev);
+	}
 }
 
 static void br_dev_change_rx_flags(struct net_device *dev, int change)
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index 8e17332..eec2c9c 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -137,7 +137,11 @@ void br_manage_promisc(struct net_bridge *br)
 	/* If vlan filtering is disabled or bridge interface is placed
 	 * into promiscuous mode, place all ports in promiscuous mode.
 	 */
-	if ((br->dev->flags & IFF_PROMISC) || !br_vlan_enabled(br))
+	if ((br->dev->flags & IFF_PROMISC)
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+	    || !br_vlan_enabled(br)
+#endif
+	    )
 		set_all = true;
 
 	list_for_each_entry(p, &br->port_list, list) {
@@ -264,7 +268,8 @@ static void del_nbp(struct net_bridge_port *p)
 
 	sysfs_remove_link(br->ifobj, p->dev->name);
 
-	nbp_delete_promisc(p);
+	if (dev->flags & IFF_PROMISC)
+	        nbp_delete_promisc(p);
 
 	spin_lock_bh(&br->lock);
 	br_stp_disable_port(p);
diff --git a/net/core/dev.c b/net/core/dev.c
index 044bb7a..6f1457f 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -150,6 +150,32 @@
 /* This should be increased if a protocol with a bigger head is added. */
 #define GRO_MAX_HEAD (MAX_HEADER + 128)
 
+static char *__macaddr = NULL;
+core_param(macaddr, __macaddr, charp, 0);
+EXPORT_SYMBOL(__macaddr);
+
+static int pxc_parse_mac(char *mac, unsigned char *macarray)
+{
+	int i, j;
+	short byte1, byte0;
+
+	if (mac == NULL || macarray == NULL)
+		return -1;
+	j = 0;
+	for (i = 0; i < 6; i++) {
+		if ((byte1 = hex_to_bin(mac[j++])) < 0)
+			return -1;
+		if ((byte0 = hex_to_bin(mac[j++])) < 0)
+			return -1;
+		macarray[i] = (unsigned char)(byte1 * 16 + byte0);
+		if (i < 5) {
+			if (mac[j++] != ':')
+				return -1;
+		}
+	}
+	return 0;
+}
+
 static DEFINE_SPINLOCK(ptype_lock);
 static DEFINE_SPINLOCK(offload_lock);
 struct list_head ptype_base[PTYPE_HASH_SIZE] __read_mostly;
@@ -6438,7 +6464,7 @@ void __dev_set_rx_mode(struct net_device *dev)
 	const struct net_device_ops *ops = dev->netdev_ops;
 
 	/* dev_open will call this function so the list will stay sane. */
-	if (!(dev->flags&IFF_UP))
+	if (!(dev->flags & IFF_UP))
 		return;
 
 	if (!netif_device_present(dev))
@@ -7268,6 +7294,7 @@ int register_netdevice(struct net_device *dev)
 {
 	int ret;
 	struct net *net = dev_net(dev);
+	struct sockaddr *sockaddr;
 
 	BUG_ON(dev_boot_phase);
 	ASSERT_RTNL();
@@ -7379,6 +7406,21 @@ int register_netdevice(struct net_device *dev)
 	if (dev->addr_assign_type == NET_ADDR_PERM)
 		memcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);
 
+	/* if we get an mac-addr from the bootloader (in our case barebox),
+	 * we will set this mac-addr overwrite other mac-addr source like
+	 * device-tree.
+	 */
+	if(__macaddr) {
+		sockaddr = kzalloc(sizeof(*sockaddr), GFP_KERNEL);
+		pxc_parse_mac(__macaddr, sockaddr->sa_data);
+
+		ret = eth_mac_addr(dev, sockaddr);
+		if(ret)
+			pr_warn("error: eth_mac_addr:%d, using random-mac\n");
+
+		kfree(sockaddr);
+	}
+
 	/* Notify protocols, that a new device appeared. */
 	ret = call_netdevice_notifiers(NETDEV_REGISTER, dev);
 	ret = notifier_to_errno(ret);
diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c
index f2e6e87..fb818fc 100644
--- a/net/ipv4/igmp.c
+++ b/net/ipv4/igmp.c
@@ -1092,11 +1092,12 @@ int igmp_rcv(struct sk_buff *skb)
 /*
  *	Add a filter to a device
  */
-
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
 static void ip_mc_filter_add(struct in_device *in_dev, __be32 addr)
 {
 	char buf[MAX_ADDR_LEN];
 	struct net_device *dev = in_dev->dev;
+	struct netdev_hw_addr *ha;
 
 	/* Checking for IFF_MULTICAST here is WRONG-WRONG-WRONG.
 	   We will get multicast token leakage, when IFF_MULTICAST
@@ -1107,6 +1108,13 @@ static void ip_mc_filter_add(struct in_device *in_dev, __be32 addr)
 	   */
 	if (arp_mc_map(addr, buf, dev, 0) == 0)
 		dev_mc_add(dev, buf);
+
+
+	netdev_for_each_mc_addr(ha, dev) {
+		pr_info("%s: %s: mcast:"MAC_FMT"\n", __func__, dev->name,
+			ha->addr[0], ha->addr[1], ha->addr[2],
+			ha->addr[3], ha->addr[4], ha->addr[5]);
+	}
 }
 
 /*
diff --git a/samples/modbus_test/test_MbRtuDriver.c b/samples/modbus_test/test_MbRtuDriver.c
new file mode 100644
index 0000000..7d717cc
--- /dev/null
+++ b/samples/modbus_test/test_MbRtuDriver.c
@@ -0,0 +1,243 @@
+//#include "MbManager.h"
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <termios.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <poll.h>
+
+#include <linux/time.h>
+#include <time.h>
+#include <asm/unistd.h>
+
+#include <sys/ioctl.h>
+#include <linux/serial.h>
+
+extern int nanosleep (const struct timespec *__requested_time,
+                   struct timespec *__remaining);
+
+#define ABORT(hint) {print_error(__LINE__, (hint)); return -1;}
+
+#define TRUE    1
+#define FALSE   0
+
+enum { FILENAME, TTY1, TTY2, RUNS, PARAM_CNT };
+
+void print_error(int line, int hint)
+{
+  printf("\n"
+         "--- ERROR ---\n"
+         "line: %d\n"
+         "hint: %d\n"
+         "errno: %d (%s)\n",
+         line, hint, errno, strerror(errno));
+  printf("--- DRIVER ---\n");
+  system("cat /proc/tty/driver/OMAP-SERIAL");
+  printf("--- DMESG ---\n");
+  system("dmesg | tail");
+}
+
+int main(int argc, char** argv)
+{
+  struct termios tios;
+  int fd[2];
+  struct pollfd pollfds[2];
+
+  if (argc != PARAM_CNT) {
+    printf("usage:\n\t%s TTY1 TTY2 RUNS\n", argv[FILENAME]);
+    return -1;
+  }
+
+  const int runs = atoi(argv[RUNS]);
+
+  printf(__FILE__"\n");
+  printf("Make sure %s and %s are connected with a nullmodem cable and no "
+         "other processes has them opened.\n", argv[TTY1], argv[TTY2]);
+
+  for(int i = 0; i < 2; ++i) {
+    fd[i] = open(argv[i+1], O_RDWR | O_NOCTTY | O_NDELAY | O_EXCL);
+    if(fd[i] == -1)
+      ABORT(i);
+
+    if(tcgetattr(fd[i], &tios) == -1)
+      ABORT(i);
+
+    memset(&tios, 0, sizeof(struct termios));
+
+    if ((cfsetispeed(&tios, B115200) < 0) ||
+        (cfsetospeed(&tios, B115200) < 0))
+      ABORT(i);
+
+    tios.c_cflag |= (CREAD | CLOCAL);
+    tios.c_cflag &= ~CSIZE;
+    tios.c_cflag |= CS8;
+    tios.c_cflag &=~ CSTOPB;
+    tios.c_cflag |= PARENB;
+    tios.c_cflag &=~ PARODD;
+    tios.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
+    tios.c_iflag &= ~(IXON | IXOFF | IXANY);
+    tios.c_oflag &=~ OPOST;
+    tios.c_cc[VMIN] = 0;
+    tios.c_cc[VTIME] = 0;
+
+    if (tcsetattr(fd[i], TCSANOW, &tios) < 0)
+      ABORT(i);
+
+    struct serial_rs485 rs485conf;
+    memset(&rs485conf, 0x0, sizeof(struct serial_rs485));
+    if (ioctl(fd[i], TIOCSRS485, &rs485conf) < 0)
+      ABORT(i);
+  }
+
+  int rx = fd[0], tx = fd[1];
+  char tx_data[1024], rx_data[1024];
+
+  pollfds[0].fd = rx;
+  pollfds[0].events = POLLIN;
+  pollfds[1].fd = tx;
+  pollfds[1].events = POLLIN;
+
+  ioctl(rx, TIOCSMBRTU, TRUE);
+  ioctl(rx, TIOCSMBRTUADDR, 1);
+  ioctl(tx, TIOCSMBRTU, TRUE);
+  ioctl(tx, TIOCSMBRTUADDR, 0);
+
+  sleep(1); // wait for the first interframe timeout
+
+  printf("TEST: normal case with default timeouts..");
+  int size = 10;
+  memset(tx_data, 5, size);
+  memset(rx_data, 3, size);
+  tx_data[0] = 1;
+
+  for(int i = 0; i < runs; ++i) {
+    write(tx, tx_data, size);
+
+    if(poll(pollfds, 2, 1000) < 1)
+      ABORT(i);
+    if(read(rx, rx_data, sizeof rx_data) != size)
+      ABORT(i);
+
+    write(rx, rx_data, size);
+
+    if(poll(pollfds, 2, 1000) < 1)
+      ABORT(i);
+    if(read(tx, tx_data, sizeof tx_data) != size)
+      ABORT(i);
+
+    if(memcmp(tx_data, rx_data, size))
+      ABORT(i);
+
+    if(i%(runs/10)==0) {
+      printf("%d%%..", i*100/runs);
+      fflush(stdout);
+    }
+  }
+  printf("ok\n");
+
+  printf("TEST: too small and too big packets..");
+  size = 300;
+  memset(tx_data, 6, size);
+  memset(rx_data, 7, size);
+  tx_data[0] = 1;
+
+  for(int i = 0; i < runs; ++i) {
+    write(tx, tx_data, size);
+
+    if(poll(pollfds, 2, 10) > 0)
+      ABORT(i);
+
+    if(i==runs/2)
+      size = 3;
+
+    if(i%(runs/10)==0) {
+      printf("%d%%..", i*100/runs);
+      fflush(stdout);
+    }
+  }
+  printf("ok\n");
+
+  printf("TEST: packets with another node id..");
+  size = 12;
+  memset(tx_data, 6, size);
+  memset(rx_data, 7, size);
+  tx_data[0] = 6;
+
+  for(int i = 0; i < runs; ++i) {
+    if(i%256!=0 && i%256!=1)
+      tx_data[0] = i%256;
+    else
+      tx_data[0] = 3;
+
+    write(tx, tx_data, size);
+
+    if(poll(pollfds, 2, 10) > 0)
+      ABORT(i);
+
+    if(i%(runs/10)==0) {
+      printf("%d%%..", i*100/runs);
+      fflush(stdout);
+    }
+  }
+  printf("ok\n");
+
+  printf("TEST: different if and ic timeouts..");
+  struct timespec ts;
+  ts.tv_nsec = 10000000;
+  ts.tv_sec = 0;
+  tx_data[0] = 1;
+  ioctl(rx, TIOCSMBRTUICT, 15000000);
+  ioctl(rx, TIOCSMBRTUIFT, 35000000);
+
+  for(int i = 0; i < 10; ++i) {
+    write(tx, &tx_data[i], 1);
+    nanosleep(&ts,0);
+  }
+
+  if(poll(pollfds, 2, 1000) < 1)
+    ABORT(0);
+  if(read(rx, rx_data, sizeof rx_data) != 10)
+    ABORT(0);
+
+  ts.tv_nsec = 16000000;
+  for(int i = 0; i < 10; ++i) {
+    write(tx, &tx_data[i], 1);
+    nanosleep(&ts,0);
+  }
+
+  if(poll(pollfds, 2, 1000) > 0)
+    ABORT(0);
+
+  ts.tv_nsec = 10000000;
+  for(int i = 0; i < 10; ++i) {
+    write(tx, &tx_data[i], 1);
+    nanosleep(&ts,0);
+  }
+  ts.tv_nsec = 16000000;
+  nanosleep(&ts,0);
+  ts.tv_nsec = 10000000;
+  for(int i = 0; i < 10; ++i) {
+    write(tx, &tx_data[i], 1);
+    nanosleep(&ts,0);
+  }
+  if(poll(pollfds, 2, 1000) > 0)
+    ABORT(0);
+
+  printf("ok\n");
+
+  printf("TEST: try to let the rtu buffer overrun..");
+  tx_data[0] = 1;
+  printf("ok\n");
+
+  ioctl(rx, TIOCSMBRTU, FALSE);
+  ioctl(tx, TIOCSMBRTU, FALSE);
+
+  printf("--- SUCCESS ---\n");
+  system("cat /proc/tty/driver/OMAP-SERIAL");
+
+  return 0;
+}
+
diff --git a/scripts/Lauterbach/StartLinuxKernel.cmm b/scripts/Lauterbach/StartLinuxKernel.cmm
new file mode 100644
index 0000000..47ee428
--- /dev/null
+++ b/scripts/Lauterbach/StartLinuxKernel.cmm
@@ -0,0 +1,99 @@
+REset
+
+PRINT "Initialising"
+;system.down
+system.cpu am3352
+SYStem.JTAGClock 10.0MHz	; set jtag_clk
+SYStem.Option DACR ON		; give Debugger global write permissions
+
+TrONchip.Set DABORT OFF
+TrONchip.Set PABORT OFF
+TrONchip.Set UNDEF OFF
+
+SYstem.Option MMUSPACES ON
+system.up
+
+SETUP.IMASKASM ON
+
+Go 0x80008000 /ONCHIP
+wait !run()
+;Register.Reset
+;Register.Set R2 0x85040000
+;Register.Set R1 0
+;Register.Set PC 0xc0008000
+
+PRINT "Target setup ..."
+
+
+print "load vmlinux ....."
+
+
+data.load.elf ~/buildserv/project_rocket/profinet/linux-pac-3.14.y-ext-linx/vmlinux 0x80000000-0xc0000000 /NosYmbol 
+;data.load.elf ~/buildserv/project_rocket> cd trunk/ptxproj.2013.03.0/platform-wago-pac100/build-target/linux-3.8.13.14/vmlinux 0x80000000-0xc0000000 /NosYmbol /NoREG
+
+;&tagAddr=0x80000000
+
+;ATAG CORE
+;data.set &tagAddr %LONG %LE 0x2
+;&tagAddr=&&tagAddr+0x4
+;data.set &tagAddr %LONG %LE 0x54420001
+;&tagAddr=&&tagAddr+0x4
+;ATAG MEM
+;data.set &tagAddr %LONG %LE 0x2000000 ;  size
+;&tagAddr=&&tagAddr+0x4
+;data.set &tagAddr %LONG %LE 0x80000000 ; start
+;&tagAddr=&&tagAddr+0x4
+;ATAG INITRD2
+;data.set &tagAddr %LONG %LE 0x81600000	;start
+;;&tagAddr=&&tagAddr+0x4
+;data.set &tagAddr %LONG %LE 0x300000 ; file size
+;&tagAddr=&&tagAddr+0x4
+;ATAG CMDLINE
+;data.set &tagAddr %LONG %LE 0x54410009
+;&tagAddr=&&tagAddr+
+
+
+;data.set &tagAddr %LONG %LE "console=ttyS0,115200 initrd=0x81600000,0x0030000 root=/dev/ram rw" 0
+;&tagAddr=&&tagAddr+0x8c
+
+;register.set r2
+
+data.load.binary ~/buildserv/project_rocket/profinet/linux-pac-3.14.y-ext-linx/arch/arm/boot/uImage 0x81600000
+data.load.elf 	 ~/buildserv/project_rocket/profinet/linux-pac-3.14.y-ext-linx/vmlinux /NoCODE 
+
+PRINT "Initializing debugger MMU ..."
+;MMU.FORMAT LINUXSWAP3 swapper_pg_dir 0xc0000000--0xdfffffff 0x80000000
+MMU.FORMAT LINUXSWAP3 swapper_pg_dir 
+;0xc0000000--0xdfffffff 0x80000000
+MMU.COMMON 0xc0000000--0xffffffff
+TRANSLATION.COMMON 0xc000000--0xffffffff
+TRANSLATION.TableWalk ON
+MMU.ON
+TRANSlation.ON
+
+b.s gpmc_fpga_reset\51
+;b.s gpmc_fpga_reset\64 
+b.s of_init_opp_table\0
+b.s of_init_opp_table\0
+b.s of_init_opp_table\0
+
+;b.s omap_hsmmc_probe+0x7BC
+;b.s omap_hsmmc_probe+0x828
+;B.S   `\regulator/core\regulator_get` /P
+;b.s  omap_hsmmc_probe\194
+;b.s regulator_register\15
+;b.s regulator_register\133
+;b.s lat_probe\124
+;b.s ksz8863_probe\1 
+;b.s wrlb_tb_probe\1
+;b.s omap_i2c_probe\1
+;b.s tps65218_regulator_probe\1
+;b.s gpmc_fpga_reset\9 
+;b.s gpmc_fpga_reset\52
+;TASK.CONFIG    /opt/t32/demo/arm/kernel/linux/linux
+;MENU.reProgram /opt/t32/demo/arm/kernel/linux/linux
+;HELP.FILTER.Add rtoslinux
+
+sYmbol.Autoload.CHECKLINUX "do ./autoload.cmm"
+
+print "main vmlinux running ....."
diff --git a/scripts/uboot-startup.txt b/scripts/uboot-startup.txt
new file mode 100644
index 0000000..ff9322a
--- /dev/null
+++ b/scripts/uboot-startup.txt
@@ -0,0 +1,26 @@
+##
+## Create Kernel Image with embedded DTB suited for UBOOT.
+##
+
+./m-arm wago_am3517_defconfig
+./m-arm zImage
+./m-arm dtbs
+cat arch/arm/boot/zImage arch/arm/boot/dts/am3517-evm.dtb > zImage_w_dtb
+cp zImage_w_dtb arch/arm/boot/zImage
+./m-arm uImage LOADADDR=0x80008000
+
+##
+## UBOOT Scripting
+##
+
+
+AM3517_EVM # mmc init
+mmc1 is available
+
+AM3517_EVM # fatload mmc 0 ${loadaddr} uImagedtb
+reading uImagedtb
+
+4658286 bytes read
+
+AM3517_EVM # run mmcboot
+
-- 
2.7.4

